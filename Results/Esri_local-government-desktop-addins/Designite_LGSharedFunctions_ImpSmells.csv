Implementation smell,Namespace,Class,File,Method,Description
Long Method,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The method has 161 lines of code.
Long Method,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The method has 234 lines of code.
Long Method,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The method has 147 lines of code.
Long Method,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The method has 103 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The method has 371 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlagsBarriersToLayer,The method has 237 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The method has 109 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetAngleOfLineAtPoint,The method has 126 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ReturnAccumulation,The method has 128 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,RemoveFlagBarrierAtLocation,The method has 131 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddTwoJunctionFlagsToTraceSolver,The method has 167 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateTraceFlowSolverFromToolbar,The method has 281 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectJunctions,The method has 108 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,The method has 163 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,The method has 157 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,createSpatialFilter,The method has 119 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The method has 139 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The method has 213 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayerFromMapDataset,The method has 145 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayerNotInMemory,The method has 157 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayer,The method has 142 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayerInWorkspace,The method has 117 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,EstablishFlow,The method has 110 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,copyFields,The method has 159 lines of code.
Long Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectJunctions,The method has 126 lines of code.
Long Method,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The method has 152 lines of code.
Complex Method,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetAllConfigFilesNames,Cyclomatic complexity of the method is 9
Complex Method,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,copyFileContents,Cyclomatic complexity of the method is 14
Complex Method,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,getInstalledConfig,Cyclomatic complexity of the method is 8
Complex Method,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetConfigValue,Cyclomatic complexity of the method is 11
Complex Method,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetConfigValue,Cyclomatic complexity of the method is 9
Complex Method,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetConfigValue,Cyclomatic complexity of the method is 9
Complex Method,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetConfigValue,Cyclomatic complexity of the method is 8
Complex Method,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,KeyExists,Cyclomatic complexity of the method is 9
Complex Method,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,RotatePoint,Cyclomatic complexity of the method is 8
Complex Method,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,Cyclomatic complexity of the method is 51
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddGNResultClasses,Cyclomatic complexity of the method is 16
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,copyClassToInMemory,Cyclomatic complexity of the method is 9
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,Cyclomatic complexity of the method is 50
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlagsBarriersToLayer,Cyclomatic complexity of the method is 27
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateOutageArea,Cyclomatic complexity of the method is 12
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,Cyclomatic complexity of the method is 16
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,Cyclomatic complexity of the method is 9
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateAngledLineFromLocationOnLine,Cyclomatic complexity of the method is 10
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetAngleOfLineAtPoint,Cyclomatic complexity of the method is 11
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetAddressInfo,Cyclomatic complexity of the method is 14
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ReturnAccumulation,Cyclomatic complexity of the method is 12
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetGeometricNetworksJunctionsLayersHT,Cyclomatic complexity of the method is 11
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetGeometricNetworksJunctionsLayers,Cyclomatic complexity of the method is 9
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetNetworkAndFeatureAtLocation,Cyclomatic complexity of the method is 12
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetGeometricNetworksCheckedVisible,Cyclomatic complexity of the method is 11
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetGeometricNetworksCurrentlyVisible,Cyclomatic complexity of the method is 9
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetGeometricNetworks,Cyclomatic complexity of the method is 10
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,IsInNetwork,Cyclomatic complexity of the method is 11
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddFlagsToTraceSolver,Cyclomatic complexity of the method is 9
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,RemoveFlagBarrierAtLocation,Cyclomatic complexity of the method is 24
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddTwoJunctionFlagsToTraceSolver,Cyclomatic complexity of the method is 15
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,getFlagsBarriers,Cyclomatic complexity of the method is 12
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateTraceFlowSolverFromToolbar,Cyclomatic complexity of the method is 12
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectJunctions,Cyclomatic complexity of the method is 21
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FeatureIsValidTemplate,Cyclomatic complexity of the method is 9
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,Cyclomatic complexity of the method is 20
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,Cyclomatic complexity of the method is 20
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetClosestFeatureIgnoreExistingLineFeature,Cyclomatic complexity of the method is 8
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetClosestFeature,Cyclomatic complexity of the method is 11
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,createSpatialFilter,Cyclomatic complexity of the method is 15
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetFieldStats,Cyclomatic complexity of the method is 15
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlashGeometry,Cyclomatic complexity of the method is 10
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,Cyclomatic complexity of the method is 50
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,Cyclomatic complexity of the method is 30
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetGeomCenter,Cyclomatic complexity of the method is 19
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,Cyclomatic complexity of the method is 30
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,Cyclomatic complexity of the method is 12
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,Cyclomatic complexity of the method is 13
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetDomainDisplay,Cyclomatic complexity of the method is 8
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,Cyclomatic complexity of the method is 10
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetLayers,Cyclomatic complexity of the method is 12
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayerFromMapDataset,Cyclomatic complexity of the method is 28
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayerNotInMemory,Cyclomatic complexity of the method is 34
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayer,Cyclomatic complexity of the method is 27
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayerInWorkspace,Cyclomatic complexity of the method is 27
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,getClassName,Cyclomatic complexity of the method is 12
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindParentLayer,Cyclomatic complexity of the method is 8
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,EstablishFlow,Cyclomatic complexity of the method is 11
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,LayerExist,Cyclomatic complexity of the method is 9
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetPathForALayer,Cyclomatic complexity of the method is 11
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindStandAloneTable,Cyclomatic complexity of the method is 8
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,createFeatureClassInMemory,Cyclomatic complexity of the method is 11
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,copyFields,Cyclomatic complexity of the method is 20
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetInMemoryWorkspaceFromTOC,Cyclomatic complexity of the method is 11
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectJunctions,Cyclomatic complexity of the method is 30
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetEIDInfoListByFCWithHT,Cyclomatic complexity of the method is 11
Complex Method,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetOperableValveOIDs,Cyclomatic complexity of the method is 10
Complex Method,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,Cyclomatic complexity of the method is 9
Complex Method,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,Cyclomatic complexity of the method is 23
Complex Method,A4LGSharedFunctions,CurrentUserInfo,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\UserInfo.cs,GetCurrentUser,Cyclomatic complexity of the method is 16
Long Parameter List,A4LGSharedFunctions,MergeSplitFlds,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,MergeSplitFlds,The method has 5 parameters.
Long Parameter List,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,RotatePoint,The method has 6 parameters.
Long Parameter List,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,angleLogic,The method has 7 parameters.
Long Parameter List,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,RotatePointByNetwork,The method has 5 parameters.
Long Parameter List,A4LGSharedFunctions,WindowsAPI,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePictureFromSymbol,The method has 6 parameters.
Long Parameter List,A4LGSharedFunctions,WindowsAPI,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,DrawToDC,The method has 5 parameters.
Long Parameter List,A4LGSharedFunctions,WindowsAPI,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,Clear,The method has 6 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddGNResultClasses,The method has 9 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,copyClassToInMemory,The method has 9 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The method has 6 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlagsBarriersToLayer,The method has 8 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateOutageArea,The method has 6 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The method has 10 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The method has 8 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateAngledLineFromLocationToLine,The method has 6 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateAngledLineFromLocationOnLine,The method has 10 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetAddressInfo,The method has 11 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetAddressInfo,The method has 11 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetAddressInfo,The method has 11 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetNetworkAndFeatureAtLocation,The method has 5 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetJunctionFlagWithGN,The method has 9 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetJunctionFlagWithGN,The method has 8 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetJunctionFlag,The method has 10 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetJunctionFlag,The method has 9 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetEdgeFlagWithGN,The method has 10 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetEdgeFlagWithGN,The method has 9 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetEdgeFlag,The method has 11 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetEdgeFlag,The method has 10 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,junctionsToFlags,The method has 6 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateTraceFlowSolverFromToolbar,The method has 6 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectJunctions,The method has 8 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,MergeEdges,The method has 5 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,The method has 7 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,The method has 7 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetClosestFeatureIgnoreExistingLineFeature,The method has 5 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetClosestFeature,The method has 5 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,createSpatialFilter,The method has 5 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,createSpatialFilter,The method has 5 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The method has 7 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetIntersectingFeatures,The method has 6 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetIntersectingGeometry,The method has 6 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetIntersectingFeaturesOIDs,The method has 5 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The method has 8 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenArcSDEDatabaseLocatorWorkspace,The method has 5 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenArcSDEDatabaseLocatorWorkspace,The method has 6 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,copyFields,The method has 6 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectJunctions,The method has 7 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectEdges,The method has 6 parameters.
Long Parameter List,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetEIDInfoListByFCWithHT,The method has 6 parameters.
Long Identifier,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateTraceFlowSolverFromToolbar,The length of the parameter pNetworkAnalysisExtWeightFilter is 31.
Long Identifier,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetClosestFeatureIgnoreExistingLineFeature,The length of the parameter layerToLookFromExistingConnection is 33.
Long Statement,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,btnLoadConfig_Click,The length of the statement  "		string name = ConfigUtil.ChangeConfig (m_LoadedConfig' ((ConfigEntries)cboConfigs.SelectedItem)' chkBxBackupConfig.Checked); " is 124.
Long Statement,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The length of the statement  "	System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager (typeof(ConfigFormNoLog)); " is 136.
Long Statement,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,btnLoadConfig_Click,The length of the statement  "		string name = ConfigUtil.ChangeConfig (m_LoadedConfig' ((ConfigEntries)cboConfigs.SelectedItem)' this.chkBxBackupConfig.Checked); " is 129.
Long Statement,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The length of the statement  "	System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager (typeof(ConfigForm)); " is 131.
Long Statement,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,generateUserCachePath,The length of the statement  "			pathToUserProf = Registry.GetValue (@"HKEY_LOCAL_MACHINE\SOFTWARE\ArcGISSolutions\DesktopTools"' "ConfigLocation"' null) as string; " is 131.
Long Statement,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,generateUserCachePath,The length of the statement  "		} else if (Registry.GetValue (@"HKEY_CURRENT_USER\SOFTWARE\ArcGISSolutions\DesktopTools"' "ConfigLocation"' null) != null) { " is 124.
Long Statement,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,generateUserCachePath,The length of the statement  "			pathToUserProf = Registry.GetValue (@"HKEY_CURRENT_USER\SOFTWARE\ArcGISSolutions\DesktopTools"' "ConfigLocation"' null) as string; " is 130.
Long Statement,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,generateUserCachePath,The length of the statement  "			pathToUserProf = System.IO.Path.Combine (Environment.GetFolderPath (Environment.SpecialFolder.ApplicationData)' "ArcGISSolutions\\ConfigFiles"); " is 144.
Long Statement,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetAllConfigFiles,The length of the statement  "		List<string> pPrevConfFiles = new List<string> (Directory.GetFiles (pathToUserProf' "loaded.config"' System.IO.SearchOption.AllDirectories)); " is 141.
Long Statement,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetAllConfigFiles,The length of the statement  "		List<string> pConfFiles = new List<string> (Directory.GetFiles (pathToUserProf' "*." + type + ".*onfig*"' System.IO.SearchOption.AllDirectories)); " is 146.
Long Statement,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetConfigFile,The length of the statement  "		List<string> pPrevConfFiles = new List<string> (Directory.GetFiles (pathToUserProf' "loaded.config"' System.IO.SearchOption.AllDirectories)); " is 141.
Long Statement,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetConfigValue,The length of the statement  "		System.Windows.Forms.MessageBox.Show (ex.ToString () + "\nTypically an error here is from an improperly formatted config file. \nThe structure(XML) is compromised by a change you made."); " is 187.
Long Statement,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetConfigValue,The length of the statement  "		System.Windows.Forms.MessageBox.Show (ex.ToString () + "\nTypically an error here is from an improperly formatted config file. \nThe structure(XML) is compromised by a change you made."); " is 187.
Long Statement,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetConfigValue,The length of the statement  "		System.Windows.Forms.MessageBox.Show (ex.ToString () + "\nTypically an error here is from an improperly formatted config file. \nThe structure(XML) is compromised by a change you made."); " is 187.
Long Statement,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetConfigValue,The length of the statement  "		System.Windows.Forms.MessageBox.Show (ex.ToString () + "\nTypically an error here is from an improperly formatted config file. \nThe structure(XML) is compromised by a change you made."); " is 187.
Long Statement,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,getConfigAsXMLDoc,The length of the statement  "			System.Windows.Forms.MessageBox.Show (ex.ToString () + "\nTypically an error here is from an improperly formatted config file. \nThe structure(XML) is compromised by a change you made."); " is 187.
Long Statement,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetCreatePointWithRefConfig,The length of the statement  "		nodelist = xmld.SelectNodes ("configuration/AddressManagement/CreatePointWithReference/CreatePointWithReferenceDetails"); " is 121.
Long Statement,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetCreatePointWithRefConfig,The length of the statement  "			pSingleEntries = ((CreatePointWithReferenceDetails)Globals.DeserializeObject (node' typeof(CreatePointWithReferenceDetails))); " is 126.
Long Statement,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetLinePointAtEndsConfig,The length of the statement  "			pSingleEntries = ((ConstructLineWithPointsDetails)Globals.DeserializeObject (node' typeof(ConstructLineWithPointsDetails))); " is 124.
Long Statement,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetAddLateralsFromMainConfig,The length of the statement  "			pSingleEntries = (AddLateralFromMainPointDetails)Globals.DeserializeObject (node' typeof(AddLateralFromMainPointDetails)); " is 122.
Long Statement,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetProfileGraphConfig,The length of the statement  "			pSingleEntries = (ProfileGraphDetails)Globals.DeserializeObject (node.OuterXml.ToString ()' typeof(ProfileGraphDetails)); " is 121.
Long Statement,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,RotatePoint,The length of the statement  "				if (pFLayer.FeatureClass.ShapeType == esriGeometryType.esriGeometryPolyline && pFLayer.Visible && (strLayerName == "" || strLayerName == null || strLayerName == Globals.getClassName ((IDataset)pFLayer.FeatureClass))) { " is 218.
Long Statement,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The length of the statement  "	this.tbSearch.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right))); " is 187.
Long Statement,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The length of the statement  "	this.btnSearch.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 145.
Long Statement,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The length of the statement  "	this.listView1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right))); " is 233.
Long Statement,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The length of the statement  "	this.btnOK.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 144.
Long Statement,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The length of the statement  "	this.btnCancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 148.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,copyClassToInMemory,The length of the statement  "			pFlds = Globals.copyFields (sourceClass.Fields' sourceClass.LengthField' sourceClass.AreaField' IDFieldName' DateFieldName' removeMZ); " is 134.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,copyClassToInMemory,The length of the statement  "			pFlds = Globals.copyFields (sourceClass.Fields' sourceClass.LengthField' sourceClass.AreaField' IDFieldName' DateFieldName' removeMZ); " is 134.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The length of the statement  "		bool boolAddAllResultLayers = ConfigUtil.GetConfigValue ("Trace_ResultAddAllLayers"' "false").ToLower () == "false" ? false : true; " is 131.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The length of the statement  "		//bool boolAddAllResultLayers = ConfigUtil.GetConfigValue("Trace_ResultAddAllLayers"' "false").ToLower() == "false" ? false : true; " is 131.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The length of the statement  "			pGrpLay = Globals.AddGNResultClasses (gn' app' ID' dateTimeValue' IDFieldName' DateFieldName' out suffix' boolAddAllResultLayers' removeMZ); " is 140.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The length of the statement  "								pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ); " is 202.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The length of the statement  "									pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ); " is 202.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The length of the statement  "								pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ); " is 202.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The length of the statement  "							if (pFld.Type != esriFieldType.esriFieldTypeGeometry && pFld.Type != esriFieldType.esriFieldTypeOID && pFld != kvp.Value.FeatureLayer.FeatureClass.AreaField && pFld != kvp.Value.FeatureLayer.FeatureClass.LengthField) { " is 218.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlagsBarriersToLayer,The length of the statement  "			pFLayer = Globals.FindLayerInGroup (pCompLay' A4LGSharedFunctions.Localizer.GetString ("ExportFlagsName") + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix")); " is 186.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlagsBarriersToLayer,The length of the statement  "			pBLayer = Globals.FindLayerInGroup (pCompLay' A4LGSharedFunctions.Localizer.GetString ("ExportBarriersName") + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix")); " is 189.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlagsBarriersToLayer,The length of the statement  "			pFLayer = Globals.FindLayer (map' A4LGSharedFunctions.Localizer.GetString ("ExportFlagsName") + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix")' ref fndAsFL); " is 187.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlagsBarriersToLayer,The length of the statement  "			pBLayer = Globals.FindLayer (map' A4LGSharedFunctions.Localizer.GetString ("ExportBarriersName") + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix")' ref fndAsFL); " is 190.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlagsBarriersToLayer,The length of the statement  "		pFields = Globals.createFeatureClassFields (map.SpatialReference' esriGeometryType.esriGeometryPoint' IDFieldName' DateFieldName); " is 130.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlagsBarriersToLayer,The length of the statement  "			pFlagsFC = Globals.createFeatureClassInMemory (A4LGSharedFunctions.Localizer.GetString ("ExportFlagsName") + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix")' pFields' pWS' esriFeatureType.esriFTSimpleJunction); " is 233.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlagsBarriersToLayer,The length of the statement  "			pFlagsLayer.Name = A4LGSharedFunctions.Localizer.GetString ("ExportFlagsName") + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix"); " is 158.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlagsBarriersToLayer,The length of the statement  "			pFlagsFC = Globals.createFeatureClassInMemory (A4LGSharedFunctions.Localizer.GetString ("ExportFlagsName") + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix")' pFields' pWS' esriFeatureType.esriFTSimpleJunction); " is 233.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlagsBarriersToLayer,The length of the statement  "			pBarriersFC = Globals.createFeatureClassInMemory (A4LGSharedFunctions.Localizer.GetString ("ExportBarriersName") + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix")' pFields' pWS' esriFeatureType.esriFTSimpleJunction); " is 239.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlagsBarriersToLayer,The length of the statement  "			pBarriersLayer.Name = A4LGSharedFunctions.Localizer.GetString ("ExportBarriersName") + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix"); " is 164.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlagsBarriersToLayer,The length of the statement  "			pBarriersFC = Globals.createFeatureClassInMemory (A4LGSharedFunctions.Localizer.GetString ("ExportBarriersName") + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix")' pFields' pWS' esriFeatureType.esriFTSimpleJunction); " is 239.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateOutageArea,The length of the statement  "			pFLayer = Globals.FindLayerInGroup (pCompLay' A4LGSharedFunctions.Localizer.GetString ("OutageAreaName") + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix")); " is 185.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateOutageArea,The length of the statement  "			pFLayer = Globals.FindLayer (map' A4LGSharedFunctions.Localizer.GetString ("OutageAreaName") + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix")' ref fndAsFL); " is 186.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateOutageArea,The length of the statement  "			pFields = Globals.createFeatureClassFields (map.SpatialReference' esriGeometryType.esriGeometryPolygon' IDFieldName' DateFieldName); " is 132.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateOutageArea,The length of the statement  "				pFields = Globals.createFeatureClassFields (map.SpatialReference' esriGeometryType.esriGeometryPolygon' IDFieldName' DateFieldName); " is 132.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateOutageArea,The length of the statement  "					pFields = Globals.copyFields (pFTemplateLayer.FeatureClass.Fields' pFTemplateLayer.FeatureClass.LengthField' pFTemplateLayer.FeatureClass.AreaField' IDFieldName' DateFieldName' true); " is 183.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateOutageArea,The length of the statement  "					pFields = Globals.createFeatureClassFields (map.SpatialReference' esriGeometryType.esriGeometryPolygon' IDFieldName' DateFieldName); " is 132.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateOutageArea,The length of the statement  "		//pathToUserProf = System.IO.Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData)' "ArcGISSolutions\\Templates"); " is 142.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateOutageArea,The length of the statement  "		//string dataPath = "C:\\Work\\ArcGIS for Utilities\\_Water\\Staging\\UtilityNetworkEditingA4W\\MapsandGeodatabase\\Template.gdb"; " is 130.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateOutageArea,The length of the statement  "			pOutageFC = Globals.createFeatureClassInMemory ("OutageArea" + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix")' pFields' pWS' esriFeatureType.esriFTSimpleJunction); " is 187.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateOutageArea,The length of the statement  "			pOutageLayer.Name = A4LGSharedFunctions.Localizer.GetString ("OutageAreaName") + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix"); " is 158.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateOutageArea,The length of the statement  "			pOutageFC = Globals.createFeatureClassInMemory (A4LGSharedFunctions.Localizer.GetString ("OutageAreaName") + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix")' pFields' pWS' esriFeatureType.esriFTSimpleJunction); " is 233.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The length of the statement  "				return AddPointAlongLine (ref app' ref editor' curve' pointFLayer' targetPointDistance' targetPointDistanceIsPercent' editTemplate' storeFeature); " is 146.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The length of the statement  "						curve.QueryPointAndDistance (esriSegmentExtension.esriNoExtension' pIntPnt' false' pOutPnt' ref distAlongCurve' ref distFromCurve' ref bSide); " is 142.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The length of the statement  "					return AddPointAlongLine (ref app' ref editor' curve' pointFLayer' targetPointDistance' targetPointDistanceIsPercent' editTemplate' storeFeature); " is 146.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The length of the statement  "					MessageBox.Show ("Error storing new feature in the " + pointFLayer.Name + " layer\nThis is typically caused by a rule in the AA causing this feature not to be valid and deleting it\nModule: AddPointAlongLine\n" + ex.ToString ()); " is 229.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,BitmapFromTemplate,The length of the statement  "	Bitmap bitmap = WindowsAPI.SymbolToBitmap (symbol' new Size (16' 16)' control.CreateGraphics ()' ColorTranslator.ToWin32 (control.BackColor)); " is 142.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetAddressInfo,The length of the statement  "		return GetAddressInfo (app' pointLocation' lineLayer' idxRdName' idxRdLtTo' idxRdRtTo' idxRdLtFrm' idxRdRtFrm' idxRdId' searchOnLayer' searchDistance); " is 151.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetAddressInfo,The length of the statement  "		return GetAddressInfo (app' pointLocation' pLineFeat' FullNameField' LeftToField' RightToField' LeftFromField' RightFromField' StreetIDField' searchOnLayer' searchDistance); " is 173.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ReturnAccumulation,The length of the statement  "		traceFlowSolver = Globals.CreateTraceFlowSolverFromToolbar (ref pNetAnalysisExt' out pEdgeFlags' out pJunctionFlags' out pEdgeElementBarriers' out pJunctionElementBarriers' out pSelectionSetBarriers) as ITraceFlowSolverGEN; " is 223.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ReturnAccumulation,The length of the statement  "		if (pFeature.FeatureType == esriFeatureType.esriFTComplexEdge || pFeature.FeatureType == esriFeatureType.esriFTSimpleEdge) { " is 124.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ReturnAccumulation,The length of the statement  "		} else if (pFeature.FeatureType == esriFeatureType.esriFTSimpleJunction || pFeature.FeatureType == esriFeatureType.esriFTComplexJunction) { " is 139.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ReturnAccumulation,The length of the statement  "		traceFlowSolver.FindAccumulation (flowMethod' esriFlowElements.esriFEJunctionsAndEdges' out pJuncSel' out pEdgeSel' out pTotalCost); " is 132.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,getConnectionCount,The length of the statement  "	if (inFeature.FeatureType == esriFeatureType.esriFTComplexJunction || inFeature.FeatureType == esriFeatureType.esriFTSimpleJunction) { " is 134.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetGeometricNetworksJunctionsLayersHT,The length of the statement  "		MessageBox.Show ("Error in the Global Functions - GetGeomtricNetworksJunctionsLayersHT" + Environment.NewLine + ex.ToString ()); " is 128.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetGeometricNetworksJunctionsLayers,The length of the statement  "		MessageBox.Show ("Error in the Global Functions - GetGeometricNetworksJunctionsLayers" + Environment.NewLine + ex.ToString ()); " is 127.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetGeometricNetworksCheckedVisible,The length of the statement  "				if (fLayer.FeatureClass.FeatureType == esriFeatureType.esriFTComplexEdge || fLayer.FeatureClass.FeatureType == esriFeatureType.esriFTSimpleEdge || fLayer.FeatureClass.FeatureType == esriFeatureType.esriFTSimpleJunction) { " is 221.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetGeometricNetworksCurrentlyVisible,The length of the statement  "				if (fLayer.FeatureClass.FeatureType == esriFeatureType.esriFTComplexEdge || fLayer.FeatureClass.FeatureType == esriFeatureType.esriFTSimpleEdge || fLayer.FeatureClass.FeatureType == esriFeatureType.esriFTSimpleJunction) { " is 221.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetGeometricNetworks,The length of the statement  "				if (fLayer.FeatureClass.FeatureType == esriFeatureType.esriFTComplexEdge || fLayer.FeatureClass.FeatureType == esriFeatureType.esriFTSimpleEdge || fLayer.FeatureClass.FeatureType == esriFeatureType.esriFTSimpleJunction) { " is 221.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,isOrpanJunction,The length of the statement  "				if ((inNetFeat != null) && (inFeature.Class.ObjectClassID == inNetFeat.GeometricNetwork.OrphanJunctionFeatureClass.ObjectClassID)) " is 130.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetFeatureClassFromGeometricNetwork,The length of the statement  "				if ((pDataset.FullName.NameString).Substring (pDataset.FullName.NameString.LastIndexOf (".") + 1).ToUpper () == (sourceFCName).ToUpper ()) { " is 140.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetFeatureClassFromGeometricNetwork,The length of the statement  "				if ((pDataset.BrowseName).Substring (pDataset.BrowseName.LastIndexOf (".") + 1).ToUpper () == (sourceFCName).ToUpper ()) { " is 122.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetJunctionFlag,The length of the statement  "			junctionFlag = GetJunctionFlagWithGN (ref point' ref map' ref gn' snapTol' out snappedPoint' out EID' out pFlagDisplay' Flag); " is 126.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetJunctionFlag,The length of the statement  "			junctionFlag = GetJunctionFlagWithGN (ref point' ref map' ref gn' snapTol' out snappedPoint' out EID' out pFlagDisplay' Flag); " is 126.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetEdgeFlagWithGN,The length of the statement  "		return GetEdgeFlagWithGN (ref point' ref map' ref gn' snapTol' out snappedPoint' out EID' out distanceAlong' out pFlagDisplay' Flag); " is 133.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetEdgeFlag,The length of the statement  "			edgeFlag = GetEdgeFlagWithGN (ref point' ref map' ref gn' snapTol' out snappedPoint' out EID' out distanceAlong' out pFlagDisplay' Flag); " is 137.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetEdgeFlag,The length of the statement  "			edgeFlag = GetEdgeFlagWithGN (ref point' ref map' ref gn' snapTol' out snappedPoint' out EID' out distanceAlong' out pFlagDisplay' Flag); " is 137.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,junctionsToFlags,The length of the statement  "			junFlag = GetJunctionFlagWithGN (ref pPnt' ref pMap' ref gn' snapTol' out pRetPnt' out pOutEID' out pFlagDisplay [i]' Flag); " is 124.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateTraceFlowSolverFromToolbar,The length of the statement  "	//public static ITraceFlowSolverGEN CreateTraceFlowSolverFromToolbar(ref INetworkAnalysisExt pNetworkAnalysisExt' out List<IEdgeFlag> pEdgeFlags' out List<IJunctionFlag> pJunctionFlags' " is 185.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateTraceFlowSolverFromToolbar,The length of the statement  "	//        out INetElementBarriers pEdgeElementBarriers' out INetElementBarriers pJunctionElementBarriers' out ISelectionSetBarriers pSelectionSetBarriers' INetElementBarriers inBarr = null) " is 189.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateTraceFlowSolverFromToolbar,The length of the statement  "			pNetworkAnalysisExtWeightFilter.GetFilterType (esriElementType.esriETJunction' out eWeightFilterType' out blnApplyNotOperator); " is 127.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateTraceFlowSolverFromToolbar,The length of the statement  "				pNetworkAnalysisExtWeightFilter.GetFilterRange (esriElementType.esriETJunction' i' out lngFromValues [i]' out lngToValues [i]); " is 127.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateTraceFlowSolverFromToolbar,The length of the statement  "			pNetworkAnalysisExtWeightFilter.GetFilterType (esriElementType.esriETEdge' out eWeightFilterType' out blnApplyNotOperator); " is 123.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateTraceFlowSolverFromToolbar,The length of the statement  "				pNetworkAnalysisExtWeightFilter.GetFilterRange (esriElementType.esriETEdge' i' out lngFromValues [i]' out lngToValues [i]); " is 123.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectJunctions,The length of the statement  "					selectionSet = fLayer.FeatureClass.Select (null' esriSelectionType.esriSelectionTypeHybrid' esriSelectionOption.esriSelectionOptionEmpty' dataset.Workspace); " is 157.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectEdges,The length of the statement  "			if (fLayer.Valid && fLayer.Visible && fLayer.Selectable && IsInNetwork (fLayer.FeatureClass.FeatureClassID' gn' false)) { " is 121.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectEdges,The length of the statement  "				selectionSet = fLayer.FeatureClass.Select (null' esriSelectionType.esriSelectionTypeHybrid' esriSelectionOption.esriSelectionOptionEmpty' dataset.Workspace); " is 157.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,DrawEdges,The length of the statement  "		symb.Color = GetColor (Convert.ToInt32 (strColors [0])' Convert.ToInt32 (strColors [1])' Convert.ToInt32 (strColors [2])); " is 122.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,MergeEdges,The length of the statement  "				if (mainsFL.FeatureClass.ObjectClassID.ToString () == eidInfo.Feature.Class.ObjectClassID.ToString () && mainsFL.FeatureClass.CLSID.Value.ToString () == eidInfo.Feature.Class.CLSID.Value.ToString ()) { " is 201.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,returnToXML,The length of the statement  "			//  System.Windows.Forms.MessageBox.Show(ex.ToString() + "\nTypically an error here is from an improperly formatted config file. \nThe structure(XML) is compromised by a change you made."); " is 189.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,getFileAtDLLLocation,The length of the statement  "		} else if ((System.IO.File.Exists (System.IO.Path.Combine (System.IO.Directory.GetParent (AppPath).ToString ()' configFileName)))) { " is 132.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,InitDefaults,The length of the statement  "	System.Reflection.PropertyInfo[] props = o.GetType ().GetProperties (BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static); " is 161.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,PromptAndGetEditTemplate,The length of the statement  "		string SelectedTemplate = Globals.showValuesOptionsForm (strTemplateNames' Layer.Name' caption' ComboBoxStyle.DropDownList); " is 124.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FeatureIsValidTemplate,The length of the statement  "				if (inFeature.get_Value (fldDx) != null && inFeature.get_Value (fldDx) != DBNull.Value && pEdTempl.get_DefaultValue (Fld) != null && pEdTempl.get_DefaultValue (Fld) != DBNull.Value) { " is 183.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FeatureIsValidTemplate,The length of the statement  "					if (inFeature.get_Value (fldDx) != null && inFeature.get_Value (fldDx) != DBNull.Value && pEdTempl.get_DefaultValue (inFeature.Fields.get_Field (fldDx).Name) != null && pEdTempl.get_DefaultValue (inFeature.Fields.get_Field (fldDx).Name) != DBNull.Value) { " is 255.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FeatureIsValidTemplate,The length of the statement  "						if (inFeature.get_Value (fldDx).ToString () != pEdTempl.get_DefaultValue (inFeature.Fields.get_Field (fldDx).Name).ToString ()) { " is 129.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,The length of the statement  "		//Editor.Display.Invalidate((app.Document as IMxDocument).ActiveView.Extent' true' (short)esriScreenCache.esriAllScreenCaches); " is 127.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,The length of the statement  "		MessageBox.Show ("Error creating a feature with template\r\nFeature Template: " + pEditTemplate.Name + "\r\n" + ex.ToString ()); " is 128.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,The length of the statement  "		Editor.Display.Invalidate ((app.Document as IMxDocument).ActiveView.Extent' true' (short)esriScreenCache.esriAllScreenCaches); " is 126.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetMapCoordinatesFromScreenCoordinates,The length of the statement  "		MessageBox.Show ("Error in the Project Costing Tools - Globals.Functions: GetMapCoordinatesFromScreenCoordinates" + Environment.NewLine + ex.ToString ()); " is 154.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetScreenCoordinatesFromMapCoordinates,The length of the statement  "		MessageBox.Show ("Error in Project Costing Tools - Globals.Functions: GetScreenCoordinatesFromMapCoordinates" + Environment.NewLine + ex.ToString ()); " is 150.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateContextMenu,The length of the statement  "		pContextMenu = ((IDocument)app.Document).CommandBars.Create ("StylePopup"' ESRI.ArcGIS.SystemUI.esriCmdBarType.esriCmdBarTypeShortcutMenu); " is 139.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindMarkerSym,The length of the statement  "		pEnumStyGallItm = pStyGall.get_Items ("Marker Symbols"' stylename' A4LGSharedFunctions.Localizer.GetString ("Category_Style")); " is 127.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The length of the statement  "		bool hit = hitTest.HitTest (SplitPoint' SnapTol' esriGeometryHitPartType.esriGeometryPartBoundary' pHitPnt' pHitDist' pHitPrt' pHitSeg' pHitSide); " is 146.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The length of the statement  "					dblMidVal = Convert.ToDouble (string.Format (SplitFormatString' dblLowVal + ((dblHighVal - dblLowVal) * percentSplit))); " is 120.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The length of the statement  "						if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) { " is 137.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The length of the statement  "						} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) { " is 140.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The length of the statement  "					if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) { " is 133.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The length of the statement  "					} else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) { " is 136.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The length of the statement  "						if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) { " is 137.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The length of the statement  "						} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) { " is 140.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The length of the statement  "					//if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) " is 133.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The length of the statement  "					//else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) " is 134.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetPointOnLine,The length of the statement  "	if (inPoint.GeometryType != esriGeometryType.esriGeometryPoint && InLine.GeometryType != esriGeometryType.esriGeometryPolyline) { " is 129.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetPointOnLine,The length of the statement  "		bool foundGeometry = pHt.HitTest (inPoint' snapTol' ESRI.ArcGIS.Geometry.esriGeometryHitPartType.esriGeometryPartBoundary' pHitPnt' ref hitDistance' ref hitPartIndex' ref hitSegmentIndex' ref RightSide); " is 203.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,PointDistanceOnLine,The length of the statement  "		iCurv.QueryPointAndDistance (esriSegmentExtension.esriExtendAtFrom' inPoint' false' SnapPnt' ref outDistAlongCurve' ref outDistFromCurve' false); " is 145.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The length of the statement  "				//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension); " is 120.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The length of the statement  "						//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension); " is 124.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The length of the statement  "							//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension); " is 124.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateSpatRef,The length of the statement  "	//IGeographicCoordinateSystem srGeo = spatRefFact.CreateGeographicCoordinateSystem((int)esriSRGeoCSType.esriSRGeoCS_WGS1984); " is 125.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertFeetToMapUnits,The length of the statement  "			return pUnitConverter.ConvertUnits (unitsFeet' ESRI.ArcGIS.esriSystem.esriUnits.esriFeet' ConvertUnitType (pPrjCoord.CoordinateUnit)); " is 134.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertFeetToMapUnits,The length of the statement  "			return pUnitConverter.ConvertUnits (unitsFeet' ESRI.ArcGIS.esriSystem.esriUnits.esriFeet' ConvertUnitType (pGeoCoord.CoordinateUnit)); " is 134.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertSpatRefToFeet,The length of the statement  "			return pUnitConverter.ConvertUnits (unitsSpatRef' ConvertUnitType (pPrjCoord.CoordinateUnit)' ESRI.ArcGIS.esriSystem.esriUnits.esriFeet); " is 137.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertSpatRefToFeet,The length of the statement  "			return pUnitConverter.ConvertUnits (unitsSpatRef' ConvertUnitType (pPrjCoord.CoordinateUnit)' ESRI.ArcGIS.esriSystem.esriUnits.esriFeet); " is 137.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The length of the statement  "					pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]); " is 132.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The length of the statement  "					pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]); " is 149.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayerFromMapDataset,The length of the statement  "					if (pDataset.BrowseName.ToUpper ().Substring (pDataset.BrowseName.LastIndexOf (".") + 1) == sLName.ToUpper () && dataset.Workspace == pDataset.Workspace) { " is 155.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayerFromMapDataset,The length of the statement  "					if (pDataset.FullName.NameString.ToUpper ().Substring (pDataset.FullName.NameString.LastIndexOf (".") + 1) == sLName.ToUpper () && dataset.Workspace == pDataset.Workspace) { " is 173.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayerFromMapDataset,The length of the statement  "						if (pDataset.BrowseName.ToUpper ().Substring (pDataset.BrowseName.LastIndexOf (".") + 1) == sLName.ToUpper () && dataset.Workspace == pDataset.Workspace) { " is 155.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayerFromMapDataset,The length of the statement  "						if (pDataset.FullName.NameString.ToUpper ().Substring (pDataset.FullName.NameString.LastIndexOf (".") + 1) == sLName.ToUpper () && dataset.Workspace == pDataset.Workspace) { " is 173.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayerNotInMemory,The length of the statement  "						if (pDataset.FullName.NameString.ToUpper ().Substring (pDataset.FullName.NameString.LastIndexOf (".") + 1) == sLName.ToUpper ()) { " is 130.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayerNotInMemory,The length of the statement  "							if (pDataset.FullName.NameString.ToUpper ().Substring (pDataset.FullName.NameString.LastIndexOf (".") + 1) == sLName.ToUpper ()) { " is 130.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayer,The length of the statement  "					if (pDataset.FullName.NameString.ToUpper ().Substring (pDataset.FullName.NameString.LastIndexOf (".") + 1) == sLName.ToUpper ()) { " is 130.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayer,The length of the statement  "						if (pDataset.FullName.NameString.ToUpper ().Substring (pDataset.FullName.NameString.LastIndexOf (".") + 1) == sLName.ToUpper ()) { " is 130.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayerInWorkspace,The length of the statement  "					if (pDataset.BrowseName.ToUpper ().Substring (pDataset.BrowseName.LastIndexOf (".") + 1) == sLName.ToUpper () && ((IWorkspace)pLay).Equals (workspace)) { " is 153.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayerInWorkspace,The length of the statement  "					if (pDataset.FullName.NameString.ToUpper ().Substring (pDataset.FullName.NameString.LastIndexOf (".") + 1) == sLName.ToUpper () && ((IWorkspace)pLay).Equals (workspace)) { " is 171.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayerInWorkspace,The length of the statement  "						if (pDataset.BrowseName.ToUpper ().Substring (pDataset.BrowseName.LastIndexOf (".") + 1) == sLName.ToUpper () && ((IWorkspace)pLay).Equals (workspace)) { " is 153.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayerInWorkspace,The length of the statement  "						if (pDataset.FullName.NameString.ToUpper ().Substring (pDataset.FullName.NameString.LastIndexOf (".") + 1) == sLName.ToUpper () && ((IWorkspace)pLay).Equals (workspace)) { " is 171.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,EstablishFlow,The length of the statement  "			//    MessageBox.Show("Unable to set flow direction for " + gn.FeatureDataset.Name + ".  Add the " + gn.OrphanJunctionFeatureClass.AliasName + " to your map and try again' if needed"' "Establish Flow Direction"); " is 212.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,EstablishFlow,The length of the statement  "			//    MessageBox.Show("Unable to set flow direction for " + gn.FeatureDataset.Name + ".  It is visible but not editable."' "Establish Flow Direction"); " is 151.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,EstablishFlow,The length of the statement  "					MessageBox.Show ("Flow direction for " + gn.FeatureDataset.Name + " not set.  No feature classes have source/sink capability." + Environment.NewLine + "You must recreate your geometric network to use this command on this network."' "Establish Flow"); " is 250.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,LayerExist,The length of the statement  "				if ((pDataset.FullName.NameString).Substring (pDataset.FullName.NameString.LastIndexOf (".") + 1).ToUpper () == (sLName).ToUpper ()) { " is 134.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,createFeatureClassInMemory,The length of the statement  "					newFeat = pFWS.CreateFeatureClass (strName + (loopCnt - 1).ToString ()' validatedFields' null' null' featType' "SHAPE"' ""); " is 124.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,createFieldsFromSourceFields,The length of the statement  "		if (SourceField.Editable || SourceField.Type == esriFieldType.esriFieldTypeOID || SourceField.Type == esriFieldType.esriFieldTypeGeometry) { " is 140.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectJunctions,The length of the statement  "			progressDialog.Description = pFL.Name + ": " + A4LGSharedFunctions.Localizer.GetString ("SltByJctCountProc_3") + k.ToString () + A4LGSharedFunctions.Localizer.GetString ("Of") + totSel.ToString () + "."; " is 203.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectEdges,The length of the statement  "			progressDialog.Description = A4LGSharedFunctions.Localizer.GetString ("SltByJctCountProc_3") + ": " + pFL.Name + " " + k.ToString () + A4LGSharedFunctions.Localizer.GetString ("of") + totSel.ToString () + "."; " is 209.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectEdges,The length of the statement  "			} else if (((edgeFeature.FromJunctionFeature as IFeature).Class.ObjectClassID == OrphanObjectClassID) || ((edgeFeature.ToJunctionFeature as IFeature).Class.ObjectClassID == OrphanObjectClassID)) { " is 196.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,RemoveTraceGraphics,The length of the statement  "			if (elemProp.Name.Contains ("MoveFeatureFlag") || elemProp.Name == "TraceFlag" || elemProp.Name == "TraceResults" || elemProp.Name == "SewerProfileFlag" || elemProp.Name == "SewerProfileFlag1" || elemProp.Name == "SewerProfileFlag2" || elemProp.Name.Contains ("ProfileGraph")) { " is 278.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetEIDInfoListByFCWithHT,The length of the statement  "						if (testEidInfo.Feature.get_Value (testEidInfo.Feature.Fields.FindField (operableFieldNameSources)).ToString () == opValues [0]) { " is 130.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetEIDInfoListByFCWithHT,The length of the statement  "					if (testEidInfo.Feature.get_Value (testEidInfo.Feature.Fields.FindFieldByAliasName (operableFieldNameSources)) == null) { " is 121.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetEIDInfoListByFCWithHT,The length of the statement  "						if (testEidInfo.Feature.get_Value (testEidInfo.Feature.Fields.FindFieldByAliasName (operableFieldNameSources)).ToString () == opValues [0]) { " is 141.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetOperableValveOIDs,The length of the statement  "					qf.WhereClause = "(" + operableFieldNameValves + " <> " + opValues [0] + " or " + operableFieldNameValves + " Is Null )"; " is 121.
Long Statement,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetOperableValveOIDs,The length of the statement  "					qf.WhereClause = "(" + operableFieldNameValves + " <> '" + opValues [0] + "' or " + operableFieldNameValves + " Is Null )"; " is 123.
Long Statement,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The length of the statement  "				rotationAngle = rotFunc.RotatePoint (pMxDoc.FocusMap' pMxDoc.SearchTolerance' inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName); " is 196.
Long Statement,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The length of the statement  "				rotationAngle = rotFunc.RotatePointByNetwork (pMxDoc.FocusMap' (INetworkFeature)inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName); " is 198.
Long Statement,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The length of the statement  "			MessageBox.Show ("Error Rotation Feature at " + inFeature.Class.AliasName + " with Object ID:" + inFeature.OID + "\n" + ex.ToString ()); " is 136.
Long Statement,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetAngleOfSegment,The length of the statement  "	//double testa =  DegreeToRadian(Math.Atan((inSegment.ToPoint.Y - inSegment.FromPoint.Y) / (inSegment.ToPoint.X - inSegment.FromPoint.X))); " is 139.
Long Statement,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetAngleOfSegment,The length of the statement  "	//double testa =  DegreeToRadian(Math.Atan((inSegment.ToPoint.Y - inSegment.FromPoint.Y) / (inSegment.ToPoint.X - inSegment.FromPoint.X))); " is 139.
Complex Conditional,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,RotatePoint,The conditional expression  "pFLayer.FeatureClass.ShapeType == esriGeometryType.esriGeometryPolyline && pFLayer.Visible && (strLayerName == "" || strLayerName == null || strLayerName == Globals.getClassName ((IDataset)pFLayer.FeatureClass))"  is complex.
Complex Conditional,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The conditional expression  "pFld.Type != esriFieldType.esriFieldTypeGeometry && pFld.Type != esriFieldType.esriFieldTypeOID && pFld != kvp.Value.FeatureLayer.FeatureClass.AreaField && pFld != kvp.Value.FeatureLayer.FeatureClass.LengthField"  is complex.
Complex Conditional,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetAddressInfo,The conditional expression  "FullNameField == -1 || LeftToField == -1 || RightToField == -1 || LeftFromField == -1 || RightFromField == -1"  is complex.
Complex Conditional,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectEdges,The conditional expression  "fLayer.Valid && fLayer.Visible && fLayer.Selectable && IsInNetwork (fLayer.FeatureClass.FeatureClassID' gn' false)"  is complex.
Complex Conditional,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FeatureIsValidTemplate,The conditional expression  "inFeature.get_Value (fldDx) != null && inFeature.get_Value (fldDx) != DBNull.Value && pEdTempl.get_DefaultValue (Fld) != null && pEdTempl.get_DefaultValue (Fld) != DBNull.Value"  is complex.
Complex Conditional,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FeatureIsValidTemplate,The conditional expression  "inFeature.get_Value (fldDx) != null && inFeature.get_Value (fldDx) != DBNull.Value && pEdTempl.get_DefaultValue (inFeature.Fields.get_Field (fldDx).Name) != null && pEdTempl.get_DefaultValue (inFeature.Fields.get_Field (fldDx).Name) != DBNull.Value"  is complex.
Complex Conditional,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,RemoveTraceGraphics,The conditional expression  "elemProp.Name.Contains ("MoveFeatureFlag") || elemProp.Name == "TraceFlag" || elemProp.Name == "TraceResults" || elemProp.Name == "SewerProfileFlag" || elemProp.Name == "SewerProfileFlag1" || elemProp.Name == "SewerProfileFlag2" || elemProp.Name.Contains ("ProfileGraph")"  is complex.
Empty Catch Block,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,ConfigFormNoLog,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,ConfigForm,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,SelectTemplateFormGraphic,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,LoadListView,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,SelectOptionForm,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,deleteFeatures,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,deleteFeatures,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlagsBarriersToLayer,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetAngleOfLineAtPoint,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetNetworkAndFeatureAtLocation,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetNetworkAndFeatureAtLocation,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetJunctionFlagWithGN,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,getEIDAtLocation,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetEdgeFlagWithGN,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddFlagToTraceSolver,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddFlagToTraceSolver,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddFlagToTraceSolver,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddFlagsToTraceSolver,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddBarriersToSolver,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddFlagToGN,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddFlagToGN,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddBarrierToGN,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddBarrierToGN,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,RemoveFlagBarrierAtLocation,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,RemoveFlagBarrierAtLocation,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,junctionsToFlags,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddTwoJunctionFlagsToTraceSolver,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddTwoJunctionFlagsToTraceSolver,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddTwoJunctionFlagsToTraceSolver,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddTwoJunctionFlagsToTraceSolver,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddTwoJunctionFlagsToTraceSolver,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,getFlagsBarriers,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectEdges,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetRegistryValueLM,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetRegistryValueCU,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ValidateFeature,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,DeleteFeatures,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,createSpatialFilter,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,createSpatialFilter,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindCommandAndExecute,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindCommandAndExecute,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,IdentifySelectedDockable,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,IdentifySelected,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ClearSelected,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ClearSelected,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ClearSelected,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlashGeometry,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointGraphic,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,getClassName,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,getClassName,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,getClassName,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,getClassName,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,getClassName,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,RemoveTraceGraphics,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetEIDInfoListByFCWithHT,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectValveJunctionsByName,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectValveJunctionsLayer,The method has an empty catch block.
Empty Catch Block,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,SelectTemplateForm,The method has an empty catch block.
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.btnOpenConfigLoc.Location = new System.Drawing.Point (13' 123);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.btnOpenConfigLoc.Location = new System.Drawing.Point (13' 123);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.btnOpenConfigLoc.Size = new System.Drawing.Size (144' 23);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.btnOpenConfigLoc.Size = new System.Drawing.Size (144' 23);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.txtBxPath.Location = new System.Drawing.Point (13' 95);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.txtBxPath.Location = new System.Drawing.Point (13' 95);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.txtBxPath.Size = new System.Drawing.Size (471' 20);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.txtBxPath.Size = new System.Drawing.Size (471' 20);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.cboConfigs.Location = new System.Drawing.Point (13' 29);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.cboConfigs.Location = new System.Drawing.Point (13' 29);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.cboConfigs.Size = new System.Drawing.Size (276' 21);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.cboConfigs.Size = new System.Drawing.Size (276' 21);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.cboConfigs.TabIndex = 2;  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.btnLoadConfig.Location = new System.Drawing.Point (13' 57);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.btnLoadConfig.Location = new System.Drawing.Point (13' 57);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.btnLoadConfig.Size = new System.Drawing.Size (145' 23);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.btnLoadConfig.Size = new System.Drawing.Size (145' 23);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.btnLoadConfig.TabIndex = 3;  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point (13' 74);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point (13' 74);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size (81' 13);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size (81' 13);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 4;  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.gpBxConfig.Size = new System.Drawing.Size (495' 158);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.gpBxConfig.Size = new System.Drawing.Size (495' 158);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.gpBxConfig.TabIndex = 5;  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.btnPreviewLoaded.Location = new System.Drawing.Point (315' 40);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.btnPreviewLoaded.Location = new System.Drawing.Point (315' 40);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.btnPreviewLoaded.Size = new System.Drawing.Size (145' 23);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.btnPreviewLoaded.Size = new System.Drawing.Size (145' 23);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.btnPreviewLoaded.TabIndex = 5;  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.lblConfig.Location = new System.Drawing.Point (13' 20);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.lblConfig.Location = new System.Drawing.Point (13' 20);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.lblConfig.Size = new System.Drawing.Size (76' 13);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.lblConfig.Size = new System.Drawing.Size (76' 13);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.lblConfig.TabIndex = 6;  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.txtBxLoadedConfig.Location = new System.Drawing.Point (13' 40);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.txtBxLoadedConfig.Location = new System.Drawing.Point (13' 40);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.txtBxLoadedConfig.Size = new System.Drawing.Size (276' 20);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.txtBxLoadedConfig.Size = new System.Drawing.Size (276' 20);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.txtBxLoadedConfig.TabIndex = 5;  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.gpBxconfigFiles.Location = new System.Drawing.Point (0' 164);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.gpBxconfigFiles.Size = new System.Drawing.Size (495' 92);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.gpBxconfigFiles.Size = new System.Drawing.Size (495' 92);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.gpBxconfigFiles.TabIndex = 6;  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.chkBxBackupConfig.Location = new System.Drawing.Point (164' 61);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.chkBxBackupConfig.Location = new System.Drawing.Point (164' 61);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.chkBxBackupConfig.Size = new System.Drawing.Size (80' 17);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.chkBxBackupConfig.Size = new System.Drawing.Size (80' 17);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.chkBxBackupConfig.TabIndex = 5;  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.btnPreview.Location = new System.Drawing.Point (300' 28);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.btnPreview.Location = new System.Drawing.Point (300' 28);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.btnPreview.Size = new System.Drawing.Size (145' 23);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.btnPreview.Size = new System.Drawing.Size (145' 23);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.btnPreview.TabIndex = 4;  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (495' 256);  
Magic Number,A4LGSharedFunctions,ConfigFormNoLog,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigFormNoLog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (495' 256);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnOpenConfigLoc.Location = new System.Drawing.Point (13' 123);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnOpenConfigLoc.Location = new System.Drawing.Point (13' 123);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnOpenConfigLoc.Size = new System.Drawing.Size (144' 23);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnOpenConfigLoc.Size = new System.Drawing.Size (144' 23);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.txtBxPath.Location = new System.Drawing.Point (13' 95);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.txtBxPath.Location = new System.Drawing.Point (13' 95);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.txtBxPath.Size = new System.Drawing.Size (471' 20);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.txtBxPath.Size = new System.Drawing.Size (471' 20);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.cboConfigs.Location = new System.Drawing.Point (13' 29);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.cboConfigs.Location = new System.Drawing.Point (13' 29);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.cboConfigs.Size = new System.Drawing.Size (276' 21);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.cboConfigs.Size = new System.Drawing.Size (276' 21);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.cboConfigs.TabIndex = 2;  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnLoadConfig.Location = new System.Drawing.Point (13' 57);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnLoadConfig.Location = new System.Drawing.Point (13' 57);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnLoadConfig.Size = new System.Drawing.Size (145' 23);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnLoadConfig.Size = new System.Drawing.Size (145' 23);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnLoadConfig.TabIndex = 3;  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point (13' 74);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point (13' 74);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size (81' 13);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size (81' 13);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 4;  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.gpBxConfig.Size = new System.Drawing.Size (495' 158);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.gpBxConfig.Size = new System.Drawing.Size (495' 158);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.gpBxConfig.TabIndex = 5;  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnPreviewLoaded.Location = new System.Drawing.Point (316' 52);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnPreviewLoaded.Location = new System.Drawing.Point (316' 52);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnPreviewLoaded.Size = new System.Drawing.Size (145' 23);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnPreviewLoaded.Size = new System.Drawing.Size (145' 23);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnPreviewLoaded.TabIndex = 5;  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnReload.Location = new System.Drawing.Point (316' 23);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnReload.Location = new System.Drawing.Point (316' 23);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnReload.Size = new System.Drawing.Size (145' 23);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnReload.Size = new System.Drawing.Size (145' 23);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnReload.TabIndex = 7;  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.lblConfig.Location = new System.Drawing.Point (13' 20);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.lblConfig.Location = new System.Drawing.Point (13' 20);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.lblConfig.Size = new System.Drawing.Size (76' 13);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.lblConfig.Size = new System.Drawing.Size (76' 13);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.lblConfig.TabIndex = 6;  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.txtBxLoadedConfig.Location = new System.Drawing.Point (13' 40);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.txtBxLoadedConfig.Location = new System.Drawing.Point (13' 40);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.txtBxLoadedConfig.Size = new System.Drawing.Size (276' 20);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.txtBxLoadedConfig.Size = new System.Drawing.Size (276' 20);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.txtBxLoadedConfig.TabIndex = 5;  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.gpBxconfigFiles.Location = new System.Drawing.Point (0' 251);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.gpBxconfigFiles.Size = new System.Drawing.Size (495' 92);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.gpBxconfigFiles.Size = new System.Drawing.Size (495' 92);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.gpBxconfigFiles.TabIndex = 6;  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.chkBxBackupConfig.Location = new System.Drawing.Point (164' 61);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.chkBxBackupConfig.Location = new System.Drawing.Point (164' 61);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.chkBxBackupConfig.Size = new System.Drawing.Size (80' 17);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.chkBxBackupConfig.Size = new System.Drawing.Size (80' 17);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.chkBxBackupConfig.TabIndex = 6;  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnPreview.Location = new System.Drawing.Point (300' 28);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnPreview.Location = new System.Drawing.Point (300' 28);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnPreview.Size = new System.Drawing.Size (145' 23);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnPreview.Size = new System.Drawing.Size (145' 23);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnPreview.TabIndex = 4;  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.gpBxLog.Location = new System.Drawing.Point (0' 158);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.gpBxLog.Size = new System.Drawing.Size (495' 93);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.gpBxLog.Size = new System.Drawing.Size (495' 93);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.gpBxLog.TabIndex = 7;  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point (13' 73);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point (13' 73);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size (476' 17);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size (476' 17);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 7;  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnPrevLog.Location = new System.Drawing.Point (162' 46);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnPrevLog.Location = new System.Drawing.Point (162' 46);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnPrevLog.Size = new System.Drawing.Size (145' 23);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnPrevLog.Size = new System.Drawing.Size (145' 23);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnPrevLog.TabIndex = 6;  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnOpenLogLoc.Location = new System.Drawing.Point (12' 46);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnOpenLogLoc.Location = new System.Drawing.Point (12' 46);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnOpenLogLoc.Size = new System.Drawing.Size (145' 23);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnOpenLogLoc.Size = new System.Drawing.Size (145' 23);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.btnOpenLogLoc.TabIndex = 2;  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.txtBoxLogPath.Location = new System.Drawing.Point (12' 21);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.txtBoxLogPath.Location = new System.Drawing.Point (12' 21);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.txtBoxLogPath.Size = new System.Drawing.Size (471' 20);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.txtBoxLogPath.Size = new System.Drawing.Size (471' 20);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.txtBoxLogPath.TabIndex = 3;  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (495' 343);  
Magic Number,A4LGSharedFunctions,ConfigForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (495' 343);  
Magic Number,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetAddLateralsConfig,The following statement contains a magic number: try {  	//Get the list of name nodes   	//nodelist = xmld.SelectNodes("LayerViewerConfig/Layers/Layer");  	nodelist = xmld.SelectNodes ("configuration/AddLateralsLayers/AddLateralDetails");  	if (nodelist == null) {  		return null;  	}  	//Loop through the nodes   	pEntries = new List<AddLateralDetails> ();  	for (int i = 0; i < nodelist.Count; i++) {  		node = nodelist.Item (i);  		// Globals.InitDefaults((Object)pSingleEntries);  		pSingleEntries = (AddLateralDetails)Globals.DeserializeObject (node' typeof(AddLateralDetails));  		if (pSingleEntries != null) {  			if (pSingleEntries.Hook_Angle == 0)  				pSingleEntries.Hook_Angle = 45;  			pEntries.Add (pSingleEntries);  		}  	}  	return pEntries;  } catch//(Exception ex)   {  	return null;  } finally {  	xmld = null;  	nodelist = null;  	node = null;  	pSingleEntries = null;  }  
Magic Number,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetAddLateralsConfig,The following statement contains a magic number: for (int i = 0; i < nodelist.Count; i++) {  	node = nodelist.Item (i);  	// Globals.InitDefaults((Object)pSingleEntries);  	pSingleEntries = (AddLateralDetails)Globals.DeserializeObject (node' typeof(AddLateralDetails));  	if (pSingleEntries != null) {  		if (pSingleEntries.Hook_Angle == 0)  			pSingleEntries.Hook_Angle = 45;  		pEntries.Add (pSingleEntries);  	}  }  
Magic Number,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetAddLateralsConfig,The following statement contains a magic number: if (pSingleEntries != null) {  	if (pSingleEntries.Hook_Angle == 0)  		pSingleEntries.Hook_Angle = 45;  	pEntries.Add (pSingleEntries);  }  
Magic Number,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetAddLateralsConfig,The following statement contains a magic number: if (pSingleEntries.Hook_Angle == 0)  	pSingleEntries.Hook_Angle = 45;  
Magic Number,A4LGSharedFunctions,ConfigUtil,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\ConfigUtil.cs,GetAddLateralsConfig,The following statement contains a magic number: pSingleEntries.Hook_Angle = 45;  
Magic Number,A4LGSharedFunctions,LastValueForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\LastValueForm.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.Size = new System.Drawing.Size (525' 542);  
Magic Number,A4LGSharedFunctions,LastValueForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\LastValueForm.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.Size = new System.Drawing.Size (525' 542);  
Magic Number,A4LGSharedFunctions,LastValueForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\LastValueForm.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.SplitterDistance = 479;  
Magic Number,A4LGSharedFunctions,LastValueForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\LastValueForm.cs,InitializeComponent,The following statement contains a magic number: this.dataGridView1.Size = new System.Drawing.Size (525' 479);  
Magic Number,A4LGSharedFunctions,LastValueForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\LastValueForm.cs,InitializeComponent,The following statement contains a magic number: this.dataGridView1.Size = new System.Drawing.Size (525' 479);  
Magic Number,A4LGSharedFunctions,LastValueForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\LastValueForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (525' 542);  
Magic Number,A4LGSharedFunctions,LastValueForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\LastValueForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (525' 542);  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,RotatePoint,The following statement contains a magic number: try {  	//This routine is used by both RotateDuringCreateFeature and RotateSelectedFeature.  	//It contains all of logic for determining the rotation angle.  	const int iAngleTol = 5;  	//Used for Tees> a straight line is 180 + or - iAngleTol  	pPointFC = (IFeatureClass)pPointFeature.Class;  	pPoint = (IPoint)pPointFeature.Shape;  	xyTol = Globals.GetXYTolerance (pPoint);  	//Create spatial filter to find intersecting features at this given point  	pTopo = (ITopologicalOperator)pPoint;  	pSFilter = new SpatialFilter ();  	pSFilter.Geometry = pTopo.Buffer (mapTol);  	//pPoint  	pSFilter.GeometryField = pPointFC.ShapeFieldName;  	pSFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelIntersects;  	//Step through each feature layer  	pUID.Value = "{E156D7E5-22AF-11D3-9F99-00C04F6BC78E}";  	//GeoFeatureLayer  	pEnumLayer = (IEnumLayer)pMap.get_Layers (pUID' true);  	pEnumLayer.Reset ();  	pLayer = (ILayer)pEnumLayer.Next ();  	diameterMeterFeat diamPnt = null;  	while ((pLayer != null)) {  		//Verify that this is a line layer  		pFLayer = (IFeatureLayer)pLayer;  		if (pFLayer.FeatureClass != null) {  			if (pFLayer.FeatureClass.ShapeType == esriGeometryType.esriGeometryPolyline && pFLayer.Visible && (strLayerName == "" || strLayerName == null || strLayerName == Globals.getClassName ((IDataset)pFLayer.FeatureClass))) {  				//Apply the filter this line layer  				pLineCursor = pFLayer.FeatureClass.Search (pSFilter' true);  				//Loop through the found lines for this layer  				pLineFeature = pLineCursor.NextFeature ();  				while ((pLineFeature != null)) {  					if (pLstInt.Count > 0) {  						if (pLstInt.Contains (pLineFeature.Class.ObjectClassID + " " + pLineFeature.OID)) {  							pLineFeature = pLineCursor.NextFeature ();  							continue;  						}  					}  					string listInt;  					diamPnt = null;  					angleLogic (pPoint' pLineFeature' bArithmeticAngle' strDiameterFld' xyTol' out listInt' out diamPnt);  					pLstInt.Add (listInt);  					diametersWithPoints.Add (diamPnt);  					//Get next line  					pLineFeature = pLineCursor.NextFeature ();  				}  			}  		}  		//Get next line layer  		pLayer = pEnumLayer.Next ();  	}  	return getAngle (diametersWithPoints' iAngleTol);  } catch {  	return 0;  } finally {  	pPointFC = null;  	pSFilter = null;  	pLineCursor = null;  	pLineFeature = null;  	pPoint = null;  	pEnumLayer = null;  	pLayer = null;  	pFLayer = null;  	pId = null;  	pUID = null;  	pTopo = null;  	pLstInt.Clear ();  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,angleLogic,The following statement contains a magic number: dblAngle = Math.Round (dblAngle' 4);  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,angleLogic,The following statement contains a magic number: if (iLineDiameterFieldPos < 0) {  	dblDiameter = -9999;  } else if (pFeat.get_Value (iLineDiameterFieldPos) == null) {  	dblDiameter = -9999;  } else if (object.ReferenceEquals (pFeat.get_Value (iLineDiameterFieldPos)' DBNull.Value)) {  	dblDiameter = -9999;  } else {  	double.TryParse (pFeat.get_Value (iLineDiameterFieldPos).ToString ()' out dblDiameter);  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,angleLogic,The following statement contains a magic number: if (iLineDiameterFieldPos < 0) {  	dblDiameter = -9999;  } else if (pFeat.get_Value (iLineDiameterFieldPos) == null) {  	dblDiameter = -9999;  } else if (object.ReferenceEquals (pFeat.get_Value (iLineDiameterFieldPos)' DBNull.Value)) {  	dblDiameter = -9999;  } else {  	double.TryParse (pFeat.get_Value (iLineDiameterFieldPos).ToString ()' out dblDiameter);  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,angleLogic,The following statement contains a magic number: if (iLineDiameterFieldPos < 0) {  	dblDiameter = -9999;  } else if (pFeat.get_Value (iLineDiameterFieldPos) == null) {  	dblDiameter = -9999;  } else if (object.ReferenceEquals (pFeat.get_Value (iLineDiameterFieldPos)' DBNull.Value)) {  	dblDiameter = -9999;  } else {  	double.TryParse (pFeat.get_Value (iLineDiameterFieldPos).ToString ()' out dblDiameter);  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,angleLogic,The following statement contains a magic number: dblDiameter = -9999;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,angleLogic,The following statement contains a magic number: if (pFeat.get_Value (iLineDiameterFieldPos) == null) {  	dblDiameter = -9999;  } else if (object.ReferenceEquals (pFeat.get_Value (iLineDiameterFieldPos)' DBNull.Value)) {  	dblDiameter = -9999;  } else {  	double.TryParse (pFeat.get_Value (iLineDiameterFieldPos).ToString ()' out dblDiameter);  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,angleLogic,The following statement contains a magic number: if (pFeat.get_Value (iLineDiameterFieldPos) == null) {  	dblDiameter = -9999;  } else if (object.ReferenceEquals (pFeat.get_Value (iLineDiameterFieldPos)' DBNull.Value)) {  	dblDiameter = -9999;  } else {  	double.TryParse (pFeat.get_Value (iLineDiameterFieldPos).ToString ()' out dblDiameter);  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,angleLogic,The following statement contains a magic number: dblDiameter = -9999;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,angleLogic,The following statement contains a magic number: if (object.ReferenceEquals (pFeat.get_Value (iLineDiameterFieldPos)' DBNull.Value)) {  	dblDiameter = -9999;  } else {  	double.TryParse (pFeat.get_Value (iLineDiameterFieldPos).ToString ()' out dblDiameter);  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,angleLogic,The following statement contains a magic number: dblDiameter = -9999;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,angleLogic,The following statement contains a magic number: if (distFrom < xyTol * 2) {  	diamPnt.location = "From";  } else if (distTo < xyTol * 2) {  	diamPnt.location = "To";  } else {  	diamPnt.location = null;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,angleLogic,The following statement contains a magic number: if (distFrom < xyTol * 2) {  	diamPnt.location = "From";  } else if (distTo < xyTol * 2) {  	diamPnt.location = "To";  } else {  	diamPnt.location = null;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,angleLogic,The following statement contains a magic number: if (distTo < xyTol * 2) {  	diamPnt.location = "To";  } else {  	diamPnt.location = null;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: switch (diametersWithPoints.Count) {  case 0:  	//One line such as at valves  	return null;  case 1:  	//One line such as at valves  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	return diametersWithPoints [0].angle;  case 2:  	//Two lines such as at reducers Or at tee fittings where line is not broken  	if (diametersWithPoints.Count == 2) {  		//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  		//    Return cAngles.Item(0)  		//Else  		if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter == -9999) {  			return diametersWithPoints [1].angle;  		} else if (diametersWithPoints [1].dblDiameter == -9999) {  			return diametersWithPoints [0].angle;  		} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [0].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				if (diametersWithPoints [0].angle >= 180) {  					return diametersWithPoints [0].angle - 180;  				} else {  					return diametersWithPoints [0].angle + 180;  				}  			} else {  				//Checked  				return diametersWithPoints [0].angle;  			}  		} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  			if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  				//Checked  				return diametersWithPoints [1].angle;  			} else {  				//Checked  				if (diametersWithPoints [1].angle >= 180) {  					return diametersWithPoints [1].angle - 180;  				} else {  					return diametersWithPoints [1].angle + 180;  				}  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  	break;  case 3:  	double flatAngle1 = flattenAngle (diametersWithPoints [0].angle);  	double flatAngle2 = flattenAngle (diametersWithPoints [1].angle);  	double flatAngle3 = flattenAngle (diametersWithPoints [2].angle);  	double angleDifA = Math.Abs (flatAngle1 - flatAngle2);  	double angleDifB = Math.Abs (flatAngle1 - flatAngle3);  	double angleDifC = Math.Abs (flatAngle2 - flatAngle3);  	if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [2].location == "From") {  			if (diametersWithPoints [2].angle >= 180) {  				return diametersWithPoints [2].angle - 180;  			} else {  				return diametersWithPoints [2].angle + 180;  			}  		} else {  			return diametersWithPoints [2].angle;  		}  	}  	if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [1].location == "From") {  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else {  			return diametersWithPoints [1].angle;  		}  	}  	if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  		if (diametersWithPoints [0].location == "From") {  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			return diametersWithPoints [0].angle;  		}  	}  	//Three lines such as at tee fittings where line is broken  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [1].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [2].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [1].angle;  		} else {  			ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  			if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  				return diametersWithPoints [0].angle;  			} else {  				return -360;  			}  		}  	}  	break;  case 4:  	//Four lines such as at crosses  	//the angle of any of the four lines should work since the symbol should be symetrically  	return diametersWithPoints [0].angle;  default:  	return 0;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].location == "From") {  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].location == "From") {  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].location == "From") {  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].angle >= 180) {  	return diametersWithPoints [0].angle - 180;  } else {  	return diametersWithPoints [0].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].angle >= 180) {  	return diametersWithPoints [0].angle - 180;  } else {  	return diametersWithPoints [0].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].angle >= 180) {  	return diametersWithPoints [0].angle - 180;  } else {  	return diametersWithPoints [0].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return diametersWithPoints [0].angle - 180;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return diametersWithPoints [0].angle + 180;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints.Count == 2) {  	//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  	//    Return cAngles.Item(0)  	//Else  	if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter == -9999) {  		return diametersWithPoints [1].angle;  	} else if (diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [0].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			//Checked  			return diametersWithPoints [0].angle;  		}  	} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		}  	} else {  		return diametersWithPoints [0].angle;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints.Count == 2) {  	//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  	//    Return cAngles.Item(0)  	//Else  	if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter == -9999) {  		return diametersWithPoints [1].angle;  	} else if (diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [0].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			//Checked  			return diametersWithPoints [0].angle;  		}  	} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		}  	} else {  		return diametersWithPoints [0].angle;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints.Count == 2) {  	//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  	//    Return cAngles.Item(0)  	//Else  	if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter == -9999) {  		return diametersWithPoints [1].angle;  	} else if (diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [0].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			//Checked  			return diametersWithPoints [0].angle;  		}  	} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		}  	} else {  		return diametersWithPoints [0].angle;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints.Count == 2) {  	//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  	//    Return cAngles.Item(0)  	//Else  	if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter == -9999) {  		return diametersWithPoints [1].angle;  	} else if (diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [0].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			//Checked  			return diametersWithPoints [0].angle;  		}  	} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		}  	} else {  		return diametersWithPoints [0].angle;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints.Count == 2) {  	//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  	//    Return cAngles.Item(0)  	//Else  	if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter == -9999) {  		return diametersWithPoints [1].angle;  	} else if (diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [0].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			//Checked  			return diametersWithPoints [0].angle;  		}  	} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		}  	} else {  		return diametersWithPoints [0].angle;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints.Count == 2) {  	//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  	//    Return cAngles.Item(0)  	//Else  	if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter == -9999) {  		return diametersWithPoints [1].angle;  	} else if (diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [0].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			//Checked  			return diametersWithPoints [0].angle;  		}  	} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		}  	} else {  		return diametersWithPoints [0].angle;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints.Count == 2) {  	//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  	//    Return cAngles.Item(0)  	//Else  	if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter == -9999) {  		return diametersWithPoints [1].angle;  	} else if (diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [0].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			//Checked  			return diametersWithPoints [0].angle;  		}  	} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		}  	} else {  		return diametersWithPoints [0].angle;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints.Count == 2) {  	//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  	//    Return cAngles.Item(0)  	//Else  	if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter == -9999) {  		return diametersWithPoints [1].angle;  	} else if (diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [0].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			//Checked  			return diametersWithPoints [0].angle;  		}  	} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		}  	} else {  		return diametersWithPoints [0].angle;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints.Count == 2) {  	//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  	//    Return cAngles.Item(0)  	//Else  	if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter == -9999) {  		return diametersWithPoints [1].angle;  	} else if (diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [0].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			//Checked  			return diametersWithPoints [0].angle;  		}  	} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		}  	} else {  		return diametersWithPoints [0].angle;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints.Count == 2) {  	//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  	//    Return cAngles.Item(0)  	//Else  	if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter == -9999) {  		return diametersWithPoints [1].angle;  	} else if (diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [0].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			//Checked  			return diametersWithPoints [0].angle;  		}  	} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		}  	} else {  		return diametersWithPoints [0].angle;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints.Count == 2) {  	//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  	//    Return cAngles.Item(0)  	//Else  	if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter == -9999) {  		return diametersWithPoints [1].angle;  	} else if (diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [0].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			//Checked  			return diametersWithPoints [0].angle;  		}  	} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		}  	} else {  		return diametersWithPoints [0].angle;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints.Count == 2) {  	//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  	//    Return cAngles.Item(0)  	//Else  	if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter == -9999) {  		return diametersWithPoints [1].angle;  	} else if (diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [0].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			//Checked  			return diametersWithPoints [0].angle;  		}  	} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		}  	} else {  		return diametersWithPoints [0].angle;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints.Count == 2) {  	//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  	//    Return cAngles.Item(0)  	//Else  	if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter == -9999) {  		return diametersWithPoints [1].angle;  	} else if (diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [0].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			//Checked  			return diametersWithPoints [0].angle;  		}  	} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		}  	} else {  		return diametersWithPoints [0].angle;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints.Count == 2) {  	//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  	//    Return cAngles.Item(0)  	//Else  	if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter == -9999) {  		return diametersWithPoints [1].angle;  	} else if (diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [0].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			//Checked  			return diametersWithPoints [0].angle;  		}  	} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		}  	} else {  		return diametersWithPoints [0].angle;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints.Count == 2) {  	//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  	//    Return cAngles.Item(0)  	//Else  	if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter == -9999) {  		return diametersWithPoints [1].angle;  	} else if (diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [0].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			//Checked  			return diametersWithPoints [0].angle;  		}  	} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		}  	} else {  		return diametersWithPoints [0].angle;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints.Count == 2) {  	//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  	//    Return cAngles.Item(0)  	//Else  	if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter == -9999) {  		return diametersWithPoints [1].angle;  	} else if (diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [0].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			//Checked  			return diametersWithPoints [0].angle;  		}  	} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		}  	} else {  		return diametersWithPoints [0].angle;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints.Count == 2) {  	//If cDiameters(0) Is Nothing Or cDiameters(1) Is Nothing Then  	//    Return cAngles.Item(0)  	//Else  	if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter == -9999) {  		return diametersWithPoints [1].angle;  	} else if (diametersWithPoints [1].dblDiameter == -9999) {  		return diametersWithPoints [0].angle;  	} else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [0].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			if (diametersWithPoints [0].angle >= 180) {  				return diametersWithPoints [0].angle - 180;  			} else {  				return diametersWithPoints [0].angle + 180;  			}  		} else {  			//Checked  			return diametersWithPoints [0].angle;  		}  	} else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  		if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  			//Checked  			return diametersWithPoints [1].angle;  		} else {  			//Checked  			if (diametersWithPoints [1].angle >= 180) {  				return diametersWithPoints [1].angle - 180;  			} else {  				return diametersWithPoints [1].angle + 180;  			}  		}  	} else {  		return diametersWithPoints [0].angle;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999 && diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter == -9999) {  	return diametersWithPoints [1].angle;  } else if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].dblDiameter == -9999) {  	return diametersWithPoints [0].angle;  } else if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter > diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [0].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		//Checked  		return diametersWithPoints [0].angle;  	}  } else if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [0].angle;  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	//Checked  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [0].angle;  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	//Checked  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [0].angle;  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	//Checked  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [0].angle;  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	//Checked  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [0].angle;  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	//Checked  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [0].angle;  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	//Checked  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	//Checked  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	//Checked  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	//Checked  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	//Checked  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	//Checked  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	//Checked  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].angle >= 180) {  	return diametersWithPoints [0].angle - 180;  } else {  	return diametersWithPoints [0].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].angle >= 180) {  	return diametersWithPoints [0].angle - 180;  } else {  	return diametersWithPoints [0].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].angle >= 180) {  	return diametersWithPoints [0].angle - 180;  } else {  	return diametersWithPoints [0].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return diametersWithPoints [0].angle - 180;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return diametersWithPoints [0].angle + 180;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	//Checked  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	//Checked  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	//Checked  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].angle >= 180) {  	return diametersWithPoints [0].angle - 180;  } else {  	return diametersWithPoints [0].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].angle >= 180) {  	return diametersWithPoints [0].angle - 180;  } else {  	return diametersWithPoints [0].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].angle >= 180) {  	return diametersWithPoints [0].angle - 180;  } else {  	return diametersWithPoints [0].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return diametersWithPoints [0].angle - 180;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return diametersWithPoints [0].angle + 180;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].dblDiameter < diametersWithPoints [1].dblDiameter) {  	if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  		//Checked  		return diametersWithPoints [1].angle;  	} else {  		//Checked  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntStart' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntEnd)) {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  } else if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].angle >= 180) {  	return diametersWithPoints [1].angle - 180;  } else {  	return diametersWithPoints [1].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].angle >= 180) {  	return diametersWithPoints [1].angle - 180;  } else {  	return diametersWithPoints [1].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].angle >= 180) {  	return diametersWithPoints [1].angle - 180;  } else {  	return diametersWithPoints [1].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return diametersWithPoints [1].angle - 180;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return diametersWithPoints [1].angle + 180;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (Globals.pointscoincident (diametersWithPoints [0].pntEnd' diametersWithPoints [1].pntStart)) {  	//Checked  	return diametersWithPoints [1].angle;  } else {  	//Checked  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].angle >= 180) {  	return diametersWithPoints [1].angle - 180;  } else {  	return diametersWithPoints [1].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].angle >= 180) {  	return diametersWithPoints [1].angle - 180;  } else {  	return diametersWithPoints [1].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].angle >= 180) {  	return diametersWithPoints [1].angle - 180;  } else {  	return diametersWithPoints [1].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return diametersWithPoints [1].angle - 180;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return diametersWithPoints [1].angle + 180;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [2].location == "From") {  		if (diametersWithPoints [2].angle >= 180) {  			return diametersWithPoints [2].angle - 180;  		} else {  			return diametersWithPoints [2].angle + 180;  		}  	} else {  		return diametersWithPoints [2].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [2].location == "From") {  		if (diametersWithPoints [2].angle >= 180) {  			return diametersWithPoints [2].angle - 180;  		} else {  			return diametersWithPoints [2].angle + 180;  		}  	} else {  		return diametersWithPoints [2].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [2].location == "From") {  		if (diametersWithPoints [2].angle >= 180) {  			return diametersWithPoints [2].angle - 180;  		} else {  			return diametersWithPoints [2].angle + 180;  		}  	} else {  		return diametersWithPoints [2].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [2].location == "From") {  		if (diametersWithPoints [2].angle >= 180) {  			return diametersWithPoints [2].angle - 180;  		} else {  			return diametersWithPoints [2].angle + 180;  		}  	} else {  		return diametersWithPoints [2].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [2].location == "From") {  		if (diametersWithPoints [2].angle >= 180) {  			return diametersWithPoints [2].angle - 180;  		} else {  			return diametersWithPoints [2].angle + 180;  		}  	} else {  		return diametersWithPoints [2].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [2].location == "From") {  		if (diametersWithPoints [2].angle >= 180) {  			return diametersWithPoints [2].angle - 180;  		} else {  			return diametersWithPoints [2].angle + 180;  		}  	} else {  		return diametersWithPoints [2].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [2].location == "From") {  		if (diametersWithPoints [2].angle >= 180) {  			return diametersWithPoints [2].angle - 180;  		} else {  			return diametersWithPoints [2].angle + 180;  		}  	} else {  		return diametersWithPoints [2].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [2].location == "From") {  		if (diametersWithPoints [2].angle >= 180) {  			return diametersWithPoints [2].angle - 180;  		} else {  			return diametersWithPoints [2].angle + 180;  		}  	} else {  		return diametersWithPoints [2].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [2].location == "From") {  		if (diametersWithPoints [2].angle >= 180) {  			return diametersWithPoints [2].angle - 180;  		} else {  			return diametersWithPoints [2].angle + 180;  		}  	} else {  		return diametersWithPoints [2].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [2].location == "From") {  		if (diametersWithPoints [2].angle >= 180) {  			return diametersWithPoints [2].angle - 180;  		} else {  			return diametersWithPoints [2].angle + 180;  		}  	} else {  		return diametersWithPoints [2].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifA <= (iAngleTol * 2) || angleDifA >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [2].location == "From") {  		if (diametersWithPoints [2].angle >= 180) {  			return diametersWithPoints [2].angle - 180;  		} else {  			return diametersWithPoints [2].angle + 180;  		}  	} else {  		return diametersWithPoints [2].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [2].location == "From") {  	if (diametersWithPoints [2].angle >= 180) {  		return diametersWithPoints [2].angle - 180;  	} else {  		return diametersWithPoints [2].angle + 180;  	}  } else {  	return diametersWithPoints [2].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [2].location == "From") {  	if (diametersWithPoints [2].angle >= 180) {  		return diametersWithPoints [2].angle - 180;  	} else {  		return diametersWithPoints [2].angle + 180;  	}  } else {  	return diametersWithPoints [2].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [2].location == "From") {  	if (diametersWithPoints [2].angle >= 180) {  		return diametersWithPoints [2].angle - 180;  	} else {  		return diametersWithPoints [2].angle + 180;  	}  } else {  	return diametersWithPoints [2].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [2].location == "From") {  	if (diametersWithPoints [2].angle >= 180) {  		return diametersWithPoints [2].angle - 180;  	} else {  		return diametersWithPoints [2].angle + 180;  	}  } else {  	return diametersWithPoints [2].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [2].location == "From") {  	if (diametersWithPoints [2].angle >= 180) {  		return diametersWithPoints [2].angle - 180;  	} else {  		return diametersWithPoints [2].angle + 180;  	}  } else {  	return diametersWithPoints [2].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [2].location == "From") {  	if (diametersWithPoints [2].angle >= 180) {  		return diametersWithPoints [2].angle - 180;  	} else {  		return diametersWithPoints [2].angle + 180;  	}  } else {  	return diametersWithPoints [2].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [2].location == "From") {  	if (diametersWithPoints [2].angle >= 180) {  		return diametersWithPoints [2].angle - 180;  	} else {  		return diametersWithPoints [2].angle + 180;  	}  } else {  	return diametersWithPoints [2].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [2].location == "From") {  	if (diametersWithPoints [2].angle >= 180) {  		return diametersWithPoints [2].angle - 180;  	} else {  		return diametersWithPoints [2].angle + 180;  	}  } else {  	return diametersWithPoints [2].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [2].angle >= 180) {  	return diametersWithPoints [2].angle - 180;  } else {  	return diametersWithPoints [2].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [2].angle >= 180) {  	return diametersWithPoints [2].angle - 180;  } else {  	return diametersWithPoints [2].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [2].angle >= 180) {  	return diametersWithPoints [2].angle - 180;  } else {  	return diametersWithPoints [2].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [2].angle >= 180) {  	return diametersWithPoints [2].angle - 180;  } else {  	return diametersWithPoints [2].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [2].angle >= 180) {  	return diametersWithPoints [2].angle - 180;  } else {  	return diametersWithPoints [2].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [2].angle >= 180) {  	return diametersWithPoints [2].angle - 180;  } else {  	return diametersWithPoints [2].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return diametersWithPoints [2].angle - 180;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return diametersWithPoints [2].angle - 180;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return diametersWithPoints [2].angle + 180;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return diametersWithPoints [2].angle + 180;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return diametersWithPoints [2].angle;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [1].location == "From") {  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else {  		return diametersWithPoints [1].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [1].location == "From") {  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else {  		return diametersWithPoints [1].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [1].location == "From") {  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else {  		return diametersWithPoints [1].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [1].location == "From") {  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else {  		return diametersWithPoints [1].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [1].location == "From") {  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else {  		return diametersWithPoints [1].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifB <= (iAngleTol * 2) || angleDifB >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [1].location == "From") {  		if (diametersWithPoints [1].angle >= 180) {  			return diametersWithPoints [1].angle - 180;  		} else {  			return diametersWithPoints [1].angle + 180;  		}  	} else {  		return diametersWithPoints [1].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].location == "From") {  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  } else {  	return diametersWithPoints [1].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].location == "From") {  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  } else {  	return diametersWithPoints [1].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].location == "From") {  	if (diametersWithPoints [1].angle >= 180) {  		return diametersWithPoints [1].angle - 180;  	} else {  		return diametersWithPoints [1].angle + 180;  	}  } else {  	return diametersWithPoints [1].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].angle >= 180) {  	return diametersWithPoints [1].angle - 180;  } else {  	return diametersWithPoints [1].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].angle >= 180) {  	return diametersWithPoints [1].angle - 180;  } else {  	return diametersWithPoints [1].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [1].angle >= 180) {  	return diametersWithPoints [1].angle - 180;  } else {  	return diametersWithPoints [1].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return diametersWithPoints [1].angle - 180;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return diametersWithPoints [1].angle + 180;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (angleDifC <= (iAngleTol * 2) || angleDifC >= (180 - (iAngleTol * 2))) {  	if (diametersWithPoints [0].location == "From") {  		if (diametersWithPoints [0].angle >= 180) {  			return diametersWithPoints [0].angle - 180;  		} else {  			return diametersWithPoints [0].angle + 180;  		}  	} else {  		return diametersWithPoints [0].angle;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].location == "From") {  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].location == "From") {  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].location == "From") {  	if (diametersWithPoints [0].angle >= 180) {  		return diametersWithPoints [0].angle - 180;  	} else {  		return diametersWithPoints [0].angle + 180;  	}  } else {  	return diametersWithPoints [0].angle;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].angle >= 180) {  	return diametersWithPoints [0].angle - 180;  } else {  	return diametersWithPoints [0].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].angle >= 180) {  	return diametersWithPoints [0].angle - 180;  } else {  	return diametersWithPoints [0].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (diametersWithPoints [0].angle >= 180) {  	return diametersWithPoints [0].angle - 180;  } else {  	return diametersWithPoints [0].angle + 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return diametersWithPoints [0].angle - 180;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return diametersWithPoints [0].angle + 180;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  	return diametersWithPoints [2].angle;  } else {  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [1].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [0].angle;  		} else {  			return -360;  		}  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  	return diametersWithPoints [2].angle;  } else {  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [1].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [0].angle;  		} else {  			return -360;  		}  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  	return diametersWithPoints [2].angle;  } else {  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [1].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [0].angle;  		} else {  			return -360;  		}  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  	return diametersWithPoints [2].angle;  } else {  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [1].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [0].angle;  		} else {  			return -360;  		}  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  	return diametersWithPoints [2].angle;  } else {  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [1].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [0].angle;  		} else {  			return -360;  		}  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  	return diametersWithPoints [2].angle;  } else {  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [1].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [0].angle;  		} else {  			return -360;  		}  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  	return diametersWithPoints [2].angle;  } else {  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [1].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [0].angle;  		} else {  			return -360;  		}  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  	return diametersWithPoints [2].angle;  } else {  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [1].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [0].angle;  		} else {  			return -360;  		}  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  	return diametersWithPoints [2].angle;  } else {  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [1].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [0].angle;  		} else {  			return -360;  		}  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  	return diametersWithPoints [2].angle;  } else {  	ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [1].angle;  	} else {  		ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  		if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  			return diametersWithPoints [0].angle;  		} else {  			return -360;  		}  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return diametersWithPoints [2].angle;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: ltest = Math.Abs (diametersWithPoints [0].angle - diametersWithPoints [2].angle);  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  	return diametersWithPoints [1].angle;  } else {  	ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [0].angle;  	} else {  		return -360;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  	return diametersWithPoints [1].angle;  } else {  	ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [0].angle;  	} else {  		return -360;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  	return diametersWithPoints [1].angle;  } else {  	ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [0].angle;  	} else {  		return -360;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  	return diametersWithPoints [1].angle;  } else {  	ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [0].angle;  	} else {  		return -360;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  	return diametersWithPoints [1].angle;  } else {  	ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [0].angle;  	} else {  		return -360;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  	return diametersWithPoints [1].angle;  } else {  	ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  	if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  		return diametersWithPoints [0].angle;  	} else {  		return -360;  	}  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: ltest = Math.Abs (diametersWithPoints [1].angle - diametersWithPoints [2].angle);  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  	return diametersWithPoints [0].angle;  } else {  	return -360;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  	return diametersWithPoints [0].angle;  } else {  	return -360;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: if (ltest >= 180 - iAngleTol & ltest <= 180 + iAngleTol) {  	return diametersWithPoints [0].angle;  } else {  	return -360;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,getAngle,The following statement contains a magic number: return -360;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,flattenAngle,The following statement contains a magic number: while (newAngle <= 0) {  	newAngle = newAngle + 360;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,flattenAngle,The following statement contains a magic number: newAngle = newAngle + 360;  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,flattenAngle,The following statement contains a magic number: while (newAngle >= 180) {  	newAngle = newAngle - 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,flattenAngle,The following statement contains a magic number: while (newAngle >= 180) {  	newAngle = newAngle - 180;  }  
Magic Number,A4LGSharedFunctions,Rotate,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Rotate.cs,flattenAngle,The following statement contains a magic number: newAngle = newAngle - 180;  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,ColumnSort,The following statement contains a magic number: header.Width = 125;  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,ColumnSort,The following statement contains a magic number: listView1.Columns [0].Width = System.Math.Max (width' 10);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.lblLayer.Location = new System.Drawing.Point (15' 11);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.lblLayer.Location = new System.Drawing.Point (15' 11);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.lblLayer.Size = new System.Drawing.Size (35' 13);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.lblLayer.Size = new System.Drawing.Size (35' 13);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.tbSearch.Location = new System.Drawing.Point (14' 31);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.tbSearch.Location = new System.Drawing.Point (14' 31);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.tbSearch.Size = new System.Drawing.Size (370' 20);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.tbSearch.Size = new System.Drawing.Size (370' 20);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.tbSearch.TabIndex = 8;  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.btnSearch.Location = new System.Drawing.Point (391' 31);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.btnSearch.Location = new System.Drawing.Point (391' 31);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.btnSearch.Size = new System.Drawing.Size (75' 23);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.btnSearch.Size = new System.Drawing.Size (75' 23);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.btnSearch.TabIndex = 9;  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.listView1.Location = new System.Drawing.Point (14' 60);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.listView1.Location = new System.Drawing.Point (14' 60);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.listView1.Size = new System.Drawing.Size (451' 243);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.listView1.Size = new System.Drawing.Size (451' 243);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.listView1.TabIndex = 5;  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.btnOK.Location = new System.Drawing.Point (309' 309);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.btnOK.Location = new System.Drawing.Point (309' 309);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.btnOK.Size = new System.Drawing.Size (75' 23);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.btnOK.Size = new System.Drawing.Size (75' 23);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.btnOK.TabIndex = 6;  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point (390' 309);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point (390' 309);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size (75' 23);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size (75' 23);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.TabIndex = 7;  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.imageListSym.ImageSize = new System.Drawing.Size (16' 16);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.imageListSym.ImageSize = new System.Drawing.Size (16' 16);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (480' 353);  
Magic Number,A4LGSharedFunctions,SelectTemplateFormGraphic,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateFormGraphic.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (480' 353);  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,setWidth,The following statement contains a magic number: if (Width < 180) {  	this.Width = 280;  } else {  	this.Width = Width + 100;  }  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,setWidth,The following statement contains a magic number: if (Width < 180) {  	this.Width = 280;  } else {  	this.Width = Width + 100;  }  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,setWidth,The following statement contains a magic number: if (Width < 180) {  	this.Width = 280;  } else {  	this.Width = Width + 100;  }  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,setWidth,The following statement contains a magic number: this.Width = 280;  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,setWidth,The following statement contains a magic number: this.Width = Width + 100;  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,setWidth,The following statement contains a magic number: cboSelectTemplate.Width = this.Width - 50 - cboSelectTemplate.Left;  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,SelectOptionForm_Resize,The following statement contains a magic number: cboSelectTemplate.Width = this.Width - 50 - cboSelectTemplate.Left;  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,InitializeComponent,The following statement contains a magic number: this.lblLayer.Location = new System.Drawing.Point (15' 16);  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,InitializeComponent,The following statement contains a magic number: this.lblLayer.Location = new System.Drawing.Point (15' 16);  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,InitializeComponent,The following statement contains a magic number: this.lblLayer.Size = new System.Drawing.Size (35' 13);  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,InitializeComponent,The following statement contains a magic number: this.lblLayer.Size = new System.Drawing.Size (35' 13);  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,InitializeComponent,The following statement contains a magic number: this.cboSelectTemplate.Location = new System.Drawing.Point (15' 40);  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,InitializeComponent,The following statement contains a magic number: this.cboSelectTemplate.Location = new System.Drawing.Point (15' 40);  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,InitializeComponent,The following statement contains a magic number: this.cboSelectTemplate.Size = new System.Drawing.Size (720' 21);  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,InitializeComponent,The following statement contains a magic number: this.cboSelectTemplate.Size = new System.Drawing.Size (720' 21);  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSelect.Location = new System.Drawing.Point (18' 67);  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSelect.Location = new System.Drawing.Point (18' 67);  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSelect.Size = new System.Drawing.Size (106' 23);  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSelect.Size = new System.Drawing.Size (106' 23);  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSelect.TabIndex = 2;  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point (18' 96);  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point (18' 96);  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size (106' 23);  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size (106' 23);  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.TabIndex = 3;  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (902' 192);  
Magic Number,A4LGSharedFunctions,SelectOptionForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectOptionForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (902' 192);  
Magic Number,A4LGSharedFunctions,WindowsAPI,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateSymShape,The following statement contains a magic number: try {  	if (pSymbol is IMarkerSymbol) {  		// For a MarkerSymbol return a Point.  		IArea pArea = (IArea)pEnvelope;  		return pArea.Centroid;  	} else if ((pSymbol is ILineSymbol) || (pSymbol is ITextSymbol)) {  		// For a LineSymbol or TextSymbol return a Polyline.  		IPolyline pPolyline = new PolylineClass ();  		//diagonal line default  		//pPolyline.FromPoint = pEnvelope.LowerLeft;  		//pPolyline.ToPoint = pEnvelope.UpperRight;  		//straight line like templates  		IPoint fromPoint = new PointClass ();  		fromPoint.X = pEnvelope.LowerLeft.X;  		fromPoint.Y = pEnvelope.LowerLeft.Y + (pEnvelope.Height / 2);  		IPoint toPoint = new PointClass ();  		toPoint.X = pEnvelope.LowerRight.X;  		toPoint.Y = pEnvelope.LowerRight.Y + (pEnvelope.Height / 2);  		pPolyline.FromPoint = fromPoint;  		pPolyline.ToPoint = toPoint;  		return pPolyline;  	} else {  		// For any FillSymbol return an Envelope.  		return pEnvelope;  	}  } catch {  	return null;  }  
Magic Number,A4LGSharedFunctions,WindowsAPI,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateSymShape,The following statement contains a magic number: try {  	if (pSymbol is IMarkerSymbol) {  		// For a MarkerSymbol return a Point.  		IArea pArea = (IArea)pEnvelope;  		return pArea.Centroid;  	} else if ((pSymbol is ILineSymbol) || (pSymbol is ITextSymbol)) {  		// For a LineSymbol or TextSymbol return a Polyline.  		IPolyline pPolyline = new PolylineClass ();  		//diagonal line default  		//pPolyline.FromPoint = pEnvelope.LowerLeft;  		//pPolyline.ToPoint = pEnvelope.UpperRight;  		//straight line like templates  		IPoint fromPoint = new PointClass ();  		fromPoint.X = pEnvelope.LowerLeft.X;  		fromPoint.Y = pEnvelope.LowerLeft.Y + (pEnvelope.Height / 2);  		IPoint toPoint = new PointClass ();  		toPoint.X = pEnvelope.LowerRight.X;  		toPoint.Y = pEnvelope.LowerRight.Y + (pEnvelope.Height / 2);  		pPolyline.FromPoint = fromPoint;  		pPolyline.ToPoint = toPoint;  		return pPolyline;  	} else {  		// For any FillSymbol return an Envelope.  		return pEnvelope;  	}  } catch {  	return null;  }  
Magic Number,A4LGSharedFunctions,WindowsAPI,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateSymShape,The following statement contains a magic number: if (pSymbol is IMarkerSymbol) {  	// For a MarkerSymbol return a Point.  	IArea pArea = (IArea)pEnvelope;  	return pArea.Centroid;  } else if ((pSymbol is ILineSymbol) || (pSymbol is ITextSymbol)) {  	// For a LineSymbol or TextSymbol return a Polyline.  	IPolyline pPolyline = new PolylineClass ();  	//diagonal line default  	//pPolyline.FromPoint = pEnvelope.LowerLeft;  	//pPolyline.ToPoint = pEnvelope.UpperRight;  	//straight line like templates  	IPoint fromPoint = new PointClass ();  	fromPoint.X = pEnvelope.LowerLeft.X;  	fromPoint.Y = pEnvelope.LowerLeft.Y + (pEnvelope.Height / 2);  	IPoint toPoint = new PointClass ();  	toPoint.X = pEnvelope.LowerRight.X;  	toPoint.Y = pEnvelope.LowerRight.Y + (pEnvelope.Height / 2);  	pPolyline.FromPoint = fromPoint;  	pPolyline.ToPoint = toPoint;  	return pPolyline;  } else {  	// For any FillSymbol return an Envelope.  	return pEnvelope;  }  
Magic Number,A4LGSharedFunctions,WindowsAPI,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateSymShape,The following statement contains a magic number: if (pSymbol is IMarkerSymbol) {  	// For a MarkerSymbol return a Point.  	IArea pArea = (IArea)pEnvelope;  	return pArea.Centroid;  } else if ((pSymbol is ILineSymbol) || (pSymbol is ITextSymbol)) {  	// For a LineSymbol or TextSymbol return a Polyline.  	IPolyline pPolyline = new PolylineClass ();  	//diagonal line default  	//pPolyline.FromPoint = pEnvelope.LowerLeft;  	//pPolyline.ToPoint = pEnvelope.UpperRight;  	//straight line like templates  	IPoint fromPoint = new PointClass ();  	fromPoint.X = pEnvelope.LowerLeft.X;  	fromPoint.Y = pEnvelope.LowerLeft.Y + (pEnvelope.Height / 2);  	IPoint toPoint = new PointClass ();  	toPoint.X = pEnvelope.LowerRight.X;  	toPoint.Y = pEnvelope.LowerRight.Y + (pEnvelope.Height / 2);  	pPolyline.FromPoint = fromPoint;  	pPolyline.ToPoint = toPoint;  	return pPolyline;  } else {  	// For any FillSymbol return an Envelope.  	return pEnvelope;  }  
Magic Number,A4LGSharedFunctions,WindowsAPI,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateSymShape,The following statement contains a magic number: if ((pSymbol is ILineSymbol) || (pSymbol is ITextSymbol)) {  	// For a LineSymbol or TextSymbol return a Polyline.  	IPolyline pPolyline = new PolylineClass ();  	//diagonal line default  	//pPolyline.FromPoint = pEnvelope.LowerLeft;  	//pPolyline.ToPoint = pEnvelope.UpperRight;  	//straight line like templates  	IPoint fromPoint = new PointClass ();  	fromPoint.X = pEnvelope.LowerLeft.X;  	fromPoint.Y = pEnvelope.LowerLeft.Y + (pEnvelope.Height / 2);  	IPoint toPoint = new PointClass ();  	toPoint.X = pEnvelope.LowerRight.X;  	toPoint.Y = pEnvelope.LowerRight.Y + (pEnvelope.Height / 2);  	pPolyline.FromPoint = fromPoint;  	pPolyline.ToPoint = toPoint;  	return pPolyline;  } else {  	// For any FillSymbol return an Envelope.  	return pEnvelope;  }  
Magic Number,A4LGSharedFunctions,WindowsAPI,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateSymShape,The following statement contains a magic number: if ((pSymbol is ILineSymbol) || (pSymbol is ITextSymbol)) {  	// For a LineSymbol or TextSymbol return a Polyline.  	IPolyline pPolyline = new PolylineClass ();  	//diagonal line default  	//pPolyline.FromPoint = pEnvelope.LowerLeft;  	//pPolyline.ToPoint = pEnvelope.UpperRight;  	//straight line like templates  	IPoint fromPoint = new PointClass ();  	fromPoint.X = pEnvelope.LowerLeft.X;  	fromPoint.Y = pEnvelope.LowerLeft.Y + (pEnvelope.Height / 2);  	IPoint toPoint = new PointClass ();  	toPoint.X = pEnvelope.LowerRight.X;  	toPoint.Y = pEnvelope.LowerRight.Y + (pEnvelope.Height / 2);  	pPolyline.FromPoint = fromPoint;  	pPolyline.ToPoint = toPoint;  	return pPolyline;  } else {  	// For any FillSymbol return an Envelope.  	return pEnvelope;  }  
Magic Number,A4LGSharedFunctions,WindowsAPI,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateSymShape,The following statement contains a magic number: fromPoint.Y = pEnvelope.LowerLeft.Y + (pEnvelope.Height / 2);  
Magic Number,A4LGSharedFunctions,WindowsAPI,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateSymShape,The following statement contains a magic number: toPoint.Y = pEnvelope.LowerRight.Y + (pEnvelope.Height / 2);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddGNResultClasses,The following statement contains a magic number: try {  	string gpLayerName = A4LGSharedFunctions.Localizer.GetString ("traceLayerName");  	string fcName = null;  	string fcNameClass = null;  	map = ((IMxDocument)app.Document).FocusMap;  	groupLayers = Globals.FindGroupLayers (map' gpLayerName);  	int idx = 0;  	if (groupLayers == null) {  		idx = idx + 1;  		groupLayer = new GroupLayerClass ();  		groupLayer.Name = gpLayerName + " " + idx;  		map.AddLayer (groupLayer);  	} else if (groupLayers.Count == 0) {  		idx = idx + 1;  		groupLayer = new GroupLayerClass ();  		groupLayer.Name = gpLayerName + " " + idx;  		map.AddLayer (groupLayer);  	} else {  		foreach (IGroupLayer gpLay in groupLayers) {  			string strStrip = gpLay.Name.Replace (gpLayerName' "");  			int tmpIdx = 0;  			if (Int32.TryParse (strStrip' out tmpIdx)) {  				if (tmpIdx > idx) {  					idx = tmpIdx;  				}  			}  		}  		groupLayer = new GroupLayerClass ();  		idx = idx + 1;  		groupLayer.Name = gpLayerName + " " + idx;  		map.AddLayer (groupLayer);  	}  	Globals.FlagsBarriersToLayer (app' map' groupLayer' ID' dateTimeValue' IDFieldName' DateFieldName' idx);  	suffix = " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  	// + " " + idx;  	for (int i = 0; i < 4; i++) {  		if (i == 0) {  			enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTComplexJunction);  		} else if (i == 1) {  			enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleJunction);  		} else if (i == 2) {  			enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTComplexEdge);  		} else if (i == 3) {  			enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleEdge);  		}  		fc = enumFC.Next ();  		while (fc != null) {  			if (geomNetwork.OrphanJunctionFeatureClass.FeatureClassID != fc.ObjectClassID) {  				if (addAllLayers) {  					pDataset = (IDataset)fc;  					fcNameClass = Globals.getClassName (pDataset) + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  					fcName = fc.AliasName + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  					// + " " + idx;  					copyClassToInMemory (fc' fcNameClass' fcName' map' groupLayer' false' IDFieldName' DateFieldName' removeMZ);  				} else {  					if (Globals.FindLayerByClassID (map' fc.ObjectClassID.ToString ()) != null) {  						pDataset = (IDataset)fc;  						fcNameClass = Globals.getClassName (pDataset) + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  						fcName = fc.AliasName + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  						// +" " + idx;  						copyClassToInMemory (fc' fcNameClass' fcName' map' groupLayer' false' IDFieldName' DateFieldName' removeMZ);  					}  				}  			}  			fc = enumFC.Next ();  		}  	}  	Globals.CreateOutageArea (map' groupLayer' ID' IDFieldName' DateFieldName' idx);  	return groupLayer;  } catch (Exception ex) {  	return null;  } finally {  	enumFC = null;  	fc = null;  	groupLayers = null;  	pDataset = null;  	map = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddGNResultClasses,The following statement contains a magic number: try {  	string gpLayerName = A4LGSharedFunctions.Localizer.GetString ("traceLayerName");  	string fcName = null;  	string fcNameClass = null;  	map = ((IMxDocument)app.Document).FocusMap;  	groupLayers = Globals.FindGroupLayers (map' gpLayerName);  	int idx = 0;  	if (groupLayers == null) {  		idx = idx + 1;  		groupLayer = new GroupLayerClass ();  		groupLayer.Name = gpLayerName + " " + idx;  		map.AddLayer (groupLayer);  	} else if (groupLayers.Count == 0) {  		idx = idx + 1;  		groupLayer = new GroupLayerClass ();  		groupLayer.Name = gpLayerName + " " + idx;  		map.AddLayer (groupLayer);  	} else {  		foreach (IGroupLayer gpLay in groupLayers) {  			string strStrip = gpLay.Name.Replace (gpLayerName' "");  			int tmpIdx = 0;  			if (Int32.TryParse (strStrip' out tmpIdx)) {  				if (tmpIdx > idx) {  					idx = tmpIdx;  				}  			}  		}  		groupLayer = new GroupLayerClass ();  		idx = idx + 1;  		groupLayer.Name = gpLayerName + " " + idx;  		map.AddLayer (groupLayer);  	}  	Globals.FlagsBarriersToLayer (app' map' groupLayer' ID' dateTimeValue' IDFieldName' DateFieldName' idx);  	suffix = " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  	// + " " + idx;  	for (int i = 0; i < 4; i++) {  		if (i == 0) {  			enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTComplexJunction);  		} else if (i == 1) {  			enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleJunction);  		} else if (i == 2) {  			enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTComplexEdge);  		} else if (i == 3) {  			enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleEdge);  		}  		fc = enumFC.Next ();  		while (fc != null) {  			if (geomNetwork.OrphanJunctionFeatureClass.FeatureClassID != fc.ObjectClassID) {  				if (addAllLayers) {  					pDataset = (IDataset)fc;  					fcNameClass = Globals.getClassName (pDataset) + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  					fcName = fc.AliasName + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  					// + " " + idx;  					copyClassToInMemory (fc' fcNameClass' fcName' map' groupLayer' false' IDFieldName' DateFieldName' removeMZ);  				} else {  					if (Globals.FindLayerByClassID (map' fc.ObjectClassID.ToString ()) != null) {  						pDataset = (IDataset)fc;  						fcNameClass = Globals.getClassName (pDataset) + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  						fcName = fc.AliasName + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  						// +" " + idx;  						copyClassToInMemory (fc' fcNameClass' fcName' map' groupLayer' false' IDFieldName' DateFieldName' removeMZ);  					}  				}  			}  			fc = enumFC.Next ();  		}  	}  	Globals.CreateOutageArea (map' groupLayer' ID' IDFieldName' DateFieldName' idx);  	return groupLayer;  } catch (Exception ex) {  	return null;  } finally {  	enumFC = null;  	fc = null;  	groupLayers = null;  	pDataset = null;  	map = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddGNResultClasses,The following statement contains a magic number: try {  	string gpLayerName = A4LGSharedFunctions.Localizer.GetString ("traceLayerName");  	string fcName = null;  	string fcNameClass = null;  	map = ((IMxDocument)app.Document).FocusMap;  	groupLayers = Globals.FindGroupLayers (map' gpLayerName);  	int idx = 0;  	if (groupLayers == null) {  		idx = idx + 1;  		groupLayer = new GroupLayerClass ();  		groupLayer.Name = gpLayerName + " " + idx;  		map.AddLayer (groupLayer);  	} else if (groupLayers.Count == 0) {  		idx = idx + 1;  		groupLayer = new GroupLayerClass ();  		groupLayer.Name = gpLayerName + " " + idx;  		map.AddLayer (groupLayer);  	} else {  		foreach (IGroupLayer gpLay in groupLayers) {  			string strStrip = gpLay.Name.Replace (gpLayerName' "");  			int tmpIdx = 0;  			if (Int32.TryParse (strStrip' out tmpIdx)) {  				if (tmpIdx > idx) {  					idx = tmpIdx;  				}  			}  		}  		groupLayer = new GroupLayerClass ();  		idx = idx + 1;  		groupLayer.Name = gpLayerName + " " + idx;  		map.AddLayer (groupLayer);  	}  	Globals.FlagsBarriersToLayer (app' map' groupLayer' ID' dateTimeValue' IDFieldName' DateFieldName' idx);  	suffix = " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  	// + " " + idx;  	for (int i = 0; i < 4; i++) {  		if (i == 0) {  			enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTComplexJunction);  		} else if (i == 1) {  			enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleJunction);  		} else if (i == 2) {  			enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTComplexEdge);  		} else if (i == 3) {  			enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleEdge);  		}  		fc = enumFC.Next ();  		while (fc != null) {  			if (geomNetwork.OrphanJunctionFeatureClass.FeatureClassID != fc.ObjectClassID) {  				if (addAllLayers) {  					pDataset = (IDataset)fc;  					fcNameClass = Globals.getClassName (pDataset) + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  					fcName = fc.AliasName + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  					// + " " + idx;  					copyClassToInMemory (fc' fcNameClass' fcName' map' groupLayer' false' IDFieldName' DateFieldName' removeMZ);  				} else {  					if (Globals.FindLayerByClassID (map' fc.ObjectClassID.ToString ()) != null) {  						pDataset = (IDataset)fc;  						fcNameClass = Globals.getClassName (pDataset) + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  						fcName = fc.AliasName + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  						// +" " + idx;  						copyClassToInMemory (fc' fcNameClass' fcName' map' groupLayer' false' IDFieldName' DateFieldName' removeMZ);  					}  				}  			}  			fc = enumFC.Next ();  		}  	}  	Globals.CreateOutageArea (map' groupLayer' ID' IDFieldName' DateFieldName' idx);  	return groupLayer;  } catch (Exception ex) {  	return null;  } finally {  	enumFC = null;  	fc = null;  	groupLayers = null;  	pDataset = null;  	map = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddGNResultClasses,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (i == 0) {  		enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTComplexJunction);  	} else if (i == 1) {  		enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleJunction);  	} else if (i == 2) {  		enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTComplexEdge);  	} else if (i == 3) {  		enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleEdge);  	}  	fc = enumFC.Next ();  	while (fc != null) {  		if (geomNetwork.OrphanJunctionFeatureClass.FeatureClassID != fc.ObjectClassID) {  			if (addAllLayers) {  				pDataset = (IDataset)fc;  				fcNameClass = Globals.getClassName (pDataset) + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  				fcName = fc.AliasName + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  				// + " " + idx;  				copyClassToInMemory (fc' fcNameClass' fcName' map' groupLayer' false' IDFieldName' DateFieldName' removeMZ);  			} else {  				if (Globals.FindLayerByClassID (map' fc.ObjectClassID.ToString ()) != null) {  					pDataset = (IDataset)fc;  					fcNameClass = Globals.getClassName (pDataset) + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  					fcName = fc.AliasName + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  					// +" " + idx;  					copyClassToInMemory (fc' fcNameClass' fcName' map' groupLayer' false' IDFieldName' DateFieldName' removeMZ);  				}  			}  		}  		fc = enumFC.Next ();  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddGNResultClasses,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (i == 0) {  		enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTComplexJunction);  	} else if (i == 1) {  		enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleJunction);  	} else if (i == 2) {  		enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTComplexEdge);  	} else if (i == 3) {  		enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleEdge);  	}  	fc = enumFC.Next ();  	while (fc != null) {  		if (geomNetwork.OrphanJunctionFeatureClass.FeatureClassID != fc.ObjectClassID) {  			if (addAllLayers) {  				pDataset = (IDataset)fc;  				fcNameClass = Globals.getClassName (pDataset) + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  				fcName = fc.AliasName + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  				// + " " + idx;  				copyClassToInMemory (fc' fcNameClass' fcName' map' groupLayer' false' IDFieldName' DateFieldName' removeMZ);  			} else {  				if (Globals.FindLayerByClassID (map' fc.ObjectClassID.ToString ()) != null) {  					pDataset = (IDataset)fc;  					fcNameClass = Globals.getClassName (pDataset) + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  					fcName = fc.AliasName + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  					// +" " + idx;  					copyClassToInMemory (fc' fcNameClass' fcName' map' groupLayer' false' IDFieldName' DateFieldName' removeMZ);  				}  			}  		}  		fc = enumFC.Next ();  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddGNResultClasses,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (i == 0) {  		enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTComplexJunction);  	} else if (i == 1) {  		enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleJunction);  	} else if (i == 2) {  		enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTComplexEdge);  	} else if (i == 3) {  		enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleEdge);  	}  	fc = enumFC.Next ();  	while (fc != null) {  		if (geomNetwork.OrphanJunctionFeatureClass.FeatureClassID != fc.ObjectClassID) {  			if (addAllLayers) {  				pDataset = (IDataset)fc;  				fcNameClass = Globals.getClassName (pDataset) + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  				fcName = fc.AliasName + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  				// + " " + idx;  				copyClassToInMemory (fc' fcNameClass' fcName' map' groupLayer' false' IDFieldName' DateFieldName' removeMZ);  			} else {  				if (Globals.FindLayerByClassID (map' fc.ObjectClassID.ToString ()) != null) {  					pDataset = (IDataset)fc;  					fcNameClass = Globals.getClassName (pDataset) + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  					fcName = fc.AliasName + " " + A4LGSharedFunctions.Localizer.GetString ("IsoTraceResultsLayerSuffix");  					// +" " + idx;  					copyClassToInMemory (fc' fcNameClass' fcName' map' groupLayer' false' IDFieldName' DateFieldName' removeMZ);  				}  			}  		}  		fc = enumFC.Next ();  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddGNResultClasses,The following statement contains a magic number: if (i == 0) {  	enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTComplexJunction);  } else if (i == 1) {  	enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleJunction);  } else if (i == 2) {  	enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTComplexEdge);  } else if (i == 3) {  	enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleEdge);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddGNResultClasses,The following statement contains a magic number: if (i == 0) {  	enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTComplexJunction);  } else if (i == 1) {  	enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleJunction);  } else if (i == 2) {  	enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTComplexEdge);  } else if (i == 3) {  	enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleEdge);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddGNResultClasses,The following statement contains a magic number: if (i == 1) {  	enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleJunction);  } else if (i == 2) {  	enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTComplexEdge);  } else if (i == 3) {  	enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleEdge);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddGNResultClasses,The following statement contains a magic number: if (i == 1) {  	enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleJunction);  } else if (i == 2) {  	enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTComplexEdge);  } else if (i == 3) {  	enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleEdge);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddGNResultClasses,The following statement contains a magic number: if (i == 2) {  	enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTComplexEdge);  } else if (i == 3) {  	enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleEdge);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddGNResultClasses,The following statement contains a magic number: if (i == 2) {  	enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTComplexEdge);  } else if (i == 3) {  	enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleEdge);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddGNResultClasses,The following statement contains a magic number: if (i == 3) {  	enumFC = geomNetwork.get_ClassesByType (esriFeatureType.esriFTSimpleEdge);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The following statement contains a magic number: try {  	pGeometryCollection = new MultipointClass ();  	object Missing = Type.Missing;  	Dictionary<string' copyFeatureToInMem> copyFeats = null;  	IDictionaryEnumerator eidEnum = null;  	int newFldIdx = -1;  	int sourceFldIdx = -1;  	string ID = Globals.generateRandomID (10);  	map = ((IMxDocument)app.Document).FocusMap;  	string IDFieldName = ConfigUtil.GetConfigValue ("Trace_ResultLayersIDField"' "TRACEID");  	string DateFieldName = ConfigUtil.GetConfigValue ("Trace_ResultLayersDateTimeField"' "MODELRUNAT");  	string dateFieldOption = ConfigUtil.GetConfigValue ("Trace_ResultLayersDateTimeZone"' "LOCAL");  	bool removeMZ = ConfigUtil.GetConfigValue ("Trace_ResultLayersRemoveMZ"' "FALSE").ToUpper () == "FALSE" ? false : true;  	if (dateFieldOption.ToUpper () == "UTC") {  		dateTimeValue = DateTime.UtcNow;  		//DateTime.Now;  	} else {  		dateTimeValue = DateTime.Now;  	}  	bool boolAddAllResultLayers = ConfigUtil.GetConfigValue ("Trace_ResultAddAllLayers"' "false").ToLower () == "false" ? false : true;  	AddResultsAsLayersOptions addResOptions = ConfigUtil.GetAddResultsAsLayersOptions ();  	//bool boolAddAllResultLayers = ConfigUtil.GetConfigValue("Trace_ResultAddAllLayers"' "false").ToLower() == "false" ? false : true;  	double bufferAmt = ConfigUtil.GetConfigValue ("Trace_ResultBuffer"' 25.0);  	string suffix;  	try {  		env = new EnvelopeClass ();  		List<string> valveFCs = new List<string> ();  		//map.ClearSelection();  		pGrpLay = Globals.AddGNResultClasses (gn' app' ID' dateTimeValue' IDFieldName' DateFieldName' out suffix' boolAddAllResultLayers' removeMZ);  		if ((pWS = Globals.GetInMemoryWorkspaceFromTOC (((app.Document as IMxDocument).FocusMap))) == null) {  			pWS = Globals.CreateInMemoryWorkspace ();  		}  		pCompLayer = (ICompositeLayer)pGrpLay;  		copyFeats = new Dictionary<string' copyFeatureToInMem> ();  		for (int f = 0; f < 3; f++) {  			if (f == 0) {  				eidEnum = valveHT.GetEnumerator ();  				eidEnum.Reset ();  				re = eidEnum.MoveNext ();  				if (re == false) {  					eidInfo = null;  				} else {  					eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  				}  			} else if (f == 1) {  				enumEidInfo = enumEidInfoJunc;  				enumEidInfo.Reset ();  				eidInfo = enumEidInfo.Next ();  			} else {  				//enumEidInfo = eidHelper.CreateEnumEIDInfo(edgeEIDs);  				enumEidInfo = enumEidInfoEdge;  				enumEidInfo.Reset ();  				eidInfo = enumEidInfo.Next ();  			}  			bool cont = true;  			while (eidInfo != null) {  				cont = true;  				pSourceFC = ((IFeatureClass)eidInfo.Feature.Class);  				if (f == 0) {  					if (valveFCs.Contains (pSourceFC.ObjectClassID.ToString ()) == false) {  						valveFCs.Add (pSourceFC.ObjectClassID.ToString ());  					}  					//pSourceFC.CLSID;  				} else {  					if (valveFCs.Contains (pSourceFC.ObjectClassID.ToString ()) == true) {  						cont = false;  					} else {  						cont = true;  					}  				}  				if (cont) {  					string fcName = pSourceFC.AliasName + suffix;  					if (!copyFeats.ContainsKey (fcName)) {  						pLay = Globals.FindLayerInGroup (pCompLayer' fcName);  						if (pLay == null && boolAddAllResultLayers) {  							pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  							pFC = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  							pFL = new FeatureLayerClass ();  							pFL.FeatureClass = pFC;  							pFL.Name = fcName;  							pGrpLay.Add (pFL);  						} else if (pLay == null && boolAddAllResultLayers == false) {  							if (Globals.FindLayerByClassID (map' pSourceFC.ObjectClassID.ToString ()) != null) {  								pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  								pFC = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  								pFL = new FeatureLayerClass ();  								pFL.FeatureClass = pFC;  								pFL.Name = fcName;  								pGrpLay.Add (pFL);  							} else {  								if (f == 0) {  									re = eidEnum.MoveNext ();  									if (re == false) {  										eidInfo = null;  									} else {  										eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  									}  								} else {  									eidInfo = enumEidInfo.Next ();  								}  								continue;  							}  						} else {  							pFL = pLay as IFeatureLayer;  						}  						if (pFL.FeatureClass == null) {  							pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  							pFL.FeatureClass = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  						} else {  							Globals.deleteFeatures (pFL);  						}  						copFeat = new copyFeatureToInMem ();  						copFeat.OIDSGeo = new Dictionary<int' geoFeat> ();  						copFeat.FeatureLayer = pFL;  						copFeat.sourceFCName = Globals.getClassName (pSourceFC as IDataset);  						copyFeats.Add (fcName' copFeat);  					} else {  						copFeat = copyFeats [fcName];  					}  					if (!copFeat.OIDSGeo.ContainsKey (eidInfo.Feature.OID)) {  						geoFet = new geoFeat ();  						pSourceFeat = pSourceFC.GetFeature (eidInfo.Feature.OID);  						geoFet.feature = pSourceFeat;  						geoFet.geo = new GeometryBagClass ();  						geom = eidInfo.Geometry;  						if (geom == null) {  							geom = pSourceFeat.ShapeCopy;  						}  						geoFet.geo.AddGeometry (copyGeometry (geom' removeMZ)' ref Missing' ref Missing);  						copFeat.OIDSGeo.Add (eidInfo.Feature.OID' geoFet);  						env.Union (geom.Envelope);  					} else {  						geoFet = copFeat.OIDSGeo [eidInfo.Feature.OID];  						geom = eidInfo.Geometry;  						if (geom == null) {  							geom = pSourceFeat.ShapeCopy;  						}  						geoFet.geo.AddGeometry (copyGeometry (geom' removeMZ)' ref Missing' ref Missing);  						env.Union (geom.Envelope);  					}  				}  				if (f == 0) {  					re = eidEnum.MoveNext ();  					if (re == false) {  						eidInfo = null;  					} else {  						eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  					}  				} else {  					eidInfo = enumEidInfo.Next ();  				}  			}  		}  		UID uID = new UID ();  		uID.Value = "esriEditor.Editor";  		IEditor editor = app.FindExtensionByCLSID (uID) as IEditor;  		bool stopEditor = false;  		try {  			if (editor.EditState == esriEditState.esriStateNotEditing) {  				//IWorkspaceEdit workEdit = pWS as IWorkspaceEdit;  				//editor.EditWorkspace = pWS;  				//IWorkspaceEditControl workEditControl = editor.EditWorkspace as IWorkspaceEditControl;  				// workEditControl.SetStoreEventsRequired();  				editor.StartEditing (pWS);  				editor.StartOperation ();  				stopEditor = true;  			}  			//if (!workEdit.IsBeingEdited())  			//{  			//    workEdit.StartEditing(false);  			//}  			//workEdit.StartEditOperation();  			Dictionary<string' int> resultCount = new Dictionary<string' int> ();  			foreach (KeyValuePair<string' copyFeatureToInMem> kvp in copyFeats) {  				resultCount [kvp.Value.sourceFCName] = kvp.Value.OIDSGeo.Count;  				//pCursor = kvp.Value.FeatureLayer.FeatureClass.Insert(true);  				foreach (KeyValuePair<int' geoFeat> oidpair in kvp.Value.OIDSGeo) {  					//pFBuf = kvp.Value.FeatureLayer.FeatureClass.CreateFeatureBuffer();  					//pFeat = (IFeature)pFBuf;  					pFeat = kvp.Value.FeatureLayer.FeatureClass.CreateFeature ();  					if (oidpair.Value.geo.GeometryCount == 1) {  						pGeo = oidpair.Value.geo.get_Geometry (0);  						pFeat.Shape = pGeo;  						if (pGeo.GeometryType == esriGeometryType.esriGeometryPoint) {  							pGeometryCollection.AddGeometry (pGeo);  						} else {  							pPntCollection = (IPointCollection)pGeo;  							for (int p = 0; p < pPntCollection.PointCount; p++) {  								pGeometryCollection.AddGeometry (pPntCollection.get_Point (p));  							}  						}  					} else {  						enumGeometry = oidpair.Value.geo as IEnumGeometry;  						topologicalOperator = new PolylineClass ();  						topologicalOperator.ConstructUnion (enumGeometry);  						pline = (IPolyline)topologicalOperator;  						pFeat.Shape = pline;  						pPntCollection = (IPointCollection)pline;  						for (int p = 0; p < pPntCollection.PointCount; p++) {  							pGeometryCollection.AddGeometry (pPntCollection.get_Point (p));  						}  					}  					for (int i = 0; i < kvp.Value.FeatureLayer.FeatureClass.Fields.FieldCount; i++) {  						pFld = kvp.Value.FeatureLayer.FeatureClass.Fields.get_Field (i);  						if (pFld.Type != esriFieldType.esriFieldTypeGeometry && pFld.Type != esriFieldType.esriFieldTypeOID && pFld != kvp.Value.FeatureLayer.FeatureClass.AreaField && pFld != kvp.Value.FeatureLayer.FeatureClass.LengthField) {  							newFldIdx = pFeat.Fields.FindField (pFld.Name);  							sourceFldIdx = oidpair.Value.feature.Fields.FindField (pFld.Name);  							if (newFldIdx >= 0 && sourceFldIdx >= 0) {  								try {  									//pFBuf.set_Value(newFldIdx' oidpair.Value.feature.get_Value(sourceFldIdx));  									pFeat.set_Value (newFldIdx' oidpair.Value.feature.get_Value (sourceFldIdx));  									if (newFldIdx != sourceFldIdx) {  										Console.WriteLine (newFldIdx);  									}  								} catch (Exception ex) {  									Console.WriteLine (pFld.Name + " " + ex.ToString ());  								}  							}  						}  					}  					newFldIdx = pFeat.Fields.FindField (IDFieldName);  					if (newFldIdx >= 0) {  						//pFBuf.set_Value(newFldIdx' ID);  						pFeat.set_Value (newFldIdx' ID);  					}  					newFldIdx = pFeat.Fields.FindField (DateFieldName);  					if (newFldIdx >= 0) {  						//pFBuf.set_Value(newFldIdx' dateTimeValue);  						pFeat.set_Value (newFldIdx' dateTimeValue);  					}  					//pCursor.InsertFeature(pFBuf);  					pFeat.Store ();  				}  				//pCursor.Flush();  				//Marshal.ReleaseComObject(pCursor);  				pFS = (IFeatureSelection)kvp.Value.FeatureLayer;  				pFS.SelectFeatures (null' esriSelectionResultEnum.esriSelectionResultNew' false);  			}  			topologicalOperator = (ITopologicalOperator)pGeometryCollection;  			pGeo = topologicalOperator.ConvexHull ();  			topologicalOperator = (ITopologicalOperator)pGeo;  			pGeo = topologicalOperator.Buffer (bufferAmt);  			topologicalOperator = (ITopologicalOperator)pGeo;  			topologicalOperator.Simplify ();  			pGeo = (IGeometry)topologicalOperator;  			pGeo.SpatialReference = ((IGeoDataset)gn.FeatureDataset).SpatialReference;  			pLay = Globals.FindLayerInGroup (pCompLayer' A4LGSharedFunctions.Localizer.GetString ("OutageAreaName") + suffix);  			if (pLay != null) {  				pFL = (IFeatureLayer)pLay;  				//pCursor = pFL.FeatureClass.Insert(true);  				//pFBuf = pFL.FeatureClass.CreateFeatureBuffer();  				//pFeat = (IFeature)pFBuf;  				pFeat = pFL.FeatureClass.CreateFeature ();  				pFeat.Shape = pGeo;  				newFldIdx = pFeat.Fields.FindField (IDFieldName);  				if (newFldIdx >= 0) {  					//pFBuf.set_Value(newFldIdx' ID);  					pFeat.set_Value (newFldIdx' ID);  				}  				newFldIdx = pFeat.Fields.FindField (DateFieldName);  				if (newFldIdx >= 0) {  					//pFBuf.set_Value(newFldIdx' dateTimeValue);  					pFeat.set_Value (newFldIdx' dateTimeValue);  				}  				try {  					if (addResOptions != null) {  						foreach (ResultCountToField rctf in addResOptions.ResultCountToField) {  							newFldIdx = pFeat.Fields.FindField (rctf.TargetField);  							if (newFldIdx >= 0) {  								if (resultCount.ContainsKey (rctf.FeatureClassName)) {  									pFeat.set_Value (newFldIdx' resultCount [rctf.FeatureClassName]);  								}  							}  						}  					}  				} catch {  				}  				//pCursor.InsertFeature(pFBuf);  				//pCursor.Flush();  				//Marshal.ReleaseComObject(pCursor);  				pFeat.Store ();  			}  			if (stopEditor) {  				editor.StopOperation ("Trace");  				editor.StopEditing (true);  			}  		} catch {  			if (stopEditor) {  				editor.AbortOperation ();  			}  		} finally {  			uID = null;  			editor = null;  		}  		env.Expand (1.1' 1.1' true);  		((IMxDocument)app.Document).ActiveView.Refresh ();  		return env;  	} catch (Exception ex) {  		return null;  	} finally {  		env = null;  		// eidHelper = null;  		enumEidInfo = null;  		eidInfo = null;  		geom = null;  	}  } catch (Exception ex) {  	return null;  } finally {  	map = null;  	// eidHelper = null;  	enumEidInfo = null;  	enumEidInfoJunc = null;  	enumEidInfoEdge = null;  	eidInfo = null;  	geom = null;  	pFlds = null;  	pFC = null;  	pSourceFC = null;  	pSourceFeat = null;  	pFL = null;  	copFeat = null;  	geoFet = null;  	pCursor = null;  	pFBuf = null;  	pFeat = null;  	pFld = null;  	pLay = null;  	topologicalOperator = null;  	pWS = null;  	enumGeometry = null;  	pline = null;  	pCompLayer = null;  	pGrpLay = null;  	pFS = null;  	pGeometryCollection = null;  	pPntCollection = null;  	pGeo = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The following statement contains a magic number: try {  	pGeometryCollection = new MultipointClass ();  	object Missing = Type.Missing;  	Dictionary<string' copyFeatureToInMem> copyFeats = null;  	IDictionaryEnumerator eidEnum = null;  	int newFldIdx = -1;  	int sourceFldIdx = -1;  	string ID = Globals.generateRandomID (10);  	map = ((IMxDocument)app.Document).FocusMap;  	string IDFieldName = ConfigUtil.GetConfigValue ("Trace_ResultLayersIDField"' "TRACEID");  	string DateFieldName = ConfigUtil.GetConfigValue ("Trace_ResultLayersDateTimeField"' "MODELRUNAT");  	string dateFieldOption = ConfigUtil.GetConfigValue ("Trace_ResultLayersDateTimeZone"' "LOCAL");  	bool removeMZ = ConfigUtil.GetConfigValue ("Trace_ResultLayersRemoveMZ"' "FALSE").ToUpper () == "FALSE" ? false : true;  	if (dateFieldOption.ToUpper () == "UTC") {  		dateTimeValue = DateTime.UtcNow;  		//DateTime.Now;  	} else {  		dateTimeValue = DateTime.Now;  	}  	bool boolAddAllResultLayers = ConfigUtil.GetConfigValue ("Trace_ResultAddAllLayers"' "false").ToLower () == "false" ? false : true;  	AddResultsAsLayersOptions addResOptions = ConfigUtil.GetAddResultsAsLayersOptions ();  	//bool boolAddAllResultLayers = ConfigUtil.GetConfigValue("Trace_ResultAddAllLayers"' "false").ToLower() == "false" ? false : true;  	double bufferAmt = ConfigUtil.GetConfigValue ("Trace_ResultBuffer"' 25.0);  	string suffix;  	try {  		env = new EnvelopeClass ();  		List<string> valveFCs = new List<string> ();  		//map.ClearSelection();  		pGrpLay = Globals.AddGNResultClasses (gn' app' ID' dateTimeValue' IDFieldName' DateFieldName' out suffix' boolAddAllResultLayers' removeMZ);  		if ((pWS = Globals.GetInMemoryWorkspaceFromTOC (((app.Document as IMxDocument).FocusMap))) == null) {  			pWS = Globals.CreateInMemoryWorkspace ();  		}  		pCompLayer = (ICompositeLayer)pGrpLay;  		copyFeats = new Dictionary<string' copyFeatureToInMem> ();  		for (int f = 0; f < 3; f++) {  			if (f == 0) {  				eidEnum = valveHT.GetEnumerator ();  				eidEnum.Reset ();  				re = eidEnum.MoveNext ();  				if (re == false) {  					eidInfo = null;  				} else {  					eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  				}  			} else if (f == 1) {  				enumEidInfo = enumEidInfoJunc;  				enumEidInfo.Reset ();  				eidInfo = enumEidInfo.Next ();  			} else {  				//enumEidInfo = eidHelper.CreateEnumEIDInfo(edgeEIDs);  				enumEidInfo = enumEidInfoEdge;  				enumEidInfo.Reset ();  				eidInfo = enumEidInfo.Next ();  			}  			bool cont = true;  			while (eidInfo != null) {  				cont = true;  				pSourceFC = ((IFeatureClass)eidInfo.Feature.Class);  				if (f == 0) {  					if (valveFCs.Contains (pSourceFC.ObjectClassID.ToString ()) == false) {  						valveFCs.Add (pSourceFC.ObjectClassID.ToString ());  					}  					//pSourceFC.CLSID;  				} else {  					if (valveFCs.Contains (pSourceFC.ObjectClassID.ToString ()) == true) {  						cont = false;  					} else {  						cont = true;  					}  				}  				if (cont) {  					string fcName = pSourceFC.AliasName + suffix;  					if (!copyFeats.ContainsKey (fcName)) {  						pLay = Globals.FindLayerInGroup (pCompLayer' fcName);  						if (pLay == null && boolAddAllResultLayers) {  							pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  							pFC = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  							pFL = new FeatureLayerClass ();  							pFL.FeatureClass = pFC;  							pFL.Name = fcName;  							pGrpLay.Add (pFL);  						} else if (pLay == null && boolAddAllResultLayers == false) {  							if (Globals.FindLayerByClassID (map' pSourceFC.ObjectClassID.ToString ()) != null) {  								pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  								pFC = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  								pFL = new FeatureLayerClass ();  								pFL.FeatureClass = pFC;  								pFL.Name = fcName;  								pGrpLay.Add (pFL);  							} else {  								if (f == 0) {  									re = eidEnum.MoveNext ();  									if (re == false) {  										eidInfo = null;  									} else {  										eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  									}  								} else {  									eidInfo = enumEidInfo.Next ();  								}  								continue;  							}  						} else {  							pFL = pLay as IFeatureLayer;  						}  						if (pFL.FeatureClass == null) {  							pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  							pFL.FeatureClass = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  						} else {  							Globals.deleteFeatures (pFL);  						}  						copFeat = new copyFeatureToInMem ();  						copFeat.OIDSGeo = new Dictionary<int' geoFeat> ();  						copFeat.FeatureLayer = pFL;  						copFeat.sourceFCName = Globals.getClassName (pSourceFC as IDataset);  						copyFeats.Add (fcName' copFeat);  					} else {  						copFeat = copyFeats [fcName];  					}  					if (!copFeat.OIDSGeo.ContainsKey (eidInfo.Feature.OID)) {  						geoFet = new geoFeat ();  						pSourceFeat = pSourceFC.GetFeature (eidInfo.Feature.OID);  						geoFet.feature = pSourceFeat;  						geoFet.geo = new GeometryBagClass ();  						geom = eidInfo.Geometry;  						if (geom == null) {  							geom = pSourceFeat.ShapeCopy;  						}  						geoFet.geo.AddGeometry (copyGeometry (geom' removeMZ)' ref Missing' ref Missing);  						copFeat.OIDSGeo.Add (eidInfo.Feature.OID' geoFet);  						env.Union (geom.Envelope);  					} else {  						geoFet = copFeat.OIDSGeo [eidInfo.Feature.OID];  						geom = eidInfo.Geometry;  						if (geom == null) {  							geom = pSourceFeat.ShapeCopy;  						}  						geoFet.geo.AddGeometry (copyGeometry (geom' removeMZ)' ref Missing' ref Missing);  						env.Union (geom.Envelope);  					}  				}  				if (f == 0) {  					re = eidEnum.MoveNext ();  					if (re == false) {  						eidInfo = null;  					} else {  						eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  					}  				} else {  					eidInfo = enumEidInfo.Next ();  				}  			}  		}  		UID uID = new UID ();  		uID.Value = "esriEditor.Editor";  		IEditor editor = app.FindExtensionByCLSID (uID) as IEditor;  		bool stopEditor = false;  		try {  			if (editor.EditState == esriEditState.esriStateNotEditing) {  				//IWorkspaceEdit workEdit = pWS as IWorkspaceEdit;  				//editor.EditWorkspace = pWS;  				//IWorkspaceEditControl workEditControl = editor.EditWorkspace as IWorkspaceEditControl;  				// workEditControl.SetStoreEventsRequired();  				editor.StartEditing (pWS);  				editor.StartOperation ();  				stopEditor = true;  			}  			//if (!workEdit.IsBeingEdited())  			//{  			//    workEdit.StartEditing(false);  			//}  			//workEdit.StartEditOperation();  			Dictionary<string' int> resultCount = new Dictionary<string' int> ();  			foreach (KeyValuePair<string' copyFeatureToInMem> kvp in copyFeats) {  				resultCount [kvp.Value.sourceFCName] = kvp.Value.OIDSGeo.Count;  				//pCursor = kvp.Value.FeatureLayer.FeatureClass.Insert(true);  				foreach (KeyValuePair<int' geoFeat> oidpair in kvp.Value.OIDSGeo) {  					//pFBuf = kvp.Value.FeatureLayer.FeatureClass.CreateFeatureBuffer();  					//pFeat = (IFeature)pFBuf;  					pFeat = kvp.Value.FeatureLayer.FeatureClass.CreateFeature ();  					if (oidpair.Value.geo.GeometryCount == 1) {  						pGeo = oidpair.Value.geo.get_Geometry (0);  						pFeat.Shape = pGeo;  						if (pGeo.GeometryType == esriGeometryType.esriGeometryPoint) {  							pGeometryCollection.AddGeometry (pGeo);  						} else {  							pPntCollection = (IPointCollection)pGeo;  							for (int p = 0; p < pPntCollection.PointCount; p++) {  								pGeometryCollection.AddGeometry (pPntCollection.get_Point (p));  							}  						}  					} else {  						enumGeometry = oidpair.Value.geo as IEnumGeometry;  						topologicalOperator = new PolylineClass ();  						topologicalOperator.ConstructUnion (enumGeometry);  						pline = (IPolyline)topologicalOperator;  						pFeat.Shape = pline;  						pPntCollection = (IPointCollection)pline;  						for (int p = 0; p < pPntCollection.PointCount; p++) {  							pGeometryCollection.AddGeometry (pPntCollection.get_Point (p));  						}  					}  					for (int i = 0; i < kvp.Value.FeatureLayer.FeatureClass.Fields.FieldCount; i++) {  						pFld = kvp.Value.FeatureLayer.FeatureClass.Fields.get_Field (i);  						if (pFld.Type != esriFieldType.esriFieldTypeGeometry && pFld.Type != esriFieldType.esriFieldTypeOID && pFld != kvp.Value.FeatureLayer.FeatureClass.AreaField && pFld != kvp.Value.FeatureLayer.FeatureClass.LengthField) {  							newFldIdx = pFeat.Fields.FindField (pFld.Name);  							sourceFldIdx = oidpair.Value.feature.Fields.FindField (pFld.Name);  							if (newFldIdx >= 0 && sourceFldIdx >= 0) {  								try {  									//pFBuf.set_Value(newFldIdx' oidpair.Value.feature.get_Value(sourceFldIdx));  									pFeat.set_Value (newFldIdx' oidpair.Value.feature.get_Value (sourceFldIdx));  									if (newFldIdx != sourceFldIdx) {  										Console.WriteLine (newFldIdx);  									}  								} catch (Exception ex) {  									Console.WriteLine (pFld.Name + " " + ex.ToString ());  								}  							}  						}  					}  					newFldIdx = pFeat.Fields.FindField (IDFieldName);  					if (newFldIdx >= 0) {  						//pFBuf.set_Value(newFldIdx' ID);  						pFeat.set_Value (newFldIdx' ID);  					}  					newFldIdx = pFeat.Fields.FindField (DateFieldName);  					if (newFldIdx >= 0) {  						//pFBuf.set_Value(newFldIdx' dateTimeValue);  						pFeat.set_Value (newFldIdx' dateTimeValue);  					}  					//pCursor.InsertFeature(pFBuf);  					pFeat.Store ();  				}  				//pCursor.Flush();  				//Marshal.ReleaseComObject(pCursor);  				pFS = (IFeatureSelection)kvp.Value.FeatureLayer;  				pFS.SelectFeatures (null' esriSelectionResultEnum.esriSelectionResultNew' false);  			}  			topologicalOperator = (ITopologicalOperator)pGeometryCollection;  			pGeo = topologicalOperator.ConvexHull ();  			topologicalOperator = (ITopologicalOperator)pGeo;  			pGeo = topologicalOperator.Buffer (bufferAmt);  			topologicalOperator = (ITopologicalOperator)pGeo;  			topologicalOperator.Simplify ();  			pGeo = (IGeometry)topologicalOperator;  			pGeo.SpatialReference = ((IGeoDataset)gn.FeatureDataset).SpatialReference;  			pLay = Globals.FindLayerInGroup (pCompLayer' A4LGSharedFunctions.Localizer.GetString ("OutageAreaName") + suffix);  			if (pLay != null) {  				pFL = (IFeatureLayer)pLay;  				//pCursor = pFL.FeatureClass.Insert(true);  				//pFBuf = pFL.FeatureClass.CreateFeatureBuffer();  				//pFeat = (IFeature)pFBuf;  				pFeat = pFL.FeatureClass.CreateFeature ();  				pFeat.Shape = pGeo;  				newFldIdx = pFeat.Fields.FindField (IDFieldName);  				if (newFldIdx >= 0) {  					//pFBuf.set_Value(newFldIdx' ID);  					pFeat.set_Value (newFldIdx' ID);  				}  				newFldIdx = pFeat.Fields.FindField (DateFieldName);  				if (newFldIdx >= 0) {  					//pFBuf.set_Value(newFldIdx' dateTimeValue);  					pFeat.set_Value (newFldIdx' dateTimeValue);  				}  				try {  					if (addResOptions != null) {  						foreach (ResultCountToField rctf in addResOptions.ResultCountToField) {  							newFldIdx = pFeat.Fields.FindField (rctf.TargetField);  							if (newFldIdx >= 0) {  								if (resultCount.ContainsKey (rctf.FeatureClassName)) {  									pFeat.set_Value (newFldIdx' resultCount [rctf.FeatureClassName]);  								}  							}  						}  					}  				} catch {  				}  				//pCursor.InsertFeature(pFBuf);  				//pCursor.Flush();  				//Marshal.ReleaseComObject(pCursor);  				pFeat.Store ();  			}  			if (stopEditor) {  				editor.StopOperation ("Trace");  				editor.StopEditing (true);  			}  		} catch {  			if (stopEditor) {  				editor.AbortOperation ();  			}  		} finally {  			uID = null;  			editor = null;  		}  		env.Expand (1.1' 1.1' true);  		((IMxDocument)app.Document).ActiveView.Refresh ();  		return env;  	} catch (Exception ex) {  		return null;  	} finally {  		env = null;  		// eidHelper = null;  		enumEidInfo = null;  		eidInfo = null;  		geom = null;  	}  } catch (Exception ex) {  	return null;  } finally {  	map = null;  	// eidHelper = null;  	enumEidInfo = null;  	enumEidInfoJunc = null;  	enumEidInfoEdge = null;  	eidInfo = null;  	geom = null;  	pFlds = null;  	pFC = null;  	pSourceFC = null;  	pSourceFeat = null;  	pFL = null;  	copFeat = null;  	geoFet = null;  	pCursor = null;  	pFBuf = null;  	pFeat = null;  	pFld = null;  	pLay = null;  	topologicalOperator = null;  	pWS = null;  	enumGeometry = null;  	pline = null;  	pCompLayer = null;  	pGrpLay = null;  	pFS = null;  	pGeometryCollection = null;  	pPntCollection = null;  	pGeo = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The following statement contains a magic number: try {  	pGeometryCollection = new MultipointClass ();  	object Missing = Type.Missing;  	Dictionary<string' copyFeatureToInMem> copyFeats = null;  	IDictionaryEnumerator eidEnum = null;  	int newFldIdx = -1;  	int sourceFldIdx = -1;  	string ID = Globals.generateRandomID (10);  	map = ((IMxDocument)app.Document).FocusMap;  	string IDFieldName = ConfigUtil.GetConfigValue ("Trace_ResultLayersIDField"' "TRACEID");  	string DateFieldName = ConfigUtil.GetConfigValue ("Trace_ResultLayersDateTimeField"' "MODELRUNAT");  	string dateFieldOption = ConfigUtil.GetConfigValue ("Trace_ResultLayersDateTimeZone"' "LOCAL");  	bool removeMZ = ConfigUtil.GetConfigValue ("Trace_ResultLayersRemoveMZ"' "FALSE").ToUpper () == "FALSE" ? false : true;  	if (dateFieldOption.ToUpper () == "UTC") {  		dateTimeValue = DateTime.UtcNow;  		//DateTime.Now;  	} else {  		dateTimeValue = DateTime.Now;  	}  	bool boolAddAllResultLayers = ConfigUtil.GetConfigValue ("Trace_ResultAddAllLayers"' "false").ToLower () == "false" ? false : true;  	AddResultsAsLayersOptions addResOptions = ConfigUtil.GetAddResultsAsLayersOptions ();  	//bool boolAddAllResultLayers = ConfigUtil.GetConfigValue("Trace_ResultAddAllLayers"' "false").ToLower() == "false" ? false : true;  	double bufferAmt = ConfigUtil.GetConfigValue ("Trace_ResultBuffer"' 25.0);  	string suffix;  	try {  		env = new EnvelopeClass ();  		List<string> valveFCs = new List<string> ();  		//map.ClearSelection();  		pGrpLay = Globals.AddGNResultClasses (gn' app' ID' dateTimeValue' IDFieldName' DateFieldName' out suffix' boolAddAllResultLayers' removeMZ);  		if ((pWS = Globals.GetInMemoryWorkspaceFromTOC (((app.Document as IMxDocument).FocusMap))) == null) {  			pWS = Globals.CreateInMemoryWorkspace ();  		}  		pCompLayer = (ICompositeLayer)pGrpLay;  		copyFeats = new Dictionary<string' copyFeatureToInMem> ();  		for (int f = 0; f < 3; f++) {  			if (f == 0) {  				eidEnum = valveHT.GetEnumerator ();  				eidEnum.Reset ();  				re = eidEnum.MoveNext ();  				if (re == false) {  					eidInfo = null;  				} else {  					eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  				}  			} else if (f == 1) {  				enumEidInfo = enumEidInfoJunc;  				enumEidInfo.Reset ();  				eidInfo = enumEidInfo.Next ();  			} else {  				//enumEidInfo = eidHelper.CreateEnumEIDInfo(edgeEIDs);  				enumEidInfo = enumEidInfoEdge;  				enumEidInfo.Reset ();  				eidInfo = enumEidInfo.Next ();  			}  			bool cont = true;  			while (eidInfo != null) {  				cont = true;  				pSourceFC = ((IFeatureClass)eidInfo.Feature.Class);  				if (f == 0) {  					if (valveFCs.Contains (pSourceFC.ObjectClassID.ToString ()) == false) {  						valveFCs.Add (pSourceFC.ObjectClassID.ToString ());  					}  					//pSourceFC.CLSID;  				} else {  					if (valveFCs.Contains (pSourceFC.ObjectClassID.ToString ()) == true) {  						cont = false;  					} else {  						cont = true;  					}  				}  				if (cont) {  					string fcName = pSourceFC.AliasName + suffix;  					if (!copyFeats.ContainsKey (fcName)) {  						pLay = Globals.FindLayerInGroup (pCompLayer' fcName);  						if (pLay == null && boolAddAllResultLayers) {  							pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  							pFC = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  							pFL = new FeatureLayerClass ();  							pFL.FeatureClass = pFC;  							pFL.Name = fcName;  							pGrpLay.Add (pFL);  						} else if (pLay == null && boolAddAllResultLayers == false) {  							if (Globals.FindLayerByClassID (map' pSourceFC.ObjectClassID.ToString ()) != null) {  								pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  								pFC = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  								pFL = new FeatureLayerClass ();  								pFL.FeatureClass = pFC;  								pFL.Name = fcName;  								pGrpLay.Add (pFL);  							} else {  								if (f == 0) {  									re = eidEnum.MoveNext ();  									if (re == false) {  										eidInfo = null;  									} else {  										eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  									}  								} else {  									eidInfo = enumEidInfo.Next ();  								}  								continue;  							}  						} else {  							pFL = pLay as IFeatureLayer;  						}  						if (pFL.FeatureClass == null) {  							pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  							pFL.FeatureClass = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  						} else {  							Globals.deleteFeatures (pFL);  						}  						copFeat = new copyFeatureToInMem ();  						copFeat.OIDSGeo = new Dictionary<int' geoFeat> ();  						copFeat.FeatureLayer = pFL;  						copFeat.sourceFCName = Globals.getClassName (pSourceFC as IDataset);  						copyFeats.Add (fcName' copFeat);  					} else {  						copFeat = copyFeats [fcName];  					}  					if (!copFeat.OIDSGeo.ContainsKey (eidInfo.Feature.OID)) {  						geoFet = new geoFeat ();  						pSourceFeat = pSourceFC.GetFeature (eidInfo.Feature.OID);  						geoFet.feature = pSourceFeat;  						geoFet.geo = new GeometryBagClass ();  						geom = eidInfo.Geometry;  						if (geom == null) {  							geom = pSourceFeat.ShapeCopy;  						}  						geoFet.geo.AddGeometry (copyGeometry (geom' removeMZ)' ref Missing' ref Missing);  						copFeat.OIDSGeo.Add (eidInfo.Feature.OID' geoFet);  						env.Union (geom.Envelope);  					} else {  						geoFet = copFeat.OIDSGeo [eidInfo.Feature.OID];  						geom = eidInfo.Geometry;  						if (geom == null) {  							geom = pSourceFeat.ShapeCopy;  						}  						geoFet.geo.AddGeometry (copyGeometry (geom' removeMZ)' ref Missing' ref Missing);  						env.Union (geom.Envelope);  					}  				}  				if (f == 0) {  					re = eidEnum.MoveNext ();  					if (re == false) {  						eidInfo = null;  					} else {  						eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  					}  				} else {  					eidInfo = enumEidInfo.Next ();  				}  			}  		}  		UID uID = new UID ();  		uID.Value = "esriEditor.Editor";  		IEditor editor = app.FindExtensionByCLSID (uID) as IEditor;  		bool stopEditor = false;  		try {  			if (editor.EditState == esriEditState.esriStateNotEditing) {  				//IWorkspaceEdit workEdit = pWS as IWorkspaceEdit;  				//editor.EditWorkspace = pWS;  				//IWorkspaceEditControl workEditControl = editor.EditWorkspace as IWorkspaceEditControl;  				// workEditControl.SetStoreEventsRequired();  				editor.StartEditing (pWS);  				editor.StartOperation ();  				stopEditor = true;  			}  			//if (!workEdit.IsBeingEdited())  			//{  			//    workEdit.StartEditing(false);  			//}  			//workEdit.StartEditOperation();  			Dictionary<string' int> resultCount = new Dictionary<string' int> ();  			foreach (KeyValuePair<string' copyFeatureToInMem> kvp in copyFeats) {  				resultCount [kvp.Value.sourceFCName] = kvp.Value.OIDSGeo.Count;  				//pCursor = kvp.Value.FeatureLayer.FeatureClass.Insert(true);  				foreach (KeyValuePair<int' geoFeat> oidpair in kvp.Value.OIDSGeo) {  					//pFBuf = kvp.Value.FeatureLayer.FeatureClass.CreateFeatureBuffer();  					//pFeat = (IFeature)pFBuf;  					pFeat = kvp.Value.FeatureLayer.FeatureClass.CreateFeature ();  					if (oidpair.Value.geo.GeometryCount == 1) {  						pGeo = oidpair.Value.geo.get_Geometry (0);  						pFeat.Shape = pGeo;  						if (pGeo.GeometryType == esriGeometryType.esriGeometryPoint) {  							pGeometryCollection.AddGeometry (pGeo);  						} else {  							pPntCollection = (IPointCollection)pGeo;  							for (int p = 0; p < pPntCollection.PointCount; p++) {  								pGeometryCollection.AddGeometry (pPntCollection.get_Point (p));  							}  						}  					} else {  						enumGeometry = oidpair.Value.geo as IEnumGeometry;  						topologicalOperator = new PolylineClass ();  						topologicalOperator.ConstructUnion (enumGeometry);  						pline = (IPolyline)topologicalOperator;  						pFeat.Shape = pline;  						pPntCollection = (IPointCollection)pline;  						for (int p = 0; p < pPntCollection.PointCount; p++) {  							pGeometryCollection.AddGeometry (pPntCollection.get_Point (p));  						}  					}  					for (int i = 0; i < kvp.Value.FeatureLayer.FeatureClass.Fields.FieldCount; i++) {  						pFld = kvp.Value.FeatureLayer.FeatureClass.Fields.get_Field (i);  						if (pFld.Type != esriFieldType.esriFieldTypeGeometry && pFld.Type != esriFieldType.esriFieldTypeOID && pFld != kvp.Value.FeatureLayer.FeatureClass.AreaField && pFld != kvp.Value.FeatureLayer.FeatureClass.LengthField) {  							newFldIdx = pFeat.Fields.FindField (pFld.Name);  							sourceFldIdx = oidpair.Value.feature.Fields.FindField (pFld.Name);  							if (newFldIdx >= 0 && sourceFldIdx >= 0) {  								try {  									//pFBuf.set_Value(newFldIdx' oidpair.Value.feature.get_Value(sourceFldIdx));  									pFeat.set_Value (newFldIdx' oidpair.Value.feature.get_Value (sourceFldIdx));  									if (newFldIdx != sourceFldIdx) {  										Console.WriteLine (newFldIdx);  									}  								} catch (Exception ex) {  									Console.WriteLine (pFld.Name + " " + ex.ToString ());  								}  							}  						}  					}  					newFldIdx = pFeat.Fields.FindField (IDFieldName);  					if (newFldIdx >= 0) {  						//pFBuf.set_Value(newFldIdx' ID);  						pFeat.set_Value (newFldIdx' ID);  					}  					newFldIdx = pFeat.Fields.FindField (DateFieldName);  					if (newFldIdx >= 0) {  						//pFBuf.set_Value(newFldIdx' dateTimeValue);  						pFeat.set_Value (newFldIdx' dateTimeValue);  					}  					//pCursor.InsertFeature(pFBuf);  					pFeat.Store ();  				}  				//pCursor.Flush();  				//Marshal.ReleaseComObject(pCursor);  				pFS = (IFeatureSelection)kvp.Value.FeatureLayer;  				pFS.SelectFeatures (null' esriSelectionResultEnum.esriSelectionResultNew' false);  			}  			topologicalOperator = (ITopologicalOperator)pGeometryCollection;  			pGeo = topologicalOperator.ConvexHull ();  			topologicalOperator = (ITopologicalOperator)pGeo;  			pGeo = topologicalOperator.Buffer (bufferAmt);  			topologicalOperator = (ITopologicalOperator)pGeo;  			topologicalOperator.Simplify ();  			pGeo = (IGeometry)topologicalOperator;  			pGeo.SpatialReference = ((IGeoDataset)gn.FeatureDataset).SpatialReference;  			pLay = Globals.FindLayerInGroup (pCompLayer' A4LGSharedFunctions.Localizer.GetString ("OutageAreaName") + suffix);  			if (pLay != null) {  				pFL = (IFeatureLayer)pLay;  				//pCursor = pFL.FeatureClass.Insert(true);  				//pFBuf = pFL.FeatureClass.CreateFeatureBuffer();  				//pFeat = (IFeature)pFBuf;  				pFeat = pFL.FeatureClass.CreateFeature ();  				pFeat.Shape = pGeo;  				newFldIdx = pFeat.Fields.FindField (IDFieldName);  				if (newFldIdx >= 0) {  					//pFBuf.set_Value(newFldIdx' ID);  					pFeat.set_Value (newFldIdx' ID);  				}  				newFldIdx = pFeat.Fields.FindField (DateFieldName);  				if (newFldIdx >= 0) {  					//pFBuf.set_Value(newFldIdx' dateTimeValue);  					pFeat.set_Value (newFldIdx' dateTimeValue);  				}  				try {  					if (addResOptions != null) {  						foreach (ResultCountToField rctf in addResOptions.ResultCountToField) {  							newFldIdx = pFeat.Fields.FindField (rctf.TargetField);  							if (newFldIdx >= 0) {  								if (resultCount.ContainsKey (rctf.FeatureClassName)) {  									pFeat.set_Value (newFldIdx' resultCount [rctf.FeatureClassName]);  								}  							}  						}  					}  				} catch {  				}  				//pCursor.InsertFeature(pFBuf);  				//pCursor.Flush();  				//Marshal.ReleaseComObject(pCursor);  				pFeat.Store ();  			}  			if (stopEditor) {  				editor.StopOperation ("Trace");  				editor.StopEditing (true);  			}  		} catch {  			if (stopEditor) {  				editor.AbortOperation ();  			}  		} finally {  			uID = null;  			editor = null;  		}  		env.Expand (1.1' 1.1' true);  		((IMxDocument)app.Document).ActiveView.Refresh ();  		return env;  	} catch (Exception ex) {  		return null;  	} finally {  		env = null;  		// eidHelper = null;  		enumEidInfo = null;  		eidInfo = null;  		geom = null;  	}  } catch (Exception ex) {  	return null;  } finally {  	map = null;  	// eidHelper = null;  	enumEidInfo = null;  	enumEidInfoJunc = null;  	enumEidInfoEdge = null;  	eidInfo = null;  	geom = null;  	pFlds = null;  	pFC = null;  	pSourceFC = null;  	pSourceFeat = null;  	pFL = null;  	copFeat = null;  	geoFet = null;  	pCursor = null;  	pFBuf = null;  	pFeat = null;  	pFld = null;  	pLay = null;  	topologicalOperator = null;  	pWS = null;  	enumGeometry = null;  	pline = null;  	pCompLayer = null;  	pGrpLay = null;  	pFS = null;  	pGeometryCollection = null;  	pPntCollection = null;  	pGeo = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The following statement contains a magic number: try {  	pGeometryCollection = new MultipointClass ();  	object Missing = Type.Missing;  	Dictionary<string' copyFeatureToInMem> copyFeats = null;  	IDictionaryEnumerator eidEnum = null;  	int newFldIdx = -1;  	int sourceFldIdx = -1;  	string ID = Globals.generateRandomID (10);  	map = ((IMxDocument)app.Document).FocusMap;  	string IDFieldName = ConfigUtil.GetConfigValue ("Trace_ResultLayersIDField"' "TRACEID");  	string DateFieldName = ConfigUtil.GetConfigValue ("Trace_ResultLayersDateTimeField"' "MODELRUNAT");  	string dateFieldOption = ConfigUtil.GetConfigValue ("Trace_ResultLayersDateTimeZone"' "LOCAL");  	bool removeMZ = ConfigUtil.GetConfigValue ("Trace_ResultLayersRemoveMZ"' "FALSE").ToUpper () == "FALSE" ? false : true;  	if (dateFieldOption.ToUpper () == "UTC") {  		dateTimeValue = DateTime.UtcNow;  		//DateTime.Now;  	} else {  		dateTimeValue = DateTime.Now;  	}  	bool boolAddAllResultLayers = ConfigUtil.GetConfigValue ("Trace_ResultAddAllLayers"' "false").ToLower () == "false" ? false : true;  	AddResultsAsLayersOptions addResOptions = ConfigUtil.GetAddResultsAsLayersOptions ();  	//bool boolAddAllResultLayers = ConfigUtil.GetConfigValue("Trace_ResultAddAllLayers"' "false").ToLower() == "false" ? false : true;  	double bufferAmt = ConfigUtil.GetConfigValue ("Trace_ResultBuffer"' 25.0);  	string suffix;  	try {  		env = new EnvelopeClass ();  		List<string> valveFCs = new List<string> ();  		//map.ClearSelection();  		pGrpLay = Globals.AddGNResultClasses (gn' app' ID' dateTimeValue' IDFieldName' DateFieldName' out suffix' boolAddAllResultLayers' removeMZ);  		if ((pWS = Globals.GetInMemoryWorkspaceFromTOC (((app.Document as IMxDocument).FocusMap))) == null) {  			pWS = Globals.CreateInMemoryWorkspace ();  		}  		pCompLayer = (ICompositeLayer)pGrpLay;  		copyFeats = new Dictionary<string' copyFeatureToInMem> ();  		for (int f = 0; f < 3; f++) {  			if (f == 0) {  				eidEnum = valveHT.GetEnumerator ();  				eidEnum.Reset ();  				re = eidEnum.MoveNext ();  				if (re == false) {  					eidInfo = null;  				} else {  					eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  				}  			} else if (f == 1) {  				enumEidInfo = enumEidInfoJunc;  				enumEidInfo.Reset ();  				eidInfo = enumEidInfo.Next ();  			} else {  				//enumEidInfo = eidHelper.CreateEnumEIDInfo(edgeEIDs);  				enumEidInfo = enumEidInfoEdge;  				enumEidInfo.Reset ();  				eidInfo = enumEidInfo.Next ();  			}  			bool cont = true;  			while (eidInfo != null) {  				cont = true;  				pSourceFC = ((IFeatureClass)eidInfo.Feature.Class);  				if (f == 0) {  					if (valveFCs.Contains (pSourceFC.ObjectClassID.ToString ()) == false) {  						valveFCs.Add (pSourceFC.ObjectClassID.ToString ());  					}  					//pSourceFC.CLSID;  				} else {  					if (valveFCs.Contains (pSourceFC.ObjectClassID.ToString ()) == true) {  						cont = false;  					} else {  						cont = true;  					}  				}  				if (cont) {  					string fcName = pSourceFC.AliasName + suffix;  					if (!copyFeats.ContainsKey (fcName)) {  						pLay = Globals.FindLayerInGroup (pCompLayer' fcName);  						if (pLay == null && boolAddAllResultLayers) {  							pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  							pFC = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  							pFL = new FeatureLayerClass ();  							pFL.FeatureClass = pFC;  							pFL.Name = fcName;  							pGrpLay.Add (pFL);  						} else if (pLay == null && boolAddAllResultLayers == false) {  							if (Globals.FindLayerByClassID (map' pSourceFC.ObjectClassID.ToString ()) != null) {  								pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  								pFC = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  								pFL = new FeatureLayerClass ();  								pFL.FeatureClass = pFC;  								pFL.Name = fcName;  								pGrpLay.Add (pFL);  							} else {  								if (f == 0) {  									re = eidEnum.MoveNext ();  									if (re == false) {  										eidInfo = null;  									} else {  										eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  									}  								} else {  									eidInfo = enumEidInfo.Next ();  								}  								continue;  							}  						} else {  							pFL = pLay as IFeatureLayer;  						}  						if (pFL.FeatureClass == null) {  							pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  							pFL.FeatureClass = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  						} else {  							Globals.deleteFeatures (pFL);  						}  						copFeat = new copyFeatureToInMem ();  						copFeat.OIDSGeo = new Dictionary<int' geoFeat> ();  						copFeat.FeatureLayer = pFL;  						copFeat.sourceFCName = Globals.getClassName (pSourceFC as IDataset);  						copyFeats.Add (fcName' copFeat);  					} else {  						copFeat = copyFeats [fcName];  					}  					if (!copFeat.OIDSGeo.ContainsKey (eidInfo.Feature.OID)) {  						geoFet = new geoFeat ();  						pSourceFeat = pSourceFC.GetFeature (eidInfo.Feature.OID);  						geoFet.feature = pSourceFeat;  						geoFet.geo = new GeometryBagClass ();  						geom = eidInfo.Geometry;  						if (geom == null) {  							geom = pSourceFeat.ShapeCopy;  						}  						geoFet.geo.AddGeometry (copyGeometry (geom' removeMZ)' ref Missing' ref Missing);  						copFeat.OIDSGeo.Add (eidInfo.Feature.OID' geoFet);  						env.Union (geom.Envelope);  					} else {  						geoFet = copFeat.OIDSGeo [eidInfo.Feature.OID];  						geom = eidInfo.Geometry;  						if (geom == null) {  							geom = pSourceFeat.ShapeCopy;  						}  						geoFet.geo.AddGeometry (copyGeometry (geom' removeMZ)' ref Missing' ref Missing);  						env.Union (geom.Envelope);  					}  				}  				if (f == 0) {  					re = eidEnum.MoveNext ();  					if (re == false) {  						eidInfo = null;  					} else {  						eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  					}  				} else {  					eidInfo = enumEidInfo.Next ();  				}  			}  		}  		UID uID = new UID ();  		uID.Value = "esriEditor.Editor";  		IEditor editor = app.FindExtensionByCLSID (uID) as IEditor;  		bool stopEditor = false;  		try {  			if (editor.EditState == esriEditState.esriStateNotEditing) {  				//IWorkspaceEdit workEdit = pWS as IWorkspaceEdit;  				//editor.EditWorkspace = pWS;  				//IWorkspaceEditControl workEditControl = editor.EditWorkspace as IWorkspaceEditControl;  				// workEditControl.SetStoreEventsRequired();  				editor.StartEditing (pWS);  				editor.StartOperation ();  				stopEditor = true;  			}  			//if (!workEdit.IsBeingEdited())  			//{  			//    workEdit.StartEditing(false);  			//}  			//workEdit.StartEditOperation();  			Dictionary<string' int> resultCount = new Dictionary<string' int> ();  			foreach (KeyValuePair<string' copyFeatureToInMem> kvp in copyFeats) {  				resultCount [kvp.Value.sourceFCName] = kvp.Value.OIDSGeo.Count;  				//pCursor = kvp.Value.FeatureLayer.FeatureClass.Insert(true);  				foreach (KeyValuePair<int' geoFeat> oidpair in kvp.Value.OIDSGeo) {  					//pFBuf = kvp.Value.FeatureLayer.FeatureClass.CreateFeatureBuffer();  					//pFeat = (IFeature)pFBuf;  					pFeat = kvp.Value.FeatureLayer.FeatureClass.CreateFeature ();  					if (oidpair.Value.geo.GeometryCount == 1) {  						pGeo = oidpair.Value.geo.get_Geometry (0);  						pFeat.Shape = pGeo;  						if (pGeo.GeometryType == esriGeometryType.esriGeometryPoint) {  							pGeometryCollection.AddGeometry (pGeo);  						} else {  							pPntCollection = (IPointCollection)pGeo;  							for (int p = 0; p < pPntCollection.PointCount; p++) {  								pGeometryCollection.AddGeometry (pPntCollection.get_Point (p));  							}  						}  					} else {  						enumGeometry = oidpair.Value.geo as IEnumGeometry;  						topologicalOperator = new PolylineClass ();  						topologicalOperator.ConstructUnion (enumGeometry);  						pline = (IPolyline)topologicalOperator;  						pFeat.Shape = pline;  						pPntCollection = (IPointCollection)pline;  						for (int p = 0; p < pPntCollection.PointCount; p++) {  							pGeometryCollection.AddGeometry (pPntCollection.get_Point (p));  						}  					}  					for (int i = 0; i < kvp.Value.FeatureLayer.FeatureClass.Fields.FieldCount; i++) {  						pFld = kvp.Value.FeatureLayer.FeatureClass.Fields.get_Field (i);  						if (pFld.Type != esriFieldType.esriFieldTypeGeometry && pFld.Type != esriFieldType.esriFieldTypeOID && pFld != kvp.Value.FeatureLayer.FeatureClass.AreaField && pFld != kvp.Value.FeatureLayer.FeatureClass.LengthField) {  							newFldIdx = pFeat.Fields.FindField (pFld.Name);  							sourceFldIdx = oidpair.Value.feature.Fields.FindField (pFld.Name);  							if (newFldIdx >= 0 && sourceFldIdx >= 0) {  								try {  									//pFBuf.set_Value(newFldIdx' oidpair.Value.feature.get_Value(sourceFldIdx));  									pFeat.set_Value (newFldIdx' oidpair.Value.feature.get_Value (sourceFldIdx));  									if (newFldIdx != sourceFldIdx) {  										Console.WriteLine (newFldIdx);  									}  								} catch (Exception ex) {  									Console.WriteLine (pFld.Name + " " + ex.ToString ());  								}  							}  						}  					}  					newFldIdx = pFeat.Fields.FindField (IDFieldName);  					if (newFldIdx >= 0) {  						//pFBuf.set_Value(newFldIdx' ID);  						pFeat.set_Value (newFldIdx' ID);  					}  					newFldIdx = pFeat.Fields.FindField (DateFieldName);  					if (newFldIdx >= 0) {  						//pFBuf.set_Value(newFldIdx' dateTimeValue);  						pFeat.set_Value (newFldIdx' dateTimeValue);  					}  					//pCursor.InsertFeature(pFBuf);  					pFeat.Store ();  				}  				//pCursor.Flush();  				//Marshal.ReleaseComObject(pCursor);  				pFS = (IFeatureSelection)kvp.Value.FeatureLayer;  				pFS.SelectFeatures (null' esriSelectionResultEnum.esriSelectionResultNew' false);  			}  			topologicalOperator = (ITopologicalOperator)pGeometryCollection;  			pGeo = topologicalOperator.ConvexHull ();  			topologicalOperator = (ITopologicalOperator)pGeo;  			pGeo = topologicalOperator.Buffer (bufferAmt);  			topologicalOperator = (ITopologicalOperator)pGeo;  			topologicalOperator.Simplify ();  			pGeo = (IGeometry)topologicalOperator;  			pGeo.SpatialReference = ((IGeoDataset)gn.FeatureDataset).SpatialReference;  			pLay = Globals.FindLayerInGroup (pCompLayer' A4LGSharedFunctions.Localizer.GetString ("OutageAreaName") + suffix);  			if (pLay != null) {  				pFL = (IFeatureLayer)pLay;  				//pCursor = pFL.FeatureClass.Insert(true);  				//pFBuf = pFL.FeatureClass.CreateFeatureBuffer();  				//pFeat = (IFeature)pFBuf;  				pFeat = pFL.FeatureClass.CreateFeature ();  				pFeat.Shape = pGeo;  				newFldIdx = pFeat.Fields.FindField (IDFieldName);  				if (newFldIdx >= 0) {  					//pFBuf.set_Value(newFldIdx' ID);  					pFeat.set_Value (newFldIdx' ID);  				}  				newFldIdx = pFeat.Fields.FindField (DateFieldName);  				if (newFldIdx >= 0) {  					//pFBuf.set_Value(newFldIdx' dateTimeValue);  					pFeat.set_Value (newFldIdx' dateTimeValue);  				}  				try {  					if (addResOptions != null) {  						foreach (ResultCountToField rctf in addResOptions.ResultCountToField) {  							newFldIdx = pFeat.Fields.FindField (rctf.TargetField);  							if (newFldIdx >= 0) {  								if (resultCount.ContainsKey (rctf.FeatureClassName)) {  									pFeat.set_Value (newFldIdx' resultCount [rctf.FeatureClassName]);  								}  							}  						}  					}  				} catch {  				}  				//pCursor.InsertFeature(pFBuf);  				//pCursor.Flush();  				//Marshal.ReleaseComObject(pCursor);  				pFeat.Store ();  			}  			if (stopEditor) {  				editor.StopOperation ("Trace");  				editor.StopEditing (true);  			}  		} catch {  			if (stopEditor) {  				editor.AbortOperation ();  			}  		} finally {  			uID = null;  			editor = null;  		}  		env.Expand (1.1' 1.1' true);  		((IMxDocument)app.Document).ActiveView.Refresh ();  		return env;  	} catch (Exception ex) {  		return null;  	} finally {  		env = null;  		// eidHelper = null;  		enumEidInfo = null;  		eidInfo = null;  		geom = null;  	}  } catch (Exception ex) {  	return null;  } finally {  	map = null;  	// eidHelper = null;  	enumEidInfo = null;  	enumEidInfoJunc = null;  	enumEidInfoEdge = null;  	eidInfo = null;  	geom = null;  	pFlds = null;  	pFC = null;  	pSourceFC = null;  	pSourceFeat = null;  	pFL = null;  	copFeat = null;  	geoFet = null;  	pCursor = null;  	pFBuf = null;  	pFeat = null;  	pFld = null;  	pLay = null;  	topologicalOperator = null;  	pWS = null;  	enumGeometry = null;  	pline = null;  	pCompLayer = null;  	pGrpLay = null;  	pFS = null;  	pGeometryCollection = null;  	pPntCollection = null;  	pGeo = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The following statement contains a magic number: try {  	pGeometryCollection = new MultipointClass ();  	object Missing = Type.Missing;  	Dictionary<string' copyFeatureToInMem> copyFeats = null;  	IDictionaryEnumerator eidEnum = null;  	int newFldIdx = -1;  	int sourceFldIdx = -1;  	string ID = Globals.generateRandomID (10);  	map = ((IMxDocument)app.Document).FocusMap;  	string IDFieldName = ConfigUtil.GetConfigValue ("Trace_ResultLayersIDField"' "TRACEID");  	string DateFieldName = ConfigUtil.GetConfigValue ("Trace_ResultLayersDateTimeField"' "MODELRUNAT");  	string dateFieldOption = ConfigUtil.GetConfigValue ("Trace_ResultLayersDateTimeZone"' "LOCAL");  	bool removeMZ = ConfigUtil.GetConfigValue ("Trace_ResultLayersRemoveMZ"' "FALSE").ToUpper () == "FALSE" ? false : true;  	if (dateFieldOption.ToUpper () == "UTC") {  		dateTimeValue = DateTime.UtcNow;  		//DateTime.Now;  	} else {  		dateTimeValue = DateTime.Now;  	}  	bool boolAddAllResultLayers = ConfigUtil.GetConfigValue ("Trace_ResultAddAllLayers"' "false").ToLower () == "false" ? false : true;  	AddResultsAsLayersOptions addResOptions = ConfigUtil.GetAddResultsAsLayersOptions ();  	//bool boolAddAllResultLayers = ConfigUtil.GetConfigValue("Trace_ResultAddAllLayers"' "false").ToLower() == "false" ? false : true;  	double bufferAmt = ConfigUtil.GetConfigValue ("Trace_ResultBuffer"' 25.0);  	string suffix;  	try {  		env = new EnvelopeClass ();  		List<string> valveFCs = new List<string> ();  		//map.ClearSelection();  		pGrpLay = Globals.AddGNResultClasses (gn' app' ID' dateTimeValue' IDFieldName' DateFieldName' out suffix' boolAddAllResultLayers' removeMZ);  		if ((pWS = Globals.GetInMemoryWorkspaceFromTOC (((app.Document as IMxDocument).FocusMap))) == null) {  			pWS = Globals.CreateInMemoryWorkspace ();  		}  		pCompLayer = (ICompositeLayer)pGrpLay;  		copyFeats = new Dictionary<string' copyFeatureToInMem> ();  		for (int f = 0; f < 3; f++) {  			if (f == 0) {  				eidEnum = valveHT.GetEnumerator ();  				eidEnum.Reset ();  				re = eidEnum.MoveNext ();  				if (re == false) {  					eidInfo = null;  				} else {  					eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  				}  			} else if (f == 1) {  				enumEidInfo = enumEidInfoJunc;  				enumEidInfo.Reset ();  				eidInfo = enumEidInfo.Next ();  			} else {  				//enumEidInfo = eidHelper.CreateEnumEIDInfo(edgeEIDs);  				enumEidInfo = enumEidInfoEdge;  				enumEidInfo.Reset ();  				eidInfo = enumEidInfo.Next ();  			}  			bool cont = true;  			while (eidInfo != null) {  				cont = true;  				pSourceFC = ((IFeatureClass)eidInfo.Feature.Class);  				if (f == 0) {  					if (valveFCs.Contains (pSourceFC.ObjectClassID.ToString ()) == false) {  						valveFCs.Add (pSourceFC.ObjectClassID.ToString ());  					}  					//pSourceFC.CLSID;  				} else {  					if (valveFCs.Contains (pSourceFC.ObjectClassID.ToString ()) == true) {  						cont = false;  					} else {  						cont = true;  					}  				}  				if (cont) {  					string fcName = pSourceFC.AliasName + suffix;  					if (!copyFeats.ContainsKey (fcName)) {  						pLay = Globals.FindLayerInGroup (pCompLayer' fcName);  						if (pLay == null && boolAddAllResultLayers) {  							pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  							pFC = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  							pFL = new FeatureLayerClass ();  							pFL.FeatureClass = pFC;  							pFL.Name = fcName;  							pGrpLay.Add (pFL);  						} else if (pLay == null && boolAddAllResultLayers == false) {  							if (Globals.FindLayerByClassID (map' pSourceFC.ObjectClassID.ToString ()) != null) {  								pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  								pFC = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  								pFL = new FeatureLayerClass ();  								pFL.FeatureClass = pFC;  								pFL.Name = fcName;  								pGrpLay.Add (pFL);  							} else {  								if (f == 0) {  									re = eidEnum.MoveNext ();  									if (re == false) {  										eidInfo = null;  									} else {  										eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  									}  								} else {  									eidInfo = enumEidInfo.Next ();  								}  								continue;  							}  						} else {  							pFL = pLay as IFeatureLayer;  						}  						if (pFL.FeatureClass == null) {  							pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  							pFL.FeatureClass = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  						} else {  							Globals.deleteFeatures (pFL);  						}  						copFeat = new copyFeatureToInMem ();  						copFeat.OIDSGeo = new Dictionary<int' geoFeat> ();  						copFeat.FeatureLayer = pFL;  						copFeat.sourceFCName = Globals.getClassName (pSourceFC as IDataset);  						copyFeats.Add (fcName' copFeat);  					} else {  						copFeat = copyFeats [fcName];  					}  					if (!copFeat.OIDSGeo.ContainsKey (eidInfo.Feature.OID)) {  						geoFet = new geoFeat ();  						pSourceFeat = pSourceFC.GetFeature (eidInfo.Feature.OID);  						geoFet.feature = pSourceFeat;  						geoFet.geo = new GeometryBagClass ();  						geom = eidInfo.Geometry;  						if (geom == null) {  							geom = pSourceFeat.ShapeCopy;  						}  						geoFet.geo.AddGeometry (copyGeometry (geom' removeMZ)' ref Missing' ref Missing);  						copFeat.OIDSGeo.Add (eidInfo.Feature.OID' geoFet);  						env.Union (geom.Envelope);  					} else {  						geoFet = copFeat.OIDSGeo [eidInfo.Feature.OID];  						geom = eidInfo.Geometry;  						if (geom == null) {  							geom = pSourceFeat.ShapeCopy;  						}  						geoFet.geo.AddGeometry (copyGeometry (geom' removeMZ)' ref Missing' ref Missing);  						env.Union (geom.Envelope);  					}  				}  				if (f == 0) {  					re = eidEnum.MoveNext ();  					if (re == false) {  						eidInfo = null;  					} else {  						eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  					}  				} else {  					eidInfo = enumEidInfo.Next ();  				}  			}  		}  		UID uID = new UID ();  		uID.Value = "esriEditor.Editor";  		IEditor editor = app.FindExtensionByCLSID (uID) as IEditor;  		bool stopEditor = false;  		try {  			if (editor.EditState == esriEditState.esriStateNotEditing) {  				//IWorkspaceEdit workEdit = pWS as IWorkspaceEdit;  				//editor.EditWorkspace = pWS;  				//IWorkspaceEditControl workEditControl = editor.EditWorkspace as IWorkspaceEditControl;  				// workEditControl.SetStoreEventsRequired();  				editor.StartEditing (pWS);  				editor.StartOperation ();  				stopEditor = true;  			}  			//if (!workEdit.IsBeingEdited())  			//{  			//    workEdit.StartEditing(false);  			//}  			//workEdit.StartEditOperation();  			Dictionary<string' int> resultCount = new Dictionary<string' int> ();  			foreach (KeyValuePair<string' copyFeatureToInMem> kvp in copyFeats) {  				resultCount [kvp.Value.sourceFCName] = kvp.Value.OIDSGeo.Count;  				//pCursor = kvp.Value.FeatureLayer.FeatureClass.Insert(true);  				foreach (KeyValuePair<int' geoFeat> oidpair in kvp.Value.OIDSGeo) {  					//pFBuf = kvp.Value.FeatureLayer.FeatureClass.CreateFeatureBuffer();  					//pFeat = (IFeature)pFBuf;  					pFeat = kvp.Value.FeatureLayer.FeatureClass.CreateFeature ();  					if (oidpair.Value.geo.GeometryCount == 1) {  						pGeo = oidpair.Value.geo.get_Geometry (0);  						pFeat.Shape = pGeo;  						if (pGeo.GeometryType == esriGeometryType.esriGeometryPoint) {  							pGeometryCollection.AddGeometry (pGeo);  						} else {  							pPntCollection = (IPointCollection)pGeo;  							for (int p = 0; p < pPntCollection.PointCount; p++) {  								pGeometryCollection.AddGeometry (pPntCollection.get_Point (p));  							}  						}  					} else {  						enumGeometry = oidpair.Value.geo as IEnumGeometry;  						topologicalOperator = new PolylineClass ();  						topologicalOperator.ConstructUnion (enumGeometry);  						pline = (IPolyline)topologicalOperator;  						pFeat.Shape = pline;  						pPntCollection = (IPointCollection)pline;  						for (int p = 0; p < pPntCollection.PointCount; p++) {  							pGeometryCollection.AddGeometry (pPntCollection.get_Point (p));  						}  					}  					for (int i = 0; i < kvp.Value.FeatureLayer.FeatureClass.Fields.FieldCount; i++) {  						pFld = kvp.Value.FeatureLayer.FeatureClass.Fields.get_Field (i);  						if (pFld.Type != esriFieldType.esriFieldTypeGeometry && pFld.Type != esriFieldType.esriFieldTypeOID && pFld != kvp.Value.FeatureLayer.FeatureClass.AreaField && pFld != kvp.Value.FeatureLayer.FeatureClass.LengthField) {  							newFldIdx = pFeat.Fields.FindField (pFld.Name);  							sourceFldIdx = oidpair.Value.feature.Fields.FindField (pFld.Name);  							if (newFldIdx >= 0 && sourceFldIdx >= 0) {  								try {  									//pFBuf.set_Value(newFldIdx' oidpair.Value.feature.get_Value(sourceFldIdx));  									pFeat.set_Value (newFldIdx' oidpair.Value.feature.get_Value (sourceFldIdx));  									if (newFldIdx != sourceFldIdx) {  										Console.WriteLine (newFldIdx);  									}  								} catch (Exception ex) {  									Console.WriteLine (pFld.Name + " " + ex.ToString ());  								}  							}  						}  					}  					newFldIdx = pFeat.Fields.FindField (IDFieldName);  					if (newFldIdx >= 0) {  						//pFBuf.set_Value(newFldIdx' ID);  						pFeat.set_Value (newFldIdx' ID);  					}  					newFldIdx = pFeat.Fields.FindField (DateFieldName);  					if (newFldIdx >= 0) {  						//pFBuf.set_Value(newFldIdx' dateTimeValue);  						pFeat.set_Value (newFldIdx' dateTimeValue);  					}  					//pCursor.InsertFeature(pFBuf);  					pFeat.Store ();  				}  				//pCursor.Flush();  				//Marshal.ReleaseComObject(pCursor);  				pFS = (IFeatureSelection)kvp.Value.FeatureLayer;  				pFS.SelectFeatures (null' esriSelectionResultEnum.esriSelectionResultNew' false);  			}  			topologicalOperator = (ITopologicalOperator)pGeometryCollection;  			pGeo = topologicalOperator.ConvexHull ();  			topologicalOperator = (ITopologicalOperator)pGeo;  			pGeo = topologicalOperator.Buffer (bufferAmt);  			topologicalOperator = (ITopologicalOperator)pGeo;  			topologicalOperator.Simplify ();  			pGeo = (IGeometry)topologicalOperator;  			pGeo.SpatialReference = ((IGeoDataset)gn.FeatureDataset).SpatialReference;  			pLay = Globals.FindLayerInGroup (pCompLayer' A4LGSharedFunctions.Localizer.GetString ("OutageAreaName") + suffix);  			if (pLay != null) {  				pFL = (IFeatureLayer)pLay;  				//pCursor = pFL.FeatureClass.Insert(true);  				//pFBuf = pFL.FeatureClass.CreateFeatureBuffer();  				//pFeat = (IFeature)pFBuf;  				pFeat = pFL.FeatureClass.CreateFeature ();  				pFeat.Shape = pGeo;  				newFldIdx = pFeat.Fields.FindField (IDFieldName);  				if (newFldIdx >= 0) {  					//pFBuf.set_Value(newFldIdx' ID);  					pFeat.set_Value (newFldIdx' ID);  				}  				newFldIdx = pFeat.Fields.FindField (DateFieldName);  				if (newFldIdx >= 0) {  					//pFBuf.set_Value(newFldIdx' dateTimeValue);  					pFeat.set_Value (newFldIdx' dateTimeValue);  				}  				try {  					if (addResOptions != null) {  						foreach (ResultCountToField rctf in addResOptions.ResultCountToField) {  							newFldIdx = pFeat.Fields.FindField (rctf.TargetField);  							if (newFldIdx >= 0) {  								if (resultCount.ContainsKey (rctf.FeatureClassName)) {  									pFeat.set_Value (newFldIdx' resultCount [rctf.FeatureClassName]);  								}  							}  						}  					}  				} catch {  				}  				//pCursor.InsertFeature(pFBuf);  				//pCursor.Flush();  				//Marshal.ReleaseComObject(pCursor);  				pFeat.Store ();  			}  			if (stopEditor) {  				editor.StopOperation ("Trace");  				editor.StopEditing (true);  			}  		} catch {  			if (stopEditor) {  				editor.AbortOperation ();  			}  		} finally {  			uID = null;  			editor = null;  		}  		env.Expand (1.1' 1.1' true);  		((IMxDocument)app.Document).ActiveView.Refresh ();  		return env;  	} catch (Exception ex) {  		return null;  	} finally {  		env = null;  		// eidHelper = null;  		enumEidInfo = null;  		eidInfo = null;  		geom = null;  	}  } catch (Exception ex) {  	return null;  } finally {  	map = null;  	// eidHelper = null;  	enumEidInfo = null;  	enumEidInfoJunc = null;  	enumEidInfoEdge = null;  	eidInfo = null;  	geom = null;  	pFlds = null;  	pFC = null;  	pSourceFC = null;  	pSourceFeat = null;  	pFL = null;  	copFeat = null;  	geoFet = null;  	pCursor = null;  	pFBuf = null;  	pFeat = null;  	pFld = null;  	pLay = null;  	topologicalOperator = null;  	pWS = null;  	enumGeometry = null;  	pline = null;  	pCompLayer = null;  	pGrpLay = null;  	pFS = null;  	pGeometryCollection = null;  	pPntCollection = null;  	pGeo = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The following statement contains a magic number: try {  	env = new EnvelopeClass ();  	List<string> valveFCs = new List<string> ();  	//map.ClearSelection();  	pGrpLay = Globals.AddGNResultClasses (gn' app' ID' dateTimeValue' IDFieldName' DateFieldName' out suffix' boolAddAllResultLayers' removeMZ);  	if ((pWS = Globals.GetInMemoryWorkspaceFromTOC (((app.Document as IMxDocument).FocusMap))) == null) {  		pWS = Globals.CreateInMemoryWorkspace ();  	}  	pCompLayer = (ICompositeLayer)pGrpLay;  	copyFeats = new Dictionary<string' copyFeatureToInMem> ();  	for (int f = 0; f < 3; f++) {  		if (f == 0) {  			eidEnum = valveHT.GetEnumerator ();  			eidEnum.Reset ();  			re = eidEnum.MoveNext ();  			if (re == false) {  				eidInfo = null;  			} else {  				eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  			}  		} else if (f == 1) {  			enumEidInfo = enumEidInfoJunc;  			enumEidInfo.Reset ();  			eidInfo = enumEidInfo.Next ();  		} else {  			//enumEidInfo = eidHelper.CreateEnumEIDInfo(edgeEIDs);  			enumEidInfo = enumEidInfoEdge;  			enumEidInfo.Reset ();  			eidInfo = enumEidInfo.Next ();  		}  		bool cont = true;  		while (eidInfo != null) {  			cont = true;  			pSourceFC = ((IFeatureClass)eidInfo.Feature.Class);  			if (f == 0) {  				if (valveFCs.Contains (pSourceFC.ObjectClassID.ToString ()) == false) {  					valveFCs.Add (pSourceFC.ObjectClassID.ToString ());  				}  				//pSourceFC.CLSID;  			} else {  				if (valveFCs.Contains (pSourceFC.ObjectClassID.ToString ()) == true) {  					cont = false;  				} else {  					cont = true;  				}  			}  			if (cont) {  				string fcName = pSourceFC.AliasName + suffix;  				if (!copyFeats.ContainsKey (fcName)) {  					pLay = Globals.FindLayerInGroup (pCompLayer' fcName);  					if (pLay == null && boolAddAllResultLayers) {  						pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  						pFC = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  						pFL = new FeatureLayerClass ();  						pFL.FeatureClass = pFC;  						pFL.Name = fcName;  						pGrpLay.Add (pFL);  					} else if (pLay == null && boolAddAllResultLayers == false) {  						if (Globals.FindLayerByClassID (map' pSourceFC.ObjectClassID.ToString ()) != null) {  							pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  							pFC = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  							pFL = new FeatureLayerClass ();  							pFL.FeatureClass = pFC;  							pFL.Name = fcName;  							pGrpLay.Add (pFL);  						} else {  							if (f == 0) {  								re = eidEnum.MoveNext ();  								if (re == false) {  									eidInfo = null;  								} else {  									eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  								}  							} else {  								eidInfo = enumEidInfo.Next ();  							}  							continue;  						}  					} else {  						pFL = pLay as IFeatureLayer;  					}  					if (pFL.FeatureClass == null) {  						pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  						pFL.FeatureClass = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  					} else {  						Globals.deleteFeatures (pFL);  					}  					copFeat = new copyFeatureToInMem ();  					copFeat.OIDSGeo = new Dictionary<int' geoFeat> ();  					copFeat.FeatureLayer = pFL;  					copFeat.sourceFCName = Globals.getClassName (pSourceFC as IDataset);  					copyFeats.Add (fcName' copFeat);  				} else {  					copFeat = copyFeats [fcName];  				}  				if (!copFeat.OIDSGeo.ContainsKey (eidInfo.Feature.OID)) {  					geoFet = new geoFeat ();  					pSourceFeat = pSourceFC.GetFeature (eidInfo.Feature.OID);  					geoFet.feature = pSourceFeat;  					geoFet.geo = new GeometryBagClass ();  					geom = eidInfo.Geometry;  					if (geom == null) {  						geom = pSourceFeat.ShapeCopy;  					}  					geoFet.geo.AddGeometry (copyGeometry (geom' removeMZ)' ref Missing' ref Missing);  					copFeat.OIDSGeo.Add (eidInfo.Feature.OID' geoFet);  					env.Union (geom.Envelope);  				} else {  					geoFet = copFeat.OIDSGeo [eidInfo.Feature.OID];  					geom = eidInfo.Geometry;  					if (geom == null) {  						geom = pSourceFeat.ShapeCopy;  					}  					geoFet.geo.AddGeometry (copyGeometry (geom' removeMZ)' ref Missing' ref Missing);  					env.Union (geom.Envelope);  				}  			}  			if (f == 0) {  				re = eidEnum.MoveNext ();  				if (re == false) {  					eidInfo = null;  				} else {  					eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  				}  			} else {  				eidInfo = enumEidInfo.Next ();  			}  		}  	}  	UID uID = new UID ();  	uID.Value = "esriEditor.Editor";  	IEditor editor = app.FindExtensionByCLSID (uID) as IEditor;  	bool stopEditor = false;  	try {  		if (editor.EditState == esriEditState.esriStateNotEditing) {  			//IWorkspaceEdit workEdit = pWS as IWorkspaceEdit;  			//editor.EditWorkspace = pWS;  			//IWorkspaceEditControl workEditControl = editor.EditWorkspace as IWorkspaceEditControl;  			// workEditControl.SetStoreEventsRequired();  			editor.StartEditing (pWS);  			editor.StartOperation ();  			stopEditor = true;  		}  		//if (!workEdit.IsBeingEdited())  		//{  		//    workEdit.StartEditing(false);  		//}  		//workEdit.StartEditOperation();  		Dictionary<string' int> resultCount = new Dictionary<string' int> ();  		foreach (KeyValuePair<string' copyFeatureToInMem> kvp in copyFeats) {  			resultCount [kvp.Value.sourceFCName] = kvp.Value.OIDSGeo.Count;  			//pCursor = kvp.Value.FeatureLayer.FeatureClass.Insert(true);  			foreach (KeyValuePair<int' geoFeat> oidpair in kvp.Value.OIDSGeo) {  				//pFBuf = kvp.Value.FeatureLayer.FeatureClass.CreateFeatureBuffer();  				//pFeat = (IFeature)pFBuf;  				pFeat = kvp.Value.FeatureLayer.FeatureClass.CreateFeature ();  				if (oidpair.Value.geo.GeometryCount == 1) {  					pGeo = oidpair.Value.geo.get_Geometry (0);  					pFeat.Shape = pGeo;  					if (pGeo.GeometryType == esriGeometryType.esriGeometryPoint) {  						pGeometryCollection.AddGeometry (pGeo);  					} else {  						pPntCollection = (IPointCollection)pGeo;  						for (int p = 0; p < pPntCollection.PointCount; p++) {  							pGeometryCollection.AddGeometry (pPntCollection.get_Point (p));  						}  					}  				} else {  					enumGeometry = oidpair.Value.geo as IEnumGeometry;  					topologicalOperator = new PolylineClass ();  					topologicalOperator.ConstructUnion (enumGeometry);  					pline = (IPolyline)topologicalOperator;  					pFeat.Shape = pline;  					pPntCollection = (IPointCollection)pline;  					for (int p = 0; p < pPntCollection.PointCount; p++) {  						pGeometryCollection.AddGeometry (pPntCollection.get_Point (p));  					}  				}  				for (int i = 0; i < kvp.Value.FeatureLayer.FeatureClass.Fields.FieldCount; i++) {  					pFld = kvp.Value.FeatureLayer.FeatureClass.Fields.get_Field (i);  					if (pFld.Type != esriFieldType.esriFieldTypeGeometry && pFld.Type != esriFieldType.esriFieldTypeOID && pFld != kvp.Value.FeatureLayer.FeatureClass.AreaField && pFld != kvp.Value.FeatureLayer.FeatureClass.LengthField) {  						newFldIdx = pFeat.Fields.FindField (pFld.Name);  						sourceFldIdx = oidpair.Value.feature.Fields.FindField (pFld.Name);  						if (newFldIdx >= 0 && sourceFldIdx >= 0) {  							try {  								//pFBuf.set_Value(newFldIdx' oidpair.Value.feature.get_Value(sourceFldIdx));  								pFeat.set_Value (newFldIdx' oidpair.Value.feature.get_Value (sourceFldIdx));  								if (newFldIdx != sourceFldIdx) {  									Console.WriteLine (newFldIdx);  								}  							} catch (Exception ex) {  								Console.WriteLine (pFld.Name + " " + ex.ToString ());  							}  						}  					}  				}  				newFldIdx = pFeat.Fields.FindField (IDFieldName);  				if (newFldIdx >= 0) {  					//pFBuf.set_Value(newFldIdx' ID);  					pFeat.set_Value (newFldIdx' ID);  				}  				newFldIdx = pFeat.Fields.FindField (DateFieldName);  				if (newFldIdx >= 0) {  					//pFBuf.set_Value(newFldIdx' dateTimeValue);  					pFeat.set_Value (newFldIdx' dateTimeValue);  				}  				//pCursor.InsertFeature(pFBuf);  				pFeat.Store ();  			}  			//pCursor.Flush();  			//Marshal.ReleaseComObject(pCursor);  			pFS = (IFeatureSelection)kvp.Value.FeatureLayer;  			pFS.SelectFeatures (null' esriSelectionResultEnum.esriSelectionResultNew' false);  		}  		topologicalOperator = (ITopologicalOperator)pGeometryCollection;  		pGeo = topologicalOperator.ConvexHull ();  		topologicalOperator = (ITopologicalOperator)pGeo;  		pGeo = topologicalOperator.Buffer (bufferAmt);  		topologicalOperator = (ITopologicalOperator)pGeo;  		topologicalOperator.Simplify ();  		pGeo = (IGeometry)topologicalOperator;  		pGeo.SpatialReference = ((IGeoDataset)gn.FeatureDataset).SpatialReference;  		pLay = Globals.FindLayerInGroup (pCompLayer' A4LGSharedFunctions.Localizer.GetString ("OutageAreaName") + suffix);  		if (pLay != null) {  			pFL = (IFeatureLayer)pLay;  			//pCursor = pFL.FeatureClass.Insert(true);  			//pFBuf = pFL.FeatureClass.CreateFeatureBuffer();  			//pFeat = (IFeature)pFBuf;  			pFeat = pFL.FeatureClass.CreateFeature ();  			pFeat.Shape = pGeo;  			newFldIdx = pFeat.Fields.FindField (IDFieldName);  			if (newFldIdx >= 0) {  				//pFBuf.set_Value(newFldIdx' ID);  				pFeat.set_Value (newFldIdx' ID);  			}  			newFldIdx = pFeat.Fields.FindField (DateFieldName);  			if (newFldIdx >= 0) {  				//pFBuf.set_Value(newFldIdx' dateTimeValue);  				pFeat.set_Value (newFldIdx' dateTimeValue);  			}  			try {  				if (addResOptions != null) {  					foreach (ResultCountToField rctf in addResOptions.ResultCountToField) {  						newFldIdx = pFeat.Fields.FindField (rctf.TargetField);  						if (newFldIdx >= 0) {  							if (resultCount.ContainsKey (rctf.FeatureClassName)) {  								pFeat.set_Value (newFldIdx' resultCount [rctf.FeatureClassName]);  							}  						}  					}  				}  			} catch {  			}  			//pCursor.InsertFeature(pFBuf);  			//pCursor.Flush();  			//Marshal.ReleaseComObject(pCursor);  			pFeat.Store ();  		}  		if (stopEditor) {  			editor.StopOperation ("Trace");  			editor.StopEditing (true);  		}  	} catch {  		if (stopEditor) {  			editor.AbortOperation ();  		}  	} finally {  		uID = null;  		editor = null;  	}  	env.Expand (1.1' 1.1' true);  	((IMxDocument)app.Document).ActiveView.Refresh ();  	return env;  } catch (Exception ex) {  	return null;  } finally {  	env = null;  	// eidHelper = null;  	enumEidInfo = null;  	eidInfo = null;  	geom = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The following statement contains a magic number: try {  	env = new EnvelopeClass ();  	List<string> valveFCs = new List<string> ();  	//map.ClearSelection();  	pGrpLay = Globals.AddGNResultClasses (gn' app' ID' dateTimeValue' IDFieldName' DateFieldName' out suffix' boolAddAllResultLayers' removeMZ);  	if ((pWS = Globals.GetInMemoryWorkspaceFromTOC (((app.Document as IMxDocument).FocusMap))) == null) {  		pWS = Globals.CreateInMemoryWorkspace ();  	}  	pCompLayer = (ICompositeLayer)pGrpLay;  	copyFeats = new Dictionary<string' copyFeatureToInMem> ();  	for (int f = 0; f < 3; f++) {  		if (f == 0) {  			eidEnum = valveHT.GetEnumerator ();  			eidEnum.Reset ();  			re = eidEnum.MoveNext ();  			if (re == false) {  				eidInfo = null;  			} else {  				eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  			}  		} else if (f == 1) {  			enumEidInfo = enumEidInfoJunc;  			enumEidInfo.Reset ();  			eidInfo = enumEidInfo.Next ();  		} else {  			//enumEidInfo = eidHelper.CreateEnumEIDInfo(edgeEIDs);  			enumEidInfo = enumEidInfoEdge;  			enumEidInfo.Reset ();  			eidInfo = enumEidInfo.Next ();  		}  		bool cont = true;  		while (eidInfo != null) {  			cont = true;  			pSourceFC = ((IFeatureClass)eidInfo.Feature.Class);  			if (f == 0) {  				if (valveFCs.Contains (pSourceFC.ObjectClassID.ToString ()) == false) {  					valveFCs.Add (pSourceFC.ObjectClassID.ToString ());  				}  				//pSourceFC.CLSID;  			} else {  				if (valveFCs.Contains (pSourceFC.ObjectClassID.ToString ()) == true) {  					cont = false;  				} else {  					cont = true;  				}  			}  			if (cont) {  				string fcName = pSourceFC.AliasName + suffix;  				if (!copyFeats.ContainsKey (fcName)) {  					pLay = Globals.FindLayerInGroup (pCompLayer' fcName);  					if (pLay == null && boolAddAllResultLayers) {  						pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  						pFC = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  						pFL = new FeatureLayerClass ();  						pFL.FeatureClass = pFC;  						pFL.Name = fcName;  						pGrpLay.Add (pFL);  					} else if (pLay == null && boolAddAllResultLayers == false) {  						if (Globals.FindLayerByClassID (map' pSourceFC.ObjectClassID.ToString ()) != null) {  							pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  							pFC = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  							pFL = new FeatureLayerClass ();  							pFL.FeatureClass = pFC;  							pFL.Name = fcName;  							pGrpLay.Add (pFL);  						} else {  							if (f == 0) {  								re = eidEnum.MoveNext ();  								if (re == false) {  									eidInfo = null;  								} else {  									eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  								}  							} else {  								eidInfo = enumEidInfo.Next ();  							}  							continue;  						}  					} else {  						pFL = pLay as IFeatureLayer;  					}  					if (pFL.FeatureClass == null) {  						pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  						pFL.FeatureClass = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  					} else {  						Globals.deleteFeatures (pFL);  					}  					copFeat = new copyFeatureToInMem ();  					copFeat.OIDSGeo = new Dictionary<int' geoFeat> ();  					copFeat.FeatureLayer = pFL;  					copFeat.sourceFCName = Globals.getClassName (pSourceFC as IDataset);  					copyFeats.Add (fcName' copFeat);  				} else {  					copFeat = copyFeats [fcName];  				}  				if (!copFeat.OIDSGeo.ContainsKey (eidInfo.Feature.OID)) {  					geoFet = new geoFeat ();  					pSourceFeat = pSourceFC.GetFeature (eidInfo.Feature.OID);  					geoFet.feature = pSourceFeat;  					geoFet.geo = new GeometryBagClass ();  					geom = eidInfo.Geometry;  					if (geom == null) {  						geom = pSourceFeat.ShapeCopy;  					}  					geoFet.geo.AddGeometry (copyGeometry (geom' removeMZ)' ref Missing' ref Missing);  					copFeat.OIDSGeo.Add (eidInfo.Feature.OID' geoFet);  					env.Union (geom.Envelope);  				} else {  					geoFet = copFeat.OIDSGeo [eidInfo.Feature.OID];  					geom = eidInfo.Geometry;  					if (geom == null) {  						geom = pSourceFeat.ShapeCopy;  					}  					geoFet.geo.AddGeometry (copyGeometry (geom' removeMZ)' ref Missing' ref Missing);  					env.Union (geom.Envelope);  				}  			}  			if (f == 0) {  				re = eidEnum.MoveNext ();  				if (re == false) {  					eidInfo = null;  				} else {  					eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  				}  			} else {  				eidInfo = enumEidInfo.Next ();  			}  		}  	}  	UID uID = new UID ();  	uID.Value = "esriEditor.Editor";  	IEditor editor = app.FindExtensionByCLSID (uID) as IEditor;  	bool stopEditor = false;  	try {  		if (editor.EditState == esriEditState.esriStateNotEditing) {  			//IWorkspaceEdit workEdit = pWS as IWorkspaceEdit;  			//editor.EditWorkspace = pWS;  			//IWorkspaceEditControl workEditControl = editor.EditWorkspace as IWorkspaceEditControl;  			// workEditControl.SetStoreEventsRequired();  			editor.StartEditing (pWS);  			editor.StartOperation ();  			stopEditor = true;  		}  		//if (!workEdit.IsBeingEdited())  		//{  		//    workEdit.StartEditing(false);  		//}  		//workEdit.StartEditOperation();  		Dictionary<string' int> resultCount = new Dictionary<string' int> ();  		foreach (KeyValuePair<string' copyFeatureToInMem> kvp in copyFeats) {  			resultCount [kvp.Value.sourceFCName] = kvp.Value.OIDSGeo.Count;  			//pCursor = kvp.Value.FeatureLayer.FeatureClass.Insert(true);  			foreach (KeyValuePair<int' geoFeat> oidpair in kvp.Value.OIDSGeo) {  				//pFBuf = kvp.Value.FeatureLayer.FeatureClass.CreateFeatureBuffer();  				//pFeat = (IFeature)pFBuf;  				pFeat = kvp.Value.FeatureLayer.FeatureClass.CreateFeature ();  				if (oidpair.Value.geo.GeometryCount == 1) {  					pGeo = oidpair.Value.geo.get_Geometry (0);  					pFeat.Shape = pGeo;  					if (pGeo.GeometryType == esriGeometryType.esriGeometryPoint) {  						pGeometryCollection.AddGeometry (pGeo);  					} else {  						pPntCollection = (IPointCollection)pGeo;  						for (int p = 0; p < pPntCollection.PointCount; p++) {  							pGeometryCollection.AddGeometry (pPntCollection.get_Point (p));  						}  					}  				} else {  					enumGeometry = oidpair.Value.geo as IEnumGeometry;  					topologicalOperator = new PolylineClass ();  					topologicalOperator.ConstructUnion (enumGeometry);  					pline = (IPolyline)topologicalOperator;  					pFeat.Shape = pline;  					pPntCollection = (IPointCollection)pline;  					for (int p = 0; p < pPntCollection.PointCount; p++) {  						pGeometryCollection.AddGeometry (pPntCollection.get_Point (p));  					}  				}  				for (int i = 0; i < kvp.Value.FeatureLayer.FeatureClass.Fields.FieldCount; i++) {  					pFld = kvp.Value.FeatureLayer.FeatureClass.Fields.get_Field (i);  					if (pFld.Type != esriFieldType.esriFieldTypeGeometry && pFld.Type != esriFieldType.esriFieldTypeOID && pFld != kvp.Value.FeatureLayer.FeatureClass.AreaField && pFld != kvp.Value.FeatureLayer.FeatureClass.LengthField) {  						newFldIdx = pFeat.Fields.FindField (pFld.Name);  						sourceFldIdx = oidpair.Value.feature.Fields.FindField (pFld.Name);  						if (newFldIdx >= 0 && sourceFldIdx >= 0) {  							try {  								//pFBuf.set_Value(newFldIdx' oidpair.Value.feature.get_Value(sourceFldIdx));  								pFeat.set_Value (newFldIdx' oidpair.Value.feature.get_Value (sourceFldIdx));  								if (newFldIdx != sourceFldIdx) {  									Console.WriteLine (newFldIdx);  								}  							} catch (Exception ex) {  								Console.WriteLine (pFld.Name + " " + ex.ToString ());  							}  						}  					}  				}  				newFldIdx = pFeat.Fields.FindField (IDFieldName);  				if (newFldIdx >= 0) {  					//pFBuf.set_Value(newFldIdx' ID);  					pFeat.set_Value (newFldIdx' ID);  				}  				newFldIdx = pFeat.Fields.FindField (DateFieldName);  				if (newFldIdx >= 0) {  					//pFBuf.set_Value(newFldIdx' dateTimeValue);  					pFeat.set_Value (newFldIdx' dateTimeValue);  				}  				//pCursor.InsertFeature(pFBuf);  				pFeat.Store ();  			}  			//pCursor.Flush();  			//Marshal.ReleaseComObject(pCursor);  			pFS = (IFeatureSelection)kvp.Value.FeatureLayer;  			pFS.SelectFeatures (null' esriSelectionResultEnum.esriSelectionResultNew' false);  		}  		topologicalOperator = (ITopologicalOperator)pGeometryCollection;  		pGeo = topologicalOperator.ConvexHull ();  		topologicalOperator = (ITopologicalOperator)pGeo;  		pGeo = topologicalOperator.Buffer (bufferAmt);  		topologicalOperator = (ITopologicalOperator)pGeo;  		topologicalOperator.Simplify ();  		pGeo = (IGeometry)topologicalOperator;  		pGeo.SpatialReference = ((IGeoDataset)gn.FeatureDataset).SpatialReference;  		pLay = Globals.FindLayerInGroup (pCompLayer' A4LGSharedFunctions.Localizer.GetString ("OutageAreaName") + suffix);  		if (pLay != null) {  			pFL = (IFeatureLayer)pLay;  			//pCursor = pFL.FeatureClass.Insert(true);  			//pFBuf = pFL.FeatureClass.CreateFeatureBuffer();  			//pFeat = (IFeature)pFBuf;  			pFeat = pFL.FeatureClass.CreateFeature ();  			pFeat.Shape = pGeo;  			newFldIdx = pFeat.Fields.FindField (IDFieldName);  			if (newFldIdx >= 0) {  				//pFBuf.set_Value(newFldIdx' ID);  				pFeat.set_Value (newFldIdx' ID);  			}  			newFldIdx = pFeat.Fields.FindField (DateFieldName);  			if (newFldIdx >= 0) {  				//pFBuf.set_Value(newFldIdx' dateTimeValue);  				pFeat.set_Value (newFldIdx' dateTimeValue);  			}  			try {  				if (addResOptions != null) {  					foreach (ResultCountToField rctf in addResOptions.ResultCountToField) {  						newFldIdx = pFeat.Fields.FindField (rctf.TargetField);  						if (newFldIdx >= 0) {  							if (resultCount.ContainsKey (rctf.FeatureClassName)) {  								pFeat.set_Value (newFldIdx' resultCount [rctf.FeatureClassName]);  							}  						}  					}  				}  			} catch {  			}  			//pCursor.InsertFeature(pFBuf);  			//pCursor.Flush();  			//Marshal.ReleaseComObject(pCursor);  			pFeat.Store ();  		}  		if (stopEditor) {  			editor.StopOperation ("Trace");  			editor.StopEditing (true);  		}  	} catch {  		if (stopEditor) {  			editor.AbortOperation ();  		}  	} finally {  		uID = null;  		editor = null;  	}  	env.Expand (1.1' 1.1' true);  	((IMxDocument)app.Document).ActiveView.Refresh ();  	return env;  } catch (Exception ex) {  	return null;  } finally {  	env = null;  	// eidHelper = null;  	enumEidInfo = null;  	eidInfo = null;  	geom = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The following statement contains a magic number: try {  	env = new EnvelopeClass ();  	List<string> valveFCs = new List<string> ();  	//map.ClearSelection();  	pGrpLay = Globals.AddGNResultClasses (gn' app' ID' dateTimeValue' IDFieldName' DateFieldName' out suffix' boolAddAllResultLayers' removeMZ);  	if ((pWS = Globals.GetInMemoryWorkspaceFromTOC (((app.Document as IMxDocument).FocusMap))) == null) {  		pWS = Globals.CreateInMemoryWorkspace ();  	}  	pCompLayer = (ICompositeLayer)pGrpLay;  	copyFeats = new Dictionary<string' copyFeatureToInMem> ();  	for (int f = 0; f < 3; f++) {  		if (f == 0) {  			eidEnum = valveHT.GetEnumerator ();  			eidEnum.Reset ();  			re = eidEnum.MoveNext ();  			if (re == false) {  				eidInfo = null;  			} else {  				eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  			}  		} else if (f == 1) {  			enumEidInfo = enumEidInfoJunc;  			enumEidInfo.Reset ();  			eidInfo = enumEidInfo.Next ();  		} else {  			//enumEidInfo = eidHelper.CreateEnumEIDInfo(edgeEIDs);  			enumEidInfo = enumEidInfoEdge;  			enumEidInfo.Reset ();  			eidInfo = enumEidInfo.Next ();  		}  		bool cont = true;  		while (eidInfo != null) {  			cont = true;  			pSourceFC = ((IFeatureClass)eidInfo.Feature.Class);  			if (f == 0) {  				if (valveFCs.Contains (pSourceFC.ObjectClassID.ToString ()) == false) {  					valveFCs.Add (pSourceFC.ObjectClassID.ToString ());  				}  				//pSourceFC.CLSID;  			} else {  				if (valveFCs.Contains (pSourceFC.ObjectClassID.ToString ()) == true) {  					cont = false;  				} else {  					cont = true;  				}  			}  			if (cont) {  				string fcName = pSourceFC.AliasName + suffix;  				if (!copyFeats.ContainsKey (fcName)) {  					pLay = Globals.FindLayerInGroup (pCompLayer' fcName);  					if (pLay == null && boolAddAllResultLayers) {  						pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  						pFC = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  						pFL = new FeatureLayerClass ();  						pFL.FeatureClass = pFC;  						pFL.Name = fcName;  						pGrpLay.Add (pFL);  					} else if (pLay == null && boolAddAllResultLayers == false) {  						if (Globals.FindLayerByClassID (map' pSourceFC.ObjectClassID.ToString ()) != null) {  							pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  							pFC = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  							pFL = new FeatureLayerClass ();  							pFL.FeatureClass = pFC;  							pFL.Name = fcName;  							pGrpLay.Add (pFL);  						} else {  							if (f == 0) {  								re = eidEnum.MoveNext ();  								if (re == false) {  									eidInfo = null;  								} else {  									eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  								}  							} else {  								eidInfo = enumEidInfo.Next ();  							}  							continue;  						}  					} else {  						pFL = pLay as IFeatureLayer;  					}  					if (pFL.FeatureClass == null) {  						pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  						pFL.FeatureClass = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  					} else {  						Globals.deleteFeatures (pFL);  					}  					copFeat = new copyFeatureToInMem ();  					copFeat.OIDSGeo = new Dictionary<int' geoFeat> ();  					copFeat.FeatureLayer = pFL;  					copFeat.sourceFCName = Globals.getClassName (pSourceFC as IDataset);  					copyFeats.Add (fcName' copFeat);  				} else {  					copFeat = copyFeats [fcName];  				}  				if (!copFeat.OIDSGeo.ContainsKey (eidInfo.Feature.OID)) {  					geoFet = new geoFeat ();  					pSourceFeat = pSourceFC.GetFeature (eidInfo.Feature.OID);  					geoFet.feature = pSourceFeat;  					geoFet.geo = new GeometryBagClass ();  					geom = eidInfo.Geometry;  					if (geom == null) {  						geom = pSourceFeat.ShapeCopy;  					}  					geoFet.geo.AddGeometry (copyGeometry (geom' removeMZ)' ref Missing' ref Missing);  					copFeat.OIDSGeo.Add (eidInfo.Feature.OID' geoFet);  					env.Union (geom.Envelope);  				} else {  					geoFet = copFeat.OIDSGeo [eidInfo.Feature.OID];  					geom = eidInfo.Geometry;  					if (geom == null) {  						geom = pSourceFeat.ShapeCopy;  					}  					geoFet.geo.AddGeometry (copyGeometry (geom' removeMZ)' ref Missing' ref Missing);  					env.Union (geom.Envelope);  				}  			}  			if (f == 0) {  				re = eidEnum.MoveNext ();  				if (re == false) {  					eidInfo = null;  				} else {  					eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  				}  			} else {  				eidInfo = enumEidInfo.Next ();  			}  		}  	}  	UID uID = new UID ();  	uID.Value = "esriEditor.Editor";  	IEditor editor = app.FindExtensionByCLSID (uID) as IEditor;  	bool stopEditor = false;  	try {  		if (editor.EditState == esriEditState.esriStateNotEditing) {  			//IWorkspaceEdit workEdit = pWS as IWorkspaceEdit;  			//editor.EditWorkspace = pWS;  			//IWorkspaceEditControl workEditControl = editor.EditWorkspace as IWorkspaceEditControl;  			// workEditControl.SetStoreEventsRequired();  			editor.StartEditing (pWS);  			editor.StartOperation ();  			stopEditor = true;  		}  		//if (!workEdit.IsBeingEdited())  		//{  		//    workEdit.StartEditing(false);  		//}  		//workEdit.StartEditOperation();  		Dictionary<string' int> resultCount = new Dictionary<string' int> ();  		foreach (KeyValuePair<string' copyFeatureToInMem> kvp in copyFeats) {  			resultCount [kvp.Value.sourceFCName] = kvp.Value.OIDSGeo.Count;  			//pCursor = kvp.Value.FeatureLayer.FeatureClass.Insert(true);  			foreach (KeyValuePair<int' geoFeat> oidpair in kvp.Value.OIDSGeo) {  				//pFBuf = kvp.Value.FeatureLayer.FeatureClass.CreateFeatureBuffer();  				//pFeat = (IFeature)pFBuf;  				pFeat = kvp.Value.FeatureLayer.FeatureClass.CreateFeature ();  				if (oidpair.Value.geo.GeometryCount == 1) {  					pGeo = oidpair.Value.geo.get_Geometry (0);  					pFeat.Shape = pGeo;  					if (pGeo.GeometryType == esriGeometryType.esriGeometryPoint) {  						pGeometryCollection.AddGeometry (pGeo);  					} else {  						pPntCollection = (IPointCollection)pGeo;  						for (int p = 0; p < pPntCollection.PointCount; p++) {  							pGeometryCollection.AddGeometry (pPntCollection.get_Point (p));  						}  					}  				} else {  					enumGeometry = oidpair.Value.geo as IEnumGeometry;  					topologicalOperator = new PolylineClass ();  					topologicalOperator.ConstructUnion (enumGeometry);  					pline = (IPolyline)topologicalOperator;  					pFeat.Shape = pline;  					pPntCollection = (IPointCollection)pline;  					for (int p = 0; p < pPntCollection.PointCount; p++) {  						pGeometryCollection.AddGeometry (pPntCollection.get_Point (p));  					}  				}  				for (int i = 0; i < kvp.Value.FeatureLayer.FeatureClass.Fields.FieldCount; i++) {  					pFld = kvp.Value.FeatureLayer.FeatureClass.Fields.get_Field (i);  					if (pFld.Type != esriFieldType.esriFieldTypeGeometry && pFld.Type != esriFieldType.esriFieldTypeOID && pFld != kvp.Value.FeatureLayer.FeatureClass.AreaField && pFld != kvp.Value.FeatureLayer.FeatureClass.LengthField) {  						newFldIdx = pFeat.Fields.FindField (pFld.Name);  						sourceFldIdx = oidpair.Value.feature.Fields.FindField (pFld.Name);  						if (newFldIdx >= 0 && sourceFldIdx >= 0) {  							try {  								//pFBuf.set_Value(newFldIdx' oidpair.Value.feature.get_Value(sourceFldIdx));  								pFeat.set_Value (newFldIdx' oidpair.Value.feature.get_Value (sourceFldIdx));  								if (newFldIdx != sourceFldIdx) {  									Console.WriteLine (newFldIdx);  								}  							} catch (Exception ex) {  								Console.WriteLine (pFld.Name + " " + ex.ToString ());  							}  						}  					}  				}  				newFldIdx = pFeat.Fields.FindField (IDFieldName);  				if (newFldIdx >= 0) {  					//pFBuf.set_Value(newFldIdx' ID);  					pFeat.set_Value (newFldIdx' ID);  				}  				newFldIdx = pFeat.Fields.FindField (DateFieldName);  				if (newFldIdx >= 0) {  					//pFBuf.set_Value(newFldIdx' dateTimeValue);  					pFeat.set_Value (newFldIdx' dateTimeValue);  				}  				//pCursor.InsertFeature(pFBuf);  				pFeat.Store ();  			}  			//pCursor.Flush();  			//Marshal.ReleaseComObject(pCursor);  			pFS = (IFeatureSelection)kvp.Value.FeatureLayer;  			pFS.SelectFeatures (null' esriSelectionResultEnum.esriSelectionResultNew' false);  		}  		topologicalOperator = (ITopologicalOperator)pGeometryCollection;  		pGeo = topologicalOperator.ConvexHull ();  		topologicalOperator = (ITopologicalOperator)pGeo;  		pGeo = topologicalOperator.Buffer (bufferAmt);  		topologicalOperator = (ITopologicalOperator)pGeo;  		topologicalOperator.Simplify ();  		pGeo = (IGeometry)topologicalOperator;  		pGeo.SpatialReference = ((IGeoDataset)gn.FeatureDataset).SpatialReference;  		pLay = Globals.FindLayerInGroup (pCompLayer' A4LGSharedFunctions.Localizer.GetString ("OutageAreaName") + suffix);  		if (pLay != null) {  			pFL = (IFeatureLayer)pLay;  			//pCursor = pFL.FeatureClass.Insert(true);  			//pFBuf = pFL.FeatureClass.CreateFeatureBuffer();  			//pFeat = (IFeature)pFBuf;  			pFeat = pFL.FeatureClass.CreateFeature ();  			pFeat.Shape = pGeo;  			newFldIdx = pFeat.Fields.FindField (IDFieldName);  			if (newFldIdx >= 0) {  				//pFBuf.set_Value(newFldIdx' ID);  				pFeat.set_Value (newFldIdx' ID);  			}  			newFldIdx = pFeat.Fields.FindField (DateFieldName);  			if (newFldIdx >= 0) {  				//pFBuf.set_Value(newFldIdx' dateTimeValue);  				pFeat.set_Value (newFldIdx' dateTimeValue);  			}  			try {  				if (addResOptions != null) {  					foreach (ResultCountToField rctf in addResOptions.ResultCountToField) {  						newFldIdx = pFeat.Fields.FindField (rctf.TargetField);  						if (newFldIdx >= 0) {  							if (resultCount.ContainsKey (rctf.FeatureClassName)) {  								pFeat.set_Value (newFldIdx' resultCount [rctf.FeatureClassName]);  							}  						}  					}  				}  			} catch {  			}  			//pCursor.InsertFeature(pFBuf);  			//pCursor.Flush();  			//Marshal.ReleaseComObject(pCursor);  			pFeat.Store ();  		}  		if (stopEditor) {  			editor.StopOperation ("Trace");  			editor.StopEditing (true);  		}  	} catch {  		if (stopEditor) {  			editor.AbortOperation ();  		}  	} finally {  		uID = null;  		editor = null;  	}  	env.Expand (1.1' 1.1' true);  	((IMxDocument)app.Document).ActiveView.Refresh ();  	return env;  } catch (Exception ex) {  	return null;  } finally {  	env = null;  	// eidHelper = null;  	enumEidInfo = null;  	eidInfo = null;  	geom = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The following statement contains a magic number: for (int f = 0; f < 3; f++) {  	if (f == 0) {  		eidEnum = valveHT.GetEnumerator ();  		eidEnum.Reset ();  		re = eidEnum.MoveNext ();  		if (re == false) {  			eidInfo = null;  		} else {  			eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  		}  	} else if (f == 1) {  		enumEidInfo = enumEidInfoJunc;  		enumEidInfo.Reset ();  		eidInfo = enumEidInfo.Next ();  	} else {  		//enumEidInfo = eidHelper.CreateEnumEIDInfo(edgeEIDs);  		enumEidInfo = enumEidInfoEdge;  		enumEidInfo.Reset ();  		eidInfo = enumEidInfo.Next ();  	}  	bool cont = true;  	while (eidInfo != null) {  		cont = true;  		pSourceFC = ((IFeatureClass)eidInfo.Feature.Class);  		if (f == 0) {  			if (valveFCs.Contains (pSourceFC.ObjectClassID.ToString ()) == false) {  				valveFCs.Add (pSourceFC.ObjectClassID.ToString ());  			}  			//pSourceFC.CLSID;  		} else {  			if (valveFCs.Contains (pSourceFC.ObjectClassID.ToString ()) == true) {  				cont = false;  			} else {  				cont = true;  			}  		}  		if (cont) {  			string fcName = pSourceFC.AliasName + suffix;  			if (!copyFeats.ContainsKey (fcName)) {  				pLay = Globals.FindLayerInGroup (pCompLayer' fcName);  				if (pLay == null && boolAddAllResultLayers) {  					pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  					pFC = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  					pFL = new FeatureLayerClass ();  					pFL.FeatureClass = pFC;  					pFL.Name = fcName;  					pGrpLay.Add (pFL);  				} else if (pLay == null && boolAddAllResultLayers == false) {  					if (Globals.FindLayerByClassID (map' pSourceFC.ObjectClassID.ToString ()) != null) {  						pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  						pFC = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  						pFL = new FeatureLayerClass ();  						pFL.FeatureClass = pFC;  						pFL.Name = fcName;  						pGrpLay.Add (pFL);  					} else {  						if (f == 0) {  							re = eidEnum.MoveNext ();  							if (re == false) {  								eidInfo = null;  							} else {  								eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  							}  						} else {  							eidInfo = enumEidInfo.Next ();  						}  						continue;  					}  				} else {  					pFL = pLay as IFeatureLayer;  				}  				if (pFL.FeatureClass == null) {  					pFlds = Globals.copyFields (eidInfo.Feature.Class.Fields' (eidInfo.Feature.Class as IFeatureClass).LengthField' (eidInfo.Feature.Class as IFeatureClass).AreaField' IDFieldName' DateFieldName' removeMZ);  					pFL.FeatureClass = Globals.createFeatureClassInMemory (fcName' pFlds' pWS' pSourceFC.FeatureType);  				} else {  					Globals.deleteFeatures (pFL);  				}  				copFeat = new copyFeatureToInMem ();  				copFeat.OIDSGeo = new Dictionary<int' geoFeat> ();  				copFeat.FeatureLayer = pFL;  				copFeat.sourceFCName = Globals.getClassName (pSourceFC as IDataset);  				copyFeats.Add (fcName' copFeat);  			} else {  				copFeat = copyFeats [fcName];  			}  			if (!copFeat.OIDSGeo.ContainsKey (eidInfo.Feature.OID)) {  				geoFet = new geoFeat ();  				pSourceFeat = pSourceFC.GetFeature (eidInfo.Feature.OID);  				geoFet.feature = pSourceFeat;  				geoFet.geo = new GeometryBagClass ();  				geom = eidInfo.Geometry;  				if (geom == null) {  					geom = pSourceFeat.ShapeCopy;  				}  				geoFet.geo.AddGeometry (copyGeometry (geom' removeMZ)' ref Missing' ref Missing);  				copFeat.OIDSGeo.Add (eidInfo.Feature.OID' geoFet);  				env.Union (geom.Envelope);  			} else {  				geoFet = copFeat.OIDSGeo [eidInfo.Feature.OID];  				geom = eidInfo.Geometry;  				if (geom == null) {  					geom = pSourceFeat.ShapeCopy;  				}  				geoFet.geo.AddGeometry (copyGeometry (geom' removeMZ)' ref Missing' ref Missing);  				env.Union (geom.Envelope);  			}  		}  		if (f == 0) {  			re = eidEnum.MoveNext ();  			if (re == false) {  				eidInfo = null;  			} else {  				eidInfo = ((DictionaryEntry)eidEnum.Current).Value as IEIDInfo;  			}  		} else {  			eidInfo = enumEidInfo.Next ();  		}  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The following statement contains a magic number: env.Expand (1.1' 1.1' true);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,TraceResultsToLayer,The following statement contains a magic number: env.Expand (1.1' 1.1' true);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The following statement contains a magic number: try {  	if (curve != null && pointFLayer != null) {  		point = new PointClass ();  		pSpatFilt = new SpatialFilterClass ();  		pSpatFilt.Geometry = curve;  		pSpatFilt.GeometryField = pPolyFL.FeatureClass.ShapeFieldName;  		pSpatFilt.SpatialRel = esriSpatialRelEnum.esriSpatialRelIntersects;  		pFC = pPolyFL.Search (pSpatFilt' true);  		pOutPnt = new PointClass ();  		double distFromCurve = 0' distAlongCurve = 0;  		bool bSide = false;  		pFeat = pFC.NextFeature ();  		if (pFeat == null) {  			return AddPointAlongLine (ref app' ref editor' curve' pointFLayer' targetPointDistance' targetPointDistanceIsPercent' editTemplate' storeFeature);  		} else {  			bool intersectFound = false;  			while (pFeat != null) {  				pIntPnt = (IPoint)Globals.GetIntersection (pFeat.ShapeCopy' (IPolyline)curve);  				if (pIntPnt != null) {  					curve.QueryPointAndDistance (esriSegmentExtension.esriNoExtension' pIntPnt' false' pOutPnt' ref distAlongCurve' ref distFromCurve' ref bSide);  					if (targetPointDistanceIsPercent) {  						intersectFound = true;  						if (side.ToUpper () == "TO") {  							workingDist = distAlongCurve + ((curve.Length - distAlongCurve) * (targetPointDistance / 100));  						} else {  							workingDist = distAlongCurve - (distAlongCurve * (targetPointDistance / 100));  						}  						curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' false' point);  					} else {  						if (side.ToUpper () == "TO")  							targetPointDistance = distAlongCurve + targetPointDistance;  						else  							targetPointDistance = distAlongCurve - targetPointDistance;  						if (targetPointDistance > 0) {  							if (curve.Length > targetPointDistance) {  								intersectFound = true;  								curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  								break;  							} else if (targetPointDistance > curve.Length) {  								point = null;  								intersectFound = false;  								pFeat = pFC.NextFeature ();  								continue;  								//distAlongCurve  + (distAlongCurve * (targetPointDistance  								//curve.QueryPoint(esriSegmentExtension.esriNoExtension' curve.Length' true' point);  							} else if (targetPointDistance < 0) {  								point = null;  								intersectFound = false;  								pFeat = pFC.NextFeature ();  								continue;  								//distAlongCurve  + (distAlongCurve * (targetPointDistance  								//curve.QueryPoint(esriSegmentExtension.esriNoExtension' 0' true' point);  							}  						}  					}  				}  				pFeat = pFC.NextFeature ();  			}  			if (intersectFound == false) {  				return AddPointAlongLine (ref app' ref editor' curve' pointFLayer' targetPointDistance' targetPointDistanceIsPercent' editTemplate' storeFeature);  			}  		}  		if (point != null) {  			if (!(point.IsEmpty)) {  				if (editTemplate != null) {  					pFeat = Globals.CreateFeature (point' editTemplate' editor' app' true' false' true);  				} else {  					pFeat = Globals.CreateFeature (point' pointFLayer' editor' app' true' false' true);  				}  				if (storeFeature == true) {  					try {  						if (pFeat != null) {  							Globals.ValidateFeature (pFeat);  							pFeat.Store ();  							return pFeat;  						} else  							return null;  					} catch {  						return null;  					}  				} else {  					return pFeat;  				}  			} else  				return null;  		} else  			return null;  	} else  		return null;  } catch (Exception ex) {  	MessageBox.Show ("Error in addPointAlongLineWithIntersect: " + ex.ToString ());  	return null;  } finally {  	point = null;  	pSpatFilt = null;  	pFC = null;  	pFeat = null;  	pIntPnt = null;  	pOutPnt = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The following statement contains a magic number: try {  	if (curve != null && pointFLayer != null) {  		point = new PointClass ();  		pSpatFilt = new SpatialFilterClass ();  		pSpatFilt.Geometry = curve;  		pSpatFilt.GeometryField = pPolyFL.FeatureClass.ShapeFieldName;  		pSpatFilt.SpatialRel = esriSpatialRelEnum.esriSpatialRelIntersects;  		pFC = pPolyFL.Search (pSpatFilt' true);  		pOutPnt = new PointClass ();  		double distFromCurve = 0' distAlongCurve = 0;  		bool bSide = false;  		pFeat = pFC.NextFeature ();  		if (pFeat == null) {  			return AddPointAlongLine (ref app' ref editor' curve' pointFLayer' targetPointDistance' targetPointDistanceIsPercent' editTemplate' storeFeature);  		} else {  			bool intersectFound = false;  			while (pFeat != null) {  				pIntPnt = (IPoint)Globals.GetIntersection (pFeat.ShapeCopy' (IPolyline)curve);  				if (pIntPnt != null) {  					curve.QueryPointAndDistance (esriSegmentExtension.esriNoExtension' pIntPnt' false' pOutPnt' ref distAlongCurve' ref distFromCurve' ref bSide);  					if (targetPointDistanceIsPercent) {  						intersectFound = true;  						if (side.ToUpper () == "TO") {  							workingDist = distAlongCurve + ((curve.Length - distAlongCurve) * (targetPointDistance / 100));  						} else {  							workingDist = distAlongCurve - (distAlongCurve * (targetPointDistance / 100));  						}  						curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' false' point);  					} else {  						if (side.ToUpper () == "TO")  							targetPointDistance = distAlongCurve + targetPointDistance;  						else  							targetPointDistance = distAlongCurve - targetPointDistance;  						if (targetPointDistance > 0) {  							if (curve.Length > targetPointDistance) {  								intersectFound = true;  								curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  								break;  							} else if (targetPointDistance > curve.Length) {  								point = null;  								intersectFound = false;  								pFeat = pFC.NextFeature ();  								continue;  								//distAlongCurve  + (distAlongCurve * (targetPointDistance  								//curve.QueryPoint(esriSegmentExtension.esriNoExtension' curve.Length' true' point);  							} else if (targetPointDistance < 0) {  								point = null;  								intersectFound = false;  								pFeat = pFC.NextFeature ();  								continue;  								//distAlongCurve  + (distAlongCurve * (targetPointDistance  								//curve.QueryPoint(esriSegmentExtension.esriNoExtension' 0' true' point);  							}  						}  					}  				}  				pFeat = pFC.NextFeature ();  			}  			if (intersectFound == false) {  				return AddPointAlongLine (ref app' ref editor' curve' pointFLayer' targetPointDistance' targetPointDistanceIsPercent' editTemplate' storeFeature);  			}  		}  		if (point != null) {  			if (!(point.IsEmpty)) {  				if (editTemplate != null) {  					pFeat = Globals.CreateFeature (point' editTemplate' editor' app' true' false' true);  				} else {  					pFeat = Globals.CreateFeature (point' pointFLayer' editor' app' true' false' true);  				}  				if (storeFeature == true) {  					try {  						if (pFeat != null) {  							Globals.ValidateFeature (pFeat);  							pFeat.Store ();  							return pFeat;  						} else  							return null;  					} catch {  						return null;  					}  				} else {  					return pFeat;  				}  			} else  				return null;  		} else  			return null;  	} else  		return null;  } catch (Exception ex) {  	MessageBox.Show ("Error in addPointAlongLineWithIntersect: " + ex.ToString ());  	return null;  } finally {  	point = null;  	pSpatFilt = null;  	pFC = null;  	pFeat = null;  	pIntPnt = null;  	pOutPnt = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The following statement contains a magic number: if (curve != null && pointFLayer != null) {  	point = new PointClass ();  	pSpatFilt = new SpatialFilterClass ();  	pSpatFilt.Geometry = curve;  	pSpatFilt.GeometryField = pPolyFL.FeatureClass.ShapeFieldName;  	pSpatFilt.SpatialRel = esriSpatialRelEnum.esriSpatialRelIntersects;  	pFC = pPolyFL.Search (pSpatFilt' true);  	pOutPnt = new PointClass ();  	double distFromCurve = 0' distAlongCurve = 0;  	bool bSide = false;  	pFeat = pFC.NextFeature ();  	if (pFeat == null) {  		return AddPointAlongLine (ref app' ref editor' curve' pointFLayer' targetPointDistance' targetPointDistanceIsPercent' editTemplate' storeFeature);  	} else {  		bool intersectFound = false;  		while (pFeat != null) {  			pIntPnt = (IPoint)Globals.GetIntersection (pFeat.ShapeCopy' (IPolyline)curve);  			if (pIntPnt != null) {  				curve.QueryPointAndDistance (esriSegmentExtension.esriNoExtension' pIntPnt' false' pOutPnt' ref distAlongCurve' ref distFromCurve' ref bSide);  				if (targetPointDistanceIsPercent) {  					intersectFound = true;  					if (side.ToUpper () == "TO") {  						workingDist = distAlongCurve + ((curve.Length - distAlongCurve) * (targetPointDistance / 100));  					} else {  						workingDist = distAlongCurve - (distAlongCurve * (targetPointDistance / 100));  					}  					curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' false' point);  				} else {  					if (side.ToUpper () == "TO")  						targetPointDistance = distAlongCurve + targetPointDistance;  					else  						targetPointDistance = distAlongCurve - targetPointDistance;  					if (targetPointDistance > 0) {  						if (curve.Length > targetPointDistance) {  							intersectFound = true;  							curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  							break;  						} else if (targetPointDistance > curve.Length) {  							point = null;  							intersectFound = false;  							pFeat = pFC.NextFeature ();  							continue;  							//distAlongCurve  + (distAlongCurve * (targetPointDistance  							//curve.QueryPoint(esriSegmentExtension.esriNoExtension' curve.Length' true' point);  						} else if (targetPointDistance < 0) {  							point = null;  							intersectFound = false;  							pFeat = pFC.NextFeature ();  							continue;  							//distAlongCurve  + (distAlongCurve * (targetPointDistance  							//curve.QueryPoint(esriSegmentExtension.esriNoExtension' 0' true' point);  						}  					}  				}  			}  			pFeat = pFC.NextFeature ();  		}  		if (intersectFound == false) {  			return AddPointAlongLine (ref app' ref editor' curve' pointFLayer' targetPointDistance' targetPointDistanceIsPercent' editTemplate' storeFeature);  		}  	}  	if (point != null) {  		if (!(point.IsEmpty)) {  			if (editTemplate != null) {  				pFeat = Globals.CreateFeature (point' editTemplate' editor' app' true' false' true);  			} else {  				pFeat = Globals.CreateFeature (point' pointFLayer' editor' app' true' false' true);  			}  			if (storeFeature == true) {  				try {  					if (pFeat != null) {  						Globals.ValidateFeature (pFeat);  						pFeat.Store ();  						return pFeat;  					} else  						return null;  				} catch {  					return null;  				}  			} else {  				return pFeat;  			}  		} else  			return null;  	} else  		return null;  } else  	return null;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The following statement contains a magic number: if (curve != null && pointFLayer != null) {  	point = new PointClass ();  	pSpatFilt = new SpatialFilterClass ();  	pSpatFilt.Geometry = curve;  	pSpatFilt.GeometryField = pPolyFL.FeatureClass.ShapeFieldName;  	pSpatFilt.SpatialRel = esriSpatialRelEnum.esriSpatialRelIntersects;  	pFC = pPolyFL.Search (pSpatFilt' true);  	pOutPnt = new PointClass ();  	double distFromCurve = 0' distAlongCurve = 0;  	bool bSide = false;  	pFeat = pFC.NextFeature ();  	if (pFeat == null) {  		return AddPointAlongLine (ref app' ref editor' curve' pointFLayer' targetPointDistance' targetPointDistanceIsPercent' editTemplate' storeFeature);  	} else {  		bool intersectFound = false;  		while (pFeat != null) {  			pIntPnt = (IPoint)Globals.GetIntersection (pFeat.ShapeCopy' (IPolyline)curve);  			if (pIntPnt != null) {  				curve.QueryPointAndDistance (esriSegmentExtension.esriNoExtension' pIntPnt' false' pOutPnt' ref distAlongCurve' ref distFromCurve' ref bSide);  				if (targetPointDistanceIsPercent) {  					intersectFound = true;  					if (side.ToUpper () == "TO") {  						workingDist = distAlongCurve + ((curve.Length - distAlongCurve) * (targetPointDistance / 100));  					} else {  						workingDist = distAlongCurve - (distAlongCurve * (targetPointDistance / 100));  					}  					curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' false' point);  				} else {  					if (side.ToUpper () == "TO")  						targetPointDistance = distAlongCurve + targetPointDistance;  					else  						targetPointDistance = distAlongCurve - targetPointDistance;  					if (targetPointDistance > 0) {  						if (curve.Length > targetPointDistance) {  							intersectFound = true;  							curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  							break;  						} else if (targetPointDistance > curve.Length) {  							point = null;  							intersectFound = false;  							pFeat = pFC.NextFeature ();  							continue;  							//distAlongCurve  + (distAlongCurve * (targetPointDistance  							//curve.QueryPoint(esriSegmentExtension.esriNoExtension' curve.Length' true' point);  						} else if (targetPointDistance < 0) {  							point = null;  							intersectFound = false;  							pFeat = pFC.NextFeature ();  							continue;  							//distAlongCurve  + (distAlongCurve * (targetPointDistance  							//curve.QueryPoint(esriSegmentExtension.esriNoExtension' 0' true' point);  						}  					}  				}  			}  			pFeat = pFC.NextFeature ();  		}  		if (intersectFound == false) {  			return AddPointAlongLine (ref app' ref editor' curve' pointFLayer' targetPointDistance' targetPointDistanceIsPercent' editTemplate' storeFeature);  		}  	}  	if (point != null) {  		if (!(point.IsEmpty)) {  			if (editTemplate != null) {  				pFeat = Globals.CreateFeature (point' editTemplate' editor' app' true' false' true);  			} else {  				pFeat = Globals.CreateFeature (point' pointFLayer' editor' app' true' false' true);  			}  			if (storeFeature == true) {  				try {  					if (pFeat != null) {  						Globals.ValidateFeature (pFeat);  						pFeat.Store ();  						return pFeat;  					} else  						return null;  				} catch {  					return null;  				}  			} else {  				return pFeat;  			}  		} else  			return null;  	} else  		return null;  } else  	return null;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The following statement contains a magic number: if (pFeat == null) {  	return AddPointAlongLine (ref app' ref editor' curve' pointFLayer' targetPointDistance' targetPointDistanceIsPercent' editTemplate' storeFeature);  } else {  	bool intersectFound = false;  	while (pFeat != null) {  		pIntPnt = (IPoint)Globals.GetIntersection (pFeat.ShapeCopy' (IPolyline)curve);  		if (pIntPnt != null) {  			curve.QueryPointAndDistance (esriSegmentExtension.esriNoExtension' pIntPnt' false' pOutPnt' ref distAlongCurve' ref distFromCurve' ref bSide);  			if (targetPointDistanceIsPercent) {  				intersectFound = true;  				if (side.ToUpper () == "TO") {  					workingDist = distAlongCurve + ((curve.Length - distAlongCurve) * (targetPointDistance / 100));  				} else {  					workingDist = distAlongCurve - (distAlongCurve * (targetPointDistance / 100));  				}  				curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' false' point);  			} else {  				if (side.ToUpper () == "TO")  					targetPointDistance = distAlongCurve + targetPointDistance;  				else  					targetPointDistance = distAlongCurve - targetPointDistance;  				if (targetPointDistance > 0) {  					if (curve.Length > targetPointDistance) {  						intersectFound = true;  						curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  						break;  					} else if (targetPointDistance > curve.Length) {  						point = null;  						intersectFound = false;  						pFeat = pFC.NextFeature ();  						continue;  						//distAlongCurve  + (distAlongCurve * (targetPointDistance  						//curve.QueryPoint(esriSegmentExtension.esriNoExtension' curve.Length' true' point);  					} else if (targetPointDistance < 0) {  						point = null;  						intersectFound = false;  						pFeat = pFC.NextFeature ();  						continue;  						//distAlongCurve  + (distAlongCurve * (targetPointDistance  						//curve.QueryPoint(esriSegmentExtension.esriNoExtension' 0' true' point);  					}  				}  			}  		}  		pFeat = pFC.NextFeature ();  	}  	if (intersectFound == false) {  		return AddPointAlongLine (ref app' ref editor' curve' pointFLayer' targetPointDistance' targetPointDistanceIsPercent' editTemplate' storeFeature);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The following statement contains a magic number: if (pFeat == null) {  	return AddPointAlongLine (ref app' ref editor' curve' pointFLayer' targetPointDistance' targetPointDistanceIsPercent' editTemplate' storeFeature);  } else {  	bool intersectFound = false;  	while (pFeat != null) {  		pIntPnt = (IPoint)Globals.GetIntersection (pFeat.ShapeCopy' (IPolyline)curve);  		if (pIntPnt != null) {  			curve.QueryPointAndDistance (esriSegmentExtension.esriNoExtension' pIntPnt' false' pOutPnt' ref distAlongCurve' ref distFromCurve' ref bSide);  			if (targetPointDistanceIsPercent) {  				intersectFound = true;  				if (side.ToUpper () == "TO") {  					workingDist = distAlongCurve + ((curve.Length - distAlongCurve) * (targetPointDistance / 100));  				} else {  					workingDist = distAlongCurve - (distAlongCurve * (targetPointDistance / 100));  				}  				curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' false' point);  			} else {  				if (side.ToUpper () == "TO")  					targetPointDistance = distAlongCurve + targetPointDistance;  				else  					targetPointDistance = distAlongCurve - targetPointDistance;  				if (targetPointDistance > 0) {  					if (curve.Length > targetPointDistance) {  						intersectFound = true;  						curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  						break;  					} else if (targetPointDistance > curve.Length) {  						point = null;  						intersectFound = false;  						pFeat = pFC.NextFeature ();  						continue;  						//distAlongCurve  + (distAlongCurve * (targetPointDistance  						//curve.QueryPoint(esriSegmentExtension.esriNoExtension' curve.Length' true' point);  					} else if (targetPointDistance < 0) {  						point = null;  						intersectFound = false;  						pFeat = pFC.NextFeature ();  						continue;  						//distAlongCurve  + (distAlongCurve * (targetPointDistance  						//curve.QueryPoint(esriSegmentExtension.esriNoExtension' 0' true' point);  					}  				}  			}  		}  		pFeat = pFC.NextFeature ();  	}  	if (intersectFound == false) {  		return AddPointAlongLine (ref app' ref editor' curve' pointFLayer' targetPointDistance' targetPointDistanceIsPercent' editTemplate' storeFeature);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The following statement contains a magic number: while (pFeat != null) {  	pIntPnt = (IPoint)Globals.GetIntersection (pFeat.ShapeCopy' (IPolyline)curve);  	if (pIntPnt != null) {  		curve.QueryPointAndDistance (esriSegmentExtension.esriNoExtension' pIntPnt' false' pOutPnt' ref distAlongCurve' ref distFromCurve' ref bSide);  		if (targetPointDistanceIsPercent) {  			intersectFound = true;  			if (side.ToUpper () == "TO") {  				workingDist = distAlongCurve + ((curve.Length - distAlongCurve) * (targetPointDistance / 100));  			} else {  				workingDist = distAlongCurve - (distAlongCurve * (targetPointDistance / 100));  			}  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' false' point);  		} else {  			if (side.ToUpper () == "TO")  				targetPointDistance = distAlongCurve + targetPointDistance;  			else  				targetPointDistance = distAlongCurve - targetPointDistance;  			if (targetPointDistance > 0) {  				if (curve.Length > targetPointDistance) {  					intersectFound = true;  					curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  					break;  				} else if (targetPointDistance > curve.Length) {  					point = null;  					intersectFound = false;  					pFeat = pFC.NextFeature ();  					continue;  					//distAlongCurve  + (distAlongCurve * (targetPointDistance  					//curve.QueryPoint(esriSegmentExtension.esriNoExtension' curve.Length' true' point);  				} else if (targetPointDistance < 0) {  					point = null;  					intersectFound = false;  					pFeat = pFC.NextFeature ();  					continue;  					//distAlongCurve  + (distAlongCurve * (targetPointDistance  					//curve.QueryPoint(esriSegmentExtension.esriNoExtension' 0' true' point);  				}  			}  		}  	}  	pFeat = pFC.NextFeature ();  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The following statement contains a magic number: while (pFeat != null) {  	pIntPnt = (IPoint)Globals.GetIntersection (pFeat.ShapeCopy' (IPolyline)curve);  	if (pIntPnt != null) {  		curve.QueryPointAndDistance (esriSegmentExtension.esriNoExtension' pIntPnt' false' pOutPnt' ref distAlongCurve' ref distFromCurve' ref bSide);  		if (targetPointDistanceIsPercent) {  			intersectFound = true;  			if (side.ToUpper () == "TO") {  				workingDist = distAlongCurve + ((curve.Length - distAlongCurve) * (targetPointDistance / 100));  			} else {  				workingDist = distAlongCurve - (distAlongCurve * (targetPointDistance / 100));  			}  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' false' point);  		} else {  			if (side.ToUpper () == "TO")  				targetPointDistance = distAlongCurve + targetPointDistance;  			else  				targetPointDistance = distAlongCurve - targetPointDistance;  			if (targetPointDistance > 0) {  				if (curve.Length > targetPointDistance) {  					intersectFound = true;  					curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  					break;  				} else if (targetPointDistance > curve.Length) {  					point = null;  					intersectFound = false;  					pFeat = pFC.NextFeature ();  					continue;  					//distAlongCurve  + (distAlongCurve * (targetPointDistance  					//curve.QueryPoint(esriSegmentExtension.esriNoExtension' curve.Length' true' point);  				} else if (targetPointDistance < 0) {  					point = null;  					intersectFound = false;  					pFeat = pFC.NextFeature ();  					continue;  					//distAlongCurve  + (distAlongCurve * (targetPointDistance  					//curve.QueryPoint(esriSegmentExtension.esriNoExtension' 0' true' point);  				}  			}  		}  	}  	pFeat = pFC.NextFeature ();  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The following statement contains a magic number: if (pIntPnt != null) {  	curve.QueryPointAndDistance (esriSegmentExtension.esriNoExtension' pIntPnt' false' pOutPnt' ref distAlongCurve' ref distFromCurve' ref bSide);  	if (targetPointDistanceIsPercent) {  		intersectFound = true;  		if (side.ToUpper () == "TO") {  			workingDist = distAlongCurve + ((curve.Length - distAlongCurve) * (targetPointDistance / 100));  		} else {  			workingDist = distAlongCurve - (distAlongCurve * (targetPointDistance / 100));  		}  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' false' point);  	} else {  		if (side.ToUpper () == "TO")  			targetPointDistance = distAlongCurve + targetPointDistance;  		else  			targetPointDistance = distAlongCurve - targetPointDistance;  		if (targetPointDistance > 0) {  			if (curve.Length > targetPointDistance) {  				intersectFound = true;  				curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  				break;  			} else if (targetPointDistance > curve.Length) {  				point = null;  				intersectFound = false;  				pFeat = pFC.NextFeature ();  				continue;  				//distAlongCurve  + (distAlongCurve * (targetPointDistance  				//curve.QueryPoint(esriSegmentExtension.esriNoExtension' curve.Length' true' point);  			} else if (targetPointDistance < 0) {  				point = null;  				intersectFound = false;  				pFeat = pFC.NextFeature ();  				continue;  				//distAlongCurve  + (distAlongCurve * (targetPointDistance  				//curve.QueryPoint(esriSegmentExtension.esriNoExtension' 0' true' point);  			}  		}  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The following statement contains a magic number: if (pIntPnt != null) {  	curve.QueryPointAndDistance (esriSegmentExtension.esriNoExtension' pIntPnt' false' pOutPnt' ref distAlongCurve' ref distFromCurve' ref bSide);  	if (targetPointDistanceIsPercent) {  		intersectFound = true;  		if (side.ToUpper () == "TO") {  			workingDist = distAlongCurve + ((curve.Length - distAlongCurve) * (targetPointDistance / 100));  		} else {  			workingDist = distAlongCurve - (distAlongCurve * (targetPointDistance / 100));  		}  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' false' point);  	} else {  		if (side.ToUpper () == "TO")  			targetPointDistance = distAlongCurve + targetPointDistance;  		else  			targetPointDistance = distAlongCurve - targetPointDistance;  		if (targetPointDistance > 0) {  			if (curve.Length > targetPointDistance) {  				intersectFound = true;  				curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  				break;  			} else if (targetPointDistance > curve.Length) {  				point = null;  				intersectFound = false;  				pFeat = pFC.NextFeature ();  				continue;  				//distAlongCurve  + (distAlongCurve * (targetPointDistance  				//curve.QueryPoint(esriSegmentExtension.esriNoExtension' curve.Length' true' point);  			} else if (targetPointDistance < 0) {  				point = null;  				intersectFound = false;  				pFeat = pFC.NextFeature ();  				continue;  				//distAlongCurve  + (distAlongCurve * (targetPointDistance  				//curve.QueryPoint(esriSegmentExtension.esriNoExtension' 0' true' point);  			}  		}  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The following statement contains a magic number: if (targetPointDistanceIsPercent) {  	intersectFound = true;  	if (side.ToUpper () == "TO") {  		workingDist = distAlongCurve + ((curve.Length - distAlongCurve) * (targetPointDistance / 100));  	} else {  		workingDist = distAlongCurve - (distAlongCurve * (targetPointDistance / 100));  	}  	curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' false' point);  } else {  	if (side.ToUpper () == "TO")  		targetPointDistance = distAlongCurve + targetPointDistance;  	else  		targetPointDistance = distAlongCurve - targetPointDistance;  	if (targetPointDistance > 0) {  		if (curve.Length > targetPointDistance) {  			intersectFound = true;  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  			break;  		} else if (targetPointDistance > curve.Length) {  			point = null;  			intersectFound = false;  			pFeat = pFC.NextFeature ();  			continue;  			//distAlongCurve  + (distAlongCurve * (targetPointDistance  			//curve.QueryPoint(esriSegmentExtension.esriNoExtension' curve.Length' true' point);  		} else if (targetPointDistance < 0) {  			point = null;  			intersectFound = false;  			pFeat = pFC.NextFeature ();  			continue;  			//distAlongCurve  + (distAlongCurve * (targetPointDistance  			//curve.QueryPoint(esriSegmentExtension.esriNoExtension' 0' true' point);  		}  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The following statement contains a magic number: if (targetPointDistanceIsPercent) {  	intersectFound = true;  	if (side.ToUpper () == "TO") {  		workingDist = distAlongCurve + ((curve.Length - distAlongCurve) * (targetPointDistance / 100));  	} else {  		workingDist = distAlongCurve - (distAlongCurve * (targetPointDistance / 100));  	}  	curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' false' point);  } else {  	if (side.ToUpper () == "TO")  		targetPointDistance = distAlongCurve + targetPointDistance;  	else  		targetPointDistance = distAlongCurve - targetPointDistance;  	if (targetPointDistance > 0) {  		if (curve.Length > targetPointDistance) {  			intersectFound = true;  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  			break;  		} else if (targetPointDistance > curve.Length) {  			point = null;  			intersectFound = false;  			pFeat = pFC.NextFeature ();  			continue;  			//distAlongCurve  + (distAlongCurve * (targetPointDistance  			//curve.QueryPoint(esriSegmentExtension.esriNoExtension' curve.Length' true' point);  		} else if (targetPointDistance < 0) {  			point = null;  			intersectFound = false;  			pFeat = pFC.NextFeature ();  			continue;  			//distAlongCurve  + (distAlongCurve * (targetPointDistance  			//curve.QueryPoint(esriSegmentExtension.esriNoExtension' 0' true' point);  		}  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The following statement contains a magic number: if (side.ToUpper () == "TO") {  	workingDist = distAlongCurve + ((curve.Length - distAlongCurve) * (targetPointDistance / 100));  } else {  	workingDist = distAlongCurve - (distAlongCurve * (targetPointDistance / 100));  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The following statement contains a magic number: if (side.ToUpper () == "TO") {  	workingDist = distAlongCurve + ((curve.Length - distAlongCurve) * (targetPointDistance / 100));  } else {  	workingDist = distAlongCurve - (distAlongCurve * (targetPointDistance / 100));  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The following statement contains a magic number: workingDist = distAlongCurve + ((curve.Length - distAlongCurve) * (targetPointDistance / 100));  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLineWithIntersect,The following statement contains a magic number: workingDist = distAlongCurve - (distAlongCurve * (targetPointDistance / 100));  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The following statement contains a magic number: try {  	if (curve != null && pointFLayer != null) {  		point = new PointClass ();  		if (targetPointDistanceIsPercent) {  			workingDist = targetPointDistance;  			workingDist = workingDist / 100;  			//if (workingDist >= 0 && workingDist <= 100)  			//    workingDist = targetPointDistance;  			if (workingDist >= 0 && workingDist <= 100)  				curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' true' point);  			else if (workingDist < 0)  				curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0' true' point);  			else  				curve.QueryPoint (esriSegmentExtension.esriNoExtension' 100' true' point);  			//curve.QueryPoint(esriSegmentExtension.esriNoExtension' workingDist' true' point);  		} else if (curve.Length > targetPointDistance)  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  		else  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0.5' true' point);  		if (!(point.IsEmpty)) {  			if (editTemplate != null) {  				pFeat = Globals.CreateFeature (point' editTemplate' editor' app' true' false' true);  			} else {  				pFeat = Globals.CreateFeature (point' pointFLayer' editor' app' true' false' true);  			}  			try {  				if (pFeat != null && storeFeature == true) {  					Globals.ValidateFeature (pFeat);  					pFeat.Store ();  				}  				//if (pFeat is INetworkFeature)  				//{  				//    INetworkFeature pNF = (INetworkFeature)pFeat;  				//    pNF.Connect();  				//}  				return pFeat;  			} catch (Exception ex) {  				MessageBox.Show ("Error storing new feature in the " + pointFLayer.Name + " layer\nThis is typically caused by a rule in the AA causing this feature not to be valid and deleting it\nModule: AddPointAlongLine\n" + ex.ToString ());  				return null;  			}  		} else  			return null;  	} else  		return null;  } catch (Exception ex) {  	MessageBox.Show ("Error in addPointAlongLine: " + ex.ToString ());  	return null;  } finally {  	point = null;  	pFeat = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The following statement contains a magic number: try {  	if (curve != null && pointFLayer != null) {  		point = new PointClass ();  		if (targetPointDistanceIsPercent) {  			workingDist = targetPointDistance;  			workingDist = workingDist / 100;  			//if (workingDist >= 0 && workingDist <= 100)  			//    workingDist = targetPointDistance;  			if (workingDist >= 0 && workingDist <= 100)  				curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' true' point);  			else if (workingDist < 0)  				curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0' true' point);  			else  				curve.QueryPoint (esriSegmentExtension.esriNoExtension' 100' true' point);  			//curve.QueryPoint(esriSegmentExtension.esriNoExtension' workingDist' true' point);  		} else if (curve.Length > targetPointDistance)  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  		else  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0.5' true' point);  		if (!(point.IsEmpty)) {  			if (editTemplate != null) {  				pFeat = Globals.CreateFeature (point' editTemplate' editor' app' true' false' true);  			} else {  				pFeat = Globals.CreateFeature (point' pointFLayer' editor' app' true' false' true);  			}  			try {  				if (pFeat != null && storeFeature == true) {  					Globals.ValidateFeature (pFeat);  					pFeat.Store ();  				}  				//if (pFeat is INetworkFeature)  				//{  				//    INetworkFeature pNF = (INetworkFeature)pFeat;  				//    pNF.Connect();  				//}  				return pFeat;  			} catch (Exception ex) {  				MessageBox.Show ("Error storing new feature in the " + pointFLayer.Name + " layer\nThis is typically caused by a rule in the AA causing this feature not to be valid and deleting it\nModule: AddPointAlongLine\n" + ex.ToString ());  				return null;  			}  		} else  			return null;  	} else  		return null;  } catch (Exception ex) {  	MessageBox.Show ("Error in addPointAlongLine: " + ex.ToString ());  	return null;  } finally {  	point = null;  	pFeat = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The following statement contains a magic number: try {  	if (curve != null && pointFLayer != null) {  		point = new PointClass ();  		if (targetPointDistanceIsPercent) {  			workingDist = targetPointDistance;  			workingDist = workingDist / 100;  			//if (workingDist >= 0 && workingDist <= 100)  			//    workingDist = targetPointDistance;  			if (workingDist >= 0 && workingDist <= 100)  				curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' true' point);  			else if (workingDist < 0)  				curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0' true' point);  			else  				curve.QueryPoint (esriSegmentExtension.esriNoExtension' 100' true' point);  			//curve.QueryPoint(esriSegmentExtension.esriNoExtension' workingDist' true' point);  		} else if (curve.Length > targetPointDistance)  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  		else  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0.5' true' point);  		if (!(point.IsEmpty)) {  			if (editTemplate != null) {  				pFeat = Globals.CreateFeature (point' editTemplate' editor' app' true' false' true);  			} else {  				pFeat = Globals.CreateFeature (point' pointFLayer' editor' app' true' false' true);  			}  			try {  				if (pFeat != null && storeFeature == true) {  					Globals.ValidateFeature (pFeat);  					pFeat.Store ();  				}  				//if (pFeat is INetworkFeature)  				//{  				//    INetworkFeature pNF = (INetworkFeature)pFeat;  				//    pNF.Connect();  				//}  				return pFeat;  			} catch (Exception ex) {  				MessageBox.Show ("Error storing new feature in the " + pointFLayer.Name + " layer\nThis is typically caused by a rule in the AA causing this feature not to be valid and deleting it\nModule: AddPointAlongLine\n" + ex.ToString ());  				return null;  			}  		} else  			return null;  	} else  		return null;  } catch (Exception ex) {  	MessageBox.Show ("Error in addPointAlongLine: " + ex.ToString ());  	return null;  } finally {  	point = null;  	pFeat = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The following statement contains a magic number: try {  	if (curve != null && pointFLayer != null) {  		point = new PointClass ();  		if (targetPointDistanceIsPercent) {  			workingDist = targetPointDistance;  			workingDist = workingDist / 100;  			//if (workingDist >= 0 && workingDist <= 100)  			//    workingDist = targetPointDistance;  			if (workingDist >= 0 && workingDist <= 100)  				curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' true' point);  			else if (workingDist < 0)  				curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0' true' point);  			else  				curve.QueryPoint (esriSegmentExtension.esriNoExtension' 100' true' point);  			//curve.QueryPoint(esriSegmentExtension.esriNoExtension' workingDist' true' point);  		} else if (curve.Length > targetPointDistance)  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  		else  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0.5' true' point);  		if (!(point.IsEmpty)) {  			if (editTemplate != null) {  				pFeat = Globals.CreateFeature (point' editTemplate' editor' app' true' false' true);  			} else {  				pFeat = Globals.CreateFeature (point' pointFLayer' editor' app' true' false' true);  			}  			try {  				if (pFeat != null && storeFeature == true) {  					Globals.ValidateFeature (pFeat);  					pFeat.Store ();  				}  				//if (pFeat is INetworkFeature)  				//{  				//    INetworkFeature pNF = (INetworkFeature)pFeat;  				//    pNF.Connect();  				//}  				return pFeat;  			} catch (Exception ex) {  				MessageBox.Show ("Error storing new feature in the " + pointFLayer.Name + " layer\nThis is typically caused by a rule in the AA causing this feature not to be valid and deleting it\nModule: AddPointAlongLine\n" + ex.ToString ());  				return null;  			}  		} else  			return null;  	} else  		return null;  } catch (Exception ex) {  	MessageBox.Show ("Error in addPointAlongLine: " + ex.ToString ());  	return null;  } finally {  	point = null;  	pFeat = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The following statement contains a magic number: if (curve != null && pointFLayer != null) {  	point = new PointClass ();  	if (targetPointDistanceIsPercent) {  		workingDist = targetPointDistance;  		workingDist = workingDist / 100;  		//if (workingDist >= 0 && workingDist <= 100)  		//    workingDist = targetPointDistance;  		if (workingDist >= 0 && workingDist <= 100)  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' true' point);  		else if (workingDist < 0)  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0' true' point);  		else  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' 100' true' point);  		//curve.QueryPoint(esriSegmentExtension.esriNoExtension' workingDist' true' point);  	} else if (curve.Length > targetPointDistance)  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  	else  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0.5' true' point);  	if (!(point.IsEmpty)) {  		if (editTemplate != null) {  			pFeat = Globals.CreateFeature (point' editTemplate' editor' app' true' false' true);  		} else {  			pFeat = Globals.CreateFeature (point' pointFLayer' editor' app' true' false' true);  		}  		try {  			if (pFeat != null && storeFeature == true) {  				Globals.ValidateFeature (pFeat);  				pFeat.Store ();  			}  			//if (pFeat is INetworkFeature)  			//{  			//    INetworkFeature pNF = (INetworkFeature)pFeat;  			//    pNF.Connect();  			//}  			return pFeat;  		} catch (Exception ex) {  			MessageBox.Show ("Error storing new feature in the " + pointFLayer.Name + " layer\nThis is typically caused by a rule in the AA causing this feature not to be valid and deleting it\nModule: AddPointAlongLine\n" + ex.ToString ());  			return null;  		}  	} else  		return null;  } else  	return null;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The following statement contains a magic number: if (curve != null && pointFLayer != null) {  	point = new PointClass ();  	if (targetPointDistanceIsPercent) {  		workingDist = targetPointDistance;  		workingDist = workingDist / 100;  		//if (workingDist >= 0 && workingDist <= 100)  		//    workingDist = targetPointDistance;  		if (workingDist >= 0 && workingDist <= 100)  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' true' point);  		else if (workingDist < 0)  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0' true' point);  		else  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' 100' true' point);  		//curve.QueryPoint(esriSegmentExtension.esriNoExtension' workingDist' true' point);  	} else if (curve.Length > targetPointDistance)  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  	else  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0.5' true' point);  	if (!(point.IsEmpty)) {  		if (editTemplate != null) {  			pFeat = Globals.CreateFeature (point' editTemplate' editor' app' true' false' true);  		} else {  			pFeat = Globals.CreateFeature (point' pointFLayer' editor' app' true' false' true);  		}  		try {  			if (pFeat != null && storeFeature == true) {  				Globals.ValidateFeature (pFeat);  				pFeat.Store ();  			}  			//if (pFeat is INetworkFeature)  			//{  			//    INetworkFeature pNF = (INetworkFeature)pFeat;  			//    pNF.Connect();  			//}  			return pFeat;  		} catch (Exception ex) {  			MessageBox.Show ("Error storing new feature in the " + pointFLayer.Name + " layer\nThis is typically caused by a rule in the AA causing this feature not to be valid and deleting it\nModule: AddPointAlongLine\n" + ex.ToString ());  			return null;  		}  	} else  		return null;  } else  	return null;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The following statement contains a magic number: if (curve != null && pointFLayer != null) {  	point = new PointClass ();  	if (targetPointDistanceIsPercent) {  		workingDist = targetPointDistance;  		workingDist = workingDist / 100;  		//if (workingDist >= 0 && workingDist <= 100)  		//    workingDist = targetPointDistance;  		if (workingDist >= 0 && workingDist <= 100)  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' true' point);  		else if (workingDist < 0)  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0' true' point);  		else  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' 100' true' point);  		//curve.QueryPoint(esriSegmentExtension.esriNoExtension' workingDist' true' point);  	} else if (curve.Length > targetPointDistance)  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  	else  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0.5' true' point);  	if (!(point.IsEmpty)) {  		if (editTemplate != null) {  			pFeat = Globals.CreateFeature (point' editTemplate' editor' app' true' false' true);  		} else {  			pFeat = Globals.CreateFeature (point' pointFLayer' editor' app' true' false' true);  		}  		try {  			if (pFeat != null && storeFeature == true) {  				Globals.ValidateFeature (pFeat);  				pFeat.Store ();  			}  			//if (pFeat is INetworkFeature)  			//{  			//    INetworkFeature pNF = (INetworkFeature)pFeat;  			//    pNF.Connect();  			//}  			return pFeat;  		} catch (Exception ex) {  			MessageBox.Show ("Error storing new feature in the " + pointFLayer.Name + " layer\nThis is typically caused by a rule in the AA causing this feature not to be valid and deleting it\nModule: AddPointAlongLine\n" + ex.ToString ());  			return null;  		}  	} else  		return null;  } else  	return null;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The following statement contains a magic number: if (curve != null && pointFLayer != null) {  	point = new PointClass ();  	if (targetPointDistanceIsPercent) {  		workingDist = targetPointDistance;  		workingDist = workingDist / 100;  		//if (workingDist >= 0 && workingDist <= 100)  		//    workingDist = targetPointDistance;  		if (workingDist >= 0 && workingDist <= 100)  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' true' point);  		else if (workingDist < 0)  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0' true' point);  		else  			curve.QueryPoint (esriSegmentExtension.esriNoExtension' 100' true' point);  		//curve.QueryPoint(esriSegmentExtension.esriNoExtension' workingDist' true' point);  	} else if (curve.Length > targetPointDistance)  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  	else  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0.5' true' point);  	if (!(point.IsEmpty)) {  		if (editTemplate != null) {  			pFeat = Globals.CreateFeature (point' editTemplate' editor' app' true' false' true);  		} else {  			pFeat = Globals.CreateFeature (point' pointFLayer' editor' app' true' false' true);  		}  		try {  			if (pFeat != null && storeFeature == true) {  				Globals.ValidateFeature (pFeat);  				pFeat.Store ();  			}  			//if (pFeat is INetworkFeature)  			//{  			//    INetworkFeature pNF = (INetworkFeature)pFeat;  			//    pNF.Connect();  			//}  			return pFeat;  		} catch (Exception ex) {  			MessageBox.Show ("Error storing new feature in the " + pointFLayer.Name + " layer\nThis is typically caused by a rule in the AA causing this feature not to be valid and deleting it\nModule: AddPointAlongLine\n" + ex.ToString ());  			return null;  		}  	} else  		return null;  } else  	return null;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The following statement contains a magic number: if (targetPointDistanceIsPercent) {  	workingDist = targetPointDistance;  	workingDist = workingDist / 100;  	//if (workingDist >= 0 && workingDist <= 100)  	//    workingDist = targetPointDistance;  	if (workingDist >= 0 && workingDist <= 100)  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' true' point);  	else if (workingDist < 0)  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0' true' point);  	else  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' 100' true' point);  	//curve.QueryPoint(esriSegmentExtension.esriNoExtension' workingDist' true' point);  } else if (curve.Length > targetPointDistance)  	curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  else  	curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0.5' true' point);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The following statement contains a magic number: if (targetPointDistanceIsPercent) {  	workingDist = targetPointDistance;  	workingDist = workingDist / 100;  	//if (workingDist >= 0 && workingDist <= 100)  	//    workingDist = targetPointDistance;  	if (workingDist >= 0 && workingDist <= 100)  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' true' point);  	else if (workingDist < 0)  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0' true' point);  	else  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' 100' true' point);  	//curve.QueryPoint(esriSegmentExtension.esriNoExtension' workingDist' true' point);  } else if (curve.Length > targetPointDistance)  	curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  else  	curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0.5' true' point);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The following statement contains a magic number: if (targetPointDistanceIsPercent) {  	workingDist = targetPointDistance;  	workingDist = workingDist / 100;  	//if (workingDist >= 0 && workingDist <= 100)  	//    workingDist = targetPointDistance;  	if (workingDist >= 0 && workingDist <= 100)  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' true' point);  	else if (workingDist < 0)  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0' true' point);  	else  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' 100' true' point);  	//curve.QueryPoint(esriSegmentExtension.esriNoExtension' workingDist' true' point);  } else if (curve.Length > targetPointDistance)  	curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  else  	curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0.5' true' point);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The following statement contains a magic number: if (targetPointDistanceIsPercent) {  	workingDist = targetPointDistance;  	workingDist = workingDist / 100;  	//if (workingDist >= 0 && workingDist <= 100)  	//    workingDist = targetPointDistance;  	if (workingDist >= 0 && workingDist <= 100)  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' true' point);  	else if (workingDist < 0)  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0' true' point);  	else  		curve.QueryPoint (esriSegmentExtension.esriNoExtension' 100' true' point);  	//curve.QueryPoint(esriSegmentExtension.esriNoExtension' workingDist' true' point);  } else if (curve.Length > targetPointDistance)  	curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  else  	curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0.5' true' point);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The following statement contains a magic number: workingDist = workingDist / 100;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The following statement contains a magic number: if (workingDist >= 0 && workingDist <= 100)  	curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' true' point);  else if (workingDist < 0)  	curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0' true' point);  else  	curve.QueryPoint (esriSegmentExtension.esriNoExtension' 100' true' point);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The following statement contains a magic number: if (workingDist >= 0 && workingDist <= 100)  	curve.QueryPoint (esriSegmentExtension.esriNoExtension' workingDist' true' point);  else if (workingDist < 0)  	curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0' true' point);  else  	curve.QueryPoint (esriSegmentExtension.esriNoExtension' 100' true' point);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The following statement contains a magic number: if (workingDist < 0)  	curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0' true' point);  else  	curve.QueryPoint (esriSegmentExtension.esriNoExtension' 100' true' point);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The following statement contains a magic number: curve.QueryPoint (esriSegmentExtension.esriNoExtension' 100' true' point);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The following statement contains a magic number: if (curve.Length > targetPointDistance)  	curve.QueryPoint (esriSegmentExtension.esriNoExtension' targetPointDistance' false' point);  else  	curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0.5' true' point);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointAlongLine,The following statement contains a magic number: curve.QueryPoint (esriSegmentExtension.esriNoExtension' 0.5' true' point);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertClockPositionToDegrees,The following statement contains a magic number: return value * (360 / 12);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertClockPositionToDegrees,The following statement contains a magic number: return value * (360 / 12);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateAngledLineFromLocationOnLine,The following statement contains a magic number: try {  	if (mainLayer.FeatureClass.ShapeType == esriGeometryType.esriGeometryPolygon) {  		return null;  	}  	if (mainLayer == null) {  		return null;  	}  	double searchDist;  	if (searchDistance <= 0) {  		searchDist = Globals.GetXYTolerance (mainLayer) * 2000;  	} else {  		searchDist = searchDistance;  	}  	mainFeature = Globals.GetClosestFeature (inPoint' mainLayer' searchDist' boolLayerOrFC' CheckSelection);  	bool side = false;  	double angleOfLine = 0;  	if (mainFeature != null) {  		snapPnt = Globals.GetPointOnLine (inPoint' (IGeometry)mainFeature.ShapeCopy' searchDist' out side);  		//snapPnt = inPoint;  		angleOfLine = Globals.GetAngleOfLineAtPoint ((IPolyline)mainFeature.ShapeCopy' snapPnt' searchDist);  		if (angleOfLine <= Math.PI) {  			angleOfLine = angleOfLine + Math.PI;  		} else {  			angleOfLine = angleOfLine - Math.PI;  		}  	} else {  		snapPnt = inPoint;  	}  	// dAlong = Globals.PointDistanceOnLine((IPoint)inPoint' (IPolyline)geoMainLine' 2' out snapPnt);  	if (AddAngleToLineAngle.ToUpper () == "TRUE") {  		RadianAngle = angleOfLine - RadianAngle;  	}  	pNewPt = new PointClass ();  	pConsPoint = pNewPt as IConstructPoint2;  	if (RadianAngle <= Math.PI) {  		RadianAngle = RadianAngle + Math.PI;  	} else {  		RadianAngle = RadianAngle - Math.PI;  	}  	pConsPoint.ConstructAngleDistance (snapPnt' RadianAngle' LineLength);  	pPolyline = new PolylineClass ();  	if (StartAtInput) {  		pPolyline.FromPoint = snapPnt;  		pPolyline.ToPoint = pNewPt;  	} else {  		pPolyline.FromPoint = pNewPt;  		pPolyline.ToPoint = snapPnt;  	}  	return pPolyline;  } catch {  	//snapPnt = null;  	//pPolyline = null;  	//geoMainLine = null;  	//pNewPt = null;  	//pConsPoint = null;  	return null;  } finally {  	// snapPnt = null;  	pPolyline = null;  	pNewPt = null;  	pConsPoint = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateAngledLineFromLocationOnLine,The following statement contains a magic number: if (searchDistance <= 0) {  	searchDist = Globals.GetXYTolerance (mainLayer) * 2000;  } else {  	searchDist = searchDistance;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateAngledLineFromLocationOnLine,The following statement contains a magic number: searchDist = Globals.GetXYTolerance (mainLayer) * 2000;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertRadsToDegrees,The following statement contains a magic number: pi = 4 * Math.Atan (1);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertRadsToDegrees,The following statement contains a magic number: Angle = Angle * 180 / pi;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertRadsToDegrees,The following statement contains a magic number: if (Angle < 0) {  	Angle = 360 + Angle;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertRadsToDegrees,The following statement contains a magic number: Angle = 360 + Angle;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertRadsToDegrees,The following statement contains a magic number: if (Angle > 360) {  	Angle = Angle - 360;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertRadsToDegrees,The following statement contains a magic number: if (Angle > 360) {  	Angle = Angle - 360;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertRadsToDegrees,The following statement contains a magic number: Angle = Angle - 360;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertDegToRads,The following statement contains a magic number: if (Angle < 0) {  	Angle = 360 + Angle;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertDegToRads,The following statement contains a magic number: Angle = 360 + Angle;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertDegToRads,The following statement contains a magic number: if (Angle > 360) {  	Angle = Angle - 360;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertDegToRads,The following statement contains a magic number: if (Angle > 360) {  	Angle = Angle - 360;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertDegToRads,The following statement contains a magic number: Angle = Angle - 360;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertDegToRads,The following statement contains a magic number: pi = 4 * Math.Atan (1);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertDegToRads,The following statement contains a magic number: return Angle * pi / 180;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertArithmeticToGeographic,The following statement contains a magic number: Angle = 270 - Angle;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertArithmeticToGeographic,The following statement contains a magic number: if (Angle < 0) {  	Angle = 360 + Angle;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertArithmeticToGeographic,The following statement contains a magic number: Angle = 360 + Angle;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertArithmeticToGeographic,The following statement contains a magic number: if (Angle > 360) {  	Angle = Angle - 360;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertArithmeticToGeographic,The following statement contains a magic number: if (Angle > 360) {  	Angle = Angle - 360;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertArithmeticToGeographic,The following statement contains a magic number: Angle = Angle - 360;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetAngleOfLineAtDistance,The following statement contains a magic number: try {  	pLine = new LineClass ();  	pCurve = (ICurve)inLine;  	pCurve.QueryTangent (esriSegmentExtension.esriNoExtension' distance' false' pCurve.Length' pLine);  	return pLine.Angle;  } catch {  	return -9999;  } finally {  	pCurve = null;  	pLine = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetAngleOfLineAtDistance,The following statement contains a magic number: return -9999;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetAngleOfLineAtPoint,The following statement contains a magic number: try {  	ILine pLinetest = new LineClass ();  	pLinetest.ToPoint = inLine.FromPoint;  	pLinetest.FromPoint = inLine.ToPoint;  	double tst = pLinetest.Angle;  	pSnapPt = null;  	double dist = Globals.PointDistanceOnLine (location' inLine' 15' out pSnapPt);  	double angle = GetAngleOfLineAtDistance (inLine' dist);  	if (angle != -9999)  		return angle;  } catch {  } finally {  	pSnapPt = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetAngleOfLineAtPoint,The following statement contains a magic number: try {  	ILine pLinetest = new LineClass ();  	pLinetest.ToPoint = inLine.FromPoint;  	pLinetest.FromPoint = inLine.ToPoint;  	double tst = pLinetest.Angle;  	pSnapPt = null;  	double dist = Globals.PointDistanceOnLine (location' inLine' 15' out pSnapPt);  	double angle = GetAngleOfLineAtDistance (inLine' dist);  	if (angle != -9999)  		return angle;  } catch {  } finally {  	pSnapPt = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetAngleOfLineAtPoint,The following statement contains a magic number: if (angle != -9999)  	return angle;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetAngleOfLineAtPoint,The following statement contains a magic number: try {  	double dShortestDistance;  	double dDistance;  	int lngPart = 0;  	int lngSeg = 0;  	bool bFound = false;  	//Get the polyline and get a reference to it's segments  	pSegCol = (ISegmentCollection)inLine;  	//If it has more than one segment...  	if (pSegCol.SegmentCount > 1) {  		//Initalize test  		bFound = false;  		//Get segments  		pEnumSegments = pSegCol.EnumSegments;  		//Find touching segment...  		//Get first segment  		pEnumSegments.Next (out pSegment' ref lngPart' ref lngSeg);  		pRelOp = (IRelationalOperator)location;  		while ((pSegment != null)) {  			pSegColTest = new PolylineClass ();  			pSegColTest.AddSegment (pSegment);  			if (pRelOp.Within ((IPolyline)pSegColTest)) {  				bFound = true;  				pSegColNearest = new PolylineClass ();  				pSegColNearest.AddSegment (pSegment);  				break;  			}  			if (pRelOp.Touches ((IPolyline)pSegColTest)) {  				bFound = true;  				pSegColNearest = new PolylineClass ();  				pSegColNearest.AddSegment (pSegment);  				break;  			}  			pEnumSegments.Next (out pSegment' ref lngPart' ref lngSeg);  		}  		//If no touching segment found - find nearest segement  		//Get first segment  		if (!bFound) {  			//Get segments  			pEnumSegments = pSegCol.EnumSegments;  			//Find touching segment...  			//Get first segment  			pEnumSegments.Next (out pSegment' ref lngPart' ref lngSeg);  			dShortestDistance = 9999;  			while ((pSegment != null)) {  				//Create a new segment collection to hold just this segment  				pSegColTest = new PolylineClass ();  				pSegColTest.AddSegment (pSegment);  				//if it's closer to the point' save this segment  				pProxOp = (IProximityOperator)pSegColTest;  				//dDistance = pProxOp.ReturnDistance(pPoint)  				IGeometry pTempGeo = location;  				pTempGeo.Project (inLine.SpatialReference);  				dDistance = pProxOp.ReturnDistance (pTempGeo);  				if (dDistance < dShortestDistance) {  					dShortestDistance = dDistance;  					pSegColNearest = new PolylineClass ();  					IClone pClone = (IClone)pSegment;  					pSegColNearest.AddSegment ((ISegment)pClone.Clone ());  				}  				//Get next segment  				pEnumSegments.Next (out pSegment' ref lngPart' ref lngSeg);  			}  		}  		//If it only has one segment use that...  	} else {  		pSegColNearest = new PolylineClass ();  		pSegColNearest.AddSegment (pSegCol.get_Segment (0));  	}  	//Get the Polyline interface  	pPolylineTest = (IPolyline)pSegColNearest;  	//QI  	//Create a simple line so we can get it's angle  	//Also set it so it's ToPoint will be at the point feature  	pLine = new Line ();  	if (pPolylineTest.ToPoint.X == location.X & pPolylineTest.ToPoint.Y == location.Y) {  		pLine.FromPoint = pPolylineTest.FromPoint;  		pLine.ToPoint = pPolylineTest.ToPoint;  	} else {  		pLine.FromPoint = pPolylineTest.ToPoint;  		pLine.ToPoint = pPolylineTest.FromPoint;  	}  	return pLine.Angle;  } catch (Exception ex) {  	return 0;  } finally {  	pSegCol = null;  	pSegColTest = null;  	pEnumSegments = null;  	pSegment = null;  	pPolylineTest = null;  	pProxOp = null;  	pRelOp = null;  	pSegColNearest = null;  	pLine = null;  	// topoOp = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetAngleOfLineAtPoint,The following statement contains a magic number: if (pSegCol.SegmentCount > 1) {  	//Initalize test  	bFound = false;  	//Get segments  	pEnumSegments = pSegCol.EnumSegments;  	//Find touching segment...  	//Get first segment  	pEnumSegments.Next (out pSegment' ref lngPart' ref lngSeg);  	pRelOp = (IRelationalOperator)location;  	while ((pSegment != null)) {  		pSegColTest = new PolylineClass ();  		pSegColTest.AddSegment (pSegment);  		if (pRelOp.Within ((IPolyline)pSegColTest)) {  			bFound = true;  			pSegColNearest = new PolylineClass ();  			pSegColNearest.AddSegment (pSegment);  			break;  		}  		if (pRelOp.Touches ((IPolyline)pSegColTest)) {  			bFound = true;  			pSegColNearest = new PolylineClass ();  			pSegColNearest.AddSegment (pSegment);  			break;  		}  		pEnumSegments.Next (out pSegment' ref lngPart' ref lngSeg);  	}  	//If no touching segment found - find nearest segement  	//Get first segment  	if (!bFound) {  		//Get segments  		pEnumSegments = pSegCol.EnumSegments;  		//Find touching segment...  		//Get first segment  		pEnumSegments.Next (out pSegment' ref lngPart' ref lngSeg);  		dShortestDistance = 9999;  		while ((pSegment != null)) {  			//Create a new segment collection to hold just this segment  			pSegColTest = new PolylineClass ();  			pSegColTest.AddSegment (pSegment);  			//if it's closer to the point' save this segment  			pProxOp = (IProximityOperator)pSegColTest;  			//dDistance = pProxOp.ReturnDistance(pPoint)  			IGeometry pTempGeo = location;  			pTempGeo.Project (inLine.SpatialReference);  			dDistance = pProxOp.ReturnDistance (pTempGeo);  			if (dDistance < dShortestDistance) {  				dShortestDistance = dDistance;  				pSegColNearest = new PolylineClass ();  				IClone pClone = (IClone)pSegment;  				pSegColNearest.AddSegment ((ISegment)pClone.Clone ());  			}  			//Get next segment  			pEnumSegments.Next (out pSegment' ref lngPart' ref lngSeg);  		}  	}  	//If it only has one segment use that...  } else {  	pSegColNearest = new PolylineClass ();  	pSegColNearest.AddSegment (pSegCol.get_Segment (0));  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetAngleOfLineAtPoint,The following statement contains a magic number: if (!bFound) {  	//Get segments  	pEnumSegments = pSegCol.EnumSegments;  	//Find touching segment...  	//Get first segment  	pEnumSegments.Next (out pSegment' ref lngPart' ref lngSeg);  	dShortestDistance = 9999;  	while ((pSegment != null)) {  		//Create a new segment collection to hold just this segment  		pSegColTest = new PolylineClass ();  		pSegColTest.AddSegment (pSegment);  		//if it's closer to the point' save this segment  		pProxOp = (IProximityOperator)pSegColTest;  		//dDistance = pProxOp.ReturnDistance(pPoint)  		IGeometry pTempGeo = location;  		pTempGeo.Project (inLine.SpatialReference);  		dDistance = pProxOp.ReturnDistance (pTempGeo);  		if (dDistance < dShortestDistance) {  			dShortestDistance = dDistance;  			pSegColNearest = new PolylineClass ();  			IClone pClone = (IClone)pSegment;  			pSegColNearest.AddSegment ((ISegment)pClone.Clone ());  		}  		//Get next segment  		pEnumSegments.Next (out pSegment' ref lngPart' ref lngSeg);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetAngleOfLineAtPoint,The following statement contains a magic number: dShortestDistance = 9999;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetAddressInfo,The following statement contains a magic number: try {  	retAdd = new AddressInfo ();  	if (FullNameField == -1 || LeftToField == -1 || RightToField == -1 || LeftFromField == -1 || RightFromField == -1) {  		return null;  	}  	if (RoadFeature == null) {  		return null;  	}  	bool rightSide = true;  	pSnapedPoint = Globals.GetPointOnLine (pointLocation' RoadFeature.Shape as IPolyline' searchDistance' out rightSide);  	IPoint snapPnt = null;  	double dAlong = Globals.PointDistanceOnLine (pSnapedPoint' RoadFeature.Shape as IPolyline' 2' out snapPnt);  	if (Globals.IsNumeric (dAlong.ToString ())) {  		snapPnt = null;  		double totalDist = Globals.GetLineLength (RoadFeature.Shape as IPolyline);  		double perc = (dAlong / totalDist);  		//*100  		double retAddNumLeft = 0;  		double retAddNumRight = 0;  		string roadName = RoadFeature.get_Value (FullNameField).ToString ();  		string roadID = "";  		if (StreetIDField != -1)  			roadID = RoadFeature.get_Value (StreetIDField).ToString ();  		string LeftFrom = RoadFeature.get_Value (LeftFromField).ToString ();  		string LeftTo = RoadFeature.get_Value (LeftToField).ToString ();  		double dblLeftFrom = 0;  		double dblLeftTo = 0;  		if (Globals.IsNumeric (LeftFrom) && Globals.IsNumeric (LeftTo)) {  			dblLeftFrom = Convert.ToDouble (LeftFrom);  			dblLeftTo = Convert.ToDouble (LeftTo);  			if (dblLeftFrom > dblLeftTo) {  				retAddNumLeft = dblLeftTo + ((dblLeftFrom - dblLeftTo) * perc);  			} else if (dblLeftFrom < dblLeftTo) {  				retAddNumLeft = dblLeftFrom + ((dblLeftTo - dblLeftFrom) * perc);  			} else {  				retAddNumLeft = dblLeftFrom;  			}  		} else {  			// return null;  		}  		string RightFrom = RoadFeature.get_Value (RightFromField).ToString ();  		string RightTo = RoadFeature.get_Value (RightToField).ToString ();  		double dblRightFrom = 0;  		double dblRightTo = 0;  		if (Globals.IsNumeric (RightFrom) && Globals.IsNumeric (RightTo)) {  			dblRightFrom = Convert.ToDouble (RightFrom);  			dblRightTo = Convert.ToDouble (RightTo);  			if (dblRightFrom > dblRightTo) {  				retAddNumRight = dblRightTo + ((dblRightFrom - dblRightTo) * perc);  			} else if (dblRightFrom < dblRightTo) {  				retAddNumRight = dblRightFrom + ((dblRightTo - dblRightFrom) * perc);  			} else {  				retAddNumRight = dblRightFrom;  			}  		} else {  			// return null;  		}  		if (Globals.IsOdd (dblRightFrom)) {  			retAddNumRight = Globals.RoundToEvenOdd (Globals.EvenOdd.Odd' retAddNumRight);  		} else {  			retAddNumRight = Globals.RoundToEvenOdd (Globals.EvenOdd.Even' retAddNumRight);  		}  		if (Globals.IsOdd (dblLeftFrom)) {  			retAddNumLeft = Globals.RoundToEvenOdd (Globals.EvenOdd.Odd' retAddNumLeft);  		} else {  			retAddNumLeft = Globals.RoundToEvenOdd (Globals.EvenOdd.Even' retAddNumLeft);  		}  		retAdd.LeftAddress = retAddNumLeft;  		retAdd.RightAddress = retAddNumRight;  		retAdd.StreetName = roadName;  		retAdd.StreetID = roadID;  		retAdd.StreetGeometry = RoadFeature.ShapeCopy;  		retAdd.DistanceAlong = dAlong.ToString ("N2");  		return retAdd;  	} else {  		return null;  	}  } catch {  	return null;  } finally {  	pSnapedPoint = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CursorToList,The following statement contains a magic number: try {  	List<string> vals = new List<string> ();  	IRow pRow;  	while ((pRow = pCur.NextRow ()) != null) {  		string dis = "";  		for (int i = 0; i < FieldIndex.Length; i++) {  			if (dis == "") {  				dis = pRow.get_Value (FieldIndex [i]).ToString ();  			} else {  				dis = dis + " " + (char)150 + " " + pRow.get_Value (FieldIndex [i]).ToString ();  			}  		}  		vals.Add (dis.Trim ());  	}  	pRow = null;  	return vals;  } catch {  	return null;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CursorToList,The following statement contains a magic number: while ((pRow = pCur.NextRow ()) != null) {  	string dis = "";  	for (int i = 0; i < FieldIndex.Length; i++) {  		if (dis == "") {  			dis = pRow.get_Value (FieldIndex [i]).ToString ();  		} else {  			dis = dis + " " + (char)150 + " " + pRow.get_Value (FieldIndex [i]).ToString ();  		}  	}  	vals.Add (dis.Trim ());  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CursorToList,The following statement contains a magic number: for (int i = 0; i < FieldIndex.Length; i++) {  	if (dis == "") {  		dis = pRow.get_Value (FieldIndex [i]).ToString ();  	} else {  		dis = dis + " " + (char)150 + " " + pRow.get_Value (FieldIndex [i]).ToString ();  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CursorToList,The following statement contains a magic number: if (dis == "") {  	dis = pRow.get_Value (FieldIndex [i]).ToString ();  } else {  	dis = dis + " " + (char)150 + " " + pRow.get_Value (FieldIndex [i]).ToString ();  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CursorToList,The following statement contains a magic number: dis = dis + " " + (char)150 + " " + pRow.get_Value (FieldIndex [i]).ToString ();  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetFlowDirectionAtLocation,The following statement contains a magic number: try {  	if (pFeature is INetworkFeature) {  		//                        INetworkFeature pNF = (INetworkFeature)newFeature;  		INetworkClass netClass = targetLineFLayer.FeatureClass as INetworkClass;  		IGeometricNetwork gn = netClass.GeometricNetwork;  		INetwork net = gn.Network;  		IEIDHelper pEIDHelperEdges;  		IEnumEIDInfo pEnumEIDInfoEdges;  		pEIDHelperEdges = new EIDHelper ();  		pEIDHelperEdges.GeometricNetwork = gn;  		pEIDHelperEdges.ReturnFeatures = true;  		pEIDHelperEdges.ReturnGeometries = true;  		pEIDHelperEdges.PartialComplexEdgeGeometry = true;  		IUtilityNetworkGEN unet = net as IUtilityNetworkGEN;  		INetElements netelems;  		netelems = unet as INetElements;  		enumNetEID = netelems.GetEIDs (targetLineFLayer.FeatureClass.ObjectClassID' pFeature.OID' esriElementType.esriETEdge);  		enumNetEID.Reset ();  		pEnumEIDInfoEdges = pEIDHelperEdges.CreateEnumEIDInfo (enumNetEID);  		pEnumEIDInfoEdges.Reset ();  		//edges  		//int edgeEID;  		IEIDInfo pEdgeInfo;  		//ISpatialFilter pSpatFil;  		//pSpatFil = new SpatialFilterClass();  		//pSpatFil.GeometryField = "SHAPE";  		//pSpatFil.SpatialRel = ESRI.ArcGIS.Geodatabase.esriSpatialRelEnum.esriSpatialRelIntersects;  		//pSpatFil.Geometry = pPnt;  		//ITopologicalOperator2 pTopo;//= new ITopologicalOperator2();  		//IPoint[] points = new IPoint[1];  		//points[0] = pPnt;  		//IPointCollection4 pointCollection = new MultipointClass();  		//IGeometryBridge geometryBride = new GeometryEnvironmentClass();  		//geometryBride.AddPoints(pointCollection' ref points);  		//ITopologicalOperator topoOp = pPnt as ITopologicalOperator;  		////if (dist == 0)  		////    dist = 500;  		////topoOp.Simplify();  		//IPolygon poly = topoOp.Buffer(toler) as IPolygon;  		//IRelationalOperator pRelOp = (IRelationalOperator)poly;  		//for (long j = 0; j < pEnumEIDInfoEdges.Count; j++)  		//{  		//    //   edgeEID = enumNetEID.Next();  		//    pEdgeInfo = pEnumEIDInfoEdges.Next();  		//    if (pRelOp.Touches(pEdgeInfo.Geometry))  		//        return unet.GetFlowDirection(pEdgeInfo.EID);  		//    //pTopo = pPnt  		//    //   pTopo.  		//    //  unet.SetFlowDirection(pEdgeInfo.EID' esriFlowDirection.esriFDWithFlow);  		//}  		int ClosestEID = -1;  		IProximityOperator proxOp = pPnt as IProximityOperator;  		double lastDistance' distance;  		// proxOp = (IProximityOperator)searchShape;  		lastDistance = 9999999999;  		for (long j = 0; j < pEnumEIDInfoEdges.Count; j++) {  			pEdgeInfo = pEnumEIDInfoEdges.Next ();  			//distance = proxOp.ReturnDistance(pEdgeInfo.Geometry);  			IGeometry pTempGeo = pEdgeInfo.Geometry;  			pTempGeo.Project (pPnt.SpatialReference);  			distance = proxOp.ReturnDistance (pTempGeo);  			pTempGeo = null;  			if (distance <= lastDistance) {  				ClosestEID = pEdgeInfo.EID;  				lastDistance = distance;  			}  		}  		if (ClosestEID == -1) {  			return ESRI.ArcGIS.Geodatabase.esriFlowDirection.esriFDUninitialized;  		} else {  			return unet.GetFlowDirection (ClosestEID);  		}  	} else {  		return ESRI.ArcGIS.Geodatabase.esriFlowDirection.esriFDAgainstFlow;  	}  } catch (Exception ex) {  	MessageBox.Show ("Error in the Global Functions - getFlowDirection" + Environment.NewLine + ex.ToString ());  	return ESRI.ArcGIS.Geodatabase.esriFlowDirection.esriFDUninitialized;  } finally {  	if (enumNetEID != null) {  		Marshal.ReleaseComObject (enumNetEID);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetFlowDirectionAtLocation,The following statement contains a magic number: if (pFeature is INetworkFeature) {  	//                        INetworkFeature pNF = (INetworkFeature)newFeature;  	INetworkClass netClass = targetLineFLayer.FeatureClass as INetworkClass;  	IGeometricNetwork gn = netClass.GeometricNetwork;  	INetwork net = gn.Network;  	IEIDHelper pEIDHelperEdges;  	IEnumEIDInfo pEnumEIDInfoEdges;  	pEIDHelperEdges = new EIDHelper ();  	pEIDHelperEdges.GeometricNetwork = gn;  	pEIDHelperEdges.ReturnFeatures = true;  	pEIDHelperEdges.ReturnGeometries = true;  	pEIDHelperEdges.PartialComplexEdgeGeometry = true;  	IUtilityNetworkGEN unet = net as IUtilityNetworkGEN;  	INetElements netelems;  	netelems = unet as INetElements;  	enumNetEID = netelems.GetEIDs (targetLineFLayer.FeatureClass.ObjectClassID' pFeature.OID' esriElementType.esriETEdge);  	enumNetEID.Reset ();  	pEnumEIDInfoEdges = pEIDHelperEdges.CreateEnumEIDInfo (enumNetEID);  	pEnumEIDInfoEdges.Reset ();  	//edges  	//int edgeEID;  	IEIDInfo pEdgeInfo;  	//ISpatialFilter pSpatFil;  	//pSpatFil = new SpatialFilterClass();  	//pSpatFil.GeometryField = "SHAPE";  	//pSpatFil.SpatialRel = ESRI.ArcGIS.Geodatabase.esriSpatialRelEnum.esriSpatialRelIntersects;  	//pSpatFil.Geometry = pPnt;  	//ITopologicalOperator2 pTopo;//= new ITopologicalOperator2();  	//IPoint[] points = new IPoint[1];  	//points[0] = pPnt;  	//IPointCollection4 pointCollection = new MultipointClass();  	//IGeometryBridge geometryBride = new GeometryEnvironmentClass();  	//geometryBride.AddPoints(pointCollection' ref points);  	//ITopologicalOperator topoOp = pPnt as ITopologicalOperator;  	////if (dist == 0)  	////    dist = 500;  	////topoOp.Simplify();  	//IPolygon poly = topoOp.Buffer(toler) as IPolygon;  	//IRelationalOperator pRelOp = (IRelationalOperator)poly;  	//for (long j = 0; j < pEnumEIDInfoEdges.Count; j++)  	//{  	//    //   edgeEID = enumNetEID.Next();  	//    pEdgeInfo = pEnumEIDInfoEdges.Next();  	//    if (pRelOp.Touches(pEdgeInfo.Geometry))  	//        return unet.GetFlowDirection(pEdgeInfo.EID);  	//    //pTopo = pPnt  	//    //   pTopo.  	//    //  unet.SetFlowDirection(pEdgeInfo.EID' esriFlowDirection.esriFDWithFlow);  	//}  	int ClosestEID = -1;  	IProximityOperator proxOp = pPnt as IProximityOperator;  	double lastDistance' distance;  	// proxOp = (IProximityOperator)searchShape;  	lastDistance = 9999999999;  	for (long j = 0; j < pEnumEIDInfoEdges.Count; j++) {  		pEdgeInfo = pEnumEIDInfoEdges.Next ();  		//distance = proxOp.ReturnDistance(pEdgeInfo.Geometry);  		IGeometry pTempGeo = pEdgeInfo.Geometry;  		pTempGeo.Project (pPnt.SpatialReference);  		distance = proxOp.ReturnDistance (pTempGeo);  		pTempGeo = null;  		if (distance <= lastDistance) {  			ClosestEID = pEdgeInfo.EID;  			lastDistance = distance;  		}  	}  	if (ClosestEID == -1) {  		return ESRI.ArcGIS.Geodatabase.esriFlowDirection.esriFDUninitialized;  	} else {  		return unet.GetFlowDirection (ClosestEID);  	}  } else {  	return ESRI.ArcGIS.Geodatabase.esriFlowDirection.esriFDAgainstFlow;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetFlowDirectionAtLocation,The following statement contains a magic number: lastDistance = 9999999999;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddTwoJunctionFlagsToTraceSolver,The following statement contains a magic number: try {  	if (netFlag1 is EdgeFlag && netFlag2 is EdgeFlag) {  		EdgeFlag1 = netFlag1 as IEdgeFlag;  		EdgeFlag2 = netFlag2 as IEdgeFlag;  		try {  			//Add the flag to the trace solver  			if (EdgeFlag1 != null && EdgeFlag2 != null) {  				EdgeFlags = new IEdgeFlag[2];  				EdgeFlags [0] = EdgeFlag1 as IEdgeFlag;  				EdgeFlags [1] = EdgeFlag2 as IEdgeFlag;  				traceFlowSolver.PutEdgeOrigins (ref EdgeFlags);  			}  		} catch {  		} finally {  			//if (EdgeFlags != null)  			//{  			//    //  Marshal.ReleaseComObject(EdgeFlags);  			//}  			//EdgeFlags = null;  			//if (EdgeFlag1 != null)  			//{  			//    Marshal.ReleaseComObject(EdgeFlag1);  			//}  			//EdgeFlag1 = null;  			//if (EdgeFlag2 != null)  			//{  			//    Marshal.ReleaseComObject(EdgeFlag2);  			//}  			//EdgeFlag2 = null;  		}  	} else if (netFlag1 is EdgeFlag && netFlag2 is JunctionFlag) {  		EdgeFlag1 = netFlag1 as IEdgeFlag;  		JunctionFlag2 = netFlag2 as IJunctionFlag;  		try {  			//Add the flag to the trace solver  			if (EdgeFlag1 != null) {  				EdgeFlags = new IEdgeFlag[1];  				EdgeFlags [0] = EdgeFlag1 as IEdgeFlag;  				traceFlowSolver.PutEdgeOrigins (ref EdgeFlags);  			}  			if (JunctionFlag2 != null) {  				JunctionFlags = new IJunctionFlag[1];  				JunctionFlags [0] = JunctionFlag2 as IJunctionFlag;  				traceFlowSolver.PutJunctionOrigins (ref JunctionFlags);  			}  		} catch {  		} finally {  			//if (EdgeFlags != null)  			//{  			//    //  Marshal.ReleaseComObject(EdgeFlags);  			//}  			//EdgeFlags = null;  			//if (EdgeFlag1 != null)  			//{  			//    Marshal.ReleaseComObject(EdgeFlag1);  			//}  			//EdgeFlag1 = null;  			//if (EdgeFlag2 != null)  			//{  			//    Marshal.ReleaseComObject(EdgeFlag2);  			//}  			//EdgeFlag2 = null;  			//if (JunctionFlags != null)  			//{  			//    //  Marshal.ReleaseComObject(junctionFlags);  			//}  			//JunctionFlags = null;  			//if (JunctionFlag1 != null)  			//{  			//    Marshal.ReleaseComObject(JunctionFlag1);  			//}  			//JunctionFlag1 = null;  			//if (JunctionFlag2 != null)  			//{  			//    Marshal.ReleaseComObject(JunctionFlag2);  			//}  			//JunctionFlag2 = null;  		}  	} else if (netFlag1 is JunctionFlag && netFlag2 is EdgeFlag) {  		EdgeFlag1 = netFlag2 as IEdgeFlag;  		JunctionFlag2 = netFlag1 as IJunctionFlag;  		try {  			//Add the flag to the trace solver  			if (EdgeFlag1 != null) {  				EdgeFlags = new IEdgeFlag[1];  				EdgeFlags [0] = EdgeFlag1 as IEdgeFlag;  				traceFlowSolver.PutEdgeOrigins (ref EdgeFlags);  			}  			if (JunctionFlag2 != null) {  				JunctionFlags = new IJunctionFlag[1];  				JunctionFlags [0] = JunctionFlag2 as IJunctionFlag;  				traceFlowSolver.PutJunctionOrigins (ref JunctionFlags);  			}  		} catch {  		} finally {  			//if (EdgeFlags != null)  			//{  			//    //  Marshal.ReleaseComObject(EdgeFlags);  			//}  			//EdgeFlags = null;  			//if (EdgeFlag1 != null)  			//{  			//    Marshal.ReleaseComObject(EdgeFlag1);  			//}  			//EdgeFlag1 = null;  			//if (EdgeFlag2 != null)  			//{  			//    Marshal.ReleaseComObject(EdgeFlag2);  			//}  			//EdgeFlag2 = null;  			//if (JunctionFlags != null)  			//{  			//    //  Marshal.ReleaseComObject(junctionFlags);  			//}  			//JunctionFlags = null;  			//if (JunctionFlag1 != null)  			//{  			//    Marshal.ReleaseComObject(JunctionFlag1);  			//}  			//JunctionFlag1 = null;  			//if (JunctionFlag2 != null)  			//{  			//    Marshal.ReleaseComObject(JunctionFlag2);  			//}  			//JunctionFlag2 = null;  		}  	} else {  		JunctionFlag1 = netFlag1 as IJunctionFlag;  		JunctionFlag2 = netFlag2 as IJunctionFlag;  		try {  			//Add the flag to the trace solver  			if (JunctionFlag1 != null && JunctionFlag2 != null) {  				JunctionFlags = new IJunctionFlag[2];  				JunctionFlags [0] = JunctionFlag1 as IJunctionFlag;  				JunctionFlags [1] = JunctionFlag2 as IJunctionFlag;  				traceFlowSolver.PutJunctionOrigins (ref JunctionFlags);  			}  		} catch {  		} finally {  			//if (JunctionFlags != null)  			//{  			//    //  Marshal.ReleaseComObject(junctionFlags);  			//}  			//JunctionFlags = null;  			//if (JunctionFlag1 != null)  			//{  			//    Marshal.ReleaseComObject(JunctionFlag1);  			//}  			//JunctionFlag1 = null;  			//if (JunctionFlag2 != null)  			//{  			//    Marshal.ReleaseComObject(JunctionFlag2);  			//}  			//JunctionFlag2 = null;  		}  	}  } catch {  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddTwoJunctionFlagsToTraceSolver,The following statement contains a magic number: try {  	if (netFlag1 is EdgeFlag && netFlag2 is EdgeFlag) {  		EdgeFlag1 = netFlag1 as IEdgeFlag;  		EdgeFlag2 = netFlag2 as IEdgeFlag;  		try {  			//Add the flag to the trace solver  			if (EdgeFlag1 != null && EdgeFlag2 != null) {  				EdgeFlags = new IEdgeFlag[2];  				EdgeFlags [0] = EdgeFlag1 as IEdgeFlag;  				EdgeFlags [1] = EdgeFlag2 as IEdgeFlag;  				traceFlowSolver.PutEdgeOrigins (ref EdgeFlags);  			}  		} catch {  		} finally {  			//if (EdgeFlags != null)  			//{  			//    //  Marshal.ReleaseComObject(EdgeFlags);  			//}  			//EdgeFlags = null;  			//if (EdgeFlag1 != null)  			//{  			//    Marshal.ReleaseComObject(EdgeFlag1);  			//}  			//EdgeFlag1 = null;  			//if (EdgeFlag2 != null)  			//{  			//    Marshal.ReleaseComObject(EdgeFlag2);  			//}  			//EdgeFlag2 = null;  		}  	} else if (netFlag1 is EdgeFlag && netFlag2 is JunctionFlag) {  		EdgeFlag1 = netFlag1 as IEdgeFlag;  		JunctionFlag2 = netFlag2 as IJunctionFlag;  		try {  			//Add the flag to the trace solver  			if (EdgeFlag1 != null) {  				EdgeFlags = new IEdgeFlag[1];  				EdgeFlags [0] = EdgeFlag1 as IEdgeFlag;  				traceFlowSolver.PutEdgeOrigins (ref EdgeFlags);  			}  			if (JunctionFlag2 != null) {  				JunctionFlags = new IJunctionFlag[1];  				JunctionFlags [0] = JunctionFlag2 as IJunctionFlag;  				traceFlowSolver.PutJunctionOrigins (ref JunctionFlags);  			}  		} catch {  		} finally {  			//if (EdgeFlags != null)  			//{  			//    //  Marshal.ReleaseComObject(EdgeFlags);  			//}  			//EdgeFlags = null;  			//if (EdgeFlag1 != null)  			//{  			//    Marshal.ReleaseComObject(EdgeFlag1);  			//}  			//EdgeFlag1 = null;  			//if (EdgeFlag2 != null)  			//{  			//    Marshal.ReleaseComObject(EdgeFlag2);  			//}  			//EdgeFlag2 = null;  			//if (JunctionFlags != null)  			//{  			//    //  Marshal.ReleaseComObject(junctionFlags);  			//}  			//JunctionFlags = null;  			//if (JunctionFlag1 != null)  			//{  			//    Marshal.ReleaseComObject(JunctionFlag1);  			//}  			//JunctionFlag1 = null;  			//if (JunctionFlag2 != null)  			//{  			//    Marshal.ReleaseComObject(JunctionFlag2);  			//}  			//JunctionFlag2 = null;  		}  	} else if (netFlag1 is JunctionFlag && netFlag2 is EdgeFlag) {  		EdgeFlag1 = netFlag2 as IEdgeFlag;  		JunctionFlag2 = netFlag1 as IJunctionFlag;  		try {  			//Add the flag to the trace solver  			if (EdgeFlag1 != null) {  				EdgeFlags = new IEdgeFlag[1];  				EdgeFlags [0] = EdgeFlag1 as IEdgeFlag;  				traceFlowSolver.PutEdgeOrigins (ref EdgeFlags);  			}  			if (JunctionFlag2 != null) {  				JunctionFlags = new IJunctionFlag[1];  				JunctionFlags [0] = JunctionFlag2 as IJunctionFlag;  				traceFlowSolver.PutJunctionOrigins (ref JunctionFlags);  			}  		} catch {  		} finally {  			//if (EdgeFlags != null)  			//{  			//    //  Marshal.ReleaseComObject(EdgeFlags);  			//}  			//EdgeFlags = null;  			//if (EdgeFlag1 != null)  			//{  			//    Marshal.ReleaseComObject(EdgeFlag1);  			//}  			//EdgeFlag1 = null;  			//if (EdgeFlag2 != null)  			//{  			//    Marshal.ReleaseComObject(EdgeFlag2);  			//}  			//EdgeFlag2 = null;  			//if (JunctionFlags != null)  			//{  			//    //  Marshal.ReleaseComObject(junctionFlags);  			//}  			//JunctionFlags = null;  			//if (JunctionFlag1 != null)  			//{  			//    Marshal.ReleaseComObject(JunctionFlag1);  			//}  			//JunctionFlag1 = null;  			//if (JunctionFlag2 != null)  			//{  			//    Marshal.ReleaseComObject(JunctionFlag2);  			//}  			//JunctionFlag2 = null;  		}  	} else {  		JunctionFlag1 = netFlag1 as IJunctionFlag;  		JunctionFlag2 = netFlag2 as IJunctionFlag;  		try {  			//Add the flag to the trace solver  			if (JunctionFlag1 != null && JunctionFlag2 != null) {  				JunctionFlags = new IJunctionFlag[2];  				JunctionFlags [0] = JunctionFlag1 as IJunctionFlag;  				JunctionFlags [1] = JunctionFlag2 as IJunctionFlag;  				traceFlowSolver.PutJunctionOrigins (ref JunctionFlags);  			}  		} catch {  		} finally {  			//if (JunctionFlags != null)  			//{  			//    //  Marshal.ReleaseComObject(junctionFlags);  			//}  			//JunctionFlags = null;  			//if (JunctionFlag1 != null)  			//{  			//    Marshal.ReleaseComObject(JunctionFlag1);  			//}  			//JunctionFlag1 = null;  			//if (JunctionFlag2 != null)  			//{  			//    Marshal.ReleaseComObject(JunctionFlag2);  			//}  			//JunctionFlag2 = null;  		}  	}  } catch {  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddTwoJunctionFlagsToTraceSolver,The following statement contains a magic number: if (netFlag1 is EdgeFlag && netFlag2 is EdgeFlag) {  	EdgeFlag1 = netFlag1 as IEdgeFlag;  	EdgeFlag2 = netFlag2 as IEdgeFlag;  	try {  		//Add the flag to the trace solver  		if (EdgeFlag1 != null && EdgeFlag2 != null) {  			EdgeFlags = new IEdgeFlag[2];  			EdgeFlags [0] = EdgeFlag1 as IEdgeFlag;  			EdgeFlags [1] = EdgeFlag2 as IEdgeFlag;  			traceFlowSolver.PutEdgeOrigins (ref EdgeFlags);  		}  	} catch {  	} finally {  		//if (EdgeFlags != null)  		//{  		//    //  Marshal.ReleaseComObject(EdgeFlags);  		//}  		//EdgeFlags = null;  		//if (EdgeFlag1 != null)  		//{  		//    Marshal.ReleaseComObject(EdgeFlag1);  		//}  		//EdgeFlag1 = null;  		//if (EdgeFlag2 != null)  		//{  		//    Marshal.ReleaseComObject(EdgeFlag2);  		//}  		//EdgeFlag2 = null;  	}  } else if (netFlag1 is EdgeFlag && netFlag2 is JunctionFlag) {  	EdgeFlag1 = netFlag1 as IEdgeFlag;  	JunctionFlag2 = netFlag2 as IJunctionFlag;  	try {  		//Add the flag to the trace solver  		if (EdgeFlag1 != null) {  			EdgeFlags = new IEdgeFlag[1];  			EdgeFlags [0] = EdgeFlag1 as IEdgeFlag;  			traceFlowSolver.PutEdgeOrigins (ref EdgeFlags);  		}  		if (JunctionFlag2 != null) {  			JunctionFlags = new IJunctionFlag[1];  			JunctionFlags [0] = JunctionFlag2 as IJunctionFlag;  			traceFlowSolver.PutJunctionOrigins (ref JunctionFlags);  		}  	} catch {  	} finally {  		//if (EdgeFlags != null)  		//{  		//    //  Marshal.ReleaseComObject(EdgeFlags);  		//}  		//EdgeFlags = null;  		//if (EdgeFlag1 != null)  		//{  		//    Marshal.ReleaseComObject(EdgeFlag1);  		//}  		//EdgeFlag1 = null;  		//if (EdgeFlag2 != null)  		//{  		//    Marshal.ReleaseComObject(EdgeFlag2);  		//}  		//EdgeFlag2 = null;  		//if (JunctionFlags != null)  		//{  		//    //  Marshal.ReleaseComObject(junctionFlags);  		//}  		//JunctionFlags = null;  		//if (JunctionFlag1 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag1);  		//}  		//JunctionFlag1 = null;  		//if (JunctionFlag2 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag2);  		//}  		//JunctionFlag2 = null;  	}  } else if (netFlag1 is JunctionFlag && netFlag2 is EdgeFlag) {  	EdgeFlag1 = netFlag2 as IEdgeFlag;  	JunctionFlag2 = netFlag1 as IJunctionFlag;  	try {  		//Add the flag to the trace solver  		if (EdgeFlag1 != null) {  			EdgeFlags = new IEdgeFlag[1];  			EdgeFlags [0] = EdgeFlag1 as IEdgeFlag;  			traceFlowSolver.PutEdgeOrigins (ref EdgeFlags);  		}  		if (JunctionFlag2 != null) {  			JunctionFlags = new IJunctionFlag[1];  			JunctionFlags [0] = JunctionFlag2 as IJunctionFlag;  			traceFlowSolver.PutJunctionOrigins (ref JunctionFlags);  		}  	} catch {  	} finally {  		//if (EdgeFlags != null)  		//{  		//    //  Marshal.ReleaseComObject(EdgeFlags);  		//}  		//EdgeFlags = null;  		//if (EdgeFlag1 != null)  		//{  		//    Marshal.ReleaseComObject(EdgeFlag1);  		//}  		//EdgeFlag1 = null;  		//if (EdgeFlag2 != null)  		//{  		//    Marshal.ReleaseComObject(EdgeFlag2);  		//}  		//EdgeFlag2 = null;  		//if (JunctionFlags != null)  		//{  		//    //  Marshal.ReleaseComObject(junctionFlags);  		//}  		//JunctionFlags = null;  		//if (JunctionFlag1 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag1);  		//}  		//JunctionFlag1 = null;  		//if (JunctionFlag2 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag2);  		//}  		//JunctionFlag2 = null;  	}  } else {  	JunctionFlag1 = netFlag1 as IJunctionFlag;  	JunctionFlag2 = netFlag2 as IJunctionFlag;  	try {  		//Add the flag to the trace solver  		if (JunctionFlag1 != null && JunctionFlag2 != null) {  			JunctionFlags = new IJunctionFlag[2];  			JunctionFlags [0] = JunctionFlag1 as IJunctionFlag;  			JunctionFlags [1] = JunctionFlag2 as IJunctionFlag;  			traceFlowSolver.PutJunctionOrigins (ref JunctionFlags);  		}  	} catch {  	} finally {  		//if (JunctionFlags != null)  		//{  		//    //  Marshal.ReleaseComObject(junctionFlags);  		//}  		//JunctionFlags = null;  		//if (JunctionFlag1 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag1);  		//}  		//JunctionFlag1 = null;  		//if (JunctionFlag2 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag2);  		//}  		//JunctionFlag2 = null;  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddTwoJunctionFlagsToTraceSolver,The following statement contains a magic number: if (netFlag1 is EdgeFlag && netFlag2 is EdgeFlag) {  	EdgeFlag1 = netFlag1 as IEdgeFlag;  	EdgeFlag2 = netFlag2 as IEdgeFlag;  	try {  		//Add the flag to the trace solver  		if (EdgeFlag1 != null && EdgeFlag2 != null) {  			EdgeFlags = new IEdgeFlag[2];  			EdgeFlags [0] = EdgeFlag1 as IEdgeFlag;  			EdgeFlags [1] = EdgeFlag2 as IEdgeFlag;  			traceFlowSolver.PutEdgeOrigins (ref EdgeFlags);  		}  	} catch {  	} finally {  		//if (EdgeFlags != null)  		//{  		//    //  Marshal.ReleaseComObject(EdgeFlags);  		//}  		//EdgeFlags = null;  		//if (EdgeFlag1 != null)  		//{  		//    Marshal.ReleaseComObject(EdgeFlag1);  		//}  		//EdgeFlag1 = null;  		//if (EdgeFlag2 != null)  		//{  		//    Marshal.ReleaseComObject(EdgeFlag2);  		//}  		//EdgeFlag2 = null;  	}  } else if (netFlag1 is EdgeFlag && netFlag2 is JunctionFlag) {  	EdgeFlag1 = netFlag1 as IEdgeFlag;  	JunctionFlag2 = netFlag2 as IJunctionFlag;  	try {  		//Add the flag to the trace solver  		if (EdgeFlag1 != null) {  			EdgeFlags = new IEdgeFlag[1];  			EdgeFlags [0] = EdgeFlag1 as IEdgeFlag;  			traceFlowSolver.PutEdgeOrigins (ref EdgeFlags);  		}  		if (JunctionFlag2 != null) {  			JunctionFlags = new IJunctionFlag[1];  			JunctionFlags [0] = JunctionFlag2 as IJunctionFlag;  			traceFlowSolver.PutJunctionOrigins (ref JunctionFlags);  		}  	} catch {  	} finally {  		//if (EdgeFlags != null)  		//{  		//    //  Marshal.ReleaseComObject(EdgeFlags);  		//}  		//EdgeFlags = null;  		//if (EdgeFlag1 != null)  		//{  		//    Marshal.ReleaseComObject(EdgeFlag1);  		//}  		//EdgeFlag1 = null;  		//if (EdgeFlag2 != null)  		//{  		//    Marshal.ReleaseComObject(EdgeFlag2);  		//}  		//EdgeFlag2 = null;  		//if (JunctionFlags != null)  		//{  		//    //  Marshal.ReleaseComObject(junctionFlags);  		//}  		//JunctionFlags = null;  		//if (JunctionFlag1 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag1);  		//}  		//JunctionFlag1 = null;  		//if (JunctionFlag2 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag2);  		//}  		//JunctionFlag2 = null;  	}  } else if (netFlag1 is JunctionFlag && netFlag2 is EdgeFlag) {  	EdgeFlag1 = netFlag2 as IEdgeFlag;  	JunctionFlag2 = netFlag1 as IJunctionFlag;  	try {  		//Add the flag to the trace solver  		if (EdgeFlag1 != null) {  			EdgeFlags = new IEdgeFlag[1];  			EdgeFlags [0] = EdgeFlag1 as IEdgeFlag;  			traceFlowSolver.PutEdgeOrigins (ref EdgeFlags);  		}  		if (JunctionFlag2 != null) {  			JunctionFlags = new IJunctionFlag[1];  			JunctionFlags [0] = JunctionFlag2 as IJunctionFlag;  			traceFlowSolver.PutJunctionOrigins (ref JunctionFlags);  		}  	} catch {  	} finally {  		//if (EdgeFlags != null)  		//{  		//    //  Marshal.ReleaseComObject(EdgeFlags);  		//}  		//EdgeFlags = null;  		//if (EdgeFlag1 != null)  		//{  		//    Marshal.ReleaseComObject(EdgeFlag1);  		//}  		//EdgeFlag1 = null;  		//if (EdgeFlag2 != null)  		//{  		//    Marshal.ReleaseComObject(EdgeFlag2);  		//}  		//EdgeFlag2 = null;  		//if (JunctionFlags != null)  		//{  		//    //  Marshal.ReleaseComObject(junctionFlags);  		//}  		//JunctionFlags = null;  		//if (JunctionFlag1 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag1);  		//}  		//JunctionFlag1 = null;  		//if (JunctionFlag2 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag2);  		//}  		//JunctionFlag2 = null;  	}  } else {  	JunctionFlag1 = netFlag1 as IJunctionFlag;  	JunctionFlag2 = netFlag2 as IJunctionFlag;  	try {  		//Add the flag to the trace solver  		if (JunctionFlag1 != null && JunctionFlag2 != null) {  			JunctionFlags = new IJunctionFlag[2];  			JunctionFlags [0] = JunctionFlag1 as IJunctionFlag;  			JunctionFlags [1] = JunctionFlag2 as IJunctionFlag;  			traceFlowSolver.PutJunctionOrigins (ref JunctionFlags);  		}  	} catch {  	} finally {  		//if (JunctionFlags != null)  		//{  		//    //  Marshal.ReleaseComObject(junctionFlags);  		//}  		//JunctionFlags = null;  		//if (JunctionFlag1 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag1);  		//}  		//JunctionFlag1 = null;  		//if (JunctionFlag2 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag2);  		//}  		//JunctionFlag2 = null;  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddTwoJunctionFlagsToTraceSolver,The following statement contains a magic number: try {  	//Add the flag to the trace solver  	if (EdgeFlag1 != null && EdgeFlag2 != null) {  		EdgeFlags = new IEdgeFlag[2];  		EdgeFlags [0] = EdgeFlag1 as IEdgeFlag;  		EdgeFlags [1] = EdgeFlag2 as IEdgeFlag;  		traceFlowSolver.PutEdgeOrigins (ref EdgeFlags);  	}  } catch {  } finally {  	//if (EdgeFlags != null)  	//{  	//    //  Marshal.ReleaseComObject(EdgeFlags);  	//}  	//EdgeFlags = null;  	//if (EdgeFlag1 != null)  	//{  	//    Marshal.ReleaseComObject(EdgeFlag1);  	//}  	//EdgeFlag1 = null;  	//if (EdgeFlag2 != null)  	//{  	//    Marshal.ReleaseComObject(EdgeFlag2);  	//}  	//EdgeFlag2 = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddTwoJunctionFlagsToTraceSolver,The following statement contains a magic number: if (EdgeFlag1 != null && EdgeFlag2 != null) {  	EdgeFlags = new IEdgeFlag[2];  	EdgeFlags [0] = EdgeFlag1 as IEdgeFlag;  	EdgeFlags [1] = EdgeFlag2 as IEdgeFlag;  	traceFlowSolver.PutEdgeOrigins (ref EdgeFlags);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddTwoJunctionFlagsToTraceSolver,The following statement contains a magic number: EdgeFlags = new IEdgeFlag[2];  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddTwoJunctionFlagsToTraceSolver,The following statement contains a magic number: if (netFlag1 is EdgeFlag && netFlag2 is JunctionFlag) {  	EdgeFlag1 = netFlag1 as IEdgeFlag;  	JunctionFlag2 = netFlag2 as IJunctionFlag;  	try {  		//Add the flag to the trace solver  		if (EdgeFlag1 != null) {  			EdgeFlags = new IEdgeFlag[1];  			EdgeFlags [0] = EdgeFlag1 as IEdgeFlag;  			traceFlowSolver.PutEdgeOrigins (ref EdgeFlags);  		}  		if (JunctionFlag2 != null) {  			JunctionFlags = new IJunctionFlag[1];  			JunctionFlags [0] = JunctionFlag2 as IJunctionFlag;  			traceFlowSolver.PutJunctionOrigins (ref JunctionFlags);  		}  	} catch {  	} finally {  		//if (EdgeFlags != null)  		//{  		//    //  Marshal.ReleaseComObject(EdgeFlags);  		//}  		//EdgeFlags = null;  		//if (EdgeFlag1 != null)  		//{  		//    Marshal.ReleaseComObject(EdgeFlag1);  		//}  		//EdgeFlag1 = null;  		//if (EdgeFlag2 != null)  		//{  		//    Marshal.ReleaseComObject(EdgeFlag2);  		//}  		//EdgeFlag2 = null;  		//if (JunctionFlags != null)  		//{  		//    //  Marshal.ReleaseComObject(junctionFlags);  		//}  		//JunctionFlags = null;  		//if (JunctionFlag1 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag1);  		//}  		//JunctionFlag1 = null;  		//if (JunctionFlag2 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag2);  		//}  		//JunctionFlag2 = null;  	}  } else if (netFlag1 is JunctionFlag && netFlag2 is EdgeFlag) {  	EdgeFlag1 = netFlag2 as IEdgeFlag;  	JunctionFlag2 = netFlag1 as IJunctionFlag;  	try {  		//Add the flag to the trace solver  		if (EdgeFlag1 != null) {  			EdgeFlags = new IEdgeFlag[1];  			EdgeFlags [0] = EdgeFlag1 as IEdgeFlag;  			traceFlowSolver.PutEdgeOrigins (ref EdgeFlags);  		}  		if (JunctionFlag2 != null) {  			JunctionFlags = new IJunctionFlag[1];  			JunctionFlags [0] = JunctionFlag2 as IJunctionFlag;  			traceFlowSolver.PutJunctionOrigins (ref JunctionFlags);  		}  	} catch {  	} finally {  		//if (EdgeFlags != null)  		//{  		//    //  Marshal.ReleaseComObject(EdgeFlags);  		//}  		//EdgeFlags = null;  		//if (EdgeFlag1 != null)  		//{  		//    Marshal.ReleaseComObject(EdgeFlag1);  		//}  		//EdgeFlag1 = null;  		//if (EdgeFlag2 != null)  		//{  		//    Marshal.ReleaseComObject(EdgeFlag2);  		//}  		//EdgeFlag2 = null;  		//if (JunctionFlags != null)  		//{  		//    //  Marshal.ReleaseComObject(junctionFlags);  		//}  		//JunctionFlags = null;  		//if (JunctionFlag1 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag1);  		//}  		//JunctionFlag1 = null;  		//if (JunctionFlag2 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag2);  		//}  		//JunctionFlag2 = null;  	}  } else {  	JunctionFlag1 = netFlag1 as IJunctionFlag;  	JunctionFlag2 = netFlag2 as IJunctionFlag;  	try {  		//Add the flag to the trace solver  		if (JunctionFlag1 != null && JunctionFlag2 != null) {  			JunctionFlags = new IJunctionFlag[2];  			JunctionFlags [0] = JunctionFlag1 as IJunctionFlag;  			JunctionFlags [1] = JunctionFlag2 as IJunctionFlag;  			traceFlowSolver.PutJunctionOrigins (ref JunctionFlags);  		}  	} catch {  	} finally {  		//if (JunctionFlags != null)  		//{  		//    //  Marshal.ReleaseComObject(junctionFlags);  		//}  		//JunctionFlags = null;  		//if (JunctionFlag1 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag1);  		//}  		//JunctionFlag1 = null;  		//if (JunctionFlag2 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag2);  		//}  		//JunctionFlag2 = null;  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddTwoJunctionFlagsToTraceSolver,The following statement contains a magic number: if (netFlag1 is JunctionFlag && netFlag2 is EdgeFlag) {  	EdgeFlag1 = netFlag2 as IEdgeFlag;  	JunctionFlag2 = netFlag1 as IJunctionFlag;  	try {  		//Add the flag to the trace solver  		if (EdgeFlag1 != null) {  			EdgeFlags = new IEdgeFlag[1];  			EdgeFlags [0] = EdgeFlag1 as IEdgeFlag;  			traceFlowSolver.PutEdgeOrigins (ref EdgeFlags);  		}  		if (JunctionFlag2 != null) {  			JunctionFlags = new IJunctionFlag[1];  			JunctionFlags [0] = JunctionFlag2 as IJunctionFlag;  			traceFlowSolver.PutJunctionOrigins (ref JunctionFlags);  		}  	} catch {  	} finally {  		//if (EdgeFlags != null)  		//{  		//    //  Marshal.ReleaseComObject(EdgeFlags);  		//}  		//EdgeFlags = null;  		//if (EdgeFlag1 != null)  		//{  		//    Marshal.ReleaseComObject(EdgeFlag1);  		//}  		//EdgeFlag1 = null;  		//if (EdgeFlag2 != null)  		//{  		//    Marshal.ReleaseComObject(EdgeFlag2);  		//}  		//EdgeFlag2 = null;  		//if (JunctionFlags != null)  		//{  		//    //  Marshal.ReleaseComObject(junctionFlags);  		//}  		//JunctionFlags = null;  		//if (JunctionFlag1 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag1);  		//}  		//JunctionFlag1 = null;  		//if (JunctionFlag2 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag2);  		//}  		//JunctionFlag2 = null;  	}  } else {  	JunctionFlag1 = netFlag1 as IJunctionFlag;  	JunctionFlag2 = netFlag2 as IJunctionFlag;  	try {  		//Add the flag to the trace solver  		if (JunctionFlag1 != null && JunctionFlag2 != null) {  			JunctionFlags = new IJunctionFlag[2];  			JunctionFlags [0] = JunctionFlag1 as IJunctionFlag;  			JunctionFlags [1] = JunctionFlag2 as IJunctionFlag;  			traceFlowSolver.PutJunctionOrigins (ref JunctionFlags);  		}  	} catch {  	} finally {  		//if (JunctionFlags != null)  		//{  		//    //  Marshal.ReleaseComObject(junctionFlags);  		//}  		//JunctionFlags = null;  		//if (JunctionFlag1 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag1);  		//}  		//JunctionFlag1 = null;  		//if (JunctionFlag2 != null)  		//{  		//    Marshal.ReleaseComObject(JunctionFlag2);  		//}  		//JunctionFlag2 = null;  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddTwoJunctionFlagsToTraceSolver,The following statement contains a magic number: try {  	//Add the flag to the trace solver  	if (JunctionFlag1 != null && JunctionFlag2 != null) {  		JunctionFlags = new IJunctionFlag[2];  		JunctionFlags [0] = JunctionFlag1 as IJunctionFlag;  		JunctionFlags [1] = JunctionFlag2 as IJunctionFlag;  		traceFlowSolver.PutJunctionOrigins (ref JunctionFlags);  	}  } catch {  } finally {  	//if (JunctionFlags != null)  	//{  	//    //  Marshal.ReleaseComObject(junctionFlags);  	//}  	//JunctionFlags = null;  	//if (JunctionFlag1 != null)  	//{  	//    Marshal.ReleaseComObject(JunctionFlag1);  	//}  	//JunctionFlag1 = null;  	//if (JunctionFlag2 != null)  	//{  	//    Marshal.ReleaseComObject(JunctionFlag2);  	//}  	//JunctionFlag2 = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddTwoJunctionFlagsToTraceSolver,The following statement contains a magic number: if (JunctionFlag1 != null && JunctionFlag2 != null) {  	JunctionFlags = new IJunctionFlag[2];  	JunctionFlags [0] = JunctionFlag1 as IJunctionFlag;  	JunctionFlags [1] = JunctionFlag2 as IJunctionFlag;  	traceFlowSolver.PutJunctionOrigins (ref JunctionFlags);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddTwoJunctionFlagsToTraceSolver,The following statement contains a magic number: JunctionFlags = new IJunctionFlag[2];  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetEIDInfoListByFC,The following statement contains a magic number: try {  	allEnumEidInfo = eidHelper.CreateEnumEIDInfo (juncEIDs);  	IEIDInfo testEidInfo = allEnumEidInfo.Next ();  	while (testEidInfo != null) {  		if (testEidInfo.Feature.Class.ObjectClassID == featureClassId) {  			outputEIDInfoHT.Add (testEidInfo.Feature.OID' testEidInfo);  		}  		testEidInfo = allEnumEidInfo.Next ();  	}  	return outputEIDInfoHT;  } catch (Exception ex) {  	return outputEIDInfoHT;  } finally {  	if (allEnumEidInfo != null) {  		Marshal.ReleaseComObject (allEnumEidInfo);  	}  	allEnumEidInfo = null;  	GC.Collect ();  	GC.WaitForFullGCComplete (300);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetEIDInfoListByFC,The following statement contains a magic number: GC.WaitForFullGCComplete (300);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetFeatureOIDList,The following statement contains a magic number: try {  	sourceEnumEidInfo = eidHelper.CreateEnumEIDInfo (juncEIDs);  	IEIDInfo eidInfo = sourceEnumEidInfo.Next ();  	while (eidInfo != null) {  		if (eidInfo.Feature.Class.ObjectClassID == featureClassId) {  			sourceFeatureArrayList.Add (eidInfo.Feature.OID);  		}  		eidInfo = sourceEnumEidInfo.Next ();  	}  	return sourceFeatureArrayList;  } catch (Exception ex) {  	return sourceFeatureArrayList;  } finally {  	if (sourceEnumEidInfo != null) {  		Marshal.ReleaseComObject (sourceEnumEidInfo);  	}  	sourceEnumEidInfo = null;  	GC.Collect ();  	GC.WaitForFullGCComplete (300);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetFeatureOIDList,The following statement contains a magic number: GC.WaitForFullGCComplete (300);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,DrawEdges,The following statement contains a magic number: try {  	env = new EnvelopeClass ();  	av = (IActiveView)map;  	graphics = (IGraphicsContainer)map;  	symb = new SimpleLineSymbolClass ();  	lineColors = ConfigUtil.GetConfigValue ("traceResultsLineColor"' "255'0'0");  	string[] strColors = lineColors.Split (''');  	symb.Color = GetColor (Convert.ToInt32 (strColors [0])' Convert.ToInt32 (strColors [1])' Convert.ToInt32 (strColors [2]));  	symb.Width = 2;  	eidHelper = new EIDHelperClass ();  	eidHelper.GeometricNetwork = gn;  	eidHelper.OutputSpatialReference = map.SpatialReference;  	eidHelper.ReturnFeatures = true;  	eidHelper.ReturnGeometries = true;  	eidHelper.PartialComplexEdgeGeometry = true;  	enumEidInfo = eidHelper.CreateEnumEIDInfo (edgeEIDs);  	enumEidInfo.Reset ();  	eidInfo = enumEidInfo.Next ();  	while (eidInfo != null) {  		geom = eidInfo.Geometry;  		if (geom != null) {  			//geom = eidInfo.Feature.ShapeCopy;  			env.Union (geom.Envelope);  			elem = new LineElementClass ();  			elem.Geometry = geom;  			lineElem = (ILineElement)elem;  			lineElem.Symbol = symb;  			elemProp = (IElementProperties)elem;  			elemProp.Name = "TraceResults";  			graphics.AddElement (elem' 0);  		}  		eidInfo = enumEidInfo.Next ();  	}  	env.Expand (1.1' 1.1' true);  	return env;  } catch {  	return null;  } finally {  	env = null;  	av = null;  	graphics = null;  	symb = null;  	lineElem = null;  	eidHelper = null;  	enumEidInfo = null;  	eidInfo = null;  	geom = null;  	elem = null;  	elemProp = null;  	relOp = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,DrawEdges,The following statement contains a magic number: try {  	env = new EnvelopeClass ();  	av = (IActiveView)map;  	graphics = (IGraphicsContainer)map;  	symb = new SimpleLineSymbolClass ();  	lineColors = ConfigUtil.GetConfigValue ("traceResultsLineColor"' "255'0'0");  	string[] strColors = lineColors.Split (''');  	symb.Color = GetColor (Convert.ToInt32 (strColors [0])' Convert.ToInt32 (strColors [1])' Convert.ToInt32 (strColors [2]));  	symb.Width = 2;  	eidHelper = new EIDHelperClass ();  	eidHelper.GeometricNetwork = gn;  	eidHelper.OutputSpatialReference = map.SpatialReference;  	eidHelper.ReturnFeatures = true;  	eidHelper.ReturnGeometries = true;  	eidHelper.PartialComplexEdgeGeometry = true;  	enumEidInfo = eidHelper.CreateEnumEIDInfo (edgeEIDs);  	enumEidInfo.Reset ();  	eidInfo = enumEidInfo.Next ();  	while (eidInfo != null) {  		geom = eidInfo.Geometry;  		if (geom != null) {  			//geom = eidInfo.Feature.ShapeCopy;  			env.Union (geom.Envelope);  			elem = new LineElementClass ();  			elem.Geometry = geom;  			lineElem = (ILineElement)elem;  			lineElem.Symbol = symb;  			elemProp = (IElementProperties)elem;  			elemProp.Name = "TraceResults";  			graphics.AddElement (elem' 0);  		}  		eidInfo = enumEidInfo.Next ();  	}  	env.Expand (1.1' 1.1' true);  	return env;  } catch {  	return null;  } finally {  	env = null;  	av = null;  	graphics = null;  	symb = null;  	lineElem = null;  	eidHelper = null;  	enumEidInfo = null;  	eidInfo = null;  	geom = null;  	elem = null;  	elemProp = null;  	relOp = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,DrawEdges,The following statement contains a magic number: try {  	env = new EnvelopeClass ();  	av = (IActiveView)map;  	graphics = (IGraphicsContainer)map;  	symb = new SimpleLineSymbolClass ();  	lineColors = ConfigUtil.GetConfigValue ("traceResultsLineColor"' "255'0'0");  	string[] strColors = lineColors.Split (''');  	symb.Color = GetColor (Convert.ToInt32 (strColors [0])' Convert.ToInt32 (strColors [1])' Convert.ToInt32 (strColors [2]));  	symb.Width = 2;  	eidHelper = new EIDHelperClass ();  	eidHelper.GeometricNetwork = gn;  	eidHelper.OutputSpatialReference = map.SpatialReference;  	eidHelper.ReturnFeatures = true;  	eidHelper.ReturnGeometries = true;  	eidHelper.PartialComplexEdgeGeometry = true;  	enumEidInfo = eidHelper.CreateEnumEIDInfo (edgeEIDs);  	enumEidInfo.Reset ();  	eidInfo = enumEidInfo.Next ();  	while (eidInfo != null) {  		geom = eidInfo.Geometry;  		if (geom != null) {  			//geom = eidInfo.Feature.ShapeCopy;  			env.Union (geom.Envelope);  			elem = new LineElementClass ();  			elem.Geometry = geom;  			lineElem = (ILineElement)elem;  			lineElem.Symbol = symb;  			elemProp = (IElementProperties)elem;  			elemProp.Name = "TraceResults";  			graphics.AddElement (elem' 0);  		}  		eidInfo = enumEidInfo.Next ();  	}  	env.Expand (1.1' 1.1' true);  	return env;  } catch {  	return null;  } finally {  	env = null;  	av = null;  	graphics = null;  	symb = null;  	lineElem = null;  	eidHelper = null;  	enumEidInfo = null;  	eidInfo = null;  	geom = null;  	elem = null;  	elemProp = null;  	relOp = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,DrawEdges,The following statement contains a magic number: try {  	env = new EnvelopeClass ();  	av = (IActiveView)map;  	graphics = (IGraphicsContainer)map;  	symb = new SimpleLineSymbolClass ();  	lineColors = ConfigUtil.GetConfigValue ("traceResultsLineColor"' "255'0'0");  	string[] strColors = lineColors.Split (''');  	symb.Color = GetColor (Convert.ToInt32 (strColors [0])' Convert.ToInt32 (strColors [1])' Convert.ToInt32 (strColors [2]));  	symb.Width = 2;  	eidHelper = new EIDHelperClass ();  	eidHelper.GeometricNetwork = gn;  	eidHelper.OutputSpatialReference = map.SpatialReference;  	eidHelper.ReturnFeatures = true;  	eidHelper.ReturnGeometries = true;  	eidHelper.PartialComplexEdgeGeometry = true;  	enumEidInfo = eidHelper.CreateEnumEIDInfo (edgeEIDs);  	enumEidInfo.Reset ();  	eidInfo = enumEidInfo.Next ();  	while (eidInfo != null) {  		geom = eidInfo.Geometry;  		if (geom != null) {  			//geom = eidInfo.Feature.ShapeCopy;  			env.Union (geom.Envelope);  			elem = new LineElementClass ();  			elem.Geometry = geom;  			lineElem = (ILineElement)elem;  			lineElem.Symbol = symb;  			elemProp = (IElementProperties)elem;  			elemProp.Name = "TraceResults";  			graphics.AddElement (elem' 0);  		}  		eidInfo = enumEidInfo.Next ();  	}  	env.Expand (1.1' 1.1' true);  	return env;  } catch {  	return null;  } finally {  	env = null;  	av = null;  	graphics = null;  	symb = null;  	lineElem = null;  	eidHelper = null;  	enumEidInfo = null;  	eidInfo = null;  	geom = null;  	elem = null;  	elemProp = null;  	relOp = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,DrawEdges,The following statement contains a magic number: symb.Color = GetColor (Convert.ToInt32 (strColors [0])' Convert.ToInt32 (strColors [1])' Convert.ToInt32 (strColors [2]));  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,DrawEdges,The following statement contains a magic number: symb.Width = 2;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,DrawEdges,The following statement contains a magic number: env.Expand (1.1' 1.1' true);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,DrawEdges,The following statement contains a magic number: env.Expand (1.1' 1.1' true);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,The following statement contains a magic number: try {  	try {  		if (geo.GeometryType == esriGeometryType.esriGeometryPolyline) {  			if (((IPolyline)geo).IsEmpty == true) {  				return null;  			} else if (((IPolyline)geo).Length < (GetXYTolerance (geo) * 2)) {  				return null;  			}  		} else if (geo.GeometryType == esriGeometryType.esriGeometryPolygon) {  			if (((IPolygon)geo).IsEmpty == true) {  				return null;  			} else {  				IArea area = (IArea)geo;  				if (area.Area == 0) {  					return null;  				}  			}  		} else if (geo.GeometryType == esriGeometryType.esriGeometryPoint) {  			if (((IPoint)geo).IsEmpty == true) {  				return null;  			}  		}  	} catch {  	}  	if (pEditTemplate == null) {  		MessageBox.Show ("Please select an edit template to continue");  		return null;  	}  	pfeatureLayer = pEditTemplate.Layer as IFeatureLayer;  	pfeatureClass = pfeatureLayer.FeatureClass;  	if (checkForExisting) {  		pSpatFilt = new SpatialFilterClass ();  		pSpatFilt.Geometry = geo;  		pSpatFilt.GeometryField = pfeatureLayer.FeatureClass.ShapeFieldName;  		pSpatFilt.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;  		if (pfeatureClass.FeatureCount (pSpatFilt) > 0) {  			return null;  		}  	}  	//create point for the current template  	feature = pfeatureClass.CreateFeature ();  	//if (pfeatureClass.ShapeType == esriGeometryType.esriGeometryPolyline)  	//{  	//    IGeometryDef pGeometryDefTest;  	//    string sShpName = pfeatureClass.ShapeFieldName;  	//    IFields pFieldsTest = pfeatureClass.Fields;  	//    int lGeomIndex = pFieldsTest.FindField(sShpName);  	//    IField pFieldTest = pFieldsTest.get_Field(lGeomIndex);  	//    pGeometryDefTest = pFieldTest.GeometryDef;  	//    bool bZAware;  	//    bool bMAware;  	//    //Determine if M or Z aware  	//    bZAware = pGeometryDefTest.HasZ;  	//    bMAware = pGeometryDefTest.HasM;  	//    if (bZAware)  	//    {  	//        // IGeometry pGeo = new PolylineClass();  	//        IZAware pZAware = geo as IZAware;  	//        if (pZAware.ZAware)  	//        {  	//        }  	//        else  	//        {  	//            pZAware.ZAware = true;  	//            //pZAware.DropZs();  	//        }  	//        // pZAware.DropZs();  	//        IZ pZ = geo as IZ;  	//        pZ.SetConstantZ(0);  	//    }  	//    if (bMAware)  	//    {  	//    }  	//    IGeoDataset pDS = pfeatureClass as IGeoDataset;  	//    geo.SpatialReference = pDS.SpatialReference;  	//}  	//else if (pfeatureClass.ShapeType == esriGeometryType.esriGeometryPoint)  	//{  	string sShpName = pfeatureClass.ShapeFieldName;  	pFieldsTest = pfeatureClass.Fields;  	int lGeomIndex = pFieldsTest.FindField (sShpName);  	pFieldTest = pFieldsTest.get_Field (lGeomIndex);  	pGeometryDefTest = pFieldTest.GeometryDef;  	bool bZAware;  	bool bMAware;  	//Determine if M or Z aware  	bZAware = pGeometryDefTest.HasZ;  	bMAware = pGeometryDefTest.HasM;  	if (bZAware) {  		// IGeometry pGeo = new PolylineClass();  		pZAware = geo as IZAware;  		if (pZAware.ZAware) {  		} else {  			pZAware.ZAware = true;  			//pZAware.DropZs();  		}  		// pZAware.DropZs();  		if (pfeatureClass.ShapeType == esriGeometryType.esriGeometryPoint) {  			// pZAware.InitDefaults();  			pN = geo as IPoint;  			pN.Z = 0;  			geo = pN as IGeometry;  		} else {  			pZ = geo as IZ;  			pZ.SetConstantZ (0);  		}  	}  	if (bMAware) {  	}  	pDS = pfeatureClass as IGeoDataset;  	geo.SpatialReference = pDS.SpatialReference;  	//else  	//{  	//    feature.Shape = geo;  	//}  	feature.Shape = geo;  	pEditTemplate.SetDefaultValues (feature);  	//  feature.Store();  	if (ClearSelected)  		Editor.Map.ClearSelection ();  	//if (feature is INetworkFeature)  	//{  	//    feature.Store();  	//    INetworkFeature pNF = (INetworkFeature)feature;  	//    pNF.Connect();  	//}  	if (SelectFeature)  		Editor.Map.SelectFeature (pfeatureLayer' feature);  	// MessageBox.Show(Editor.Map.SelectionCount.ToString());  	//Invalidate the area around the new feature  	//IEnvelope pEnv = null;  	//m_editor.Map.AreaOfInterest().QueryEnvelope(pEnv);  	//IEnvelope pEnv = m_editor.Map.AreaOfInterest;  	//Editor.Display.Invalidate((app.Document as IMxDocument).ActiveView.Extent' true' (short)esriScreenCache.esriAllScreenCaches);  	return feature;  } catch (Exception ex) {  	MessageBox.Show ("Error creating a feature with template\r\nFeature Template: " + pEditTemplate.Name + "\r\n" + ex.ToString ());  	return null;  } finally {  	pfeatureLayer = null;  	pfeatureClass = null;  	pSpatFilt = null;  	pGeometryDefTest = null;  	pFieldsTest = null;  	pFieldTest = null;  	pN = null;  	pZ = null;  	pDS = null;  	pZAware = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,The following statement contains a magic number: try {  	if (geo.GeometryType == esriGeometryType.esriGeometryPolyline) {  		if (((IPolyline)geo).IsEmpty == true) {  			return null;  		} else if (((IPolyline)geo).Length < (GetXYTolerance (geo) * 2)) {  			return null;  		}  	} else if (geo.GeometryType == esriGeometryType.esriGeometryPolygon) {  		if (((IPolygon)geo).IsEmpty == true) {  			return null;  		} else {  			IArea area = (IArea)geo;  			if (area.Area == 0) {  				return null;  			}  		}  	} else if (geo.GeometryType == esriGeometryType.esriGeometryPoint) {  		if (((IPoint)geo).IsEmpty == true) {  			return null;  		}  	}  } catch {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,The following statement contains a magic number: if (geo.GeometryType == esriGeometryType.esriGeometryPolyline) {  	if (((IPolyline)geo).IsEmpty == true) {  		return null;  	} else if (((IPolyline)geo).Length < (GetXYTolerance (geo) * 2)) {  		return null;  	}  } else if (geo.GeometryType == esriGeometryType.esriGeometryPolygon) {  	if (((IPolygon)geo).IsEmpty == true) {  		return null;  	} else {  		IArea area = (IArea)geo;  		if (area.Area == 0) {  			return null;  		}  	}  } else if (geo.GeometryType == esriGeometryType.esriGeometryPoint) {  	if (((IPoint)geo).IsEmpty == true) {  		return null;  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,The following statement contains a magic number: if (((IPolyline)geo).IsEmpty == true) {  	return null;  } else if (((IPolyline)geo).Length < (GetXYTolerance (geo) * 2)) {  	return null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,The following statement contains a magic number: if (((IPolyline)geo).Length < (GetXYTolerance (geo) * 2)) {  	return null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,The following statement contains a magic number: try {  	try {  		if (geo.GeometryType == esriGeometryType.esriGeometryPolyline) {  			if (((IPolyline)geo).IsEmpty == true) {  				return null;  			} else if (((IPolyline)geo).Length < (GetXYTolerance (geo) * 2)) {  				return null;  			}  		} else if (geo.GeometryType == esriGeometryType.esriGeometryPolygon) {  			if (((IPolygon)geo).IsEmpty == true) {  				return null;  			} else {  				IArea area = (IArea)geo;  				if (area.Area == 0) {  					return null;  				}  			}  		} else if (geo.GeometryType == esriGeometryType.esriGeometryPoint) {  			if (((IPoint)geo).IsEmpty == true) {  				return null;  			}  		}  	} catch {  	}  	pfeatureClass = FeatureLay.FeatureClass;  	if (checkForExisting) {  		pSpatFilt = new SpatialFilterClass ();  		pSpatFilt.Geometry = geo;  		pSpatFilt.GeometryField = FeatureLay.FeatureClass.ShapeFieldName;  		pSpatFilt.SpatialRel = esriSpatialRelEnum.esriSpatialRelIntersects;  		if (pfeatureClass.FeatureCount (pSpatFilt) > 0) {  			return null;  		}  	}  	//create point for the current template  	feature = pfeatureClass.CreateFeature ();  	//if (pfeatureClass.ShapeType == esriGeometryType.esriGeometryPolyline)  	//{  	//    IGeometryDef pGeometryDefTest;  	//    string sShpName = pfeatureClass.ShapeFieldName;  	//    IFields pFieldsTest = pfeatureClass.Fields;  	//    int lGeomIndex = pFieldsTest.FindField(sShpName);  	//    IField pFieldTest = pFieldsTest.get_Field(lGeomIndex);  	//    pGeometryDefTest = pFieldTest.GeometryDef;  	//    bool bZAware;  	//    bool bMAware;  	//    //Determine if M or Z aware  	//    bZAware = pGeometryDefTest.HasZ;  	//    bMAware = pGeometryDefTest.HasM;  	//    if (bZAware)  	//    {  	//        // IGeometry pGeo = new PolylineClass();  	//        IZAware pZAware = geo as IZAware;  	//        if (pZAware.ZAware)  	//        {  	//        }  	//        else  	//        {  	//            pZAware.ZAware = true;  	//            //pZAware.DropZs();  	//        }  	//        // pZAware.DropZs();  	//        IZ pZ = geo as IZ;  	//        pZ.SetConstantZ(0);  	//    }  	//    if (bMAware)  	//    {  	//    }  	//    IGeoDataset pDS = pfeatureClass as IGeoDataset;  	//    geo.SpatialReference = pDS.SpatialReference;  	//}  	string sShpName = pfeatureClass.ShapeFieldName;  	pFieldsTest = pfeatureClass.Fields;  	int lGeomIndex = pFieldsTest.FindField (sShpName);  	pFieldTest = pFieldsTest.get_Field (lGeomIndex);  	pGeometryDefTest = pFieldTest.GeometryDef;  	bool bZAware;  	bool bMAware;  	//Determine if M or Z aware  	bZAware = pGeometryDefTest.HasZ;  	bMAware = pGeometryDefTest.HasM;  	if (bZAware) {  		// IGeometry pGeo = new PolylineClass();  		pZAware = geo as IZAware;  		if (pZAware.ZAware) {  		} else {  			pZAware.ZAware = true;  			//pZAware.DropZs();  		}  		// pZAware.DropZs();  		if (pfeatureClass.ShapeType == esriGeometryType.esriGeometryPoint) {  			// pZAware.InitDefaults();  			pN = geo as IPoint;  			pN.Z = 0;  			geo = pN as IGeometry;  		} else {  			pZ = geo as IZ;  			pZ.SetConstantZ (0);  		}  	}  	if (bMAware) {  	}  	pDS = pfeatureClass as IGeoDataset;  	geo.SpatialReference = pDS.SpatialReference;  	feature.Shape = geo;  	rowSubtype = feature as IRowSubtypes;  	pSub = pfeatureClass as ISubtypes;  	if (pSub.HasSubtype)  		rowSubtype.SubtypeCode = pSub.DefaultSubtypeCode;  	rowSubtype.InitDefaultValues ();  	//if (feature is INetworkFeature)  	//{  	//    ((INetworkFeature)feature).Connect();  	//}  	// feature.Store();  	if (ClearSelected)  		Editor.Map.ClearSelection ();  	if (SelectFeature)  		Editor.Map.SelectFeature (FeatureLay' feature);  	// Editor.Map.SelectFeature(FeatureLay' feature);  	//Invalidate the area around the new feature  	//IEnvelope pEnv = null;  	//m_editor.Map.AreaOfInterest().QueryEnvelope(pEnv);  	//IEnvelope pEnv = m_editor.Map.AreaOfInterest;  	Editor.Display.Invalidate ((app.Document as IMxDocument).ActiveView.Extent' true' (short)esriScreenCache.esriAllScreenCaches);  	return feature;  	//            m_editor.Display.Invalidate(feature.Extent' true' (short)esriScreenCache.esriAllScreenCaches);  } catch (Exception ex) {  	MessageBox.Show ("Error in Create Feature: " + ex.ToString ());  	return null;  } finally {  	pfeatureClass = null;  	pSpatFilt = null;  	pGeometryDefTest = null;  	pFieldsTest = null;  	pFieldTest = null;  	pN = null;  	pZ = null;  	pDS = null;  	pZAware = null;  	rowSubtype = null;  	pSub = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,The following statement contains a magic number: try {  	if (geo.GeometryType == esriGeometryType.esriGeometryPolyline) {  		if (((IPolyline)geo).IsEmpty == true) {  			return null;  		} else if (((IPolyline)geo).Length < (GetXYTolerance (geo) * 2)) {  			return null;  		}  	} else if (geo.GeometryType == esriGeometryType.esriGeometryPolygon) {  		if (((IPolygon)geo).IsEmpty == true) {  			return null;  		} else {  			IArea area = (IArea)geo;  			if (area.Area == 0) {  				return null;  			}  		}  	} else if (geo.GeometryType == esriGeometryType.esriGeometryPoint) {  		if (((IPoint)geo).IsEmpty == true) {  			return null;  		}  	}  } catch {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,The following statement contains a magic number: if (geo.GeometryType == esriGeometryType.esriGeometryPolyline) {  	if (((IPolyline)geo).IsEmpty == true) {  		return null;  	} else if (((IPolyline)geo).Length < (GetXYTolerance (geo) * 2)) {  		return null;  	}  } else if (geo.GeometryType == esriGeometryType.esriGeometryPolygon) {  	if (((IPolygon)geo).IsEmpty == true) {  		return null;  	} else {  		IArea area = (IArea)geo;  		if (area.Area == 0) {  			return null;  		}  	}  } else if (geo.GeometryType == esriGeometryType.esriGeometryPoint) {  	if (((IPoint)geo).IsEmpty == true) {  		return null;  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,The following statement contains a magic number: if (((IPolyline)geo).IsEmpty == true) {  	return null;  } else if (((IPolyline)geo).Length < (GetXYTolerance (geo) * 2)) {  	return null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateFeature,The following statement contains a magic number: if (((IPolyline)geo).Length < (GetXYTolerance (geo) * 2)) {  	return null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,IsOdd,The following statement contains a magic number: return value % 2 != 0;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,IsOdd,The following statement contains a magic number: return Convert.ToInt32 (value) % 2 != 0;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetClosestFeature,The following statement contains a magic number: try {  	sFilter = new SpatialFilterClass ();  	if (maxDistance == 0) {  		sFilter.Geometry = sourceGeo;  	} else {  		topoOp = sourceGeo as ITopologicalOperator;  		poly = topoOp.Buffer (maxDistance) as IPolygon;  		if (poly == null) {  			poly = topoOp.Buffer (maxDistance * 10) as IPolygon;  			if (poly == null) {  				sFilter.Geometry = sourceGeo;  			} else  				sFilter.Geometry = poly;  		} else  			sFilter.Geometry = poly;  	}  	sFilter.GeometryField = searchFeatureLayer.FeatureClass.ShapeFieldName;  	sFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelIntersects;  	if (searchOnLayer)  		if (((IFeatureSelection)searchFeatureLayer).SelectionSet.Count > 0 && checkSelection) {  			((IFeatureSelection)searchFeatureLayer).SelectionSet.Search (sFilter' true' out cCursor);  			lineCursor = (IFeatureCursor)cCursor;  		} else {  			lineCursor = searchFeatureLayer.Search (sFilter' true);  		}  	else  		lineCursor = searchFeatureLayer.FeatureClass.Search (sFilter' true);  	lineFeature = lineCursor.NextFeature ();  	double distance;  	double lastDistance = maxDistance;  	if (lastDistance == 0) {  		lastDistance = 9999;  	}  	proxOp = (IProximityOperator)sourceGeo;  	int closestOID = -1;  	while (!(lineFeature == null)) {  		IGeometry pTempGeo = lineFeature.Shape;  		pTempGeo.Project (sourceGeo.SpatialReference);  		distance = proxOp.ReturnDistance (pTempGeo);  		pTempGeo = null;  		//distance = proxOp.ReturnDistance(lineFeature.Shape);  		if (distance < lastDistance) {  			closestOID = lineFeature.OID;  			lastDistance = distance;  		}  		lineFeature = lineCursor.NextFeature ();  	}  	proxOp = null;  	lineFeature = null;  	if (closestOID != -1)  		nearestFeature = searchFeatureLayer.FeatureClass.GetFeature (closestOID);  	else  		nearestFeature = null;  	return nearestFeature;  } catch (Exception ex) {  	MessageBox.Show ("Error in the Get Nearest Feature\n" + ex.ToString ()' ex.Source);  	return null;  } finally {  	if (lineCursor != null)  		Marshal.ReleaseComObject (lineCursor);  	if (cCursor != null)  		Marshal.ReleaseComObject (cCursor);  	topoOp = null;  	nearestFeature = null;  	lineFeature = null;  	proxOp = null;  	poly = null;  	sFilter = null;  	lineCursor = null;  	cCursor = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetClosestFeature,The following statement contains a magic number: try {  	sFilter = new SpatialFilterClass ();  	if (maxDistance == 0) {  		sFilter.Geometry = sourceGeo;  	} else {  		topoOp = sourceGeo as ITopologicalOperator;  		poly = topoOp.Buffer (maxDistance) as IPolygon;  		if (poly == null) {  			poly = topoOp.Buffer (maxDistance * 10) as IPolygon;  			if (poly == null) {  				sFilter.Geometry = sourceGeo;  			} else  				sFilter.Geometry = poly;  		} else  			sFilter.Geometry = poly;  	}  	sFilter.GeometryField = searchFeatureLayer.FeatureClass.ShapeFieldName;  	sFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelIntersects;  	if (searchOnLayer)  		if (((IFeatureSelection)searchFeatureLayer).SelectionSet.Count > 0 && checkSelection) {  			((IFeatureSelection)searchFeatureLayer).SelectionSet.Search (sFilter' true' out cCursor);  			lineCursor = (IFeatureCursor)cCursor;  		} else {  			lineCursor = searchFeatureLayer.Search (sFilter' true);  		}  	else  		lineCursor = searchFeatureLayer.FeatureClass.Search (sFilter' true);  	lineFeature = lineCursor.NextFeature ();  	double distance;  	double lastDistance = maxDistance;  	if (lastDistance == 0) {  		lastDistance = 9999;  	}  	proxOp = (IProximityOperator)sourceGeo;  	int closestOID = -1;  	while (!(lineFeature == null)) {  		IGeometry pTempGeo = lineFeature.Shape;  		pTempGeo.Project (sourceGeo.SpatialReference);  		distance = proxOp.ReturnDistance (pTempGeo);  		pTempGeo = null;  		//distance = proxOp.ReturnDistance(lineFeature.Shape);  		if (distance < lastDistance) {  			closestOID = lineFeature.OID;  			lastDistance = distance;  		}  		lineFeature = lineCursor.NextFeature ();  	}  	proxOp = null;  	lineFeature = null;  	if (closestOID != -1)  		nearestFeature = searchFeatureLayer.FeatureClass.GetFeature (closestOID);  	else  		nearestFeature = null;  	return nearestFeature;  } catch (Exception ex) {  	MessageBox.Show ("Error in the Get Nearest Feature\n" + ex.ToString ()' ex.Source);  	return null;  } finally {  	if (lineCursor != null)  		Marshal.ReleaseComObject (lineCursor);  	if (cCursor != null)  		Marshal.ReleaseComObject (cCursor);  	topoOp = null;  	nearestFeature = null;  	lineFeature = null;  	proxOp = null;  	poly = null;  	sFilter = null;  	lineCursor = null;  	cCursor = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetClosestFeature,The following statement contains a magic number: if (maxDistance == 0) {  	sFilter.Geometry = sourceGeo;  } else {  	topoOp = sourceGeo as ITopologicalOperator;  	poly = topoOp.Buffer (maxDistance) as IPolygon;  	if (poly == null) {  		poly = topoOp.Buffer (maxDistance * 10) as IPolygon;  		if (poly == null) {  			sFilter.Geometry = sourceGeo;  		} else  			sFilter.Geometry = poly;  	} else  		sFilter.Geometry = poly;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetClosestFeature,The following statement contains a magic number: if (poly == null) {  	poly = topoOp.Buffer (maxDistance * 10) as IPolygon;  	if (poly == null) {  		sFilter.Geometry = sourceGeo;  	} else  		sFilter.Geometry = poly;  } else  	sFilter.Geometry = poly;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetClosestFeature,The following statement contains a magic number: poly = topoOp.Buffer (maxDistance * 10) as IPolygon;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetClosestFeature,The following statement contains a magic number: if (lastDistance == 0) {  	lastDistance = 9999;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetClosestFeature,The following statement contains a magic number: lastDistance = 9999;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,bufferTillNotEmpty,The following statement contains a magic number: try {  	pTopo = inGeo as ITopologicalOperator;  	pGeo = pTopo.Buffer (searchDistance);  	ptempPoly = pGeo as IPolygon;  	if (ptempPoly.IsEmpty == true) {  		pGeo = bufferTillNotEmpty (inGeo' searchDistance * 10);  	}  	return pGeo;  } catch {  	return inGeo;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,bufferTillNotEmpty,The following statement contains a magic number: if (ptempPoly.IsEmpty == true) {  	pGeo = bufferTillNotEmpty (inGeo' searchDistance * 10);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,bufferTillNotEmpty,The following statement contains a magic number: pGeo = bufferTillNotEmpty (inGeo' searchDistance * 10);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlashGeometry,The following statement contains a magic number: try {  	if (geometry == null || color == null || display == null) {  		return;  	}  	display.StartDrawing (display.hDC' (System.Int16)ESRI.ArcGIS.Display.esriScreenCache.esriNoScreenCache);  	// Explicit Cast  	switch (geometry.GeometryType) {  	case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPolygon: {  		//Set the flash geometry's symbol.  		simpleFillSymbol = new ESRI.ArcGIS.Display.SimpleFillSymbolClass ();  		simpleFillSymbol.Color = color;  		symbol = simpleFillSymbol as ESRI.ArcGIS.Display.ISymbol;  		// Dynamic Cast  		symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  		//Flash the input polygon geometry.  		display.SetSymbol (symbol);  		display.DrawPolygon (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPolygon (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPolygon (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPolygon (geometry);  		break;  	}  	case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPolyline: {  		//Set the flash geometry's symbol.  		simpleLineSymbol = new ESRI.ArcGIS.Display.SimpleLineSymbolClass ();  		simpleLineSymbol.Width = 4;  		simpleLineSymbol.Color = color;  		symbol = simpleLineSymbol as ESRI.ArcGIS.Display.ISymbol;  		// Dynamic Cast  		symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  		//Flash the input polyline geometry.  		display.SetSymbol (symbol);  		display.DrawPolyline (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPolyline (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPolyline (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPolyline (geometry);  		break;  	}  	case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPoint: {  		//Set the flash geometry's symbol.  		simpleMarkerSymbol = new ESRI.ArcGIS.Display.SimpleMarkerSymbolClass ();  		simpleMarkerSymbol.Style = ESRI.ArcGIS.Display.esriSimpleMarkerStyle.esriSMSCircle;  		simpleMarkerSymbol.Size = 12;  		simpleMarkerSymbol.Color = color;  		symbol = simpleMarkerSymbol as ESRI.ArcGIS.Display.ISymbol;  		// Dynamic Cast  		symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  		//Flash the input point geometry.  		display.SetSymbol (symbol);  		display.DrawPoint (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPoint (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPoint (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPoint (geometry);  		break;  	}  	case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryMultipoint: {  		//Set the flash geometry's symbol.  		simpleMarkerSymbol = new ESRI.ArcGIS.Display.SimpleMarkerSymbolClass ();  		simpleMarkerSymbol.Style = ESRI.ArcGIS.Display.esriSimpleMarkerStyle.esriSMSCircle;  		simpleMarkerSymbol.Size = 12;  		simpleMarkerSymbol.Color = color;  		symbol = simpleMarkerSymbol as ESRI.ArcGIS.Display.ISymbol;  		// Dynamic Cast  		symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  		//Flash the input multipoint geometry.  		display.SetSymbol (symbol);  		display.DrawMultipoint (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawMultipoint (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawMultipoint (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawMultipoint (geometry);  		break;  	}  	}  	display.FinishDrawing ();  } catch {  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlashGeometry,The following statement contains a magic number: try {  	if (geometry == null || color == null || display == null) {  		return;  	}  	display.StartDrawing (display.hDC' (System.Int16)ESRI.ArcGIS.Display.esriScreenCache.esriNoScreenCache);  	// Explicit Cast  	switch (geometry.GeometryType) {  	case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPolygon: {  		//Set the flash geometry's symbol.  		simpleFillSymbol = new ESRI.ArcGIS.Display.SimpleFillSymbolClass ();  		simpleFillSymbol.Color = color;  		symbol = simpleFillSymbol as ESRI.ArcGIS.Display.ISymbol;  		// Dynamic Cast  		symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  		//Flash the input polygon geometry.  		display.SetSymbol (symbol);  		display.DrawPolygon (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPolygon (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPolygon (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPolygon (geometry);  		break;  	}  	case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPolyline: {  		//Set the flash geometry's symbol.  		simpleLineSymbol = new ESRI.ArcGIS.Display.SimpleLineSymbolClass ();  		simpleLineSymbol.Width = 4;  		simpleLineSymbol.Color = color;  		symbol = simpleLineSymbol as ESRI.ArcGIS.Display.ISymbol;  		// Dynamic Cast  		symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  		//Flash the input polyline geometry.  		display.SetSymbol (symbol);  		display.DrawPolyline (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPolyline (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPolyline (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPolyline (geometry);  		break;  	}  	case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPoint: {  		//Set the flash geometry's symbol.  		simpleMarkerSymbol = new ESRI.ArcGIS.Display.SimpleMarkerSymbolClass ();  		simpleMarkerSymbol.Style = ESRI.ArcGIS.Display.esriSimpleMarkerStyle.esriSMSCircle;  		simpleMarkerSymbol.Size = 12;  		simpleMarkerSymbol.Color = color;  		symbol = simpleMarkerSymbol as ESRI.ArcGIS.Display.ISymbol;  		// Dynamic Cast  		symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  		//Flash the input point geometry.  		display.SetSymbol (symbol);  		display.DrawPoint (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPoint (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPoint (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPoint (geometry);  		break;  	}  	case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryMultipoint: {  		//Set the flash geometry's symbol.  		simpleMarkerSymbol = new ESRI.ArcGIS.Display.SimpleMarkerSymbolClass ();  		simpleMarkerSymbol.Style = ESRI.ArcGIS.Display.esriSimpleMarkerStyle.esriSMSCircle;  		simpleMarkerSymbol.Size = 12;  		simpleMarkerSymbol.Color = color;  		symbol = simpleMarkerSymbol as ESRI.ArcGIS.Display.ISymbol;  		// Dynamic Cast  		symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  		//Flash the input multipoint geometry.  		display.SetSymbol (symbol);  		display.DrawMultipoint (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawMultipoint (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawMultipoint (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawMultipoint (geometry);  		break;  	}  	}  	display.FinishDrawing ();  } catch {  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlashGeometry,The following statement contains a magic number: try {  	if (geometry == null || color == null || display == null) {  		return;  	}  	display.StartDrawing (display.hDC' (System.Int16)ESRI.ArcGIS.Display.esriScreenCache.esriNoScreenCache);  	// Explicit Cast  	switch (geometry.GeometryType) {  	case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPolygon: {  		//Set the flash geometry's symbol.  		simpleFillSymbol = new ESRI.ArcGIS.Display.SimpleFillSymbolClass ();  		simpleFillSymbol.Color = color;  		symbol = simpleFillSymbol as ESRI.ArcGIS.Display.ISymbol;  		// Dynamic Cast  		symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  		//Flash the input polygon geometry.  		display.SetSymbol (symbol);  		display.DrawPolygon (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPolygon (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPolygon (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPolygon (geometry);  		break;  	}  	case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPolyline: {  		//Set the flash geometry's symbol.  		simpleLineSymbol = new ESRI.ArcGIS.Display.SimpleLineSymbolClass ();  		simpleLineSymbol.Width = 4;  		simpleLineSymbol.Color = color;  		symbol = simpleLineSymbol as ESRI.ArcGIS.Display.ISymbol;  		// Dynamic Cast  		symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  		//Flash the input polyline geometry.  		display.SetSymbol (symbol);  		display.DrawPolyline (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPolyline (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPolyline (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPolyline (geometry);  		break;  	}  	case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPoint: {  		//Set the flash geometry's symbol.  		simpleMarkerSymbol = new ESRI.ArcGIS.Display.SimpleMarkerSymbolClass ();  		simpleMarkerSymbol.Style = ESRI.ArcGIS.Display.esriSimpleMarkerStyle.esriSMSCircle;  		simpleMarkerSymbol.Size = 12;  		simpleMarkerSymbol.Color = color;  		symbol = simpleMarkerSymbol as ESRI.ArcGIS.Display.ISymbol;  		// Dynamic Cast  		symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  		//Flash the input point geometry.  		display.SetSymbol (symbol);  		display.DrawPoint (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPoint (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPoint (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawPoint (geometry);  		break;  	}  	case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryMultipoint: {  		//Set the flash geometry's symbol.  		simpleMarkerSymbol = new ESRI.ArcGIS.Display.SimpleMarkerSymbolClass ();  		simpleMarkerSymbol.Style = ESRI.ArcGIS.Display.esriSimpleMarkerStyle.esriSMSCircle;  		simpleMarkerSymbol.Size = 12;  		simpleMarkerSymbol.Color = color;  		symbol = simpleMarkerSymbol as ESRI.ArcGIS.Display.ISymbol;  		// Dynamic Cast  		symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  		//Flash the input multipoint geometry.  		display.SetSymbol (symbol);  		display.DrawMultipoint (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawMultipoint (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawMultipoint (geometry);  		System.Threading.Thread.Sleep (delay);  		display.DrawMultipoint (geometry);  		break;  	}  	}  	display.FinishDrawing ();  } catch {  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlashGeometry,The following statement contains a magic number: switch (geometry.GeometryType) {  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPolygon: {  	//Set the flash geometry's symbol.  	simpleFillSymbol = new ESRI.ArcGIS.Display.SimpleFillSymbolClass ();  	simpleFillSymbol.Color = color;  	symbol = simpleFillSymbol as ESRI.ArcGIS.Display.ISymbol;  	// Dynamic Cast  	symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  	//Flash the input polygon geometry.  	display.SetSymbol (symbol);  	display.DrawPolygon (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolygon (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolygon (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolygon (geometry);  	break;  }  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPolyline: {  	//Set the flash geometry's symbol.  	simpleLineSymbol = new ESRI.ArcGIS.Display.SimpleLineSymbolClass ();  	simpleLineSymbol.Width = 4;  	simpleLineSymbol.Color = color;  	symbol = simpleLineSymbol as ESRI.ArcGIS.Display.ISymbol;  	// Dynamic Cast  	symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  	//Flash the input polyline geometry.  	display.SetSymbol (symbol);  	display.DrawPolyline (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolyline (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolyline (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolyline (geometry);  	break;  }  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPoint: {  	//Set the flash geometry's symbol.  	simpleMarkerSymbol = new ESRI.ArcGIS.Display.SimpleMarkerSymbolClass ();  	simpleMarkerSymbol.Style = ESRI.ArcGIS.Display.esriSimpleMarkerStyle.esriSMSCircle;  	simpleMarkerSymbol.Size = 12;  	simpleMarkerSymbol.Color = color;  	symbol = simpleMarkerSymbol as ESRI.ArcGIS.Display.ISymbol;  	// Dynamic Cast  	symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  	//Flash the input point geometry.  	display.SetSymbol (symbol);  	display.DrawPoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPoint (geometry);  	break;  }  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryMultipoint: {  	//Set the flash geometry's symbol.  	simpleMarkerSymbol = new ESRI.ArcGIS.Display.SimpleMarkerSymbolClass ();  	simpleMarkerSymbol.Style = ESRI.ArcGIS.Display.esriSimpleMarkerStyle.esriSMSCircle;  	simpleMarkerSymbol.Size = 12;  	simpleMarkerSymbol.Color = color;  	symbol = simpleMarkerSymbol as ESRI.ArcGIS.Display.ISymbol;  	// Dynamic Cast  	symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  	//Flash the input multipoint geometry.  	display.SetSymbol (symbol);  	display.DrawMultipoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawMultipoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawMultipoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawMultipoint (geometry);  	break;  }  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlashGeometry,The following statement contains a magic number: switch (geometry.GeometryType) {  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPolygon: {  	//Set the flash geometry's symbol.  	simpleFillSymbol = new ESRI.ArcGIS.Display.SimpleFillSymbolClass ();  	simpleFillSymbol.Color = color;  	symbol = simpleFillSymbol as ESRI.ArcGIS.Display.ISymbol;  	// Dynamic Cast  	symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  	//Flash the input polygon geometry.  	display.SetSymbol (symbol);  	display.DrawPolygon (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolygon (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolygon (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolygon (geometry);  	break;  }  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPolyline: {  	//Set the flash geometry's symbol.  	simpleLineSymbol = new ESRI.ArcGIS.Display.SimpleLineSymbolClass ();  	simpleLineSymbol.Width = 4;  	simpleLineSymbol.Color = color;  	symbol = simpleLineSymbol as ESRI.ArcGIS.Display.ISymbol;  	// Dynamic Cast  	symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  	//Flash the input polyline geometry.  	display.SetSymbol (symbol);  	display.DrawPolyline (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolyline (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolyline (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolyline (geometry);  	break;  }  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPoint: {  	//Set the flash geometry's symbol.  	simpleMarkerSymbol = new ESRI.ArcGIS.Display.SimpleMarkerSymbolClass ();  	simpleMarkerSymbol.Style = ESRI.ArcGIS.Display.esriSimpleMarkerStyle.esriSMSCircle;  	simpleMarkerSymbol.Size = 12;  	simpleMarkerSymbol.Color = color;  	symbol = simpleMarkerSymbol as ESRI.ArcGIS.Display.ISymbol;  	// Dynamic Cast  	symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  	//Flash the input point geometry.  	display.SetSymbol (symbol);  	display.DrawPoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPoint (geometry);  	break;  }  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryMultipoint: {  	//Set the flash geometry's symbol.  	simpleMarkerSymbol = new ESRI.ArcGIS.Display.SimpleMarkerSymbolClass ();  	simpleMarkerSymbol.Style = ESRI.ArcGIS.Display.esriSimpleMarkerStyle.esriSMSCircle;  	simpleMarkerSymbol.Size = 12;  	simpleMarkerSymbol.Color = color;  	symbol = simpleMarkerSymbol as ESRI.ArcGIS.Display.ISymbol;  	// Dynamic Cast  	symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  	//Flash the input multipoint geometry.  	display.SetSymbol (symbol);  	display.DrawMultipoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawMultipoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawMultipoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawMultipoint (geometry);  	break;  }  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlashGeometry,The following statement contains a magic number: switch (geometry.GeometryType) {  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPolygon: {  	//Set the flash geometry's symbol.  	simpleFillSymbol = new ESRI.ArcGIS.Display.SimpleFillSymbolClass ();  	simpleFillSymbol.Color = color;  	symbol = simpleFillSymbol as ESRI.ArcGIS.Display.ISymbol;  	// Dynamic Cast  	symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  	//Flash the input polygon geometry.  	display.SetSymbol (symbol);  	display.DrawPolygon (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolygon (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolygon (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolygon (geometry);  	break;  }  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPolyline: {  	//Set the flash geometry's symbol.  	simpleLineSymbol = new ESRI.ArcGIS.Display.SimpleLineSymbolClass ();  	simpleLineSymbol.Width = 4;  	simpleLineSymbol.Color = color;  	symbol = simpleLineSymbol as ESRI.ArcGIS.Display.ISymbol;  	// Dynamic Cast  	symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  	//Flash the input polyline geometry.  	display.SetSymbol (symbol);  	display.DrawPolyline (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolyline (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolyline (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolyline (geometry);  	break;  }  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPoint: {  	//Set the flash geometry's symbol.  	simpleMarkerSymbol = new ESRI.ArcGIS.Display.SimpleMarkerSymbolClass ();  	simpleMarkerSymbol.Style = ESRI.ArcGIS.Display.esriSimpleMarkerStyle.esriSMSCircle;  	simpleMarkerSymbol.Size = 12;  	simpleMarkerSymbol.Color = color;  	symbol = simpleMarkerSymbol as ESRI.ArcGIS.Display.ISymbol;  	// Dynamic Cast  	symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  	//Flash the input point geometry.  	display.SetSymbol (symbol);  	display.DrawPoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPoint (geometry);  	break;  }  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryMultipoint: {  	//Set the flash geometry's symbol.  	simpleMarkerSymbol = new ESRI.ArcGIS.Display.SimpleMarkerSymbolClass ();  	simpleMarkerSymbol.Style = ESRI.ArcGIS.Display.esriSimpleMarkerStyle.esriSMSCircle;  	simpleMarkerSymbol.Size = 12;  	simpleMarkerSymbol.Color = color;  	symbol = simpleMarkerSymbol as ESRI.ArcGIS.Display.ISymbol;  	// Dynamic Cast  	symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  	//Flash the input multipoint geometry.  	display.SetSymbol (symbol);  	display.DrawMultipoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawMultipoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawMultipoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawMultipoint (geometry);  	break;  }  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlashGeometry,The following statement contains a magic number: simpleLineSymbol.Width = 4;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlashGeometry,The following statement contains a magic number: simpleMarkerSymbol.Size = 12;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlashGeometry,The following statement contains a magic number: simpleMarkerSymbol.Size = 12;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePictureMarkerSymbol,The following statement contains a magic number: try {  	rgbColor = new ESRI.ArcGIS.Display.RgbColorClass ();  	rgbColor.Red = 255;  	rgbColor.Green = 255;  	rgbColor.Blue = 255;  	// Create the Marker and assign properties.  	ESRI.ArcGIS.Display.IPictureMarkerSymbol pictureMarkerSymbol = new ESRI.ArcGIS.Display.PictureMarkerSymbolClass ();  	pictureMarkerSymbol.CreateMarkerSymbolFromFile (pictureType' filename);  	pictureMarkerSymbol.Angle = 0;  	pictureMarkerSymbol.BitmapTransparencyColor = rgbColor;  	pictureMarkerSymbol.Size = markerSize;  	pictureMarkerSymbol.XOffset = 0;  	pictureMarkerSymbol.YOffset = 0;  	return pictureMarkerSymbol;  } catch {  	return null;  } finally {  	rgbColor = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePictureMarkerSymbol,The following statement contains a magic number: try {  	rgbColor = new ESRI.ArcGIS.Display.RgbColorClass ();  	rgbColor.Red = 255;  	rgbColor.Green = 255;  	rgbColor.Blue = 255;  	// Create the Marker and assign properties.  	ESRI.ArcGIS.Display.IPictureMarkerSymbol pictureMarkerSymbol = new ESRI.ArcGIS.Display.PictureMarkerSymbolClass ();  	pictureMarkerSymbol.CreateMarkerSymbolFromFile (pictureType' filename);  	pictureMarkerSymbol.Angle = 0;  	pictureMarkerSymbol.BitmapTransparencyColor = rgbColor;  	pictureMarkerSymbol.Size = markerSize;  	pictureMarkerSymbol.XOffset = 0;  	pictureMarkerSymbol.YOffset = 0;  	return pictureMarkerSymbol;  } catch {  	return null;  } finally {  	rgbColor = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePictureMarkerSymbol,The following statement contains a magic number: try {  	rgbColor = new ESRI.ArcGIS.Display.RgbColorClass ();  	rgbColor.Red = 255;  	rgbColor.Green = 255;  	rgbColor.Blue = 255;  	// Create the Marker and assign properties.  	ESRI.ArcGIS.Display.IPictureMarkerSymbol pictureMarkerSymbol = new ESRI.ArcGIS.Display.PictureMarkerSymbolClass ();  	pictureMarkerSymbol.CreateMarkerSymbolFromFile (pictureType' filename);  	pictureMarkerSymbol.Angle = 0;  	pictureMarkerSymbol.BitmapTransparencyColor = rgbColor;  	pictureMarkerSymbol.Size = markerSize;  	pictureMarkerSymbol.XOffset = 0;  	pictureMarkerSymbol.YOffset = 0;  	return pictureMarkerSymbol;  } catch {  	return null;  } finally {  	rgbColor = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePictureMarkerSymbol,The following statement contains a magic number: rgbColor.Red = 255;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePictureMarkerSymbol,The following statement contains a magic number: rgbColor.Green = 255;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePictureMarkerSymbol,The following statement contains a magic number: rgbColor.Blue = 255;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,The following statement contains a magic number: switch (flgType) {  case flagType.EdgeFlag:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSSquare;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.JunctionFlag:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSCircle;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.EdgeBarrier:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSDiamond;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (255' 0' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.JunctionBarrier:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSDiamond;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (255' 0' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  default:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSCircle;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,The following statement contains a magic number: switch (flgType) {  case flagType.EdgeFlag:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSSquare;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.JunctionFlag:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSCircle;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.EdgeBarrier:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSDiamond;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (255' 0' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.JunctionBarrier:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSDiamond;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (255' 0' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  default:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSCircle;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,The following statement contains a magic number: switch (flgType) {  case flagType.EdgeFlag:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSSquare;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.JunctionFlag:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSCircle;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.EdgeBarrier:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSDiamond;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (255' 0' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.JunctionBarrier:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSDiamond;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (255' 0' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  default:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSCircle;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,The following statement contains a magic number: switch (flgType) {  case flagType.EdgeFlag:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSSquare;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.JunctionFlag:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSCircle;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.EdgeBarrier:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSDiamond;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (255' 0' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.JunctionBarrier:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSDiamond;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (255' 0' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  default:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSCircle;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,The following statement contains a magic number: switch (flgType) {  case flagType.EdgeFlag:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSSquare;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.JunctionFlag:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSCircle;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.EdgeBarrier:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSDiamond;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (255' 0' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.JunctionBarrier:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSDiamond;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (255' 0' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  default:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSCircle;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,The following statement contains a magic number: switch (flgType) {  case flagType.EdgeFlag:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSSquare;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.JunctionFlag:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSCircle;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.EdgeBarrier:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSDiamond;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (255' 0' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.JunctionBarrier:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSDiamond;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (255' 0' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  default:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSCircle;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,The following statement contains a magic number: switch (flgType) {  case flagType.EdgeFlag:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSSquare;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.JunctionFlag:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSCircle;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.EdgeBarrier:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSDiamond;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (255' 0' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.JunctionBarrier:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSDiamond;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (255' 0' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  default:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSCircle;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,The following statement contains a magic number: switch (flgType) {  case flagType.EdgeFlag:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSSquare;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.JunctionFlag:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSCircle;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.EdgeBarrier:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSDiamond;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (255' 0' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.JunctionBarrier:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSDiamond;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (255' 0' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  default:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSCircle;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,The following statement contains a magic number: switch (flgType) {  case flagType.EdgeFlag:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSSquare;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.JunctionFlag:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSCircle;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.EdgeBarrier:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSDiamond;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (255' 0' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.JunctionBarrier:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSDiamond;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (255' 0' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  default:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSCircle;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,The following statement contains a magic number: switch (flgType) {  case flagType.EdgeFlag:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSSquare;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.JunctionFlag:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSCircle;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.EdgeBarrier:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSDiamond;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (255' 0' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  case flagType.JunctionBarrier:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSDiamond;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (255' 0' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  default:  	pSymbolFlag = new SimpleMarkerSymbolClass ();  	pSymbolFlag.Style = esriSimpleMarkerStyle.esriSMSCircle;  	pSymbolFlag.Angle = 0;  	pSymbolFlag.Color = GetColor (0' 255' 0);  	pSymbolFlag.Outline = true;  	pSymbolFlag.OutlineSize = 1;  	pSymbolFlag.OutlineColor = GetColor (0' 0' 0);  	pSymbolFlag.Size = 10;  	//TODO: UserConfig  	break;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,The following statement contains a magic number: pSymbolFlag.Color = GetColor (0' 255' 0);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,The following statement contains a magic number: pSymbolFlag.Size = 10;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,The following statement contains a magic number: pSymbolFlag.Color = GetColor (0' 255' 0);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,The following statement contains a magic number: pSymbolFlag.Size = 10;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,The following statement contains a magic number: pSymbolFlag.Color = GetColor (255' 0' 0);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,The following statement contains a magic number: pSymbolFlag.Size = 10;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,The following statement contains a magic number: pSymbolFlag.Color = GetColor (255' 0' 0);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,The following statement contains a magic number: pSymbolFlag.Size = 10;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,The following statement contains a magic number: pSymbolFlag.Color = GetColor (0' 255' 0);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreateNetworkFlagBarrierSymbol,The following statement contains a magic number: pSymbolFlag.Size = 10;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The following statement contains a magic number: try {  	featureEdit = lineFeature as IFeatureEdit2;  	hitTest = lineFeature.ShapeCopy as IHitTest;  	pHitPnt = new PointClass ();  	double pHitDist = -1;  	int pHitPrt = -1;  	int pHitSeg = -1;  	bool pHitSide = false;  	bool hit = hitTest.HitTest (SplitPoint' SnapTol' esriGeometryHitPartType.esriGeometryPartBoundary' pHitPnt' pHitDist' pHitPrt' pHitSeg' pHitSide);  	double dblMidVal = -1;  	if (hit) {  		pCurve = lineFeature.ShapeCopy as ICurve;  		//Split feature  		pTopoOp = pHitPnt as ITopologicalOperator;  		pPoly = pTopoOp.Buffer (Globals.ConvertFeetToMapUnits (.1' app) * 2) as IPolygon;  		pRelOp = pPoly as IRelationalOperator;  		if (pRelOp != null) {  			if ((pRelOp.Contains (pCurve.FromPoint)) || (pRelOp.Contains (pCurve.ToPoint))) {  				return null;  			}  		} else {  			pRelOp = pHitPnt as IRelationalOperator;  			if ((pRelOp.Contains (pCurve.FromPoint)) || (pRelOp.Contains (pCurve.ToPoint))) {  				return null;  			}  		}  		//Split feature  		//Globals.FlashGeometry(pHitPnt' Globals.GetColor(255' 0' 0)' mxdoc.ActiveView.ScreenDisplay' 150);  		double dblHighVal = 0;  		double dblLowVal = 0;  		int intHighIdx = -1;  		int intLowIdx = -1;  		if (pFldsNames != null) {  			foreach (MergeSplitFlds FldNam in pFldsNames) {  				FldNam.Value = lineFeature.get_Value (FldNam.FieldIndex).ToString ();  				if (FldNam.SplitType.ToUpper () == "MAX") {  					if (FldNam.Value != null) {  						if (FldNam.Value != "") {  							dblHighVal = Convert.ToDouble (FldNam.Value);  							intHighIdx = FldNam.FieldIndex;  						}  					}  				} else if (FldNam.SplitType.ToUpper () == "MIN") {  					if (FldNam.Value != null) {  						if (FldNam.Value != "") {  							dblLowVal = Convert.ToDouble (FldNam.Value);  							intLowIdx = FldNam.FieldIndex;  						}  					}  				}  			}  		}  		if (intHighIdx > -1 && intLowIdx > -1) {  			double len = ((ICurve)(lineFeature.Shape as IPolyline)).Length;  			double splitDist = Globals.PointDistanceOnLine (pHitPnt' lineFeature.Shape as IPolyline' 2' out pHitPnt);  			double percentSplit = splitDist / len;  			if (SplitFormatString == "") {  				dblMidVal = dblLowVal + ((dblHighVal - dblLowVal) * percentSplit);  			} else {  				dblMidVal = Convert.ToDouble (string.Format (SplitFormatString' dblLowVal + ((dblHighVal - dblLowVal) * percentSplit)));  			}  		}  		//Split feature  		try {  			if (trySplitUpdateFirst == true) {  				pSet = featureEdit.SplitWithUpdate (pHitPnt);  			} else {  				try {  					pSet = featureEdit.Split (pHitPnt);  				} catch (Exception ex) {  					pSet = featureEdit.SplitWithUpdate (pHitPnt);  				}  			}  			//pSet = featureEdit.SplitWithUpdate(pHitPnt);  		} catch (Exception ex) {  			try {  				pSet = featureEdit.Split (pHitPnt);  			} catch (Exception exInner) {  				return null;  			}  		}  		if (intHighIdx > -1 && intLowIdx > -1) {  			if (pSet.Count == 1) {  				while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  					if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  						pSplitResFeat.set_Value (intHighIdx' dblMidVal);  					} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  						pSplitResFeat.set_Value (intLowIdx' dblMidVal);  					}  				}  				if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  					lineFeature.set_Value (intHighIdx' dblMidVal);  				} else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  					lineFeature.set_Value (intLowIdx' dblMidVal);  				}  			} else if (pSet.Count == 2) {  				while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  					if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  						pSplitResFeat.set_Value (intHighIdx' dblMidVal);  					} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  						pSplitResFeat.set_Value (intLowIdx' dblMidVal);  					}  				}  				//if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y)  				//{  				//    lineFeature.set_Value(intHighIdx' dblMidVal);  				//}  				//else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y)  				//{  				//    lineFeature.set_Value(intLowIdx' dblMidVal);  				//}  			}  		}  	}  	return pSet;  } catch (Exception ex) {  	return null;  } finally {  	hitTest = null;  	featureEdit = null;  	pHitPnt = null;  	pTopoOp = null;  	pPoly = null;  	pRelOp = null;  	pCurve = null;  	//pSet = null;  	pSplitResFeat = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The following statement contains a magic number: try {  	featureEdit = lineFeature as IFeatureEdit2;  	hitTest = lineFeature.ShapeCopy as IHitTest;  	pHitPnt = new PointClass ();  	double pHitDist = -1;  	int pHitPrt = -1;  	int pHitSeg = -1;  	bool pHitSide = false;  	bool hit = hitTest.HitTest (SplitPoint' SnapTol' esriGeometryHitPartType.esriGeometryPartBoundary' pHitPnt' pHitDist' pHitPrt' pHitSeg' pHitSide);  	double dblMidVal = -1;  	if (hit) {  		pCurve = lineFeature.ShapeCopy as ICurve;  		//Split feature  		pTopoOp = pHitPnt as ITopologicalOperator;  		pPoly = pTopoOp.Buffer (Globals.ConvertFeetToMapUnits (.1' app) * 2) as IPolygon;  		pRelOp = pPoly as IRelationalOperator;  		if (pRelOp != null) {  			if ((pRelOp.Contains (pCurve.FromPoint)) || (pRelOp.Contains (pCurve.ToPoint))) {  				return null;  			}  		} else {  			pRelOp = pHitPnt as IRelationalOperator;  			if ((pRelOp.Contains (pCurve.FromPoint)) || (pRelOp.Contains (pCurve.ToPoint))) {  				return null;  			}  		}  		//Split feature  		//Globals.FlashGeometry(pHitPnt' Globals.GetColor(255' 0' 0)' mxdoc.ActiveView.ScreenDisplay' 150);  		double dblHighVal = 0;  		double dblLowVal = 0;  		int intHighIdx = -1;  		int intLowIdx = -1;  		if (pFldsNames != null) {  			foreach (MergeSplitFlds FldNam in pFldsNames) {  				FldNam.Value = lineFeature.get_Value (FldNam.FieldIndex).ToString ();  				if (FldNam.SplitType.ToUpper () == "MAX") {  					if (FldNam.Value != null) {  						if (FldNam.Value != "") {  							dblHighVal = Convert.ToDouble (FldNam.Value);  							intHighIdx = FldNam.FieldIndex;  						}  					}  				} else if (FldNam.SplitType.ToUpper () == "MIN") {  					if (FldNam.Value != null) {  						if (FldNam.Value != "") {  							dblLowVal = Convert.ToDouble (FldNam.Value);  							intLowIdx = FldNam.FieldIndex;  						}  					}  				}  			}  		}  		if (intHighIdx > -1 && intLowIdx > -1) {  			double len = ((ICurve)(lineFeature.Shape as IPolyline)).Length;  			double splitDist = Globals.PointDistanceOnLine (pHitPnt' lineFeature.Shape as IPolyline' 2' out pHitPnt);  			double percentSplit = splitDist / len;  			if (SplitFormatString == "") {  				dblMidVal = dblLowVal + ((dblHighVal - dblLowVal) * percentSplit);  			} else {  				dblMidVal = Convert.ToDouble (string.Format (SplitFormatString' dblLowVal + ((dblHighVal - dblLowVal) * percentSplit)));  			}  		}  		//Split feature  		try {  			if (trySplitUpdateFirst == true) {  				pSet = featureEdit.SplitWithUpdate (pHitPnt);  			} else {  				try {  					pSet = featureEdit.Split (pHitPnt);  				} catch (Exception ex) {  					pSet = featureEdit.SplitWithUpdate (pHitPnt);  				}  			}  			//pSet = featureEdit.SplitWithUpdate(pHitPnt);  		} catch (Exception ex) {  			try {  				pSet = featureEdit.Split (pHitPnt);  			} catch (Exception exInner) {  				return null;  			}  		}  		if (intHighIdx > -1 && intLowIdx > -1) {  			if (pSet.Count == 1) {  				while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  					if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  						pSplitResFeat.set_Value (intHighIdx' dblMidVal);  					} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  						pSplitResFeat.set_Value (intLowIdx' dblMidVal);  					}  				}  				if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  					lineFeature.set_Value (intHighIdx' dblMidVal);  				} else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  					lineFeature.set_Value (intLowIdx' dblMidVal);  				}  			} else if (pSet.Count == 2) {  				while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  					if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  						pSplitResFeat.set_Value (intHighIdx' dblMidVal);  					} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  						pSplitResFeat.set_Value (intLowIdx' dblMidVal);  					}  				}  				//if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y)  				//{  				//    lineFeature.set_Value(intHighIdx' dblMidVal);  				//}  				//else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y)  				//{  				//    lineFeature.set_Value(intLowIdx' dblMidVal);  				//}  			}  		}  	}  	return pSet;  } catch (Exception ex) {  	return null;  } finally {  	hitTest = null;  	featureEdit = null;  	pHitPnt = null;  	pTopoOp = null;  	pPoly = null;  	pRelOp = null;  	pCurve = null;  	//pSet = null;  	pSplitResFeat = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The following statement contains a magic number: try {  	featureEdit = lineFeature as IFeatureEdit2;  	hitTest = lineFeature.ShapeCopy as IHitTest;  	pHitPnt = new PointClass ();  	double pHitDist = -1;  	int pHitPrt = -1;  	int pHitSeg = -1;  	bool pHitSide = false;  	bool hit = hitTest.HitTest (SplitPoint' SnapTol' esriGeometryHitPartType.esriGeometryPartBoundary' pHitPnt' pHitDist' pHitPrt' pHitSeg' pHitSide);  	double dblMidVal = -1;  	if (hit) {  		pCurve = lineFeature.ShapeCopy as ICurve;  		//Split feature  		pTopoOp = pHitPnt as ITopologicalOperator;  		pPoly = pTopoOp.Buffer (Globals.ConvertFeetToMapUnits (.1' app) * 2) as IPolygon;  		pRelOp = pPoly as IRelationalOperator;  		if (pRelOp != null) {  			if ((pRelOp.Contains (pCurve.FromPoint)) || (pRelOp.Contains (pCurve.ToPoint))) {  				return null;  			}  		} else {  			pRelOp = pHitPnt as IRelationalOperator;  			if ((pRelOp.Contains (pCurve.FromPoint)) || (pRelOp.Contains (pCurve.ToPoint))) {  				return null;  			}  		}  		//Split feature  		//Globals.FlashGeometry(pHitPnt' Globals.GetColor(255' 0' 0)' mxdoc.ActiveView.ScreenDisplay' 150);  		double dblHighVal = 0;  		double dblLowVal = 0;  		int intHighIdx = -1;  		int intLowIdx = -1;  		if (pFldsNames != null) {  			foreach (MergeSplitFlds FldNam in pFldsNames) {  				FldNam.Value = lineFeature.get_Value (FldNam.FieldIndex).ToString ();  				if (FldNam.SplitType.ToUpper () == "MAX") {  					if (FldNam.Value != null) {  						if (FldNam.Value != "") {  							dblHighVal = Convert.ToDouble (FldNam.Value);  							intHighIdx = FldNam.FieldIndex;  						}  					}  				} else if (FldNam.SplitType.ToUpper () == "MIN") {  					if (FldNam.Value != null) {  						if (FldNam.Value != "") {  							dblLowVal = Convert.ToDouble (FldNam.Value);  							intLowIdx = FldNam.FieldIndex;  						}  					}  				}  			}  		}  		if (intHighIdx > -1 && intLowIdx > -1) {  			double len = ((ICurve)(lineFeature.Shape as IPolyline)).Length;  			double splitDist = Globals.PointDistanceOnLine (pHitPnt' lineFeature.Shape as IPolyline' 2' out pHitPnt);  			double percentSplit = splitDist / len;  			if (SplitFormatString == "") {  				dblMidVal = dblLowVal + ((dblHighVal - dblLowVal) * percentSplit);  			} else {  				dblMidVal = Convert.ToDouble (string.Format (SplitFormatString' dblLowVal + ((dblHighVal - dblLowVal) * percentSplit)));  			}  		}  		//Split feature  		try {  			if (trySplitUpdateFirst == true) {  				pSet = featureEdit.SplitWithUpdate (pHitPnt);  			} else {  				try {  					pSet = featureEdit.Split (pHitPnt);  				} catch (Exception ex) {  					pSet = featureEdit.SplitWithUpdate (pHitPnt);  				}  			}  			//pSet = featureEdit.SplitWithUpdate(pHitPnt);  		} catch (Exception ex) {  			try {  				pSet = featureEdit.Split (pHitPnt);  			} catch (Exception exInner) {  				return null;  			}  		}  		if (intHighIdx > -1 && intLowIdx > -1) {  			if (pSet.Count == 1) {  				while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  					if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  						pSplitResFeat.set_Value (intHighIdx' dblMidVal);  					} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  						pSplitResFeat.set_Value (intLowIdx' dblMidVal);  					}  				}  				if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  					lineFeature.set_Value (intHighIdx' dblMidVal);  				} else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  					lineFeature.set_Value (intLowIdx' dblMidVal);  				}  			} else if (pSet.Count == 2) {  				while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  					if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  						pSplitResFeat.set_Value (intHighIdx' dblMidVal);  					} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  						pSplitResFeat.set_Value (intLowIdx' dblMidVal);  					}  				}  				//if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y)  				//{  				//    lineFeature.set_Value(intHighIdx' dblMidVal);  				//}  				//else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y)  				//{  				//    lineFeature.set_Value(intLowIdx' dblMidVal);  				//}  			}  		}  	}  	return pSet;  } catch (Exception ex) {  	return null;  } finally {  	hitTest = null;  	featureEdit = null;  	pHitPnt = null;  	pTopoOp = null;  	pPoly = null;  	pRelOp = null;  	pCurve = null;  	//pSet = null;  	pSplitResFeat = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The following statement contains a magic number: try {  	featureEdit = lineFeature as IFeatureEdit2;  	hitTest = lineFeature.ShapeCopy as IHitTest;  	pHitPnt = new PointClass ();  	double pHitDist = -1;  	int pHitPrt = -1;  	int pHitSeg = -1;  	bool pHitSide = false;  	bool hit = hitTest.HitTest (SplitPoint' SnapTol' esriGeometryHitPartType.esriGeometryPartBoundary' pHitPnt' pHitDist' pHitPrt' pHitSeg' pHitSide);  	double dblMidVal = -1;  	if (hit) {  		pCurve = lineFeature.ShapeCopy as ICurve;  		//Split feature  		pTopoOp = pHitPnt as ITopologicalOperator;  		pPoly = pTopoOp.Buffer (Globals.ConvertFeetToMapUnits (.1' app) * 2) as IPolygon;  		pRelOp = pPoly as IRelationalOperator;  		if (pRelOp != null) {  			if ((pRelOp.Contains (pCurve.FromPoint)) || (pRelOp.Contains (pCurve.ToPoint))) {  				return null;  			}  		} else {  			pRelOp = pHitPnt as IRelationalOperator;  			if ((pRelOp.Contains (pCurve.FromPoint)) || (pRelOp.Contains (pCurve.ToPoint))) {  				return null;  			}  		}  		//Split feature  		//Globals.FlashGeometry(pHitPnt' Globals.GetColor(255' 0' 0)' mxdoc.ActiveView.ScreenDisplay' 150);  		double dblHighVal = 0;  		double dblLowVal = 0;  		int intHighIdx = -1;  		int intLowIdx = -1;  		if (pFldsNames != null) {  			foreach (MergeSplitFlds FldNam in pFldsNames) {  				FldNam.Value = lineFeature.get_Value (FldNam.FieldIndex).ToString ();  				if (FldNam.SplitType.ToUpper () == "MAX") {  					if (FldNam.Value != null) {  						if (FldNam.Value != "") {  							dblHighVal = Convert.ToDouble (FldNam.Value);  							intHighIdx = FldNam.FieldIndex;  						}  					}  				} else if (FldNam.SplitType.ToUpper () == "MIN") {  					if (FldNam.Value != null) {  						if (FldNam.Value != "") {  							dblLowVal = Convert.ToDouble (FldNam.Value);  							intLowIdx = FldNam.FieldIndex;  						}  					}  				}  			}  		}  		if (intHighIdx > -1 && intLowIdx > -1) {  			double len = ((ICurve)(lineFeature.Shape as IPolyline)).Length;  			double splitDist = Globals.PointDistanceOnLine (pHitPnt' lineFeature.Shape as IPolyline' 2' out pHitPnt);  			double percentSplit = splitDist / len;  			if (SplitFormatString == "") {  				dblMidVal = dblLowVal + ((dblHighVal - dblLowVal) * percentSplit);  			} else {  				dblMidVal = Convert.ToDouble (string.Format (SplitFormatString' dblLowVal + ((dblHighVal - dblLowVal) * percentSplit)));  			}  		}  		//Split feature  		try {  			if (trySplitUpdateFirst == true) {  				pSet = featureEdit.SplitWithUpdate (pHitPnt);  			} else {  				try {  					pSet = featureEdit.Split (pHitPnt);  				} catch (Exception ex) {  					pSet = featureEdit.SplitWithUpdate (pHitPnt);  				}  			}  			//pSet = featureEdit.SplitWithUpdate(pHitPnt);  		} catch (Exception ex) {  			try {  				pSet = featureEdit.Split (pHitPnt);  			} catch (Exception exInner) {  				return null;  			}  		}  		if (intHighIdx > -1 && intLowIdx > -1) {  			if (pSet.Count == 1) {  				while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  					if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  						pSplitResFeat.set_Value (intHighIdx' dblMidVal);  					} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  						pSplitResFeat.set_Value (intLowIdx' dblMidVal);  					}  				}  				if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  					lineFeature.set_Value (intHighIdx' dblMidVal);  				} else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  					lineFeature.set_Value (intLowIdx' dblMidVal);  				}  			} else if (pSet.Count == 2) {  				while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  					if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  						pSplitResFeat.set_Value (intHighIdx' dblMidVal);  					} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  						pSplitResFeat.set_Value (intLowIdx' dblMidVal);  					}  				}  				//if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y)  				//{  				//    lineFeature.set_Value(intHighIdx' dblMidVal);  				//}  				//else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y)  				//{  				//    lineFeature.set_Value(intLowIdx' dblMidVal);  				//}  			}  		}  	}  	return pSet;  } catch (Exception ex) {  	return null;  } finally {  	hitTest = null;  	featureEdit = null;  	pHitPnt = null;  	pTopoOp = null;  	pPoly = null;  	pRelOp = null;  	pCurve = null;  	//pSet = null;  	pSplitResFeat = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The following statement contains a magic number: if (hit) {  	pCurve = lineFeature.ShapeCopy as ICurve;  	//Split feature  	pTopoOp = pHitPnt as ITopologicalOperator;  	pPoly = pTopoOp.Buffer (Globals.ConvertFeetToMapUnits (.1' app) * 2) as IPolygon;  	pRelOp = pPoly as IRelationalOperator;  	if (pRelOp != null) {  		if ((pRelOp.Contains (pCurve.FromPoint)) || (pRelOp.Contains (pCurve.ToPoint))) {  			return null;  		}  	} else {  		pRelOp = pHitPnt as IRelationalOperator;  		if ((pRelOp.Contains (pCurve.FromPoint)) || (pRelOp.Contains (pCurve.ToPoint))) {  			return null;  		}  	}  	//Split feature  	//Globals.FlashGeometry(pHitPnt' Globals.GetColor(255' 0' 0)' mxdoc.ActiveView.ScreenDisplay' 150);  	double dblHighVal = 0;  	double dblLowVal = 0;  	int intHighIdx = -1;  	int intLowIdx = -1;  	if (pFldsNames != null) {  		foreach (MergeSplitFlds FldNam in pFldsNames) {  			FldNam.Value = lineFeature.get_Value (FldNam.FieldIndex).ToString ();  			if (FldNam.SplitType.ToUpper () == "MAX") {  				if (FldNam.Value != null) {  					if (FldNam.Value != "") {  						dblHighVal = Convert.ToDouble (FldNam.Value);  						intHighIdx = FldNam.FieldIndex;  					}  				}  			} else if (FldNam.SplitType.ToUpper () == "MIN") {  				if (FldNam.Value != null) {  					if (FldNam.Value != "") {  						dblLowVal = Convert.ToDouble (FldNam.Value);  						intLowIdx = FldNam.FieldIndex;  					}  				}  			}  		}  	}  	if (intHighIdx > -1 && intLowIdx > -1) {  		double len = ((ICurve)(lineFeature.Shape as IPolyline)).Length;  		double splitDist = Globals.PointDistanceOnLine (pHitPnt' lineFeature.Shape as IPolyline' 2' out pHitPnt);  		double percentSplit = splitDist / len;  		if (SplitFormatString == "") {  			dblMidVal = dblLowVal + ((dblHighVal - dblLowVal) * percentSplit);  		} else {  			dblMidVal = Convert.ToDouble (string.Format (SplitFormatString' dblLowVal + ((dblHighVal - dblLowVal) * percentSplit)));  		}  	}  	//Split feature  	try {  		if (trySplitUpdateFirst == true) {  			pSet = featureEdit.SplitWithUpdate (pHitPnt);  		} else {  			try {  				pSet = featureEdit.Split (pHitPnt);  			} catch (Exception ex) {  				pSet = featureEdit.SplitWithUpdate (pHitPnt);  			}  		}  		//pSet = featureEdit.SplitWithUpdate(pHitPnt);  	} catch (Exception ex) {  		try {  			pSet = featureEdit.Split (pHitPnt);  		} catch (Exception exInner) {  			return null;  		}  	}  	if (intHighIdx > -1 && intLowIdx > -1) {  		if (pSet.Count == 1) {  			while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  				if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  					pSplitResFeat.set_Value (intHighIdx' dblMidVal);  				} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  					pSplitResFeat.set_Value (intLowIdx' dblMidVal);  				}  			}  			if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  				lineFeature.set_Value (intHighIdx' dblMidVal);  			} else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  				lineFeature.set_Value (intLowIdx' dblMidVal);  			}  		} else if (pSet.Count == 2) {  			while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  				if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  					pSplitResFeat.set_Value (intHighIdx' dblMidVal);  				} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  					pSplitResFeat.set_Value (intLowIdx' dblMidVal);  				}  			}  			//if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y)  			//{  			//    lineFeature.set_Value(intHighIdx' dblMidVal);  			//}  			//else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y)  			//{  			//    lineFeature.set_Value(intLowIdx' dblMidVal);  			//}  		}  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The following statement contains a magic number: if (hit) {  	pCurve = lineFeature.ShapeCopy as ICurve;  	//Split feature  	pTopoOp = pHitPnt as ITopologicalOperator;  	pPoly = pTopoOp.Buffer (Globals.ConvertFeetToMapUnits (.1' app) * 2) as IPolygon;  	pRelOp = pPoly as IRelationalOperator;  	if (pRelOp != null) {  		if ((pRelOp.Contains (pCurve.FromPoint)) || (pRelOp.Contains (pCurve.ToPoint))) {  			return null;  		}  	} else {  		pRelOp = pHitPnt as IRelationalOperator;  		if ((pRelOp.Contains (pCurve.FromPoint)) || (pRelOp.Contains (pCurve.ToPoint))) {  			return null;  		}  	}  	//Split feature  	//Globals.FlashGeometry(pHitPnt' Globals.GetColor(255' 0' 0)' mxdoc.ActiveView.ScreenDisplay' 150);  	double dblHighVal = 0;  	double dblLowVal = 0;  	int intHighIdx = -1;  	int intLowIdx = -1;  	if (pFldsNames != null) {  		foreach (MergeSplitFlds FldNam in pFldsNames) {  			FldNam.Value = lineFeature.get_Value (FldNam.FieldIndex).ToString ();  			if (FldNam.SplitType.ToUpper () == "MAX") {  				if (FldNam.Value != null) {  					if (FldNam.Value != "") {  						dblHighVal = Convert.ToDouble (FldNam.Value);  						intHighIdx = FldNam.FieldIndex;  					}  				}  			} else if (FldNam.SplitType.ToUpper () == "MIN") {  				if (FldNam.Value != null) {  					if (FldNam.Value != "") {  						dblLowVal = Convert.ToDouble (FldNam.Value);  						intLowIdx = FldNam.FieldIndex;  					}  				}  			}  		}  	}  	if (intHighIdx > -1 && intLowIdx > -1) {  		double len = ((ICurve)(lineFeature.Shape as IPolyline)).Length;  		double splitDist = Globals.PointDistanceOnLine (pHitPnt' lineFeature.Shape as IPolyline' 2' out pHitPnt);  		double percentSplit = splitDist / len;  		if (SplitFormatString == "") {  			dblMidVal = dblLowVal + ((dblHighVal - dblLowVal) * percentSplit);  		} else {  			dblMidVal = Convert.ToDouble (string.Format (SplitFormatString' dblLowVal + ((dblHighVal - dblLowVal) * percentSplit)));  		}  	}  	//Split feature  	try {  		if (trySplitUpdateFirst == true) {  			pSet = featureEdit.SplitWithUpdate (pHitPnt);  		} else {  			try {  				pSet = featureEdit.Split (pHitPnt);  			} catch (Exception ex) {  				pSet = featureEdit.SplitWithUpdate (pHitPnt);  			}  		}  		//pSet = featureEdit.SplitWithUpdate(pHitPnt);  	} catch (Exception ex) {  		try {  			pSet = featureEdit.Split (pHitPnt);  		} catch (Exception exInner) {  			return null;  		}  	}  	if (intHighIdx > -1 && intLowIdx > -1) {  		if (pSet.Count == 1) {  			while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  				if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  					pSplitResFeat.set_Value (intHighIdx' dblMidVal);  				} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  					pSplitResFeat.set_Value (intLowIdx' dblMidVal);  				}  			}  			if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  				lineFeature.set_Value (intHighIdx' dblMidVal);  			} else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  				lineFeature.set_Value (intLowIdx' dblMidVal);  			}  		} else if (pSet.Count == 2) {  			while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  				if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  					pSplitResFeat.set_Value (intHighIdx' dblMidVal);  				} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  					pSplitResFeat.set_Value (intLowIdx' dblMidVal);  				}  			}  			//if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y)  			//{  			//    lineFeature.set_Value(intHighIdx' dblMidVal);  			//}  			//else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y)  			//{  			//    lineFeature.set_Value(intLowIdx' dblMidVal);  			//}  		}  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The following statement contains a magic number: if (hit) {  	pCurve = lineFeature.ShapeCopy as ICurve;  	//Split feature  	pTopoOp = pHitPnt as ITopologicalOperator;  	pPoly = pTopoOp.Buffer (Globals.ConvertFeetToMapUnits (.1' app) * 2) as IPolygon;  	pRelOp = pPoly as IRelationalOperator;  	if (pRelOp != null) {  		if ((pRelOp.Contains (pCurve.FromPoint)) || (pRelOp.Contains (pCurve.ToPoint))) {  			return null;  		}  	} else {  		pRelOp = pHitPnt as IRelationalOperator;  		if ((pRelOp.Contains (pCurve.FromPoint)) || (pRelOp.Contains (pCurve.ToPoint))) {  			return null;  		}  	}  	//Split feature  	//Globals.FlashGeometry(pHitPnt' Globals.GetColor(255' 0' 0)' mxdoc.ActiveView.ScreenDisplay' 150);  	double dblHighVal = 0;  	double dblLowVal = 0;  	int intHighIdx = -1;  	int intLowIdx = -1;  	if (pFldsNames != null) {  		foreach (MergeSplitFlds FldNam in pFldsNames) {  			FldNam.Value = lineFeature.get_Value (FldNam.FieldIndex).ToString ();  			if (FldNam.SplitType.ToUpper () == "MAX") {  				if (FldNam.Value != null) {  					if (FldNam.Value != "") {  						dblHighVal = Convert.ToDouble (FldNam.Value);  						intHighIdx = FldNam.FieldIndex;  					}  				}  			} else if (FldNam.SplitType.ToUpper () == "MIN") {  				if (FldNam.Value != null) {  					if (FldNam.Value != "") {  						dblLowVal = Convert.ToDouble (FldNam.Value);  						intLowIdx = FldNam.FieldIndex;  					}  				}  			}  		}  	}  	if (intHighIdx > -1 && intLowIdx > -1) {  		double len = ((ICurve)(lineFeature.Shape as IPolyline)).Length;  		double splitDist = Globals.PointDistanceOnLine (pHitPnt' lineFeature.Shape as IPolyline' 2' out pHitPnt);  		double percentSplit = splitDist / len;  		if (SplitFormatString == "") {  			dblMidVal = dblLowVal + ((dblHighVal - dblLowVal) * percentSplit);  		} else {  			dblMidVal = Convert.ToDouble (string.Format (SplitFormatString' dblLowVal + ((dblHighVal - dblLowVal) * percentSplit)));  		}  	}  	//Split feature  	try {  		if (trySplitUpdateFirst == true) {  			pSet = featureEdit.SplitWithUpdate (pHitPnt);  		} else {  			try {  				pSet = featureEdit.Split (pHitPnt);  			} catch (Exception ex) {  				pSet = featureEdit.SplitWithUpdate (pHitPnt);  			}  		}  		//pSet = featureEdit.SplitWithUpdate(pHitPnt);  	} catch (Exception ex) {  		try {  			pSet = featureEdit.Split (pHitPnt);  		} catch (Exception exInner) {  			return null;  		}  	}  	if (intHighIdx > -1 && intLowIdx > -1) {  		if (pSet.Count == 1) {  			while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  				if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  					pSplitResFeat.set_Value (intHighIdx' dblMidVal);  				} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  					pSplitResFeat.set_Value (intLowIdx' dblMidVal);  				}  			}  			if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  				lineFeature.set_Value (intHighIdx' dblMidVal);  			} else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  				lineFeature.set_Value (intLowIdx' dblMidVal);  			}  		} else if (pSet.Count == 2) {  			while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  				if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  					pSplitResFeat.set_Value (intHighIdx' dblMidVal);  				} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  					pSplitResFeat.set_Value (intLowIdx' dblMidVal);  				}  			}  			//if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y)  			//{  			//    lineFeature.set_Value(intHighIdx' dblMidVal);  			//}  			//else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y)  			//{  			//    lineFeature.set_Value(intLowIdx' dblMidVal);  			//}  		}  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The following statement contains a magic number: if (hit) {  	pCurve = lineFeature.ShapeCopy as ICurve;  	//Split feature  	pTopoOp = pHitPnt as ITopologicalOperator;  	pPoly = pTopoOp.Buffer (Globals.ConvertFeetToMapUnits (.1' app) * 2) as IPolygon;  	pRelOp = pPoly as IRelationalOperator;  	if (pRelOp != null) {  		if ((pRelOp.Contains (pCurve.FromPoint)) || (pRelOp.Contains (pCurve.ToPoint))) {  			return null;  		}  	} else {  		pRelOp = pHitPnt as IRelationalOperator;  		if ((pRelOp.Contains (pCurve.FromPoint)) || (pRelOp.Contains (pCurve.ToPoint))) {  			return null;  		}  	}  	//Split feature  	//Globals.FlashGeometry(pHitPnt' Globals.GetColor(255' 0' 0)' mxdoc.ActiveView.ScreenDisplay' 150);  	double dblHighVal = 0;  	double dblLowVal = 0;  	int intHighIdx = -1;  	int intLowIdx = -1;  	if (pFldsNames != null) {  		foreach (MergeSplitFlds FldNam in pFldsNames) {  			FldNam.Value = lineFeature.get_Value (FldNam.FieldIndex).ToString ();  			if (FldNam.SplitType.ToUpper () == "MAX") {  				if (FldNam.Value != null) {  					if (FldNam.Value != "") {  						dblHighVal = Convert.ToDouble (FldNam.Value);  						intHighIdx = FldNam.FieldIndex;  					}  				}  			} else if (FldNam.SplitType.ToUpper () == "MIN") {  				if (FldNam.Value != null) {  					if (FldNam.Value != "") {  						dblLowVal = Convert.ToDouble (FldNam.Value);  						intLowIdx = FldNam.FieldIndex;  					}  				}  			}  		}  	}  	if (intHighIdx > -1 && intLowIdx > -1) {  		double len = ((ICurve)(lineFeature.Shape as IPolyline)).Length;  		double splitDist = Globals.PointDistanceOnLine (pHitPnt' lineFeature.Shape as IPolyline' 2' out pHitPnt);  		double percentSplit = splitDist / len;  		if (SplitFormatString == "") {  			dblMidVal = dblLowVal + ((dblHighVal - dblLowVal) * percentSplit);  		} else {  			dblMidVal = Convert.ToDouble (string.Format (SplitFormatString' dblLowVal + ((dblHighVal - dblLowVal) * percentSplit)));  		}  	}  	//Split feature  	try {  		if (trySplitUpdateFirst == true) {  			pSet = featureEdit.SplitWithUpdate (pHitPnt);  		} else {  			try {  				pSet = featureEdit.Split (pHitPnt);  			} catch (Exception ex) {  				pSet = featureEdit.SplitWithUpdate (pHitPnt);  			}  		}  		//pSet = featureEdit.SplitWithUpdate(pHitPnt);  	} catch (Exception ex) {  		try {  			pSet = featureEdit.Split (pHitPnt);  		} catch (Exception exInner) {  			return null;  		}  	}  	if (intHighIdx > -1 && intLowIdx > -1) {  		if (pSet.Count == 1) {  			while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  				if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  					pSplitResFeat.set_Value (intHighIdx' dblMidVal);  				} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  					pSplitResFeat.set_Value (intLowIdx' dblMidVal);  				}  			}  			if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  				lineFeature.set_Value (intHighIdx' dblMidVal);  			} else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  				lineFeature.set_Value (intLowIdx' dblMidVal);  			}  		} else if (pSet.Count == 2) {  			while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  				if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  					pSplitResFeat.set_Value (intHighIdx' dblMidVal);  				} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  					pSplitResFeat.set_Value (intLowIdx' dblMidVal);  				}  			}  			//if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y)  			//{  			//    lineFeature.set_Value(intHighIdx' dblMidVal);  			//}  			//else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y)  			//{  			//    lineFeature.set_Value(intLowIdx' dblMidVal);  			//}  		}  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The following statement contains a magic number: pPoly = pTopoOp.Buffer (Globals.ConvertFeetToMapUnits (.1' app) * 2) as IPolygon;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The following statement contains a magic number: pPoly = pTopoOp.Buffer (Globals.ConvertFeetToMapUnits (.1' app) * 2) as IPolygon;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The following statement contains a magic number: if (intHighIdx > -1 && intLowIdx > -1) {  	double len = ((ICurve)(lineFeature.Shape as IPolyline)).Length;  	double splitDist = Globals.PointDistanceOnLine (pHitPnt' lineFeature.Shape as IPolyline' 2' out pHitPnt);  	double percentSplit = splitDist / len;  	if (SplitFormatString == "") {  		dblMidVal = dblLowVal + ((dblHighVal - dblLowVal) * percentSplit);  	} else {  		dblMidVal = Convert.ToDouble (string.Format (SplitFormatString' dblLowVal + ((dblHighVal - dblLowVal) * percentSplit)));  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The following statement contains a magic number: if (intHighIdx > -1 && intLowIdx > -1) {  	if (pSet.Count == 1) {  		while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  			if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  				pSplitResFeat.set_Value (intHighIdx' dblMidVal);  			} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  				pSplitResFeat.set_Value (intLowIdx' dblMidVal);  			}  		}  		if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  			lineFeature.set_Value (intHighIdx' dblMidVal);  		} else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  			lineFeature.set_Value (intLowIdx' dblMidVal);  		}  	} else if (pSet.Count == 2) {  		while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  			if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  				pSplitResFeat.set_Value (intHighIdx' dblMidVal);  			} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  				pSplitResFeat.set_Value (intLowIdx' dblMidVal);  			}  		}  		//if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y)  		//{  		//    lineFeature.set_Value(intHighIdx' dblMidVal);  		//}  		//else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y)  		//{  		//    lineFeature.set_Value(intLowIdx' dblMidVal);  		//}  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The following statement contains a magic number: if (pSet.Count == 1) {  	while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  		if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  			pSplitResFeat.set_Value (intHighIdx' dblMidVal);  		} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  			pSplitResFeat.set_Value (intLowIdx' dblMidVal);  		}  	}  	if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  		lineFeature.set_Value (intHighIdx' dblMidVal);  	} else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  		lineFeature.set_Value (intLowIdx' dblMidVal);  	}  } else if (pSet.Count == 2) {  	while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  		if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  			pSplitResFeat.set_Value (intHighIdx' dblMidVal);  		} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  			pSplitResFeat.set_Value (intLowIdx' dblMidVal);  		}  	}  	//if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y)  	//{  	//    lineFeature.set_Value(intHighIdx' dblMidVal);  	//}  	//else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y)  	//{  	//    lineFeature.set_Value(intLowIdx' dblMidVal);  	//}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,splitLineWithPoint,The following statement contains a magic number: if (pSet.Count == 2) {  	while ((pSplitResFeat = pSet.Next () as IFeature) != null) {  		if ((pSplitResFeat.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y) {  			pSplitResFeat.set_Value (intHighIdx' dblMidVal);  		} else if ((pSplitResFeat.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (pSplitResFeat.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y) {  			pSplitResFeat.set_Value (intLowIdx' dblMidVal);  		}  	}  	//if ((lineFeature.ShapeCopy as IPolyline).FromPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).FromPoint.Y == pHitPnt.Y)  	//{  	//    lineFeature.set_Value(intHighIdx' dblMidVal);  	//}  	//else if ((lineFeature.ShapeCopy as IPolyline).ToPoint.X == pHitPnt.X && (lineFeature.ShapeCopy as IPolyline).ToPoint.Y == pHitPnt.Y)  	//{  	//    lineFeature.set_Value(intLowIdx' dblMidVal);  	//}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: try {  	if (FeatureLayer == null)  		return .000001;  	if (FeatureLayer.FeatureClass == null)  		return .000001;  	if ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference == null)  		return .000001;  	hasXY = ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference).HasXYPrecision ();  	if (hasXY) {  		pSRResolution = ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference) as ISpatialReferenceResolution;  		double dblTol;  		dblTol = pSRResolution.get_XYResolution (false);  		if (dblTol < .0000000001) {  			dblTol = .00000001;  		}  		return dblTol;  	} else {  		return .000001;  	}  } catch {  	return .000001;  } finally {  	pSRResolution = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: try {  	if (FeatureLayer == null)  		return .000001;  	if (FeatureLayer.FeatureClass == null)  		return .000001;  	if ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference == null)  		return .000001;  	hasXY = ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference).HasXYPrecision ();  	if (hasXY) {  		pSRResolution = ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference) as ISpatialReferenceResolution;  		double dblTol;  		dblTol = pSRResolution.get_XYResolution (false);  		if (dblTol < .0000000001) {  			dblTol = .00000001;  		}  		return dblTol;  	} else {  		return .000001;  	}  } catch {  	return .000001;  } finally {  	pSRResolution = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: try {  	if (FeatureLayer == null)  		return .000001;  	if (FeatureLayer.FeatureClass == null)  		return .000001;  	if ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference == null)  		return .000001;  	hasXY = ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference).HasXYPrecision ();  	if (hasXY) {  		pSRResolution = ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference) as ISpatialReferenceResolution;  		double dblTol;  		dblTol = pSRResolution.get_XYResolution (false);  		if (dblTol < .0000000001) {  			dblTol = .00000001;  		}  		return dblTol;  	} else {  		return .000001;  	}  } catch {  	return .000001;  } finally {  	pSRResolution = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: try {  	if (FeatureLayer == null)  		return .000001;  	if (FeatureLayer.FeatureClass == null)  		return .000001;  	if ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference == null)  		return .000001;  	hasXY = ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference).HasXYPrecision ();  	if (hasXY) {  		pSRResolution = ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference) as ISpatialReferenceResolution;  		double dblTol;  		dblTol = pSRResolution.get_XYResolution (false);  		if (dblTol < .0000000001) {  			dblTol = .00000001;  		}  		return dblTol;  	} else {  		return .000001;  	}  } catch {  	return .000001;  } finally {  	pSRResolution = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: try {  	if (FeatureLayer == null)  		return .000001;  	if (FeatureLayer.FeatureClass == null)  		return .000001;  	if ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference == null)  		return .000001;  	hasXY = ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference).HasXYPrecision ();  	if (hasXY) {  		pSRResolution = ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference) as ISpatialReferenceResolution;  		double dblTol;  		dblTol = pSRResolution.get_XYResolution (false);  		if (dblTol < .0000000001) {  			dblTol = .00000001;  		}  		return dblTol;  	} else {  		return .000001;  	}  } catch {  	return .000001;  } finally {  	pSRResolution = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: try {  	if (FeatureLayer == null)  		return .000001;  	if (FeatureLayer.FeatureClass == null)  		return .000001;  	if ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference == null)  		return .000001;  	hasXY = ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference).HasXYPrecision ();  	if (hasXY) {  		pSRResolution = ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference) as ISpatialReferenceResolution;  		double dblTol;  		dblTol = pSRResolution.get_XYResolution (false);  		if (dblTol < .0000000001) {  			dblTol = .00000001;  		}  		return dblTol;  	} else {  		return .000001;  	}  } catch {  	return .000001;  } finally {  	pSRResolution = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: try {  	if (FeatureLayer == null)  		return .000001;  	if (FeatureLayer.FeatureClass == null)  		return .000001;  	if ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference == null)  		return .000001;  	hasXY = ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference).HasXYPrecision ();  	if (hasXY) {  		pSRResolution = ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference) as ISpatialReferenceResolution;  		double dblTol;  		dblTol = pSRResolution.get_XYResolution (false);  		if (dblTol < .0000000001) {  			dblTol = .00000001;  		}  		return dblTol;  	} else {  		return .000001;  	}  } catch {  	return .000001;  } finally {  	pSRResolution = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (FeatureLayer == null)  	return .000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: return .000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (FeatureLayer.FeatureClass == null)  	return .000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: return .000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference == null)  	return .000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: return .000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (hasXY) {  	pSRResolution = ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference) as ISpatialReferenceResolution;  	double dblTol;  	dblTol = pSRResolution.get_XYResolution (false);  	if (dblTol < .0000000001) {  		dblTol = .00000001;  	}  	return dblTol;  } else {  	return .000001;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (hasXY) {  	pSRResolution = ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference) as ISpatialReferenceResolution;  	double dblTol;  	dblTol = pSRResolution.get_XYResolution (false);  	if (dblTol < .0000000001) {  		dblTol = .00000001;  	}  	return dblTol;  } else {  	return .000001;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (hasXY) {  	pSRResolution = ((FeatureLayer.FeatureClass as IGeoDataset).SpatialReference) as ISpatialReferenceResolution;  	double dblTol;  	dblTol = pSRResolution.get_XYResolution (false);  	if (dblTol < .0000000001) {  		dblTol = .00000001;  	}  	return dblTol;  } else {  	return .000001;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (dblTol < .0000000001) {  	dblTol = .00000001;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (dblTol < .0000000001) {  	dblTol = .00000001;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: dblTol = .00000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: return .000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: return .000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,pointscoincident,The following statement contains a magic number: tol = tol * 2;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: try {  	if (Feature == null)  		return .000001;  	if (Feature.Shape.SpatialReference == null)  		return .000001;  	hasXY = (Feature.Shape.SpatialReference).HasXYPrecision ();  	if (hasXY) {  		pSRResolution = (Feature.Shape.SpatialReference) as ISpatialReferenceResolution;  		double dblTol;  		dblTol = pSRResolution.get_XYResolution (false);  		if (dblTol < .0000000001) {  			dblTol = .00000001;  		}  		return dblTol;  	} else {  		return .000001;  	}  } catch {  	return .000001;  } finally {  	pSRResolution = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: try {  	if (Feature == null)  		return .000001;  	if (Feature.Shape.SpatialReference == null)  		return .000001;  	hasXY = (Feature.Shape.SpatialReference).HasXYPrecision ();  	if (hasXY) {  		pSRResolution = (Feature.Shape.SpatialReference) as ISpatialReferenceResolution;  		double dblTol;  		dblTol = pSRResolution.get_XYResolution (false);  		if (dblTol < .0000000001) {  			dblTol = .00000001;  		}  		return dblTol;  	} else {  		return .000001;  	}  } catch {  	return .000001;  } finally {  	pSRResolution = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: try {  	if (Feature == null)  		return .000001;  	if (Feature.Shape.SpatialReference == null)  		return .000001;  	hasXY = (Feature.Shape.SpatialReference).HasXYPrecision ();  	if (hasXY) {  		pSRResolution = (Feature.Shape.SpatialReference) as ISpatialReferenceResolution;  		double dblTol;  		dblTol = pSRResolution.get_XYResolution (false);  		if (dblTol < .0000000001) {  			dblTol = .00000001;  		}  		return dblTol;  	} else {  		return .000001;  	}  } catch {  	return .000001;  } finally {  	pSRResolution = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: try {  	if (Feature == null)  		return .000001;  	if (Feature.Shape.SpatialReference == null)  		return .000001;  	hasXY = (Feature.Shape.SpatialReference).HasXYPrecision ();  	if (hasXY) {  		pSRResolution = (Feature.Shape.SpatialReference) as ISpatialReferenceResolution;  		double dblTol;  		dblTol = pSRResolution.get_XYResolution (false);  		if (dblTol < .0000000001) {  			dblTol = .00000001;  		}  		return dblTol;  	} else {  		return .000001;  	}  } catch {  	return .000001;  } finally {  	pSRResolution = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: try {  	if (Feature == null)  		return .000001;  	if (Feature.Shape.SpatialReference == null)  		return .000001;  	hasXY = (Feature.Shape.SpatialReference).HasXYPrecision ();  	if (hasXY) {  		pSRResolution = (Feature.Shape.SpatialReference) as ISpatialReferenceResolution;  		double dblTol;  		dblTol = pSRResolution.get_XYResolution (false);  		if (dblTol < .0000000001) {  			dblTol = .00000001;  		}  		return dblTol;  	} else {  		return .000001;  	}  } catch {  	return .000001;  } finally {  	pSRResolution = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: try {  	if (Feature == null)  		return .000001;  	if (Feature.Shape.SpatialReference == null)  		return .000001;  	hasXY = (Feature.Shape.SpatialReference).HasXYPrecision ();  	if (hasXY) {  		pSRResolution = (Feature.Shape.SpatialReference) as ISpatialReferenceResolution;  		double dblTol;  		dblTol = pSRResolution.get_XYResolution (false);  		if (dblTol < .0000000001) {  			dblTol = .00000001;  		}  		return dblTol;  	} else {  		return .000001;  	}  } catch {  	return .000001;  } finally {  	pSRResolution = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (Feature == null)  	return .000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: return .000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (Feature.Shape.SpatialReference == null)  	return .000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: return .000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (hasXY) {  	pSRResolution = (Feature.Shape.SpatialReference) as ISpatialReferenceResolution;  	double dblTol;  	dblTol = pSRResolution.get_XYResolution (false);  	if (dblTol < .0000000001) {  		dblTol = .00000001;  	}  	return dblTol;  } else {  	return .000001;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (hasXY) {  	pSRResolution = (Feature.Shape.SpatialReference) as ISpatialReferenceResolution;  	double dblTol;  	dblTol = pSRResolution.get_XYResolution (false);  	if (dblTol < .0000000001) {  		dblTol = .00000001;  	}  	return dblTol;  } else {  	return .000001;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (hasXY) {  	pSRResolution = (Feature.Shape.SpatialReference) as ISpatialReferenceResolution;  	double dblTol;  	dblTol = pSRResolution.get_XYResolution (false);  	if (dblTol < .0000000001) {  		dblTol = .00000001;  	}  	return dblTol;  } else {  	return .000001;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (dblTol < .0000000001) {  	dblTol = .00000001;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (dblTol < .0000000001) {  	dblTol = .00000001;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: dblTol = .00000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: return .000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: return .000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: try {  	if (Geo == null)  		return .000001;  	if (Geo.SpatialReference == null)  		return .000001;  	hasXY = (Geo.SpatialReference).HasXYPrecision ();  	if (hasXY) {  		pSRResolution = (Geo.SpatialReference) as ISpatialReferenceResolution;  		double dblTol;  		dblTol = pSRResolution.get_XYResolution (false);  		if (dblTol < .0000000001) {  			dblTol = .00000001;  		}  		return dblTol;  	} else {  		return .000001;  	}  } catch {  	return .000001;  } finally {  	pSRResolution = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: try {  	if (Geo == null)  		return .000001;  	if (Geo.SpatialReference == null)  		return .000001;  	hasXY = (Geo.SpatialReference).HasXYPrecision ();  	if (hasXY) {  		pSRResolution = (Geo.SpatialReference) as ISpatialReferenceResolution;  		double dblTol;  		dblTol = pSRResolution.get_XYResolution (false);  		if (dblTol < .0000000001) {  			dblTol = .00000001;  		}  		return dblTol;  	} else {  		return .000001;  	}  } catch {  	return .000001;  } finally {  	pSRResolution = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: try {  	if (Geo == null)  		return .000001;  	if (Geo.SpatialReference == null)  		return .000001;  	hasXY = (Geo.SpatialReference).HasXYPrecision ();  	if (hasXY) {  		pSRResolution = (Geo.SpatialReference) as ISpatialReferenceResolution;  		double dblTol;  		dblTol = pSRResolution.get_XYResolution (false);  		if (dblTol < .0000000001) {  			dblTol = .00000001;  		}  		return dblTol;  	} else {  		return .000001;  	}  } catch {  	return .000001;  } finally {  	pSRResolution = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: try {  	if (Geo == null)  		return .000001;  	if (Geo.SpatialReference == null)  		return .000001;  	hasXY = (Geo.SpatialReference).HasXYPrecision ();  	if (hasXY) {  		pSRResolution = (Geo.SpatialReference) as ISpatialReferenceResolution;  		double dblTol;  		dblTol = pSRResolution.get_XYResolution (false);  		if (dblTol < .0000000001) {  			dblTol = .00000001;  		}  		return dblTol;  	} else {  		return .000001;  	}  } catch {  	return .000001;  } finally {  	pSRResolution = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: try {  	if (Geo == null)  		return .000001;  	if (Geo.SpatialReference == null)  		return .000001;  	hasXY = (Geo.SpatialReference).HasXYPrecision ();  	if (hasXY) {  		pSRResolution = (Geo.SpatialReference) as ISpatialReferenceResolution;  		double dblTol;  		dblTol = pSRResolution.get_XYResolution (false);  		if (dblTol < .0000000001) {  			dblTol = .00000001;  		}  		return dblTol;  	} else {  		return .000001;  	}  } catch {  	return .000001;  } finally {  	pSRResolution = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: try {  	if (Geo == null)  		return .000001;  	if (Geo.SpatialReference == null)  		return .000001;  	hasXY = (Geo.SpatialReference).HasXYPrecision ();  	if (hasXY) {  		pSRResolution = (Geo.SpatialReference) as ISpatialReferenceResolution;  		double dblTol;  		dblTol = pSRResolution.get_XYResolution (false);  		if (dblTol < .0000000001) {  			dblTol = .00000001;  		}  		return dblTol;  	} else {  		return .000001;  	}  } catch {  	return .000001;  } finally {  	pSRResolution = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (Geo == null)  	return .000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: return .000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (Geo.SpatialReference == null)  	return .000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: return .000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (hasXY) {  	pSRResolution = (Geo.SpatialReference) as ISpatialReferenceResolution;  	double dblTol;  	dblTol = pSRResolution.get_XYResolution (false);  	if (dblTol < .0000000001) {  		dblTol = .00000001;  	}  	return dblTol;  } else {  	return .000001;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (hasXY) {  	pSRResolution = (Geo.SpatialReference) as ISpatialReferenceResolution;  	double dblTol;  	dblTol = pSRResolution.get_XYResolution (false);  	if (dblTol < .0000000001) {  		dblTol = .00000001;  	}  	return dblTol;  } else {  	return .000001;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (hasXY) {  	pSRResolution = (Geo.SpatialReference) as ISpatialReferenceResolution;  	double dblTol;  	dblTol = pSRResolution.get_XYResolution (false);  	if (dblTol < .0000000001) {  		dblTol = .00000001;  	}  	return dblTol;  } else {  	return .000001;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (dblTol < .0000000001) {  	dblTol = .00000001;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: if (dblTol < .0000000001) {  	dblTol = .00000001;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: dblTol = .00000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: return .000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetXYTolerance,The following statement contains a magic number: return .000001;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetGeomCenter,The following statement contains a magic number: try {  	switch (geo.GeometryType) {  	case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPoint:  		//pCenterPoint = geo as ESRI.ArcGIS.Geometry.IPoint;  		pCenterPoints.Add (geo as ESRI.ArcGIS.Geometry.IPoint);  		break;  	case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPolyline:  		pl = (ESRI.ArcGIS.Geometry.IPolyline)geo;  		pCenterPoint = new ESRI.ArcGIS.Geometry.Point ();  		//int prtIdx;  		//int segIdx;  		//bool bSplit;  		//pl.SplitAtDistance(50' true' false' out bSplit' out prtIdx' out segIdx);  		pl.QueryPoint (ESRI.ArcGIS.Geometry.esriSegmentExtension.esriNoExtension' .5' true' pCenterPoint);  		pCenterPoints.Add (pCenterPoint);  		pl = null;  		break;  	case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPolygon:  		pPoly = geo as ESRI.ArcGIS.Geometry.IPolygon4;  		pPoly.SimplifySpaghetti ();  		if (pPoly.ExteriorRingCount > 1) {  			//Comps = new IPolygon[pPoly.ExteriorRingCount];  			pGeoBag = pPoly.ConnectedComponentBag;  			enumGeometry = pGeoBag as IEnumGeometry;  			enumGeometry.Reset ();  			geometry = enumGeometry.Next ();  			while (geometry != null) {  				pArea = geometry as ESRI.ArcGIS.Geometry.IArea;  				pCenterPoint = pArea.Centroid;  				pCenterPoints.Add (pCenterPoint);  				geometry = enumGeometry.Next ();  			}  		} else {  			pArea = geo as ESRI.ArcGIS.Geometry.IArea;  			pCenterPoint = pArea.Centroid;  			pCenterPoints.Add (pCenterPoint);  			pArea = null;  		}  		break;  	}  	return pCenterPoints;  } catch (Exception ex) {  	MessageBox.Show ("Error in the Global Functions - GetGeomCenter" + Environment.NewLine + ex.ToString ());  	return null;  } finally {  	pCenterPoint = null;  	pArea = null;  	pl = null;  	pPoly = null;  	enumGeometry = null;  	geometry = null;  	pGeoBag = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetGeomCenter,The following statement contains a magic number: switch (geo.GeometryType) {  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPoint:  	//pCenterPoint = geo as ESRI.ArcGIS.Geometry.IPoint;  	pCenterPoints.Add (geo as ESRI.ArcGIS.Geometry.IPoint);  	break;  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPolyline:  	pl = (ESRI.ArcGIS.Geometry.IPolyline)geo;  	pCenterPoint = new ESRI.ArcGIS.Geometry.Point ();  	//int prtIdx;  	//int segIdx;  	//bool bSplit;  	//pl.SplitAtDistance(50' true' false' out bSplit' out prtIdx' out segIdx);  	pl.QueryPoint (ESRI.ArcGIS.Geometry.esriSegmentExtension.esriNoExtension' .5' true' pCenterPoint);  	pCenterPoints.Add (pCenterPoint);  	pl = null;  	break;  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPolygon:  	pPoly = geo as ESRI.ArcGIS.Geometry.IPolygon4;  	pPoly.SimplifySpaghetti ();  	if (pPoly.ExteriorRingCount > 1) {  		//Comps = new IPolygon[pPoly.ExteriorRingCount];  		pGeoBag = pPoly.ConnectedComponentBag;  		enumGeometry = pGeoBag as IEnumGeometry;  		enumGeometry.Reset ();  		geometry = enumGeometry.Next ();  		while (geometry != null) {  			pArea = geometry as ESRI.ArcGIS.Geometry.IArea;  			pCenterPoint = pArea.Centroid;  			pCenterPoints.Add (pCenterPoint);  			geometry = enumGeometry.Next ();  		}  	} else {  		pArea = geo as ESRI.ArcGIS.Geometry.IArea;  		pCenterPoint = pArea.Centroid;  		pCenterPoints.Add (pCenterPoint);  		pArea = null;  	}  	break;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetGeomCenter,The following statement contains a magic number: pl.QueryPoint (ESRI.ArcGIS.Geometry.esriSegmentExtension.esriNoExtension' .5' true' pCenterPoint);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CalcSearchExtent,The following statement contains a magic number: try {  	ISpatialReferenceResolution pSRResolution;  	pSRResolution = ((sourceLayer.FeatureClass as IGeoDataset).SpatialReference) as ISpatialReferenceResolution;  	//  sFilter = new SpatialFilterClass();  	double dblTol;  	if (SearchTolerence != 0.0) {  		dblTol = SearchTolerence;  	} else {  		dblTol = pSRResolution.get_XYResolution (false);  	}  	// bool hasXY = ((sourceLayer.FeatureClass as IGeoDataset).SpatialReference).HasXYPrecision();  	searchEnvelope = inFeature.ShapeCopy.Envelope;  	searchEnvelope.XMin = searchEnvelope.XMin - dblTol;  	searchEnvelope.YMin = searchEnvelope.YMin - dblTol;  	searchEnvelope.XMax = searchEnvelope.XMax + dblTol;  	searchEnvelope.YMax = searchEnvelope.YMax + dblTol;  	searchEnvelope.SpatialReference = ((inFeature.Class as IFeatureClass) as IGeoDataset).SpatialReference;  	//searchEnvelope.Expand(.1' .1' true);  	//searchEnvelope.Expand(searchDistance' searchDistance' false);  } catch {  	double dblTol;  	if (SearchTolerence != 0) {  		dblTol = SearchTolerence;  	} else {  		dblTol = .01;  	}  	searchEnvelope = inFeature.ShapeCopy.Envelope;  	searchEnvelope.XMin = searchEnvelope.XMin - dblTol;  	searchEnvelope.YMin = searchEnvelope.YMin - dblTol;  	searchEnvelope.XMax = searchEnvelope.XMax + dblTol;  	searchEnvelope.YMax = searchEnvelope.YMax + dblTol;  	searchEnvelope.SpatialReference = ((inFeature.Class as IFeatureClass) as IGeoDataset).SpatialReference;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CalcSearchExtent,The following statement contains a magic number: if (SearchTolerence != 0) {  	dblTol = SearchTolerence;  } else {  	dblTol = .01;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CalcSearchExtent,The following statement contains a magic number: dblTol = .01;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetDistanceBetweenPoints,The following statement contains a magic number: try {  	pProx = onePoint as IProximityOperator;  	return pProx.ReturnDistance (twoPoint);  } catch {  	return -99999.9;  } finally {  	pProx = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetDistanceBetweenPoints,The following statement contains a magic number: return -99999.9;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPoints,The following statement contains a magic number: try {  	Missing = Type.Missing;  	newPolyLine = new PolylineClass ();  	newPointColl = (IPointCollection)newPolyLine;  	foreach (IPoint pnt in points) {  		if (pnt != null && !pnt.IsEmpty) {  			pnt.Z = 0;  			pnt.M = 0;  			newPointColl.AddPoint (pnt' ref Missing' ref Missing);  		}  	}  	if (newPointColl.PointCount < 2)  		newPolyLine = new PolylineClass ();  	return newPolyLine;  } catch (Exception ex) {  	MessageBox.Show ("Error in CreatePolylineFromPoints: " + ex.ToString ());  	return null;  } finally {  	Missing = null;  	newPointColl = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPoints,The following statement contains a magic number: if (newPointColl.PointCount < 2)  	newPolyLine = new PolylineClass ();  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: try {  	Missing = Type.Missing;  	newPolyLine = new PolylineClass ();  	newPointColl = (IPointCollection)newPolyLine;  	if (turnPoint == null) {  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	} else {  		double dblTol = 1.0;  		lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  		ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  		if (lineFeature == null) {  			lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  		} else {  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  		}  		straightLine = new LineClass ();  		straightLine.FromPoint = fromPoint;  		straightLine.ToPoint = turnPoint;  		angleLine = new LineClass ();  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = toPoint;  		pNewPnt = new PointClass ();  		pConsPoint = (IConstructPoint2)pNewPnt;  		double degs = angleLine.Angle * (180 / Math.PI);  		if (degs < 0)  			degs = 360 + degs;  		double rads = (degs + angle) * (Math.PI / 180);  		pCl = (IClone)turnPoint;  		pStraightLinePoint = (IPoint)pCl.Clone ();  		pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = pNewPnt;  		double pHitDistOne = -1;  		double pHitDistTwo = -1;  		IPoint snapPnt = null;  		pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		snapPnt = null;  		if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  		} else {  			if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				angleLine.FromPoint = turnPoint;  				angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			}  		}  		newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  		//// return newPolyLine;  		newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  		if (lineFeature != null) {  			//pTopoOptr = (ITopologicalOperator)newPolyLine;  			//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  			pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  			if (pIntPnt != null) {  				newPolyLine = new PolylineClass ();  				newPointColl = (IPointCollection)newPolyLine;  				newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  				if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  				} else {  					newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  				}  				newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  					if (pIntGeo.Count > 0) {  						//pTopoOptr = (ITopologicalOperator)newPolyLine;  						//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  						pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  						if (pIntPnt != null) {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  						} else {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  						}  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  					//newPolyLine = new PolylineClass();  					//newPointColl = (IPointCollection)newPolyLine;  					//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  					//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  					//{  					//}  					//else  					//{  					//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  					//}  					//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  				}  			}  		} else {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  		}  	}  	if (newPointColl.PointCount < 2)  		newPolyLine = new PolylineClass ();  	return newPolyLine;  } catch (Exception ex) {  	MessageBox.Show ("Error in CreatePolylineFromPointsNewTurn: " + ex.ToString ());  	return null;  } finally {  	Missing = null;  	newPointColl = null;  	straightLine = null;  	angleLine = null;  	pNewPnt = null;  	pConsPoint = null;  	pCl = null;  	pStraightLinePoint = null;  	pIntGeo = null;  	pIntPnt = null;  	//pTopoOptr = null;  	//pGeomColl = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: try {  	Missing = Type.Missing;  	newPolyLine = new PolylineClass ();  	newPointColl = (IPointCollection)newPolyLine;  	if (turnPoint == null) {  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	} else {  		double dblTol = 1.0;  		lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  		ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  		if (lineFeature == null) {  			lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  		} else {  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  		}  		straightLine = new LineClass ();  		straightLine.FromPoint = fromPoint;  		straightLine.ToPoint = turnPoint;  		angleLine = new LineClass ();  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = toPoint;  		pNewPnt = new PointClass ();  		pConsPoint = (IConstructPoint2)pNewPnt;  		double degs = angleLine.Angle * (180 / Math.PI);  		if (degs < 0)  			degs = 360 + degs;  		double rads = (degs + angle) * (Math.PI / 180);  		pCl = (IClone)turnPoint;  		pStraightLinePoint = (IPoint)pCl.Clone ();  		pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = pNewPnt;  		double pHitDistOne = -1;  		double pHitDistTwo = -1;  		IPoint snapPnt = null;  		pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		snapPnt = null;  		if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  		} else {  			if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				angleLine.FromPoint = turnPoint;  				angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			}  		}  		newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  		//// return newPolyLine;  		newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  		if (lineFeature != null) {  			//pTopoOptr = (ITopologicalOperator)newPolyLine;  			//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  			pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  			if (pIntPnt != null) {  				newPolyLine = new PolylineClass ();  				newPointColl = (IPointCollection)newPolyLine;  				newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  				if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  				} else {  					newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  				}  				newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  					if (pIntGeo.Count > 0) {  						//pTopoOptr = (ITopologicalOperator)newPolyLine;  						//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  						pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  						if (pIntPnt != null) {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  						} else {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  						}  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  					//newPolyLine = new PolylineClass();  					//newPointColl = (IPointCollection)newPolyLine;  					//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  					//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  					//{  					//}  					//else  					//{  					//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  					//}  					//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  				}  			}  		} else {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  		}  	}  	if (newPointColl.PointCount < 2)  		newPolyLine = new PolylineClass ();  	return newPolyLine;  } catch (Exception ex) {  	MessageBox.Show ("Error in CreatePolylineFromPointsNewTurn: " + ex.ToString ());  	return null;  } finally {  	Missing = null;  	newPointColl = null;  	straightLine = null;  	angleLine = null;  	pNewPnt = null;  	pConsPoint = null;  	pCl = null;  	pStraightLinePoint = null;  	pIntGeo = null;  	pIntPnt = null;  	//pTopoOptr = null;  	//pGeomColl = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: try {  	Missing = Type.Missing;  	newPolyLine = new PolylineClass ();  	newPointColl = (IPointCollection)newPolyLine;  	if (turnPoint == null) {  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	} else {  		double dblTol = 1.0;  		lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  		ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  		if (lineFeature == null) {  			lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  		} else {  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  		}  		straightLine = new LineClass ();  		straightLine.FromPoint = fromPoint;  		straightLine.ToPoint = turnPoint;  		angleLine = new LineClass ();  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = toPoint;  		pNewPnt = new PointClass ();  		pConsPoint = (IConstructPoint2)pNewPnt;  		double degs = angleLine.Angle * (180 / Math.PI);  		if (degs < 0)  			degs = 360 + degs;  		double rads = (degs + angle) * (Math.PI / 180);  		pCl = (IClone)turnPoint;  		pStraightLinePoint = (IPoint)pCl.Clone ();  		pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = pNewPnt;  		double pHitDistOne = -1;  		double pHitDistTwo = -1;  		IPoint snapPnt = null;  		pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		snapPnt = null;  		if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  		} else {  			if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				angleLine.FromPoint = turnPoint;  				angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			}  		}  		newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  		//// return newPolyLine;  		newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  		if (lineFeature != null) {  			//pTopoOptr = (ITopologicalOperator)newPolyLine;  			//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  			pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  			if (pIntPnt != null) {  				newPolyLine = new PolylineClass ();  				newPointColl = (IPointCollection)newPolyLine;  				newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  				if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  				} else {  					newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  				}  				newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  					if (pIntGeo.Count > 0) {  						//pTopoOptr = (ITopologicalOperator)newPolyLine;  						//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  						pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  						if (pIntPnt != null) {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  						} else {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  						}  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  					//newPolyLine = new PolylineClass();  					//newPointColl = (IPointCollection)newPolyLine;  					//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  					//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  					//{  					//}  					//else  					//{  					//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  					//}  					//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  				}  			}  		} else {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  		}  	}  	if (newPointColl.PointCount < 2)  		newPolyLine = new PolylineClass ();  	return newPolyLine;  } catch (Exception ex) {  	MessageBox.Show ("Error in CreatePolylineFromPointsNewTurn: " + ex.ToString ());  	return null;  } finally {  	Missing = null;  	newPointColl = null;  	straightLine = null;  	angleLine = null;  	pNewPnt = null;  	pConsPoint = null;  	pCl = null;  	pStraightLinePoint = null;  	pIntGeo = null;  	pIntPnt = null;  	//pTopoOptr = null;  	//pGeomColl = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: try {  	Missing = Type.Missing;  	newPolyLine = new PolylineClass ();  	newPointColl = (IPointCollection)newPolyLine;  	if (turnPoint == null) {  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	} else {  		double dblTol = 1.0;  		lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  		ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  		if (lineFeature == null) {  			lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  		} else {  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  		}  		straightLine = new LineClass ();  		straightLine.FromPoint = fromPoint;  		straightLine.ToPoint = turnPoint;  		angleLine = new LineClass ();  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = toPoint;  		pNewPnt = new PointClass ();  		pConsPoint = (IConstructPoint2)pNewPnt;  		double degs = angleLine.Angle * (180 / Math.PI);  		if (degs < 0)  			degs = 360 + degs;  		double rads = (degs + angle) * (Math.PI / 180);  		pCl = (IClone)turnPoint;  		pStraightLinePoint = (IPoint)pCl.Clone ();  		pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = pNewPnt;  		double pHitDistOne = -1;  		double pHitDistTwo = -1;  		IPoint snapPnt = null;  		pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		snapPnt = null;  		if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  		} else {  			if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				angleLine.FromPoint = turnPoint;  				angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			}  		}  		newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  		//// return newPolyLine;  		newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  		if (lineFeature != null) {  			//pTopoOptr = (ITopologicalOperator)newPolyLine;  			//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  			pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  			if (pIntPnt != null) {  				newPolyLine = new PolylineClass ();  				newPointColl = (IPointCollection)newPolyLine;  				newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  				if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  				} else {  					newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  				}  				newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  					if (pIntGeo.Count > 0) {  						//pTopoOptr = (ITopologicalOperator)newPolyLine;  						//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  						pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  						if (pIntPnt != null) {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  						} else {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  						}  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  					//newPolyLine = new PolylineClass();  					//newPointColl = (IPointCollection)newPolyLine;  					//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  					//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  					//{  					//}  					//else  					//{  					//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  					//}  					//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  				}  			}  		} else {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  		}  	}  	if (newPointColl.PointCount < 2)  		newPolyLine = new PolylineClass ();  	return newPolyLine;  } catch (Exception ex) {  	MessageBox.Show ("Error in CreatePolylineFromPointsNewTurn: " + ex.ToString ());  	return null;  } finally {  	Missing = null;  	newPointColl = null;  	straightLine = null;  	angleLine = null;  	pNewPnt = null;  	pConsPoint = null;  	pCl = null;  	pStraightLinePoint = null;  	pIntGeo = null;  	pIntPnt = null;  	//pTopoOptr = null;  	//pGeomColl = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: try {  	Missing = Type.Missing;  	newPolyLine = new PolylineClass ();  	newPointColl = (IPointCollection)newPolyLine;  	if (turnPoint == null) {  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	} else {  		double dblTol = 1.0;  		lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  		ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  		if (lineFeature == null) {  			lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  		} else {  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  		}  		straightLine = new LineClass ();  		straightLine.FromPoint = fromPoint;  		straightLine.ToPoint = turnPoint;  		angleLine = new LineClass ();  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = toPoint;  		pNewPnt = new PointClass ();  		pConsPoint = (IConstructPoint2)pNewPnt;  		double degs = angleLine.Angle * (180 / Math.PI);  		if (degs < 0)  			degs = 360 + degs;  		double rads = (degs + angle) * (Math.PI / 180);  		pCl = (IClone)turnPoint;  		pStraightLinePoint = (IPoint)pCl.Clone ();  		pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = pNewPnt;  		double pHitDistOne = -1;  		double pHitDistTwo = -1;  		IPoint snapPnt = null;  		pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		snapPnt = null;  		if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  		} else {  			if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				angleLine.FromPoint = turnPoint;  				angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			}  		}  		newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  		//// return newPolyLine;  		newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  		if (lineFeature != null) {  			//pTopoOptr = (ITopologicalOperator)newPolyLine;  			//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  			pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  			if (pIntPnt != null) {  				newPolyLine = new PolylineClass ();  				newPointColl = (IPointCollection)newPolyLine;  				newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  				if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  				} else {  					newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  				}  				newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  					if (pIntGeo.Count > 0) {  						//pTopoOptr = (ITopologicalOperator)newPolyLine;  						//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  						pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  						if (pIntPnt != null) {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  						} else {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  						}  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  					//newPolyLine = new PolylineClass();  					//newPointColl = (IPointCollection)newPolyLine;  					//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  					//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  					//{  					//}  					//else  					//{  					//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  					//}  					//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  				}  			}  		} else {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  		}  	}  	if (newPointColl.PointCount < 2)  		newPolyLine = new PolylineClass ();  	return newPolyLine;  } catch (Exception ex) {  	MessageBox.Show ("Error in CreatePolylineFromPointsNewTurn: " + ex.ToString ());  	return null;  } finally {  	Missing = null;  	newPointColl = null;  	straightLine = null;  	angleLine = null;  	pNewPnt = null;  	pConsPoint = null;  	pCl = null;  	pStraightLinePoint = null;  	pIntGeo = null;  	pIntPnt = null;  	//pTopoOptr = null;  	//pGeomColl = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: try {  	Missing = Type.Missing;  	newPolyLine = new PolylineClass ();  	newPointColl = (IPointCollection)newPolyLine;  	if (turnPoint == null) {  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	} else {  		double dblTol = 1.0;  		lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  		ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  		if (lineFeature == null) {  			lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  		} else {  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  		}  		straightLine = new LineClass ();  		straightLine.FromPoint = fromPoint;  		straightLine.ToPoint = turnPoint;  		angleLine = new LineClass ();  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = toPoint;  		pNewPnt = new PointClass ();  		pConsPoint = (IConstructPoint2)pNewPnt;  		double degs = angleLine.Angle * (180 / Math.PI);  		if (degs < 0)  			degs = 360 + degs;  		double rads = (degs + angle) * (Math.PI / 180);  		pCl = (IClone)turnPoint;  		pStraightLinePoint = (IPoint)pCl.Clone ();  		pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = pNewPnt;  		double pHitDistOne = -1;  		double pHitDistTwo = -1;  		IPoint snapPnt = null;  		pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		snapPnt = null;  		if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  		} else {  			if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				angleLine.FromPoint = turnPoint;  				angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			}  		}  		newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  		//// return newPolyLine;  		newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  		if (lineFeature != null) {  			//pTopoOptr = (ITopologicalOperator)newPolyLine;  			//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  			pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  			if (pIntPnt != null) {  				newPolyLine = new PolylineClass ();  				newPointColl = (IPointCollection)newPolyLine;  				newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  				if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  				} else {  					newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  				}  				newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  					if (pIntGeo.Count > 0) {  						//pTopoOptr = (ITopologicalOperator)newPolyLine;  						//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  						pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  						if (pIntPnt != null) {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  						} else {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  						}  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  					//newPolyLine = new PolylineClass();  					//newPointColl = (IPointCollection)newPolyLine;  					//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  					//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  					//{  					//}  					//else  					//{  					//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  					//}  					//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  				}  			}  		} else {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  		}  	}  	if (newPointColl.PointCount < 2)  		newPolyLine = new PolylineClass ();  	return newPolyLine;  } catch (Exception ex) {  	MessageBox.Show ("Error in CreatePolylineFromPointsNewTurn: " + ex.ToString ());  	return null;  } finally {  	Missing = null;  	newPointColl = null;  	straightLine = null;  	angleLine = null;  	pNewPnt = null;  	pConsPoint = null;  	pCl = null;  	pStraightLinePoint = null;  	pIntGeo = null;  	pIntPnt = null;  	//pTopoOptr = null;  	//pGeomColl = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: try {  	Missing = Type.Missing;  	newPolyLine = new PolylineClass ();  	newPointColl = (IPointCollection)newPolyLine;  	if (turnPoint == null) {  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	} else {  		double dblTol = 1.0;  		lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  		ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  		if (lineFeature == null) {  			lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  		} else {  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  		}  		straightLine = new LineClass ();  		straightLine.FromPoint = fromPoint;  		straightLine.ToPoint = turnPoint;  		angleLine = new LineClass ();  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = toPoint;  		pNewPnt = new PointClass ();  		pConsPoint = (IConstructPoint2)pNewPnt;  		double degs = angleLine.Angle * (180 / Math.PI);  		if (degs < 0)  			degs = 360 + degs;  		double rads = (degs + angle) * (Math.PI / 180);  		pCl = (IClone)turnPoint;  		pStraightLinePoint = (IPoint)pCl.Clone ();  		pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = pNewPnt;  		double pHitDistOne = -1;  		double pHitDistTwo = -1;  		IPoint snapPnt = null;  		pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		snapPnt = null;  		if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  		} else {  			if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				angleLine.FromPoint = turnPoint;  				angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			}  		}  		newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  		//// return newPolyLine;  		newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  		if (lineFeature != null) {  			//pTopoOptr = (ITopologicalOperator)newPolyLine;  			//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  			pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  			if (pIntPnt != null) {  				newPolyLine = new PolylineClass ();  				newPointColl = (IPointCollection)newPolyLine;  				newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  				if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  				} else {  					newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  				}  				newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  					if (pIntGeo.Count > 0) {  						//pTopoOptr = (ITopologicalOperator)newPolyLine;  						//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  						pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  						if (pIntPnt != null) {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  						} else {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  						}  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  					//newPolyLine = new PolylineClass();  					//newPointColl = (IPointCollection)newPolyLine;  					//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  					//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  					//{  					//}  					//else  					//{  					//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  					//}  					//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  				}  			}  		} else {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  		}  	}  	if (newPointColl.PointCount < 2)  		newPolyLine = new PolylineClass ();  	return newPolyLine;  } catch (Exception ex) {  	MessageBox.Show ("Error in CreatePolylineFromPointsNewTurn: " + ex.ToString ());  	return null;  } finally {  	Missing = null;  	newPointColl = null;  	straightLine = null;  	angleLine = null;  	pNewPnt = null;  	pConsPoint = null;  	pCl = null;  	pStraightLinePoint = null;  	pIntGeo = null;  	pIntPnt = null;  	//pTopoOptr = null;  	//pGeomColl = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: try {  	Missing = Type.Missing;  	newPolyLine = new PolylineClass ();  	newPointColl = (IPointCollection)newPolyLine;  	if (turnPoint == null) {  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	} else {  		double dblTol = 1.0;  		lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  		ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  		if (lineFeature == null) {  			lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  		} else {  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  		}  		straightLine = new LineClass ();  		straightLine.FromPoint = fromPoint;  		straightLine.ToPoint = turnPoint;  		angleLine = new LineClass ();  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = toPoint;  		pNewPnt = new PointClass ();  		pConsPoint = (IConstructPoint2)pNewPnt;  		double degs = angleLine.Angle * (180 / Math.PI);  		if (degs < 0)  			degs = 360 + degs;  		double rads = (degs + angle) * (Math.PI / 180);  		pCl = (IClone)turnPoint;  		pStraightLinePoint = (IPoint)pCl.Clone ();  		pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = pNewPnt;  		double pHitDistOne = -1;  		double pHitDistTwo = -1;  		IPoint snapPnt = null;  		pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		snapPnt = null;  		if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  		} else {  			if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				angleLine.FromPoint = turnPoint;  				angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			}  		}  		newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  		//// return newPolyLine;  		newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  		if (lineFeature != null) {  			//pTopoOptr = (ITopologicalOperator)newPolyLine;  			//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  			pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  			if (pIntPnt != null) {  				newPolyLine = new PolylineClass ();  				newPointColl = (IPointCollection)newPolyLine;  				newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  				if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  				} else {  					newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  				}  				newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  					if (pIntGeo.Count > 0) {  						//pTopoOptr = (ITopologicalOperator)newPolyLine;  						//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  						pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  						if (pIntPnt != null) {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  						} else {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  						}  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  					//newPolyLine = new PolylineClass();  					//newPointColl = (IPointCollection)newPolyLine;  					//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  					//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  					//{  					//}  					//else  					//{  					//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  					//}  					//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  				}  			}  		} else {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  		}  	}  	if (newPointColl.PointCount < 2)  		newPolyLine = new PolylineClass ();  	return newPolyLine;  } catch (Exception ex) {  	MessageBox.Show ("Error in CreatePolylineFromPointsNewTurn: " + ex.ToString ());  	return null;  } finally {  	Missing = null;  	newPointColl = null;  	straightLine = null;  	angleLine = null;  	pNewPnt = null;  	pConsPoint = null;  	pCl = null;  	pStraightLinePoint = null;  	pIntGeo = null;  	pIntPnt = null;  	//pTopoOptr = null;  	//pGeomColl = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: try {  	Missing = Type.Missing;  	newPolyLine = new PolylineClass ();  	newPointColl = (IPointCollection)newPolyLine;  	if (turnPoint == null) {  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	} else {  		double dblTol = 1.0;  		lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  		ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  		if (lineFeature == null) {  			lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  		} else {  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  		}  		straightLine = new LineClass ();  		straightLine.FromPoint = fromPoint;  		straightLine.ToPoint = turnPoint;  		angleLine = new LineClass ();  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = toPoint;  		pNewPnt = new PointClass ();  		pConsPoint = (IConstructPoint2)pNewPnt;  		double degs = angleLine.Angle * (180 / Math.PI);  		if (degs < 0)  			degs = 360 + degs;  		double rads = (degs + angle) * (Math.PI / 180);  		pCl = (IClone)turnPoint;  		pStraightLinePoint = (IPoint)pCl.Clone ();  		pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = pNewPnt;  		double pHitDistOne = -1;  		double pHitDistTwo = -1;  		IPoint snapPnt = null;  		pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		snapPnt = null;  		if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  		} else {  			if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				angleLine.FromPoint = turnPoint;  				angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			}  		}  		newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  		//// return newPolyLine;  		newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  		if (lineFeature != null) {  			//pTopoOptr = (ITopologicalOperator)newPolyLine;  			//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  			pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  			if (pIntPnt != null) {  				newPolyLine = new PolylineClass ();  				newPointColl = (IPointCollection)newPolyLine;  				newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  				if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  				} else {  					newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  				}  				newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  					if (pIntGeo.Count > 0) {  						//pTopoOptr = (ITopologicalOperator)newPolyLine;  						//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  						pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  						if (pIntPnt != null) {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  						} else {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  						}  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  					//newPolyLine = new PolylineClass();  					//newPointColl = (IPointCollection)newPolyLine;  					//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  					//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  					//{  					//}  					//else  					//{  					//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  					//}  					//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  				}  			}  		} else {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  		}  	}  	if (newPointColl.PointCount < 2)  		newPolyLine = new PolylineClass ();  	return newPolyLine;  } catch (Exception ex) {  	MessageBox.Show ("Error in CreatePolylineFromPointsNewTurn: " + ex.ToString ());  	return null;  } finally {  	Missing = null;  	newPointColl = null;  	straightLine = null;  	angleLine = null;  	pNewPnt = null;  	pConsPoint = null;  	pCl = null;  	pStraightLinePoint = null;  	pIntGeo = null;  	pIntPnt = null;  	//pTopoOptr = null;  	//pGeomColl = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: try {  	Missing = Type.Missing;  	newPolyLine = new PolylineClass ();  	newPointColl = (IPointCollection)newPolyLine;  	if (turnPoint == null) {  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	} else {  		double dblTol = 1.0;  		lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  		ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  		if (lineFeature == null) {  			lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  		} else {  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  		}  		straightLine = new LineClass ();  		straightLine.FromPoint = fromPoint;  		straightLine.ToPoint = turnPoint;  		angleLine = new LineClass ();  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = toPoint;  		pNewPnt = new PointClass ();  		pConsPoint = (IConstructPoint2)pNewPnt;  		double degs = angleLine.Angle * (180 / Math.PI);  		if (degs < 0)  			degs = 360 + degs;  		double rads = (degs + angle) * (Math.PI / 180);  		pCl = (IClone)turnPoint;  		pStraightLinePoint = (IPoint)pCl.Clone ();  		pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = pNewPnt;  		double pHitDistOne = -1;  		double pHitDistTwo = -1;  		IPoint snapPnt = null;  		pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		snapPnt = null;  		if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  		} else {  			if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				angleLine.FromPoint = turnPoint;  				angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			}  		}  		newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  		//// return newPolyLine;  		newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  		if (lineFeature != null) {  			//pTopoOptr = (ITopologicalOperator)newPolyLine;  			//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  			pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  			if (pIntPnt != null) {  				newPolyLine = new PolylineClass ();  				newPointColl = (IPointCollection)newPolyLine;  				newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  				if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  				} else {  					newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  				}  				newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  					if (pIntGeo.Count > 0) {  						//pTopoOptr = (ITopologicalOperator)newPolyLine;  						//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  						pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  						if (pIntPnt != null) {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  						} else {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  						}  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  					//newPolyLine = new PolylineClass();  					//newPointColl = (IPointCollection)newPolyLine;  					//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  					//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  					//{  					//}  					//else  					//{  					//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  					//}  					//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  				}  			}  		} else {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  		}  	}  	if (newPointColl.PointCount < 2)  		newPolyLine = new PolylineClass ();  	return newPolyLine;  } catch (Exception ex) {  	MessageBox.Show ("Error in CreatePolylineFromPointsNewTurn: " + ex.ToString ());  	return null;  } finally {  	Missing = null;  	newPointColl = null;  	straightLine = null;  	angleLine = null;  	pNewPnt = null;  	pConsPoint = null;  	pCl = null;  	pStraightLinePoint = null;  	pIntGeo = null;  	pIntPnt = null;  	//pTopoOptr = null;  	//pGeomColl = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: try {  	Missing = Type.Missing;  	newPolyLine = new PolylineClass ();  	newPointColl = (IPointCollection)newPolyLine;  	if (turnPoint == null) {  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	} else {  		double dblTol = 1.0;  		lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  		ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  		if (lineFeature == null) {  			lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  		} else {  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  		}  		straightLine = new LineClass ();  		straightLine.FromPoint = fromPoint;  		straightLine.ToPoint = turnPoint;  		angleLine = new LineClass ();  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = toPoint;  		pNewPnt = new PointClass ();  		pConsPoint = (IConstructPoint2)pNewPnt;  		double degs = angleLine.Angle * (180 / Math.PI);  		if (degs < 0)  			degs = 360 + degs;  		double rads = (degs + angle) * (Math.PI / 180);  		pCl = (IClone)turnPoint;  		pStraightLinePoint = (IPoint)pCl.Clone ();  		pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = pNewPnt;  		double pHitDistOne = -1;  		double pHitDistTwo = -1;  		IPoint snapPnt = null;  		pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		snapPnt = null;  		if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  		} else {  			if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				angleLine.FromPoint = turnPoint;  				angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			}  		}  		newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  		//// return newPolyLine;  		newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  		if (lineFeature != null) {  			//pTopoOptr = (ITopologicalOperator)newPolyLine;  			//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  			pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  			if (pIntPnt != null) {  				newPolyLine = new PolylineClass ();  				newPointColl = (IPointCollection)newPolyLine;  				newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  				if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  				} else {  					newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  				}  				newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  					if (pIntGeo.Count > 0) {  						//pTopoOptr = (ITopologicalOperator)newPolyLine;  						//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  						pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  						if (pIntPnt != null) {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  						} else {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  						}  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  					//newPolyLine = new PolylineClass();  					//newPointColl = (IPointCollection)newPolyLine;  					//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  					//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  					//{  					//}  					//else  					//{  					//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  					//}  					//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  				}  			}  		} else {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  		}  	}  	if (newPointColl.PointCount < 2)  		newPolyLine = new PolylineClass ();  	return newPolyLine;  } catch (Exception ex) {  	MessageBox.Show ("Error in CreatePolylineFromPointsNewTurn: " + ex.ToString ());  	return null;  } finally {  	Missing = null;  	newPointColl = null;  	straightLine = null;  	angleLine = null;  	pNewPnt = null;  	pConsPoint = null;  	pCl = null;  	pStraightLinePoint = null;  	pIntGeo = null;  	pIntPnt = null;  	//pTopoOptr = null;  	//pGeomColl = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: try {  	Missing = Type.Missing;  	newPolyLine = new PolylineClass ();  	newPointColl = (IPointCollection)newPolyLine;  	if (turnPoint == null) {  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	} else {  		double dblTol = 1.0;  		lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  		ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  		if (lineFeature == null) {  			lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  		} else {  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  		}  		straightLine = new LineClass ();  		straightLine.FromPoint = fromPoint;  		straightLine.ToPoint = turnPoint;  		angleLine = new LineClass ();  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = toPoint;  		pNewPnt = new PointClass ();  		pConsPoint = (IConstructPoint2)pNewPnt;  		double degs = angleLine.Angle * (180 / Math.PI);  		if (degs < 0)  			degs = 360 + degs;  		double rads = (degs + angle) * (Math.PI / 180);  		pCl = (IClone)turnPoint;  		pStraightLinePoint = (IPoint)pCl.Clone ();  		pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = pNewPnt;  		double pHitDistOne = -1;  		double pHitDistTwo = -1;  		IPoint snapPnt = null;  		pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		snapPnt = null;  		if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  		} else {  			if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				angleLine.FromPoint = turnPoint;  				angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			}  		}  		newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  		//// return newPolyLine;  		newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  		if (lineFeature != null) {  			//pTopoOptr = (ITopologicalOperator)newPolyLine;  			//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  			pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  			if (pIntPnt != null) {  				newPolyLine = new PolylineClass ();  				newPointColl = (IPointCollection)newPolyLine;  				newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  				if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  				} else {  					newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  				}  				newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  					if (pIntGeo.Count > 0) {  						//pTopoOptr = (ITopologicalOperator)newPolyLine;  						//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  						pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  						if (pIntPnt != null) {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  						} else {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  						}  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  					//newPolyLine = new PolylineClass();  					//newPointColl = (IPointCollection)newPolyLine;  					//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  					//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  					//{  					//}  					//else  					//{  					//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  					//}  					//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  				}  			}  		} else {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  		}  	}  	if (newPointColl.PointCount < 2)  		newPolyLine = new PolylineClass ();  	return newPolyLine;  } catch (Exception ex) {  	MessageBox.Show ("Error in CreatePolylineFromPointsNewTurn: " + ex.ToString ());  	return null;  } finally {  	Missing = null;  	newPointColl = null;  	straightLine = null;  	angleLine = null;  	pNewPnt = null;  	pConsPoint = null;  	pCl = null;  	pStraightLinePoint = null;  	pIntGeo = null;  	pIntPnt = null;  	//pTopoOptr = null;  	//pGeomColl = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: try {  	Missing = Type.Missing;  	newPolyLine = new PolylineClass ();  	newPointColl = (IPointCollection)newPolyLine;  	if (turnPoint == null) {  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	} else {  		double dblTol = 1.0;  		lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  		ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  		if (lineFeature == null) {  			lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  		} else {  			lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  		}  		straightLine = new LineClass ();  		straightLine.FromPoint = fromPoint;  		straightLine.ToPoint = turnPoint;  		angleLine = new LineClass ();  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = toPoint;  		pNewPnt = new PointClass ();  		pConsPoint = (IConstructPoint2)pNewPnt;  		double degs = angleLine.Angle * (180 / Math.PI);  		if (degs < 0)  			degs = 360 + degs;  		double rads = (degs + angle) * (Math.PI / 180);  		pCl = (IClone)turnPoint;  		pStraightLinePoint = (IPoint)pCl.Clone ();  		pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = pNewPnt;  		double pHitDistOne = -1;  		double pHitDistTwo = -1;  		IPoint snapPnt = null;  		pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  		snapPnt = null;  		if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  		} else {  			if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				angleLine.FromPoint = turnPoint;  				angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				if (angle > 0) {  					//rads = (degs + angle) * (Math.PI / 180);  					angle = 0 - Math.Abs (angle);  				} else if (angle < 0) {  					angle = Math.Abs (angle);  				}  				rads = (degs + angle) * (Math.PI / 180);  				if (degs < 0)  					degs = 360 + degs;  				pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			} else {  				//angleLine.FromPoint = turnPoint;  				//angleLine.ToPoint = pNewPnt;  			}  		}  		newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  		//// return newPolyLine;  		newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  		if (lineFeature != null) {  			//pTopoOptr = (ITopologicalOperator)newPolyLine;  			//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  			pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  			if (pIntPnt != null) {  				newPolyLine = new PolylineClass ();  				newPointColl = (IPointCollection)newPolyLine;  				newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  				if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  				} else {  					newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  				}  				newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  					if (pIntGeo.Count > 0) {  						//pTopoOptr = (ITopologicalOperator)newPolyLine;  						//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  						pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  						if (pIntPnt != null) {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  						} else {  							newPolyLine = new PolylineClass ();  							newPointColl = (IPointCollection)newPolyLine;  							newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  							if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  							} else {  								newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  							}  							newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  						}  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  					//newPolyLine = new PolylineClass();  					//newPointColl = (IPointCollection)newPolyLine;  					//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  					//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  					//{  					//}  					//else  					//{  					//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  					//}  					//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  				}  			}  		} else {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  		}  	}  	if (newPointColl.PointCount < 2)  		newPolyLine = new PolylineClass ();  	return newPolyLine;  } catch (Exception ex) {  	MessageBox.Show ("Error in CreatePolylineFromPointsNewTurn: " + ex.ToString ());  	return null;  } finally {  	Missing = null;  	newPointColl = null;  	straightLine = null;  	angleLine = null;  	pNewPnt = null;  	pConsPoint = null;  	pCl = null;  	pStraightLinePoint = null;  	pIntGeo = null;  	pIntPnt = null;  	//pTopoOptr = null;  	//pGeomColl = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (turnPoint == null) {  	newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  } else {  	double dblTol = 1.0;  	lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  	ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  	if (lineFeature == null) {  		lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  	} else {  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  	}  	straightLine = new LineClass ();  	straightLine.FromPoint = fromPoint;  	straightLine.ToPoint = turnPoint;  	angleLine = new LineClass ();  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = toPoint;  	pNewPnt = new PointClass ();  	pConsPoint = (IConstructPoint2)pNewPnt;  	double degs = angleLine.Angle * (180 / Math.PI);  	if (degs < 0)  		degs = 360 + degs;  	double rads = (degs + angle) * (Math.PI / 180);  	pCl = (IClone)turnPoint;  	pStraightLinePoint = (IPoint)pCl.Clone ();  	pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = pNewPnt;  	double pHitDistOne = -1;  	double pHitDistTwo = -1;  	IPoint snapPnt = null;  	pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	snapPnt = null;  	if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  	} else {  		if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			angleLine.FromPoint = turnPoint;  			angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  		} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		}  	}  	newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  	//// return newPolyLine;  	newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  	if (lineFeature != null) {  		//pTopoOptr = (ITopologicalOperator)newPolyLine;  		//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  		pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  		if (pIntPnt != null) {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  		} else {  			pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  			if (pIntGeo.Count > 0) {  				//pTopoOptr = (ITopologicalOperator)newPolyLine;  				//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  				pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  				if (pIntPnt != null) {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  				//newPolyLine = new PolylineClass();  				//newPointColl = (IPointCollection)newPolyLine;  				//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  				//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  				//{  				//}  				//else  				//{  				//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  				//}  				//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  			}  		}  	} else {  		newPolyLine = new PolylineClass ();  		newPointColl = (IPointCollection)newPolyLine;  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  		} else {  			newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		}  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (turnPoint == null) {  	newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  } else {  	double dblTol = 1.0;  	lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  	ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  	if (lineFeature == null) {  		lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  	} else {  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  	}  	straightLine = new LineClass ();  	straightLine.FromPoint = fromPoint;  	straightLine.ToPoint = turnPoint;  	angleLine = new LineClass ();  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = toPoint;  	pNewPnt = new PointClass ();  	pConsPoint = (IConstructPoint2)pNewPnt;  	double degs = angleLine.Angle * (180 / Math.PI);  	if (degs < 0)  		degs = 360 + degs;  	double rads = (degs + angle) * (Math.PI / 180);  	pCl = (IClone)turnPoint;  	pStraightLinePoint = (IPoint)pCl.Clone ();  	pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = pNewPnt;  	double pHitDistOne = -1;  	double pHitDistTwo = -1;  	IPoint snapPnt = null;  	pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	snapPnt = null;  	if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  	} else {  		if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			angleLine.FromPoint = turnPoint;  			angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  		} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		}  	}  	newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  	//// return newPolyLine;  	newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  	if (lineFeature != null) {  		//pTopoOptr = (ITopologicalOperator)newPolyLine;  		//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  		pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  		if (pIntPnt != null) {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  		} else {  			pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  			if (pIntGeo.Count > 0) {  				//pTopoOptr = (ITopologicalOperator)newPolyLine;  				//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  				pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  				if (pIntPnt != null) {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  				//newPolyLine = new PolylineClass();  				//newPointColl = (IPointCollection)newPolyLine;  				//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  				//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  				//{  				//}  				//else  				//{  				//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  				//}  				//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  			}  		}  	} else {  		newPolyLine = new PolylineClass ();  		newPointColl = (IPointCollection)newPolyLine;  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  		} else {  			newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		}  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (turnPoint == null) {  	newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  } else {  	double dblTol = 1.0;  	lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  	ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  	if (lineFeature == null) {  		lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  	} else {  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  	}  	straightLine = new LineClass ();  	straightLine.FromPoint = fromPoint;  	straightLine.ToPoint = turnPoint;  	angleLine = new LineClass ();  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = toPoint;  	pNewPnt = new PointClass ();  	pConsPoint = (IConstructPoint2)pNewPnt;  	double degs = angleLine.Angle * (180 / Math.PI);  	if (degs < 0)  		degs = 360 + degs;  	double rads = (degs + angle) * (Math.PI / 180);  	pCl = (IClone)turnPoint;  	pStraightLinePoint = (IPoint)pCl.Clone ();  	pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = pNewPnt;  	double pHitDistOne = -1;  	double pHitDistTwo = -1;  	IPoint snapPnt = null;  	pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	snapPnt = null;  	if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  	} else {  		if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			angleLine.FromPoint = turnPoint;  			angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  		} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		}  	}  	newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  	//// return newPolyLine;  	newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  	if (lineFeature != null) {  		//pTopoOptr = (ITopologicalOperator)newPolyLine;  		//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  		pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  		if (pIntPnt != null) {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  		} else {  			pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  			if (pIntGeo.Count > 0) {  				//pTopoOptr = (ITopologicalOperator)newPolyLine;  				//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  				pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  				if (pIntPnt != null) {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  				//newPolyLine = new PolylineClass();  				//newPointColl = (IPointCollection)newPolyLine;  				//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  				//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  				//{  				//}  				//else  				//{  				//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  				//}  				//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  			}  		}  	} else {  		newPolyLine = new PolylineClass ();  		newPointColl = (IPointCollection)newPolyLine;  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  		} else {  			newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		}  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (turnPoint == null) {  	newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  } else {  	double dblTol = 1.0;  	lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  	ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  	if (lineFeature == null) {  		lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  	} else {  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  	}  	straightLine = new LineClass ();  	straightLine.FromPoint = fromPoint;  	straightLine.ToPoint = turnPoint;  	angleLine = new LineClass ();  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = toPoint;  	pNewPnt = new PointClass ();  	pConsPoint = (IConstructPoint2)pNewPnt;  	double degs = angleLine.Angle * (180 / Math.PI);  	if (degs < 0)  		degs = 360 + degs;  	double rads = (degs + angle) * (Math.PI / 180);  	pCl = (IClone)turnPoint;  	pStraightLinePoint = (IPoint)pCl.Clone ();  	pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = pNewPnt;  	double pHitDistOne = -1;  	double pHitDistTwo = -1;  	IPoint snapPnt = null;  	pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	snapPnt = null;  	if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  	} else {  		if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			angleLine.FromPoint = turnPoint;  			angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  		} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		}  	}  	newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  	//// return newPolyLine;  	newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  	if (lineFeature != null) {  		//pTopoOptr = (ITopologicalOperator)newPolyLine;  		//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  		pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  		if (pIntPnt != null) {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  		} else {  			pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  			if (pIntGeo.Count > 0) {  				//pTopoOptr = (ITopologicalOperator)newPolyLine;  				//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  				pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  				if (pIntPnt != null) {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  				//newPolyLine = new PolylineClass();  				//newPointColl = (IPointCollection)newPolyLine;  				//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  				//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  				//{  				//}  				//else  				//{  				//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  				//}  				//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  			}  		}  	} else {  		newPolyLine = new PolylineClass ();  		newPointColl = (IPointCollection)newPolyLine;  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  		} else {  			newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		}  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (turnPoint == null) {  	newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  } else {  	double dblTol = 1.0;  	lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  	ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  	if (lineFeature == null) {  		lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  	} else {  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  	}  	straightLine = new LineClass ();  	straightLine.FromPoint = fromPoint;  	straightLine.ToPoint = turnPoint;  	angleLine = new LineClass ();  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = toPoint;  	pNewPnt = new PointClass ();  	pConsPoint = (IConstructPoint2)pNewPnt;  	double degs = angleLine.Angle * (180 / Math.PI);  	if (degs < 0)  		degs = 360 + degs;  	double rads = (degs + angle) * (Math.PI / 180);  	pCl = (IClone)turnPoint;  	pStraightLinePoint = (IPoint)pCl.Clone ();  	pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = pNewPnt;  	double pHitDistOne = -1;  	double pHitDistTwo = -1;  	IPoint snapPnt = null;  	pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	snapPnt = null;  	if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  	} else {  		if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			angleLine.FromPoint = turnPoint;  			angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  		} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		}  	}  	newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  	//// return newPolyLine;  	newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  	if (lineFeature != null) {  		//pTopoOptr = (ITopologicalOperator)newPolyLine;  		//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  		pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  		if (pIntPnt != null) {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  		} else {  			pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  			if (pIntGeo.Count > 0) {  				//pTopoOptr = (ITopologicalOperator)newPolyLine;  				//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  				pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  				if (pIntPnt != null) {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  				//newPolyLine = new PolylineClass();  				//newPointColl = (IPointCollection)newPolyLine;  				//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  				//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  				//{  				//}  				//else  				//{  				//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  				//}  				//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  			}  		}  	} else {  		newPolyLine = new PolylineClass ();  		newPointColl = (IPointCollection)newPolyLine;  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  		} else {  			newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		}  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (turnPoint == null) {  	newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  } else {  	double dblTol = 1.0;  	lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  	ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  	if (lineFeature == null) {  		lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  	} else {  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  	}  	straightLine = new LineClass ();  	straightLine.FromPoint = fromPoint;  	straightLine.ToPoint = turnPoint;  	angleLine = new LineClass ();  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = toPoint;  	pNewPnt = new PointClass ();  	pConsPoint = (IConstructPoint2)pNewPnt;  	double degs = angleLine.Angle * (180 / Math.PI);  	if (degs < 0)  		degs = 360 + degs;  	double rads = (degs + angle) * (Math.PI / 180);  	pCl = (IClone)turnPoint;  	pStraightLinePoint = (IPoint)pCl.Clone ();  	pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = pNewPnt;  	double pHitDistOne = -1;  	double pHitDistTwo = -1;  	IPoint snapPnt = null;  	pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	snapPnt = null;  	if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  	} else {  		if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			angleLine.FromPoint = turnPoint;  			angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  		} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		}  	}  	newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  	//// return newPolyLine;  	newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  	if (lineFeature != null) {  		//pTopoOptr = (ITopologicalOperator)newPolyLine;  		//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  		pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  		if (pIntPnt != null) {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  		} else {  			pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  			if (pIntGeo.Count > 0) {  				//pTopoOptr = (ITopologicalOperator)newPolyLine;  				//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  				pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  				if (pIntPnt != null) {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  				//newPolyLine = new PolylineClass();  				//newPointColl = (IPointCollection)newPolyLine;  				//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  				//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  				//{  				//}  				//else  				//{  				//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  				//}  				//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  			}  		}  	} else {  		newPolyLine = new PolylineClass ();  		newPointColl = (IPointCollection)newPolyLine;  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  		} else {  			newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		}  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (turnPoint == null) {  	newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  } else {  	double dblTol = 1.0;  	lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  	ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  	if (lineFeature == null) {  		lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  	} else {  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  	}  	straightLine = new LineClass ();  	straightLine.FromPoint = fromPoint;  	straightLine.ToPoint = turnPoint;  	angleLine = new LineClass ();  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = toPoint;  	pNewPnt = new PointClass ();  	pConsPoint = (IConstructPoint2)pNewPnt;  	double degs = angleLine.Angle * (180 / Math.PI);  	if (degs < 0)  		degs = 360 + degs;  	double rads = (degs + angle) * (Math.PI / 180);  	pCl = (IClone)turnPoint;  	pStraightLinePoint = (IPoint)pCl.Clone ();  	pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = pNewPnt;  	double pHitDistOne = -1;  	double pHitDistTwo = -1;  	IPoint snapPnt = null;  	pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	snapPnt = null;  	if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  	} else {  		if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			angleLine.FromPoint = turnPoint;  			angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  		} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		}  	}  	newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  	//// return newPolyLine;  	newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  	if (lineFeature != null) {  		//pTopoOptr = (ITopologicalOperator)newPolyLine;  		//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  		pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  		if (pIntPnt != null) {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  		} else {  			pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  			if (pIntGeo.Count > 0) {  				//pTopoOptr = (ITopologicalOperator)newPolyLine;  				//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  				pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  				if (pIntPnt != null) {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  				//newPolyLine = new PolylineClass();  				//newPointColl = (IPointCollection)newPolyLine;  				//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  				//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  				//{  				//}  				//else  				//{  				//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  				//}  				//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  			}  		}  	} else {  		newPolyLine = new PolylineClass ();  		newPointColl = (IPointCollection)newPolyLine;  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  		} else {  			newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		}  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (turnPoint == null) {  	newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  } else {  	double dblTol = 1.0;  	lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  	ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  	if (lineFeature == null) {  		lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  	} else {  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  	}  	straightLine = new LineClass ();  	straightLine.FromPoint = fromPoint;  	straightLine.ToPoint = turnPoint;  	angleLine = new LineClass ();  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = toPoint;  	pNewPnt = new PointClass ();  	pConsPoint = (IConstructPoint2)pNewPnt;  	double degs = angleLine.Angle * (180 / Math.PI);  	if (degs < 0)  		degs = 360 + degs;  	double rads = (degs + angle) * (Math.PI / 180);  	pCl = (IClone)turnPoint;  	pStraightLinePoint = (IPoint)pCl.Clone ();  	pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = pNewPnt;  	double pHitDistOne = -1;  	double pHitDistTwo = -1;  	IPoint snapPnt = null;  	pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	snapPnt = null;  	if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  	} else {  		if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			angleLine.FromPoint = turnPoint;  			angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  		} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		}  	}  	newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  	//// return newPolyLine;  	newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  	if (lineFeature != null) {  		//pTopoOptr = (ITopologicalOperator)newPolyLine;  		//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  		pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  		if (pIntPnt != null) {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  		} else {  			pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  			if (pIntGeo.Count > 0) {  				//pTopoOptr = (ITopologicalOperator)newPolyLine;  				//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  				pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  				if (pIntPnt != null) {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  				//newPolyLine = new PolylineClass();  				//newPointColl = (IPointCollection)newPolyLine;  				//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  				//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  				//{  				//}  				//else  				//{  				//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  				//}  				//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  			}  		}  	} else {  		newPolyLine = new PolylineClass ();  		newPointColl = (IPointCollection)newPolyLine;  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  		} else {  			newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		}  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (turnPoint == null) {  	newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  } else {  	double dblTol = 1.0;  	lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  	ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  	if (lineFeature == null) {  		lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  	} else {  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  	}  	straightLine = new LineClass ();  	straightLine.FromPoint = fromPoint;  	straightLine.ToPoint = turnPoint;  	angleLine = new LineClass ();  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = toPoint;  	pNewPnt = new PointClass ();  	pConsPoint = (IConstructPoint2)pNewPnt;  	double degs = angleLine.Angle * (180 / Math.PI);  	if (degs < 0)  		degs = 360 + degs;  	double rads = (degs + angle) * (Math.PI / 180);  	pCl = (IClone)turnPoint;  	pStraightLinePoint = (IPoint)pCl.Clone ();  	pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = pNewPnt;  	double pHitDistOne = -1;  	double pHitDistTwo = -1;  	IPoint snapPnt = null;  	pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	snapPnt = null;  	if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  	} else {  		if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			angleLine.FromPoint = turnPoint;  			angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  		} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		}  	}  	newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  	//// return newPolyLine;  	newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  	if (lineFeature != null) {  		//pTopoOptr = (ITopologicalOperator)newPolyLine;  		//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  		pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  		if (pIntPnt != null) {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  		} else {  			pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  			if (pIntGeo.Count > 0) {  				//pTopoOptr = (ITopologicalOperator)newPolyLine;  				//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  				pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  				if (pIntPnt != null) {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  				//newPolyLine = new PolylineClass();  				//newPointColl = (IPointCollection)newPolyLine;  				//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  				//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  				//{  				//}  				//else  				//{  				//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  				//}  				//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  			}  		}  	} else {  		newPolyLine = new PolylineClass ();  		newPointColl = (IPointCollection)newPolyLine;  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  		} else {  			newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		}  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (turnPoint == null) {  	newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  } else {  	double dblTol = 1.0;  	lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  	ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  	if (lineFeature == null) {  		lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  	} else {  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  	}  	straightLine = new LineClass ();  	straightLine.FromPoint = fromPoint;  	straightLine.ToPoint = turnPoint;  	angleLine = new LineClass ();  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = toPoint;  	pNewPnt = new PointClass ();  	pConsPoint = (IConstructPoint2)pNewPnt;  	double degs = angleLine.Angle * (180 / Math.PI);  	if (degs < 0)  		degs = 360 + degs;  	double rads = (degs + angle) * (Math.PI / 180);  	pCl = (IClone)turnPoint;  	pStraightLinePoint = (IPoint)pCl.Clone ();  	pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = pNewPnt;  	double pHitDistOne = -1;  	double pHitDistTwo = -1;  	IPoint snapPnt = null;  	pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	snapPnt = null;  	if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  	} else {  		if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			angleLine.FromPoint = turnPoint;  			angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  		} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		}  	}  	newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  	//// return newPolyLine;  	newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  	if (lineFeature != null) {  		//pTopoOptr = (ITopologicalOperator)newPolyLine;  		//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  		pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  		if (pIntPnt != null) {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  		} else {  			pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  			if (pIntGeo.Count > 0) {  				//pTopoOptr = (ITopologicalOperator)newPolyLine;  				//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  				pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  				if (pIntPnt != null) {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  				//newPolyLine = new PolylineClass();  				//newPointColl = (IPointCollection)newPolyLine;  				//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  				//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  				//{  				//}  				//else  				//{  				//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  				//}  				//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  			}  		}  	} else {  		newPolyLine = new PolylineClass ();  		newPointColl = (IPointCollection)newPolyLine;  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  		} else {  			newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		}  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (turnPoint == null) {  	newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  } else {  	double dblTol = 1.0;  	lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  	ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  	if (lineFeature == null) {  		lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  	} else {  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  	}  	straightLine = new LineClass ();  	straightLine.FromPoint = fromPoint;  	straightLine.ToPoint = turnPoint;  	angleLine = new LineClass ();  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = toPoint;  	pNewPnt = new PointClass ();  	pConsPoint = (IConstructPoint2)pNewPnt;  	double degs = angleLine.Angle * (180 / Math.PI);  	if (degs < 0)  		degs = 360 + degs;  	double rads = (degs + angle) * (Math.PI / 180);  	pCl = (IClone)turnPoint;  	pStraightLinePoint = (IPoint)pCl.Clone ();  	pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = pNewPnt;  	double pHitDistOne = -1;  	double pHitDistTwo = -1;  	IPoint snapPnt = null;  	pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	snapPnt = null;  	if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  	} else {  		if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			angleLine.FromPoint = turnPoint;  			angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  		} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		}  	}  	newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  	//// return newPolyLine;  	newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  	if (lineFeature != null) {  		//pTopoOptr = (ITopologicalOperator)newPolyLine;  		//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  		pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  		if (pIntPnt != null) {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  		} else {  			pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  			if (pIntGeo.Count > 0) {  				//pTopoOptr = (ITopologicalOperator)newPolyLine;  				//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  				pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  				if (pIntPnt != null) {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  				//newPolyLine = new PolylineClass();  				//newPointColl = (IPointCollection)newPolyLine;  				//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  				//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  				//{  				//}  				//else  				//{  				//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  				//}  				//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  			}  		}  	} else {  		newPolyLine = new PolylineClass ();  		newPointColl = (IPointCollection)newPolyLine;  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  		} else {  			newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		}  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (turnPoint == null) {  	newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  } else {  	double dblTol = 1.0;  	lineFeature = Globals.GetClosestFeature (toPoint as IGeometry' pMainLayer' dblTol' SearchOnLayer' false);  	ESRI.ArcGIS.Geodatabase.esriFlowDirection lineFlow = esriFlowDirection.esriFDIndeterminate;  	if (lineFeature == null) {  		lineFeature = Globals.GetClosestFeature (fromPoint' pMainLayer' dblTol' SearchOnLayer' false);  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' toPoint' dblTol);  	} else {  		lineFlow = Globals.GetFlowDirectionAtLocation (lineFeature' pMainLayer' fromPoint' dblTol);  	}  	straightLine = new LineClass ();  	straightLine.FromPoint = fromPoint;  	straightLine.ToPoint = turnPoint;  	angleLine = new LineClass ();  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = toPoint;  	pNewPnt = new PointClass ();  	pConsPoint = (IConstructPoint2)pNewPnt;  	double degs = angleLine.Angle * (180 / Math.PI);  	if (degs < 0)  		degs = 360 + degs;  	double rads = (degs + angle) * (Math.PI / 180);  	pCl = (IClone)turnPoint;  	pStraightLinePoint = (IPoint)pCl.Clone ();  	pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = pNewPnt;  	double pHitDistOne = -1;  	double pHitDistTwo = -1;  	IPoint snapPnt = null;  	pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  	snapPnt = null;  	if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  	} else {  		if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			angleLine.FromPoint = turnPoint;  			angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  		} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			if (angle > 0) {  				//rads = (degs + angle) * (Math.PI / 180);  				angle = 0 - Math.Abs (angle);  			} else if (angle < 0) {  				angle = Math.Abs (angle);  			}  			rads = (degs + angle) * (Math.PI / 180);  			if (degs < 0)  				degs = 360 + degs;  			pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		} else {  			//angleLine.FromPoint = turnPoint;  			//angleLine.ToPoint = pNewPnt;  		}  	}  	newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  	newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  	//// return newPolyLine;  	newPolyLine.SpatialReference = ((IGeoDataset)pMainLayer).SpatialReference;  	if (lineFeature != null) {  		//pTopoOptr = (ITopologicalOperator)newPolyLine;  		//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(lineFeature.Shape' esriGeometryDimension.esriGeometry0Dimension);  		pIntPnt = Globals.GetIntersection (lineFeature.Shape' newPolyLine) as IPoint;  		if (pIntPnt != null) {  			newPolyLine = new PolylineClass ();  			newPointColl = (IPointCollection)newPolyLine;  			newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  			if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  			} else {  				newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  			}  			newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  		} else {  			pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  			if (pIntGeo.Count > 0) {  				//pTopoOptr = (ITopologicalOperator)newPolyLine;  				//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  				pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  				if (pIntPnt != null) {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  			} else {  				pIntGeo = Globals.GetIntersectingGeometry (newPolyLine' pMainLayer' false' true' -1' mapSpat);  				if (pIntGeo.Count > 0) {  					//pTopoOptr = (ITopologicalOperator)newPolyLine;  					//pGeomColl = (IGeometryCollection)pTopoOptr.Intersect(pIntFeat[0].ShapeCopy' esriGeometryDimension.esriGeometry0Dimension);  					pIntPnt = Globals.GetIntersection (pIntGeo [0]' newPolyLine) as IPoint;  					if (pIntPnt != null) {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pIntPnt' ref Missing' ref Missing);  					} else {  						newPolyLine = new PolylineClass ();  						newPointColl = (IPointCollection)newPolyLine;  						newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  						if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  						} else {  							newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  						}  						newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  					}  				} else {  					newPolyLine = new PolylineClass ();  					newPointColl = (IPointCollection)newPolyLine;  					newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  					if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  					} else {  						newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  					}  					newPointColl.AddPoint (pNewPnt' ref Missing' ref Missing);  				}  				//newPolyLine = new PolylineClass();  				//newPointColl = (IPointCollection)newPolyLine;  				//newPointColl.AddPoint(fromPoint' ref Missing' ref Missing);  				//if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y)  				//{  				//}  				//else  				//{  				//    newPointColl.AddPoint(turnPoint' ref Missing' ref Missing);  				//}  				//newPointColl.AddPoint(pNewPnt' ref Missing' ref Missing);  			}  		}  	} else {  		newPolyLine = new PolylineClass ();  		newPointColl = (IPointCollection)newPolyLine;  		newPointColl.AddPoint (fromPoint' ref Missing' ref Missing);  		if (fromPoint.X == turnPoint.X && fromPoint.Y == turnPoint.Y) {  		} else {  			newPointColl.AddPoint (turnPoint' ref Missing' ref Missing);  		}  		newPointColl.AddPoint (toPoint' ref Missing' ref Missing);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (degs < 0)  	degs = 360 + degs;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: degs = 360 + degs;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: pConsPoint.ConstructAngleDistance (turnPoint' rads' angleLine.Length * 2);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: pHitDistOne = Globals.PointDistanceOnLine (pStraightLinePoint' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: pHitDistTwo = Globals.PointDistanceOnLine (pNewPnt' lineFeature.ShapeCopy as IPolyline' 2' out snapPnt);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  } else {  	if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = pNewPnt;  	} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  		if (angle > 0) {  			//rads = (degs + angle) * (Math.PI / 180);  			angle = 0 - Math.Abs (angle);  		} else if (angle < 0) {  			angle = Math.Abs (angle);  		}  		rads = (degs + angle) * (Math.PI / 180);  		if (degs < 0)  			degs = 360 + degs;  		pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  		if (angle > 0) {  			//rads = (degs + angle) * (Math.PI / 180);  			angle = 0 - Math.Abs (angle);  		} else if (angle < 0) {  			angle = Math.Abs (angle);  		}  		rads = (degs + angle) * (Math.PI / 180);  		if (degs < 0)  			degs = 360 + degs;  		pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  		//angleLine.FromPoint = turnPoint;  		//angleLine.ToPoint = pNewPnt;  	} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  		//angleLine.FromPoint = turnPoint;  		//angleLine.ToPoint = pNewPnt;  	} else {  		//angleLine.FromPoint = turnPoint;  		//angleLine.ToPoint = pNewPnt;  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  } else {  	if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = pNewPnt;  	} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  		if (angle > 0) {  			//rads = (degs + angle) * (Math.PI / 180);  			angle = 0 - Math.Abs (angle);  		} else if (angle < 0) {  			angle = Math.Abs (angle);  		}  		rads = (degs + angle) * (Math.PI / 180);  		if (degs < 0)  			degs = 360 + degs;  		pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  		if (angle > 0) {  			//rads = (degs + angle) * (Math.PI / 180);  			angle = 0 - Math.Abs (angle);  		} else if (angle < 0) {  			angle = Math.Abs (angle);  		}  		rads = (degs + angle) * (Math.PI / 180);  		if (degs < 0)  			degs = 360 + degs;  		pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  		//angleLine.FromPoint = turnPoint;  		//angleLine.ToPoint = pNewPnt;  	} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  		//angleLine.FromPoint = turnPoint;  		//angleLine.ToPoint = pNewPnt;  	} else {  		//angleLine.FromPoint = turnPoint;  		//angleLine.ToPoint = pNewPnt;  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  } else {  	if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = pNewPnt;  	} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  		if (angle > 0) {  			//rads = (degs + angle) * (Math.PI / 180);  			angle = 0 - Math.Abs (angle);  		} else if (angle < 0) {  			angle = Math.Abs (angle);  		}  		rads = (degs + angle) * (Math.PI / 180);  		if (degs < 0)  			degs = 360 + degs;  		pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  		if (angle > 0) {  			//rads = (degs + angle) * (Math.PI / 180);  			angle = 0 - Math.Abs (angle);  		} else if (angle < 0) {  			angle = Math.Abs (angle);  		}  		rads = (degs + angle) * (Math.PI / 180);  		if (degs < 0)  			degs = 360 + degs;  		pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  		//angleLine.FromPoint = turnPoint;  		//angleLine.ToPoint = pNewPnt;  	} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  		//angleLine.FromPoint = turnPoint;  		//angleLine.ToPoint = pNewPnt;  	} else {  		//angleLine.FromPoint = turnPoint;  		//angleLine.ToPoint = pNewPnt;  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  } else {  	if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = pNewPnt;  	} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  		if (angle > 0) {  			//rads = (degs + angle) * (Math.PI / 180);  			angle = 0 - Math.Abs (angle);  		} else if (angle < 0) {  			angle = Math.Abs (angle);  		}  		rads = (degs + angle) * (Math.PI / 180);  		if (degs < 0)  			degs = 360 + degs;  		pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  		if (angle > 0) {  			//rads = (degs + angle) * (Math.PI / 180);  			angle = 0 - Math.Abs (angle);  		} else if (angle < 0) {  			angle = Math.Abs (angle);  		}  		rads = (degs + angle) * (Math.PI / 180);  		if (degs < 0)  			degs = 360 + degs;  		pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  		//angleLine.FromPoint = turnPoint;  		//angleLine.ToPoint = pNewPnt;  	} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  		//angleLine.FromPoint = turnPoint;  		//angleLine.ToPoint = pNewPnt;  	} else {  		//angleLine.FromPoint = turnPoint;  		//angleLine.ToPoint = pNewPnt;  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  } else {  	if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = pNewPnt;  	} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  		if (angle > 0) {  			//rads = (degs + angle) * (Math.PI / 180);  			angle = 0 - Math.Abs (angle);  		} else if (angle < 0) {  			angle = Math.Abs (angle);  		}  		rads = (degs + angle) * (Math.PI / 180);  		if (degs < 0)  			degs = 360 + degs;  		pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  		if (angle > 0) {  			//rads = (degs + angle) * (Math.PI / 180);  			angle = 0 - Math.Abs (angle);  		} else if (angle < 0) {  			angle = Math.Abs (angle);  		}  		rads = (degs + angle) * (Math.PI / 180);  		if (degs < 0)  			degs = 360 + degs;  		pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  		//angleLine.FromPoint = turnPoint;  		//angleLine.ToPoint = pNewPnt;  	} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  		//angleLine.FromPoint = turnPoint;  		//angleLine.ToPoint = pNewPnt;  	} else {  		//angleLine.FromPoint = turnPoint;  		//angleLine.ToPoint = pNewPnt;  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (lineFlow == esriFlowDirection.esriFDUninitialized || lineFlow == esriFlowDirection.esriFDIndeterminate) {  } else {  	if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  		angleLine.FromPoint = turnPoint;  		angleLine.ToPoint = pNewPnt;  	} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  		if (angle > 0) {  			//rads = (degs + angle) * (Math.PI / 180);  			angle = 0 - Math.Abs (angle);  		} else if (angle < 0) {  			angle = Math.Abs (angle);  		}  		rads = (degs + angle) * (Math.PI / 180);  		if (degs < 0)  			degs = 360 + degs;  		pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	} else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  		if (angle > 0) {  			//rads = (degs + angle) * (Math.PI / 180);  			angle = 0 - Math.Abs (angle);  		} else if (angle < 0) {  			angle = Math.Abs (angle);  		}  		rads = (degs + angle) * (Math.PI / 180);  		if (degs < 0)  			degs = 360 + degs;  		pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  		//angleLine.FromPoint = turnPoint;  		//angleLine.ToPoint = pNewPnt;  	} else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  		//angleLine.FromPoint = turnPoint;  		//angleLine.ToPoint = pNewPnt;  	} else {  		//angleLine.FromPoint = turnPoint;  		//angleLine.ToPoint = pNewPnt;  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  } else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  } else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  } else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  } else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  } else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  	angleLine.FromPoint = turnPoint;  	angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  } else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  } else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  } else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  } else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  } else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  } else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDAgainstFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  } else if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: rads = (degs + angle) * (Math.PI / 180);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (degs < 0)  	degs = 360 + degs;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: degs = 360 + degs;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (pHitDistOne > pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	if (angle > 0) {  		//rads = (degs + angle) * (Math.PI / 180);  		angle = 0 - Math.Abs (angle);  	} else if (angle < 0) {  		angle = Math.Abs (angle);  	}  	rads = (degs + angle) * (Math.PI / 180);  	if (degs < 0)  		degs = 360 + degs;  	pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else if (pHitDistOne < pHitDistTwo && lineFlow == esriFlowDirection.esriFDWithFlow) {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  } else {  	//angleLine.FromPoint = turnPoint;  	//angleLine.ToPoint = pNewPnt;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: rads = (degs + angle) * (Math.PI / 180);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (degs < 0)  	degs = 360 + degs;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: degs = 360 + degs;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: pConsPoint.ConstructAngleDistance (pStraightLinePoint' rads' angleLine.Length * 2);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The following statement contains a magic number: if (newPointColl.PointCount < 2)  	newPolyLine = new PolylineClass ();  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointGraphic,The following statement contains a magic number: try {  	av = map as IActiveView;  	pSymbolJunctionFlag = CreateNetworkFlagBarrierSymbol (flagType.JunctionFlag);  	//Add start graphic  	gc = map as IGraphicsContainer;  	element = null;  	markerelem = new MarkerElementClass ();  	pSymbolJunctionFlag = CreateNetworkFlagBarrierSymbol (flagType.JunctionFlag);  	if (Display)  		pSymbolJunctionFlag.Size = 10;  	//TODO: UserConfig  	else  		pSymbolJunctionFlag.Size = .5;  	//TODO: UserConfig  	markerelem.Symbol = pSymbolJunctionFlag;  	element = (IElement)markerelem;  	element.Geometry = snappedPoint;  	elemProperties = element as IElementProperties3;  	elemProperties.Name = "TraceFlag";  	elemProperties.ReferenceScale = map.ReferenceScale;  	gc.AddElement (element' 0);  } catch {  } finally {  	av = null;  	gc = null;  	element = null;  	markerelem = null;  	pSymbolJunctionFlag = null;  	elemProperties = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointGraphic,The following statement contains a magic number: try {  	av = map as IActiveView;  	pSymbolJunctionFlag = CreateNetworkFlagBarrierSymbol (flagType.JunctionFlag);  	//Add start graphic  	gc = map as IGraphicsContainer;  	element = null;  	markerelem = new MarkerElementClass ();  	pSymbolJunctionFlag = CreateNetworkFlagBarrierSymbol (flagType.JunctionFlag);  	if (Display)  		pSymbolJunctionFlag.Size = 10;  	//TODO: UserConfig  	else  		pSymbolJunctionFlag.Size = .5;  	//TODO: UserConfig  	markerelem.Symbol = pSymbolJunctionFlag;  	element = (IElement)markerelem;  	element.Geometry = snappedPoint;  	elemProperties = element as IElementProperties3;  	elemProperties.Name = "TraceFlag";  	elemProperties.ReferenceScale = map.ReferenceScale;  	gc.AddElement (element' 0);  } catch {  } finally {  	av = null;  	gc = null;  	element = null;  	markerelem = null;  	pSymbolJunctionFlag = null;  	elemProperties = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointGraphic,The following statement contains a magic number: if (Display)  	pSymbolJunctionFlag.Size = 10;  //TODO: UserConfig  else  	pSymbolJunctionFlag.Size = .5;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointGraphic,The following statement contains a magic number: if (Display)  	pSymbolJunctionFlag.Size = 10;  //TODO: UserConfig  else  	pSymbolJunctionFlag.Size = .5;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointGraphic,The following statement contains a magic number: pSymbolJunctionFlag.Size = 10;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddPointGraphic,The following statement contains a magic number: pSymbolJunctionFlag.Size = .5;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: try {  	switch ((linearUnit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	}  	return esriUnits.esriUnknownUnits;  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType2" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: try {  	switch ((linearUnit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	}  	return esriUnits.esriUnknownUnits;  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType2" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: try {  	switch ((linearUnit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	}  	return esriUnits.esriUnknownUnits;  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType2" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: try {  	switch ((linearUnit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	}  	return esriUnits.esriUnknownUnits;  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType2" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: try {  	switch ((linearUnit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	}  	return esriUnits.esriUnknownUnits;  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType2" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: try {  	switch ((linearUnit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	}  	return esriUnits.esriUnknownUnits;  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType2" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: try {  	switch ((linearUnit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	}  	return esriUnits.esriUnknownUnits;  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType2" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: try {  	switch ((linearUnit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	}  	return esriUnits.esriUnknownUnits;  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType2" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: try {  	switch ((linearUnit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	}  	return esriUnits.esriUnknownUnits;  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType2" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: try {  	switch ((linearUnit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	}  	return esriUnits.esriUnknownUnits;  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType2" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: try {  	switch ((linearUnit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	}  	return esriUnits.esriUnknownUnits;  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType2" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: switch ((linearUnit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: switch ((linearUnit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: switch ((linearUnit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: switch ((linearUnit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: switch ((linearUnit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: switch ((linearUnit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: switch ((linearUnit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: switch ((linearUnit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: switch ((linearUnit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: switch ((linearUnit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following statement contains a magic number: switch ((linearUnit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: try {  	switch ((Unit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	default:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	}  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: try {  	switch ((Unit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	default:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	}  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: try {  	switch ((Unit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	default:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	}  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: try {  	switch ((Unit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	default:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	}  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: try {  	switch ((Unit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	default:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	}  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: try {  	switch ((Unit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	default:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	}  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: try {  	switch ((Unit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	default:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	}  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: try {  	switch ((Unit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	default:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	}  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: try {  	switch ((Unit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	default:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	}  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: try {  	switch ((Unit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	default:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	}  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: try {  	switch ((Unit.FactoryCode)) {  	case 109006:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  	case 9102:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  	case 109005:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  	case 9003:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	case 109008:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  	case 9036:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  	case 9001:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  	case 9035:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  	case 109007:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  	case 9030:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  	case 109002:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  	default:  		return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  	}  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - ConvertUnitType" + Environment.NewLine + ex.ToString ());  	return esriUnits.esriUnknownUnits;  } finally {  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: switch ((Unit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  default:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: switch ((Unit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  default:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: switch ((Unit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  default:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: switch ((Unit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  default:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: switch ((Unit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  default:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: switch ((Unit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  default:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: switch ((Unit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  default:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: switch ((Unit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  default:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: switch ((Unit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  default:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: switch ((Unit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  default:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType,The following statement contains a magic number: switch ((Unit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  default:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetSubtypeValue,The following statement contains a magic number: try {  	//  get  the enumeration of all of the subtypes for this feature class  	int lSubT = 0;  	string sSubT = null;  	pEnumSubTypes = pSubtypes.Subtypes;  	// loop through all of the subtypes and bring up a message  	// box with each subtype's code and name  	// Indicate when sFeature is found (a passed in string var)  	sSubT = pEnumSubTypes.Next (out lSubT);  	ArrayList pArrList = new ArrayList ();  	if (sSubT == null)  		return -99999;  	while (sSubT.Length > 0) {  		if (Display.ToString () == pSubtypes.get_SubtypeName (lSubT).ToString ()) {  			pEnumSubTypes = null;  			return lSubT;  		}  		sSubT = pEnumSubTypes.Next (out lSubT);  		if (sSubT == null)  			break;  	}  	pEnumSubTypes = null;  	return -99999;  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - GetSubtypeValue" + Environment.NewLine + ex.ToString ());  	return -99999;  } finally {  	pEnumSubTypes = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetSubtypeValue,The following statement contains a magic number: try {  	//  get  the enumeration of all of the subtypes for this feature class  	int lSubT = 0;  	string sSubT = null;  	pEnumSubTypes = pSubtypes.Subtypes;  	// loop through all of the subtypes and bring up a message  	// box with each subtype's code and name  	// Indicate when sFeature is found (a passed in string var)  	sSubT = pEnumSubTypes.Next (out lSubT);  	ArrayList pArrList = new ArrayList ();  	if (sSubT == null)  		return -99999;  	while (sSubT.Length > 0) {  		if (Display.ToString () == pSubtypes.get_SubtypeName (lSubT).ToString ()) {  			pEnumSubTypes = null;  			return lSubT;  		}  		sSubT = pEnumSubTypes.Next (out lSubT);  		if (sSubT == null)  			break;  	}  	pEnumSubTypes = null;  	return -99999;  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - GetSubtypeValue" + Environment.NewLine + ex.ToString ());  	return -99999;  } finally {  	pEnumSubTypes = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetSubtypeValue,The following statement contains a magic number: try {  	//  get  the enumeration of all of the subtypes for this feature class  	int lSubT = 0;  	string sSubT = null;  	pEnumSubTypes = pSubtypes.Subtypes;  	// loop through all of the subtypes and bring up a message  	// box with each subtype's code and name  	// Indicate when sFeature is found (a passed in string var)  	sSubT = pEnumSubTypes.Next (out lSubT);  	ArrayList pArrList = new ArrayList ();  	if (sSubT == null)  		return -99999;  	while (sSubT.Length > 0) {  		if (Display.ToString () == pSubtypes.get_SubtypeName (lSubT).ToString ()) {  			pEnumSubTypes = null;  			return lSubT;  		}  		sSubT = pEnumSubTypes.Next (out lSubT);  		if (sSubT == null)  			break;  	}  	pEnumSubTypes = null;  	return -99999;  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - GetSubtypeValue" + Environment.NewLine + ex.ToString ());  	return -99999;  } finally {  	pEnumSubTypes = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetSubtypeValue,The following statement contains a magic number: if (sSubT == null)  	return -99999;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetSubtypeValue,The following statement contains a magic number: return -99999;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetSubtypeValue,The following statement contains a magic number: return -99999;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetSubtypeValue,The following statement contains a magic number: return -99999;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SubtypeCount,The following statement contains a magic number: try {  	//  get  the enumeration of all of the subtypes for this feature class  	int lSubT = 0;  	string sSubT = null;  	pEnumSubTypes = pSubTypes.Subtypes;  	// loop through all of the subtypes and bring up a message  	// box with each subtype's code and name  	// Indicate when sFeature is found (a passed in string var)  	sSubT = pEnumSubTypes.Next (out lSubT);  	int i = 0;  	if (sSubT == null)  		return 0;  	while (sSubT.Length > 0) {  		i = i + 1;  		sSubT = pEnumSubTypes.Next (out lSubT);  		if (sSubT == null)  			break;  	}  	pEnumSubTypes = null;  	return i;  } catch (Exception ex) {  	MessageBox.Show ("Error in Global Functions - SubtypeCount" + Environment.NewLine + ex.ToString ());  	return -99999;  } finally {  	pEnumSubTypes = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SubtypeCount,The following statement contains a magic number: return -99999;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: try {  	ILocatorWorkspace2 pLocWork = null;  	if (path.Contains (";")) {  		if (path.ToUpper ().Contains ("SERVER=")) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  		} else {  			string[] strSDEStuff = path.Split (';');  			if (strSDEStuff.Length == 5) {  				pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  			} else if (strSDEStuff.Length == 6) {  				pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  			}  		}  	} else if (path.Contains (".sde")) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path);  	} else if (path.Contains (".gdb")) {  		pLocWork = OpenFileGDBDatabaseLocatorWorkspace (path);  	} else if (path.Contains (".mdb")) {  		pLocWork = OpenPersonalGDBDatabaseLocatorWorkspace (path);  	} else {  		pLocWork = OpenLocatorWorkspace (path);  	}  	if (pLocWork == null)  		return null;  	if (LocatorName.Contains (".loc")) {  		LocatorName = LocatorName.Replace (".loc"' "");  	}  	IReverseGeocoding reverseGeocoding = (IReverseGeocoding)pLocWork.GetLocator (LocatorName);  	return reverseGeocoding;  } catch {  	return null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: try {  	ILocatorWorkspace2 pLocWork = null;  	if (path.Contains (";")) {  		if (path.ToUpper ().Contains ("SERVER=")) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  		} else {  			string[] strSDEStuff = path.Split (';');  			if (strSDEStuff.Length == 5) {  				pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  			} else if (strSDEStuff.Length == 6) {  				pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  			}  		}  	} else if (path.Contains (".sde")) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path);  	} else if (path.Contains (".gdb")) {  		pLocWork = OpenFileGDBDatabaseLocatorWorkspace (path);  	} else if (path.Contains (".mdb")) {  		pLocWork = OpenPersonalGDBDatabaseLocatorWorkspace (path);  	} else {  		pLocWork = OpenLocatorWorkspace (path);  	}  	if (pLocWork == null)  		return null;  	if (LocatorName.Contains (".loc")) {  		LocatorName = LocatorName.Replace (".loc"' "");  	}  	IReverseGeocoding reverseGeocoding = (IReverseGeocoding)pLocWork.GetLocator (LocatorName);  	return reverseGeocoding;  } catch {  	return null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: try {  	ILocatorWorkspace2 pLocWork = null;  	if (path.Contains (";")) {  		if (path.ToUpper ().Contains ("SERVER=")) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  		} else {  			string[] strSDEStuff = path.Split (';');  			if (strSDEStuff.Length == 5) {  				pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  			} else if (strSDEStuff.Length == 6) {  				pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  			}  		}  	} else if (path.Contains (".sde")) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path);  	} else if (path.Contains (".gdb")) {  		pLocWork = OpenFileGDBDatabaseLocatorWorkspace (path);  	} else if (path.Contains (".mdb")) {  		pLocWork = OpenPersonalGDBDatabaseLocatorWorkspace (path);  	} else {  		pLocWork = OpenLocatorWorkspace (path);  	}  	if (pLocWork == null)  		return null;  	if (LocatorName.Contains (".loc")) {  		LocatorName = LocatorName.Replace (".loc"' "");  	}  	IReverseGeocoding reverseGeocoding = (IReverseGeocoding)pLocWork.GetLocator (LocatorName);  	return reverseGeocoding;  } catch {  	return null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: try {  	ILocatorWorkspace2 pLocWork = null;  	if (path.Contains (";")) {  		if (path.ToUpper ().Contains ("SERVER=")) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  		} else {  			string[] strSDEStuff = path.Split (';');  			if (strSDEStuff.Length == 5) {  				pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  			} else if (strSDEStuff.Length == 6) {  				pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  			}  		}  	} else if (path.Contains (".sde")) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path);  	} else if (path.Contains (".gdb")) {  		pLocWork = OpenFileGDBDatabaseLocatorWorkspace (path);  	} else if (path.Contains (".mdb")) {  		pLocWork = OpenPersonalGDBDatabaseLocatorWorkspace (path);  	} else {  		pLocWork = OpenLocatorWorkspace (path);  	}  	if (pLocWork == null)  		return null;  	if (LocatorName.Contains (".loc")) {  		LocatorName = LocatorName.Replace (".loc"' "");  	}  	IReverseGeocoding reverseGeocoding = (IReverseGeocoding)pLocWork.GetLocator (LocatorName);  	return reverseGeocoding;  } catch {  	return null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: try {  	ILocatorWorkspace2 pLocWork = null;  	if (path.Contains (";")) {  		if (path.ToUpper ().Contains ("SERVER=")) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  		} else {  			string[] strSDEStuff = path.Split (';');  			if (strSDEStuff.Length == 5) {  				pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  			} else if (strSDEStuff.Length == 6) {  				pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  			}  		}  	} else if (path.Contains (".sde")) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path);  	} else if (path.Contains (".gdb")) {  		pLocWork = OpenFileGDBDatabaseLocatorWorkspace (path);  	} else if (path.Contains (".mdb")) {  		pLocWork = OpenPersonalGDBDatabaseLocatorWorkspace (path);  	} else {  		pLocWork = OpenLocatorWorkspace (path);  	}  	if (pLocWork == null)  		return null;  	if (LocatorName.Contains (".loc")) {  		LocatorName = LocatorName.Replace (".loc"' "");  	}  	IReverseGeocoding reverseGeocoding = (IReverseGeocoding)pLocWork.GetLocator (LocatorName);  	return reverseGeocoding;  } catch {  	return null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: try {  	ILocatorWorkspace2 pLocWork = null;  	if (path.Contains (";")) {  		if (path.ToUpper ().Contains ("SERVER=")) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  		} else {  			string[] strSDEStuff = path.Split (';');  			if (strSDEStuff.Length == 5) {  				pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  			} else if (strSDEStuff.Length == 6) {  				pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  			}  		}  	} else if (path.Contains (".sde")) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path);  	} else if (path.Contains (".gdb")) {  		pLocWork = OpenFileGDBDatabaseLocatorWorkspace (path);  	} else if (path.Contains (".mdb")) {  		pLocWork = OpenPersonalGDBDatabaseLocatorWorkspace (path);  	} else {  		pLocWork = OpenLocatorWorkspace (path);  	}  	if (pLocWork == null)  		return null;  	if (LocatorName.Contains (".loc")) {  		LocatorName = LocatorName.Replace (".loc"' "");  	}  	IReverseGeocoding reverseGeocoding = (IReverseGeocoding)pLocWork.GetLocator (LocatorName);  	return reverseGeocoding;  } catch {  	return null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: try {  	ILocatorWorkspace2 pLocWork = null;  	if (path.Contains (";")) {  		if (path.ToUpper ().Contains ("SERVER=")) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  		} else {  			string[] strSDEStuff = path.Split (';');  			if (strSDEStuff.Length == 5) {  				pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  			} else if (strSDEStuff.Length == 6) {  				pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  			}  		}  	} else if (path.Contains (".sde")) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path);  	} else if (path.Contains (".gdb")) {  		pLocWork = OpenFileGDBDatabaseLocatorWorkspace (path);  	} else if (path.Contains (".mdb")) {  		pLocWork = OpenPersonalGDBDatabaseLocatorWorkspace (path);  	} else {  		pLocWork = OpenLocatorWorkspace (path);  	}  	if (pLocWork == null)  		return null;  	if (LocatorName.Contains (".loc")) {  		LocatorName = LocatorName.Replace (".loc"' "");  	}  	IReverseGeocoding reverseGeocoding = (IReverseGeocoding)pLocWork.GetLocator (LocatorName);  	return reverseGeocoding;  } catch {  	return null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: try {  	ILocatorWorkspace2 pLocWork = null;  	if (path.Contains (";")) {  		if (path.ToUpper ().Contains ("SERVER=")) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  		} else {  			string[] strSDEStuff = path.Split (';');  			if (strSDEStuff.Length == 5) {  				pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  			} else if (strSDEStuff.Length == 6) {  				pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  			}  		}  	} else if (path.Contains (".sde")) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path);  	} else if (path.Contains (".gdb")) {  		pLocWork = OpenFileGDBDatabaseLocatorWorkspace (path);  	} else if (path.Contains (".mdb")) {  		pLocWork = OpenPersonalGDBDatabaseLocatorWorkspace (path);  	} else {  		pLocWork = OpenLocatorWorkspace (path);  	}  	if (pLocWork == null)  		return null;  	if (LocatorName.Contains (".loc")) {  		LocatorName = LocatorName.Replace (".loc"' "");  	}  	IReverseGeocoding reverseGeocoding = (IReverseGeocoding)pLocWork.GetLocator (LocatorName);  	return reverseGeocoding;  } catch {  	return null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: try {  	ILocatorWorkspace2 pLocWork = null;  	if (path.Contains (";")) {  		if (path.ToUpper ().Contains ("SERVER=")) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  		} else {  			string[] strSDEStuff = path.Split (';');  			if (strSDEStuff.Length == 5) {  				pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  			} else if (strSDEStuff.Length == 6) {  				pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  			}  		}  	} else if (path.Contains (".sde")) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path);  	} else if (path.Contains (".gdb")) {  		pLocWork = OpenFileGDBDatabaseLocatorWorkspace (path);  	} else if (path.Contains (".mdb")) {  		pLocWork = OpenPersonalGDBDatabaseLocatorWorkspace (path);  	} else {  		pLocWork = OpenLocatorWorkspace (path);  	}  	if (pLocWork == null)  		return null;  	if (LocatorName.Contains (".loc")) {  		LocatorName = LocatorName.Replace (".loc"' "");  	}  	IReverseGeocoding reverseGeocoding = (IReverseGeocoding)pLocWork.GetLocator (LocatorName);  	return reverseGeocoding;  } catch {  	return null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (path.Contains (";")) {  	if (path.ToUpper ().Contains ("SERVER=")) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  	} else {  		string[] strSDEStuff = path.Split (';');  		if (strSDEStuff.Length == 5) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  		} else if (strSDEStuff.Length == 6) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  		}  	}  } else if (path.Contains (".sde")) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path);  } else if (path.Contains (".gdb")) {  	pLocWork = OpenFileGDBDatabaseLocatorWorkspace (path);  } else if (path.Contains (".mdb")) {  	pLocWork = OpenPersonalGDBDatabaseLocatorWorkspace (path);  } else {  	pLocWork = OpenLocatorWorkspace (path);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (path.Contains (";")) {  	if (path.ToUpper ().Contains ("SERVER=")) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  	} else {  		string[] strSDEStuff = path.Split (';');  		if (strSDEStuff.Length == 5) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  		} else if (strSDEStuff.Length == 6) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  		}  	}  } else if (path.Contains (".sde")) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path);  } else if (path.Contains (".gdb")) {  	pLocWork = OpenFileGDBDatabaseLocatorWorkspace (path);  } else if (path.Contains (".mdb")) {  	pLocWork = OpenPersonalGDBDatabaseLocatorWorkspace (path);  } else {  	pLocWork = OpenLocatorWorkspace (path);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (path.Contains (";")) {  	if (path.ToUpper ().Contains ("SERVER=")) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  	} else {  		string[] strSDEStuff = path.Split (';');  		if (strSDEStuff.Length == 5) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  		} else if (strSDEStuff.Length == 6) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  		}  	}  } else if (path.Contains (".sde")) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path);  } else if (path.Contains (".gdb")) {  	pLocWork = OpenFileGDBDatabaseLocatorWorkspace (path);  } else if (path.Contains (".mdb")) {  	pLocWork = OpenPersonalGDBDatabaseLocatorWorkspace (path);  } else {  	pLocWork = OpenLocatorWorkspace (path);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (path.Contains (";")) {  	if (path.ToUpper ().Contains ("SERVER=")) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  	} else {  		string[] strSDEStuff = path.Split (';');  		if (strSDEStuff.Length == 5) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  		} else if (strSDEStuff.Length == 6) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  		}  	}  } else if (path.Contains (".sde")) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path);  } else if (path.Contains (".gdb")) {  	pLocWork = OpenFileGDBDatabaseLocatorWorkspace (path);  } else if (path.Contains (".mdb")) {  	pLocWork = OpenPersonalGDBDatabaseLocatorWorkspace (path);  } else {  	pLocWork = OpenLocatorWorkspace (path);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (path.Contains (";")) {  	if (path.ToUpper ().Contains ("SERVER=")) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  	} else {  		string[] strSDEStuff = path.Split (';');  		if (strSDEStuff.Length == 5) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  		} else if (strSDEStuff.Length == 6) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  		}  	}  } else if (path.Contains (".sde")) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path);  } else if (path.Contains (".gdb")) {  	pLocWork = OpenFileGDBDatabaseLocatorWorkspace (path);  } else if (path.Contains (".mdb")) {  	pLocWork = OpenPersonalGDBDatabaseLocatorWorkspace (path);  } else {  	pLocWork = OpenLocatorWorkspace (path);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (path.Contains (";")) {  	if (path.ToUpper ().Contains ("SERVER=")) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  	} else {  		string[] strSDEStuff = path.Split (';');  		if (strSDEStuff.Length == 5) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  		} else if (strSDEStuff.Length == 6) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  		}  	}  } else if (path.Contains (".sde")) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path);  } else if (path.Contains (".gdb")) {  	pLocWork = OpenFileGDBDatabaseLocatorWorkspace (path);  } else if (path.Contains (".mdb")) {  	pLocWork = OpenPersonalGDBDatabaseLocatorWorkspace (path);  } else {  	pLocWork = OpenLocatorWorkspace (path);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (path.Contains (";")) {  	if (path.ToUpper ().Contains ("SERVER=")) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  	} else {  		string[] strSDEStuff = path.Split (';');  		if (strSDEStuff.Length == 5) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  		} else if (strSDEStuff.Length == 6) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  		}  	}  } else if (path.Contains (".sde")) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path);  } else if (path.Contains (".gdb")) {  	pLocWork = OpenFileGDBDatabaseLocatorWorkspace (path);  } else if (path.Contains (".mdb")) {  	pLocWork = OpenPersonalGDBDatabaseLocatorWorkspace (path);  } else {  	pLocWork = OpenLocatorWorkspace (path);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (path.Contains (";")) {  	if (path.ToUpper ().Contains ("SERVER=")) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  	} else {  		string[] strSDEStuff = path.Split (';');  		if (strSDEStuff.Length == 5) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  		} else if (strSDEStuff.Length == 6) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  		}  	}  } else if (path.Contains (".sde")) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path);  } else if (path.Contains (".gdb")) {  	pLocWork = OpenFileGDBDatabaseLocatorWorkspace (path);  } else if (path.Contains (".mdb")) {  	pLocWork = OpenPersonalGDBDatabaseLocatorWorkspace (path);  } else {  	pLocWork = OpenLocatorWorkspace (path);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (path.Contains (";")) {  	if (path.ToUpper ().Contains ("SERVER=")) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  	} else {  		string[] strSDEStuff = path.Split (';');  		if (strSDEStuff.Length == 5) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  		} else if (strSDEStuff.Length == 6) {  			pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  		}  	}  } else if (path.Contains (".sde")) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path);  } else if (path.Contains (".gdb")) {  	pLocWork = OpenFileGDBDatabaseLocatorWorkspace (path);  } else if (path.Contains (".mdb")) {  	pLocWork = OpenPersonalGDBDatabaseLocatorWorkspace (path);  } else {  	pLocWork = OpenLocatorWorkspace (path);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (path.ToUpper ().Contains ("SERVER=")) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  } else {  	string[] strSDEStuff = path.Split (';');  	if (strSDEStuff.Length == 5) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  	} else if (strSDEStuff.Length == 6) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (path.ToUpper ().Contains ("SERVER=")) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  } else {  	string[] strSDEStuff = path.Split (';');  	if (strSDEStuff.Length == 5) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  	} else if (strSDEStuff.Length == 6) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (path.ToUpper ().Contains ("SERVER=")) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  } else {  	string[] strSDEStuff = path.Split (';');  	if (strSDEStuff.Length == 5) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  	} else if (strSDEStuff.Length == 6) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (path.ToUpper ().Contains ("SERVER=")) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  } else {  	string[] strSDEStuff = path.Split (';');  	if (strSDEStuff.Length == 5) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  	} else if (strSDEStuff.Length == 6) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (path.ToUpper ().Contains ("SERVER=")) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  } else {  	string[] strSDEStuff = path.Split (';');  	if (strSDEStuff.Length == 5) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  	} else if (strSDEStuff.Length == 6) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (path.ToUpper ().Contains ("SERVER=")) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  } else {  	string[] strSDEStuff = path.Split (';');  	if (strSDEStuff.Length == 5) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  	} else if (strSDEStuff.Length == 6) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (path.ToUpper ().Contains ("SERVER=")) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  } else {  	string[] strSDEStuff = path.Split (';');  	if (strSDEStuff.Length == 5) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  	} else if (strSDEStuff.Length == 6) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (path.ToUpper ().Contains ("SERVER=")) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  } else {  	string[] strSDEStuff = path.Split (';');  	if (strSDEStuff.Length == 5) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  	} else if (strSDEStuff.Length == 6) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (path.ToUpper ().Contains ("SERVER=")) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (path' "t");  } else {  	string[] strSDEStuff = path.Split (';');  	if (strSDEStuff.Length == 5) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  	} else if (strSDEStuff.Length == 6) {  		pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (strSDEStuff.Length == 5) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  } else if (strSDEStuff.Length == 6) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (strSDEStuff.Length == 5) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  } else if (strSDEStuff.Length == 6) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (strSDEStuff.Length == 5) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  } else if (strSDEStuff.Length == 6) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (strSDEStuff.Length == 5) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  } else if (strSDEStuff.Length == 6) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (strSDEStuff.Length == 5) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  } else if (strSDEStuff.Length == 6) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (strSDEStuff.Length == 5) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  } else if (strSDEStuff.Length == 6) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (strSDEStuff.Length == 5) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  } else if (strSDEStuff.Length == 6) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (strSDEStuff.Length == 5) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  } else if (strSDEStuff.Length == 6) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (strSDEStuff.Length == 5) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  } else if (strSDEStuff.Length == 6) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (strSDEStuff.Length == 6) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (strSDEStuff.Length == 6) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (strSDEStuff.Length == 6) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (strSDEStuff.Length == 6) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: if (strSDEStuff.Length == 6) {  	pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,OpenLocator,The following statement contains a magic number: pLocWork = OpenArcSDEDatabaseLocatorWorkspace (strSDEStuff [0]' strSDEStuff [1]' strSDEStuff [2]' strSDEStuff [3]' strSDEStuff [4]' strSDEStuff [5]);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,EstablishFlow,The following statement contains a magic number: try {  	int calcCount = 0;  	//Get editor  	editor = Globals.getEditor (ref app);  	if (editor.EditState != esriEditState.esriStateEditing) {  		MessageBox.Show ("Must be editing."' "Desktop Tools");  		return;  	}  	eLayers = editor as IEditLayers;  	//Change mouse cursor to wait - automatically changes back (ArcGIS Desktop only)  	appCursor = new MouseCursorClass ();  	appCursor.SetCursor (2);  	ESRI.ArcGIS.esriSystem.IStatusBar statusBar = app.StatusBar;  	statusBar.set_Message (0' "Establishing flow direction. Please wait....");  	//Get NA Extension in order to update the current network with the first visible network  	pUID = new UIDClass ();  	pUID.Value = "esriEditorExt.UtilityNetworkAnalysisExt";  	netExt = app.FindExtensionByCLSID (pUID) as INetworkAnalysisExt;  	//Get Visible geometric networks  	pMap = editor.Map;  	bool editStarted = false;  	try {  		// Create an edit operation enabling undo/redo  		editor.StartOperation ();  		editStarted = true;  	} catch {  		editStarted = false;  	}  	IEnumFeatureClass enumFC = null;  	INetwork net = null;  	IUtilityNetworkGEN unet = null;  	IEnumNetEID edgeEIDs = null;  	//IFeatureLayer fLayer = null;  	try {  		// fLayer = Globals.FindLayerByFeatureClass(pMap' gn.OrphanJunctionFeatureClass' false);  		//if (fLayer == null)  		//{  		//    MessageBox.Show("Unable to set flow direction for " + gn.FeatureDataset.Name + ".  Add the " + gn.OrphanJunctionFeatureClass.AliasName + " to your map and try again' if needed"' "Establish Flow Direction");  		//    stepProgressor.Step();  		//    continue;  		//}  		//if (!eLayers.IsEditable(fLayer))  		//{  		//    MessageBox.Show("Unable to set flow direction for " + gn.FeatureDataset.Name + ".  It is visible but not editable."' "Establish Flow Direction");  		//    stepProgressor.Step();  		//    continue;  		//}  		//Establish flow using AncillaryRole values  		if (flowDirection == GNFlowDirection.AncillaryRole) {  			enumFC = gn.get_ClassesByNetworkAncillaryRole (esriNetworkClassAncillaryRole.esriNCARSourceSink);  			if (enumFC.Next () == null)  				MessageBox.Show ("Flow direction for " + gn.FeatureDataset.Name + " not set.  No feature classes have source/sink capability." + Environment.NewLine + "You must recreate your geometric network to use this command on this network."' "Establish Flow");  			else {  				gn.EstablishFlowDirection ();  				calcCount += 1;  			}  		} //Establish flow direction based on digitized direction.  		else {  			net = gn.Network;  			unet = net as IUtilityNetworkGEN;  			edgeEIDs = net.CreateNetBrowser (esriElementType.esriETEdge);  			edgeEIDs.Reset ();  			int edgeEID;  			for (long j = 0; j < edgeEIDs.Count; j++) {  				edgeEID = edgeEIDs.Next ();  				unet.SetFlowDirection (edgeEID' esriFlowDirection.esriFDWithFlow);  			}  			calcCount += 1;  		}  	} catch (Exception ex) {  		editor.AbortOperation ();  		MessageBox.Show ("EstablishFlow\n" + ex.ToString ()' ex.Source);  	} finally {  		net = null;  		unet = null;  		edgeEIDs = null;  		//fLayer = null;  	}  	if (editStarted) {  		// Stop the edit operation  		if (flowDirection == GNFlowDirection.AncillaryRole)  			editor.StopOperation ("Establish Flow");  		else  			editor.StopOperation ("Establish Flow by Digitized Direction");  	}  	object Missing = Type.Missing;  	mxdoc = app.Document as IMxDocument;  	mxdoc.ActiveView.PartialRefresh (esriViewDrawPhase.esriViewGraphics' Missing' mxdoc.ActiveView.Extent);  	if (app != null)  		app.StatusBar.set_Message (2' "Flow direction established for " + calcCount + " geometric network(s).");  } catch (Exception ex) {  	return;  } finally {  	editor = null;  	eLayers = null;  	appCursor = null;  	netExt = null;  	pUID = null;  	pMap = null;  	mxdoc = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,EstablishFlow,The following statement contains a magic number: try {  	int calcCount = 0;  	//Get editor  	editor = Globals.getEditor (ref app);  	if (editor.EditState != esriEditState.esriStateEditing) {  		MessageBox.Show ("Must be editing."' "Desktop Tools");  		return;  	}  	eLayers = editor as IEditLayers;  	//Change mouse cursor to wait - automatically changes back (ArcGIS Desktop only)  	appCursor = new MouseCursorClass ();  	appCursor.SetCursor (2);  	ESRI.ArcGIS.esriSystem.IStatusBar statusBar = app.StatusBar;  	statusBar.set_Message (0' "Establishing flow direction. Please wait....");  	//Get NA Extension in order to update the current network with the first visible network  	pUID = new UIDClass ();  	pUID.Value = "esriEditorExt.UtilityNetworkAnalysisExt";  	netExt = app.FindExtensionByCLSID (pUID) as INetworkAnalysisExt;  	//Get Visible geometric networks  	pMap = editor.Map;  	bool editStarted = false;  	try {  		// Create an edit operation enabling undo/redo  		editor.StartOperation ();  		editStarted = true;  	} catch {  		editStarted = false;  	}  	IEnumFeatureClass enumFC = null;  	INetwork net = null;  	IUtilityNetworkGEN unet = null;  	IEnumNetEID edgeEIDs = null;  	//IFeatureLayer fLayer = null;  	try {  		// fLayer = Globals.FindLayerByFeatureClass(pMap' gn.OrphanJunctionFeatureClass' false);  		//if (fLayer == null)  		//{  		//    MessageBox.Show("Unable to set flow direction for " + gn.FeatureDataset.Name + ".  Add the " + gn.OrphanJunctionFeatureClass.AliasName + " to your map and try again' if needed"' "Establish Flow Direction");  		//    stepProgressor.Step();  		//    continue;  		//}  		//if (!eLayers.IsEditable(fLayer))  		//{  		//    MessageBox.Show("Unable to set flow direction for " + gn.FeatureDataset.Name + ".  It is visible but not editable."' "Establish Flow Direction");  		//    stepProgressor.Step();  		//    continue;  		//}  		//Establish flow using AncillaryRole values  		if (flowDirection == GNFlowDirection.AncillaryRole) {  			enumFC = gn.get_ClassesByNetworkAncillaryRole (esriNetworkClassAncillaryRole.esriNCARSourceSink);  			if (enumFC.Next () == null)  				MessageBox.Show ("Flow direction for " + gn.FeatureDataset.Name + " not set.  No feature classes have source/sink capability." + Environment.NewLine + "You must recreate your geometric network to use this command on this network."' "Establish Flow");  			else {  				gn.EstablishFlowDirection ();  				calcCount += 1;  			}  		} //Establish flow direction based on digitized direction.  		else {  			net = gn.Network;  			unet = net as IUtilityNetworkGEN;  			edgeEIDs = net.CreateNetBrowser (esriElementType.esriETEdge);  			edgeEIDs.Reset ();  			int edgeEID;  			for (long j = 0; j < edgeEIDs.Count; j++) {  				edgeEID = edgeEIDs.Next ();  				unet.SetFlowDirection (edgeEID' esriFlowDirection.esriFDWithFlow);  			}  			calcCount += 1;  		}  	} catch (Exception ex) {  		editor.AbortOperation ();  		MessageBox.Show ("EstablishFlow\n" + ex.ToString ()' ex.Source);  	} finally {  		net = null;  		unet = null;  		edgeEIDs = null;  		//fLayer = null;  	}  	if (editStarted) {  		// Stop the edit operation  		if (flowDirection == GNFlowDirection.AncillaryRole)  			editor.StopOperation ("Establish Flow");  		else  			editor.StopOperation ("Establish Flow by Digitized Direction");  	}  	object Missing = Type.Missing;  	mxdoc = app.Document as IMxDocument;  	mxdoc.ActiveView.PartialRefresh (esriViewDrawPhase.esriViewGraphics' Missing' mxdoc.ActiveView.Extent);  	if (app != null)  		app.StatusBar.set_Message (2' "Flow direction established for " + calcCount + " geometric network(s).");  } catch (Exception ex) {  	return;  } finally {  	editor = null;  	eLayers = null;  	appCursor = null;  	netExt = null;  	pUID = null;  	pMap = null;  	mxdoc = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,EstablishFlow,The following statement contains a magic number: appCursor.SetCursor (2);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,EstablishFlow,The following statement contains a magic number: if (app != null)  	app.StatusBar.set_Message (2' "Flow direction established for " + calcCount + " geometric network(s).");  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,EstablishFlow,The following statement contains a magic number: app.StatusBar.set_Message (2' "Flow direction established for " + calcCount + " geometric network(s).");  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,createFeatureClassInMemory,The following statement contains a magic number: try {  	//CLSEXT = null;  	pFWS = (IFeatureWorkspace)pWS;  	if (CLSID == null) {  		CLSID = new ESRI.ArcGIS.esriSystem.UIDClass ();  		CLSID.Value = "esriGeoDatabase.Feature";  	}  	fieldChecker = new ESRI.ArcGIS.Geodatabase.FieldCheckerClass ();  	enumFieldError = null;  	validatedFields = null;  	fieldChecker.ValidateWorkspace = pWS;  	try {  		fieldChecker.Validate (FeatureFields' out enumFieldError' out validatedFields);  	} catch (Exception e) {  		validatedFields = FeatureFields;  	}  	bool FCCreated = false;  	int loopCnt = 0;  	if (featType == esriFeatureType.esriFTComplexEdge) {  		featType = esriFeatureType.esriFTSimple;  	}  	if (featType == esriFeatureType.esriFTComplexJunction) {  		featType = esriFeatureType.esriFTSimple;  	}  	if (featType == esriFeatureType.esriFTSimpleJunction) {  		featType = esriFeatureType.esriFTSimple;  	}  	while (FCCreated == false) {  		try {  			if (loopCnt == 0) {  				loopCnt = loopCnt + 1;  				newFeat = pFWS.CreateFeatureClass (strName' validatedFields' null' null' featType' "SHAPE"' "");  			} else {  				loopCnt = loopCnt + 1;  				newFeat = pFWS.CreateFeatureClass (strName + (loopCnt - 1).ToString ()' validatedFields' null' null' featType' "SHAPE"' "");  			}  			FCCreated = true;  		} catch (Exception ex) {  			FCCreated = false;  		}  		if (loopCnt == 5)  			FCCreated = true;  	}  	return newFeat;  } catch (Exception ex) {  	return null;  } finally {  	CLSID = null;  	pFWS = null;  	fieldChecker = null;  	enumFieldError = null;  	validatedFields = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,createFeatureClassInMemory,The following statement contains a magic number: while (FCCreated == false) {  	try {  		if (loopCnt == 0) {  			loopCnt = loopCnt + 1;  			newFeat = pFWS.CreateFeatureClass (strName' validatedFields' null' null' featType' "SHAPE"' "");  		} else {  			loopCnt = loopCnt + 1;  			newFeat = pFWS.CreateFeatureClass (strName + (loopCnt - 1).ToString ()' validatedFields' null' null' featType' "SHAPE"' "");  		}  		FCCreated = true;  	} catch (Exception ex) {  		FCCreated = false;  	}  	if (loopCnt == 5)  		FCCreated = true;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,createFeatureClassInMemory,The following statement contains a magic number: if (loopCnt == 5)  	FCCreated = true;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,copyFields,The following statement contains a magic number: try {  	pFields = new FieldsClass ();  	pFieldsEdit = (IFieldsEdit)pFields;  	int totFlds = SourceFields.FieldCount;  	bool idFieldExist = false;  	bool dateFieldExist = false;  	int resFldCnt = totFlds;  	for (int i = 0; i < totFlds; i++) {  		SourceField = SourceFields.get_Field (i);  		if (IDFieldName != null) {  			if (SourceField.Name == IDFieldName) {  				idFieldExist = true;  				IDFieldName = null;  			}  		}  		if (DateFieldName != null) {  			if (SourceField.Name == DateFieldName) {  				dateFieldExist = true;  				DateFieldName = null;  			}  		}  		if (SourceField == lenFld) {  			resFldCnt = resFldCnt - 1;  		}  		if (SourceField == areaField) {  			resFldCnt = resFldCnt - 1;  		}  	}  	if (idFieldExist == false && IDFieldName != null) {  		resFldCnt++;  	}  	if (dateFieldExist == false && DateFieldName != null) {  		resFldCnt++;  	}  	pFieldsEdit.FieldCount_2 = resFldCnt;  	int addFldIdx = 0;  	for (int i = 0; i < totFlds; i++) {  		SourceField = SourceFields.get_Field (i);  		if (SourceField == lenFld || SourceField == areaField) {  			//pField = new FieldClass();  			//pFieldEdit = (IFieldEdit)pField;  			//pFieldEdit.Editable_2 = SourceField.Editable;  			//pFieldEdit.Name_2 = SourceField.Name;  			//pFieldEdit.IsNullable_2 = SourceField.IsNullable;  			//pFieldEdit.Length_2 = SourceField.Length;  			//pFieldEdit.Precision_2 = SourceField.Precision;  			//pFieldEdit.Type_2 = SourceField.Type;  			//pFieldsEdit.set_Field(addFldIdx' pField);  			//addFldIdx++;  		} else if (SourceField.Type == esriFieldType.esriFieldTypeGeometry) {  			clone = SourceField as IClone;  			pField = clone.Clone () as IField;  			if (removeMZ) {  				pGeomDefEdit = (IGeometryDefEdit)pField.GeometryDef;  				pGeomDefEdit.HasM_2 = false;  				pGeomDefEdit.HasZ_2 = false;  			}  			pFieldsEdit.set_Field (addFldIdx' pField);  			addFldIdx++;  		} else if (SourceField.Type == esriFieldType.esriFieldTypeOID) {  			clone = SourceField as IClone;  			pField = clone.Clone () as IField;  			pFieldsEdit.set_Field (addFldIdx' pField);  			addFldIdx++;  		} else if (SourceField.Type == esriFieldType.esriFieldTypeGlobalID) {  			pField = new FieldClass ();  			pFieldEdit = (IFieldEdit)pField;  			pFieldEdit.Editable_2 = true;  			pFieldEdit.Name_2 = SourceField.Name;  			pFieldEdit.IsNullable_2 = SourceField.IsNullable;  			pFieldEdit.Length_2 = SourceField.Length;  			pFieldEdit.Precision_2 = SourceField.Precision;  			pFieldEdit.Type_2 = esriFieldType.esriFieldTypeGUID;  			pFieldsEdit.set_Field (addFldIdx' pField);  			addFldIdx++;  		} else if (SourceField.Editable) {  			//IClone clone = SourceField as IClone;  			//pField = clone.Clone() as IField;  			//pFieldsEdit.set_Field(i' pField);  			pField = new FieldClass ();  			pFieldEdit = (IFieldEdit)pField;  			pFieldEdit.Editable_2 = SourceField.Editable;  			pFieldEdit.Name_2 = SourceField.Name;  			pFieldEdit.IsNullable_2 = SourceField.IsNullable;  			pFieldEdit.Length_2 = SourceField.Length;  			pFieldEdit.Precision_2 = SourceField.Precision;  			pFieldEdit.Type_2 = SourceField.Type;  			pFieldsEdit.set_Field (addFldIdx' pField);  			addFldIdx++;  		} else {  			pField = new FieldClass ();  			pFieldEdit = (IFieldEdit)pField;  			pFieldEdit.Editable_2 = SourceField.Editable;  			pFieldEdit.Name_2 = SourceField.Name;  			pFieldEdit.IsNullable_2 = SourceField.IsNullable;  			pFieldEdit.Length_2 = SourceField.Length;  			pFieldEdit.Precision_2 = SourceField.Precision;  			pFieldEdit.Type_2 = SourceField.Type;  			pFieldsEdit.set_Field (addFldIdx' pField);  			addFldIdx++;  		}  		//else  		//{  		//    pField = new FieldClass();  		//    pFieldEdit = (IFieldEdit)pField;  		//    pFieldEdit.Editable_2 = true;  		//    pFieldEdit.Name_2 = SourceField.Name;  		//    pFieldEdit.IsNullable_2 = SourceField.IsNullable;  		//    pFieldEdit.Length_2 = SourceField.Length;  		//    pFieldEdit.Precision_2 = SourceField.Precision;  		//    pFieldEdit.Type_2 = SourceField.Type;  		//}  	}  	if (IDFieldName != null) {  		pField = new FieldClass ();  		pFieldEdit = (IFieldEdit)pField;  		pFieldEdit.Editable_2 = true;  		pFieldEdit.Name_2 = IDFieldName;  		pFieldEdit.IsNullable_2 = true;  		pFieldEdit.Length_2 = 50;  		pFieldEdit.Precision_2 = 0;  		pFieldEdit.Type_2 = esriFieldType.esriFieldTypeString;  		pFieldsEdit.set_Field (addFldIdx' pField);  		addFldIdx++;  	}  	if (DateFieldName != null) {  		pField = new FieldClass ();  		pFieldEdit = (IFieldEdit)pField;  		pFieldEdit.Editable_2 = true;  		pFieldEdit.Name_2 = DateFieldName;  		pFieldEdit.IsNullable_2 = true;  		//pFieldEdit.Length_2 = 50;  		//pFieldEdit.Precision_2 = 0;  		pFieldEdit.Type_2 = esriFieldType.esriFieldTypeDate;  		pFieldsEdit.set_Field (addFldIdx' pField);  		addFldIdx++;  	}  	return pFields;  } catch (Exception ex) {  	MessageBox.Show ("copyFields: " + ex.ToString ());  	return null;  } finally {  	pFields = null;  	pFieldsEdit = null;  	pField = null;  	pFieldEdit = null;  	SourceField = null;  	pGeomDefEdit = null;  	clone = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,copyFields,The following statement contains a magic number: if (IDFieldName != null) {  	pField = new FieldClass ();  	pFieldEdit = (IFieldEdit)pField;  	pFieldEdit.Editable_2 = true;  	pFieldEdit.Name_2 = IDFieldName;  	pFieldEdit.IsNullable_2 = true;  	pFieldEdit.Length_2 = 50;  	pFieldEdit.Precision_2 = 0;  	pFieldEdit.Type_2 = esriFieldType.esriFieldTypeString;  	pFieldsEdit.set_Field (addFldIdx' pField);  	addFldIdx++;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,copyFields,The following statement contains a magic number: pFieldEdit.Length_2 = 50;  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectJunctions,The following statement contains a magic number: try {  	featureClass = pFL.FeatureClass;  	spatialFilter = new SpatialFilterClass ();  	spatialFilter.Geometry = Extent;  	spatialFilter.GeometryField = featureClass.ShapeFieldName;  	spatialFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelIntersects;  	int totSel = pFL.FeatureClass.FeatureCount (spatialFilter);  	stepProgressor.StepValue = 0;  	pLbl = new Label ();  	featureSel = (IFeatureSelection)pFL;  	featureCursor = featureClass.Search (spatialFilter' false);  	int k = 0;  	feature = featureCursor.NextFeature ();  	while (feature != null) {  		junctionFeature = (ISimpleJunctionFeature)feature;  		k += 1;  		//Update progress bar  		progressDialog.Description = pFL.Name + ": " + A4LGSharedFunctions.Localizer.GetString ("SltByJctCountProc_3") + k.ToString () + A4LGSharedFunctions.Localizer.GetString ("Of") + totSel.ToString () + ".";  		stepProgressor.Step ();  		//Check if the cancel button was pressed. If so' stop process  		bool boolean_Continue = trackCancel.Continue ();  		if (!boolean_Continue) {  			break;  		}  		#region select features where edgecount meets request number  		switch (comparsionAbbrev) {  		//special case  		case "ORPHAN":  			if (junctionFeature.EdgeFeatureCount == 0) {  				Count += 1;  				featureSel.Add (feature);  			} else if (junctionFeature.EdgeFeatureCount == 2) {  				feat1 = junctionFeature.get_EdgeFeature (0) as IFeature;  				feat2 = junctionFeature.get_EdgeFeature (1) as IFeature;  				if ((feat1.OID == feat2.OID) && (feat1.Class.ObjectClassID == feat2.Class.ObjectClassID)) {  					Count += 1;  					featureSel.Add (feature);  				}  			}  			break;  		case "LT": {  			if (junctionFeature.EdgeFeatureCount < numberOfEdges) {  				Count += 1;  				featureSel.Add (feature);  				break;  			}  			break;  		}  		case "LE": {  			if (junctionFeature.EdgeFeatureCount <= numberOfEdges) {  				Count += 1;  				featureSel.Add (feature);  			}  			break;  		}  		case "GT": {  			if (junctionFeature.EdgeFeatureCount > numberOfEdges) {  				Count += 1;  				featureSel.Add (feature);  			}  			break;  		}  		case "GE": {  			if (junctionFeature.EdgeFeatureCount >= numberOfEdges) {  				Count += 1;  				featureSel.Add (feature);  			}  			break;  		}  		case "EQ": {  			if (junctionFeature.EdgeFeatureCount == numberOfEdges) {  				Count += 1;  				featureSel.Add (feature);  			}  			break;  		}  		case "NE": {  			if (junctionFeature.EdgeFeatureCount == numberOfEdges) {  				Count += 1;  				featureSel.Add (feature);  			}  			break;  		}  		default://LT  		 {  			if (junctionFeature.EdgeFeatureCount < numberOfEdges) {  				Count += 1;  				featureSel.Add (feature);  			}  			break;  		}  		}  		#endregion  		feature = featureCursor.NextFeature ();  	}  	return Count;  } catch {  	return 0;  } finally {  	if (featureCursor != null) {  		Marshal.ReleaseComObject (featureCursor);  	}  	featureClass = null;  	spatialFilter = null;  	featureCursor = null;  	feature = null;  	featureSel = null;  	junctionFeature = null;  	pLbl = null;  	feat1 = null;  	feat2 = null;  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectJunctions,The following statement contains a magic number: while (feature != null) {  	junctionFeature = (ISimpleJunctionFeature)feature;  	k += 1;  	//Update progress bar  	progressDialog.Description = pFL.Name + ": " + A4LGSharedFunctions.Localizer.GetString ("SltByJctCountProc_3") + k.ToString () + A4LGSharedFunctions.Localizer.GetString ("Of") + totSel.ToString () + ".";  	stepProgressor.Step ();  	//Check if the cancel button was pressed. If so' stop process  	bool boolean_Continue = trackCancel.Continue ();  	if (!boolean_Continue) {  		break;  	}  	#region select features where edgecount meets request number  	switch (comparsionAbbrev) {  	//special case  	case "ORPHAN":  		if (junctionFeature.EdgeFeatureCount == 0) {  			Count += 1;  			featureSel.Add (feature);  		} else if (junctionFeature.EdgeFeatureCount == 2) {  			feat1 = junctionFeature.get_EdgeFeature (0) as IFeature;  			feat2 = junctionFeature.get_EdgeFeature (1) as IFeature;  			if ((feat1.OID == feat2.OID) && (feat1.Class.ObjectClassID == feat2.Class.ObjectClassID)) {  				Count += 1;  				featureSel.Add (feature);  			}  		}  		break;  	case "LT": {  		if (junctionFeature.EdgeFeatureCount < numberOfEdges) {  			Count += 1;  			featureSel.Add (feature);  			break;  		}  		break;  	}  	case "LE": {  		if (junctionFeature.EdgeFeatureCount <= numberOfEdges) {  			Count += 1;  			featureSel.Add (feature);  		}  		break;  	}  	case "GT": {  		if (junctionFeature.EdgeFeatureCount > numberOfEdges) {  			Count += 1;  			featureSel.Add (feature);  		}  		break;  	}  	case "GE": {  		if (junctionFeature.EdgeFeatureCount >= numberOfEdges) {  			Count += 1;  			featureSel.Add (feature);  		}  		break;  	}  	case "EQ": {  		if (junctionFeature.EdgeFeatureCount == numberOfEdges) {  			Count += 1;  			featureSel.Add (feature);  		}  		break;  	}  	case "NE": {  		if (junctionFeature.EdgeFeatureCount == numberOfEdges) {  			Count += 1;  			featureSel.Add (feature);  		}  		break;  	}  	default://LT  	 {  		if (junctionFeature.EdgeFeatureCount < numberOfEdges) {  			Count += 1;  			featureSel.Add (feature);  		}  		break;  	}  	}  	#endregion  	feature = featureCursor.NextFeature ();  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectJunctions,The following statement contains a magic number: switch (comparsionAbbrev) {  //special case  case "ORPHAN":  	if (junctionFeature.EdgeFeatureCount == 0) {  		Count += 1;  		featureSel.Add (feature);  	} else if (junctionFeature.EdgeFeatureCount == 2) {  		feat1 = junctionFeature.get_EdgeFeature (0) as IFeature;  		feat2 = junctionFeature.get_EdgeFeature (1) as IFeature;  		if ((feat1.OID == feat2.OID) && (feat1.Class.ObjectClassID == feat2.Class.ObjectClassID)) {  			Count += 1;  			featureSel.Add (feature);  		}  	}  	break;  case "LT": {  	if (junctionFeature.EdgeFeatureCount < numberOfEdges) {  		Count += 1;  		featureSel.Add (feature);  		break;  	}  	break;  }  case "LE": {  	if (junctionFeature.EdgeFeatureCount <= numberOfEdges) {  		Count += 1;  		featureSel.Add (feature);  	}  	break;  }  case "GT": {  	if (junctionFeature.EdgeFeatureCount > numberOfEdges) {  		Count += 1;  		featureSel.Add (feature);  	}  	break;  }  case "GE": {  	if (junctionFeature.EdgeFeatureCount >= numberOfEdges) {  		Count += 1;  		featureSel.Add (feature);  	}  	break;  }  case "EQ": {  	if (junctionFeature.EdgeFeatureCount == numberOfEdges) {  		Count += 1;  		featureSel.Add (feature);  	}  	break;  }  case "NE": {  	if (junctionFeature.EdgeFeatureCount == numberOfEdges) {  		Count += 1;  		featureSel.Add (feature);  	}  	break;  }  default://LT   {  	if (junctionFeature.EdgeFeatureCount < numberOfEdges) {  		Count += 1;  		featureSel.Add (feature);  	}  	break;  }  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectJunctions,The following statement contains a magic number: if (junctionFeature.EdgeFeatureCount == 0) {  	Count += 1;  	featureSel.Add (feature);  } else if (junctionFeature.EdgeFeatureCount == 2) {  	feat1 = junctionFeature.get_EdgeFeature (0) as IFeature;  	feat2 = junctionFeature.get_EdgeFeature (1) as IFeature;  	if ((feat1.OID == feat2.OID) && (feat1.Class.ObjectClassID == feat2.Class.ObjectClassID)) {  		Count += 1;  		featureSel.Add (feature);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,SelectJunctions,The following statement contains a magic number: if (junctionFeature.EdgeFeatureCount == 2) {  	feat1 = junctionFeature.get_EdgeFeature (0) as IFeature;  	feat2 = junctionFeature.get_EdgeFeature (1) as IFeature;  	if ((feat1.OID == feat2.OID) && (feat1.Class.ObjectClassID == feat2.Class.ObjectClassID)) {  		Count += 1;  		featureSel.Add (feature);  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetEIDInfoListByFCWithHT,The following statement contains a magic number: try {  	allEnumEidInfo = eidHelper.CreateEnumEIDInfo (juncEIDs);  	testEidInfo = allEnumEidInfo.Next ();  	while (testEidInfo != null) {  		if (featureClassIds.Contains (testEidInfo.Feature.Class.ObjectClassID)) {  			if (testEidInfo.Feature.Fields.FindField (operableFieldNameSources) > 0) {  				if (testEidInfo.Feature.get_Value (testEidInfo.Feature.Fields.FindField (operableFieldNameSources)) == null) {  					inHT.Add (testEidInfo.Feature.OID' testEidInfo);  				} else {  					if (testEidInfo.Feature.get_Value (testEidInfo.Feature.Fields.FindField (operableFieldNameSources)).ToString () == opValues [0]) {  						//inHT.Add(testEidInfo.Feature.OID' testEidInfo);  					} else {  						inHT.Add (testEidInfo.Feature.OID' testEidInfo);  					}  				}  			} else if (testEidInfo.Feature.Fields.FindFieldByAliasName (operableFieldNameSources) > 0) {  				if (testEidInfo.Feature.get_Value (testEidInfo.Feature.Fields.FindFieldByAliasName (operableFieldNameSources)) == null) {  					inHT.Add (testEidInfo.Feature.OID' testEidInfo);  				} else {  					if (testEidInfo.Feature.get_Value (testEidInfo.Feature.Fields.FindFieldByAliasName (operableFieldNameSources)).ToString () == opValues [0]) {  						//inHT.Add(testEidInfo.Feature.OID' testEidInfo);  					} else {  						inHT.Add (testEidInfo.Feature.OID' testEidInfo);  					}  				}  			} else  				inHT.Add (testEidInfo.Feature.OID' testEidInfo);  		}  		testEidInfo = allEnumEidInfo.Next ();  	}  	//return outputEIDInfoHT;  } catch (Exception ex) {  } finally {  	if (allEnumEidInfo != null) {  		Marshal.ReleaseComObject (allEnumEidInfo);  	}  	allEnumEidInfo = null;  	if (testEidInfo != null) {  		Marshal.ReleaseComObject (testEidInfo);  	}  	testEidInfo = null;  	GC.Collect ();  	GC.WaitForFullGCComplete (300);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetEIDInfoListByFCWithHT,The following statement contains a magic number: GC.WaitForFullGCComplete (300);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetOperableValveOIDs,The following statement contains a magic number: try {  	foreach (IFeatureClass valveFC in valveFCs) {  		//Find field  		int[] userId;  		int operableFieldPos = valveFC.FindField (operableFieldNameValves);  		qf = new QueryFilterClass ();  		qf.SubFields = valveFC.OIDFieldName;  		if (operableFieldPos > -1 && opValues.Length == 2 && opValues [0] != "") {  			opField = valveFC.Fields.get_Field (operableFieldPos);  			if (opField.Type == esriFieldType.esriFieldTypeInteger || opField.Type == esriFieldType.esriFieldTypeSmallInteger) {  				qf.WhereClause = "(" + operableFieldNameValves + " <> " + opValues [0] + " or " + operableFieldNameValves + " Is Null )";  			} else {  				qf.WhereClause = "(" + operableFieldNameValves + " <> '" + opValues [0] + "' or " + operableFieldNameValves + " Is Null )";  			}  		}  		if (addSQL != "") {  			if (qf.WhereClause == "") {  				qf.WhereClause = addSQL;  			} else {  				qf.WhereClause = qf.WhereClause + " AND " + addSQL;  			}  		}  		fCursor = valveFC.Search (qf' true);  		feat = fCursor.NextFeature ();  		int selCount = valveFC.FeatureCount (qf);  		userId = new int[selCount];  		if (selCount != 0) {  			for (int i = 0; i < selCount; i++) {  				//userId.Add(feat.OID);  				userId.SetValue (feat.OID' i);  				Marshal.ReleaseComObject (feat);  				feat = fCursor.NextFeature ();  			}  		}  		userIds.Add (userId);  		if (fCursor != null) {  			Marshal.ReleaseComObject (fCursor);  		}  		fCursor = null;  		GC.Collect ();  		GC.WaitForFullGCComplete (300);  	}  	return userIds;  	//.ToArray();  	//return userIds;  } catch (Exception ex) {  	return null;  } finally {  	if (fCursor != null) {  		Marshal.ReleaseComObject (fCursor);  	}  	fCursor = null;  	userIds = null;  	if (qf != null) {  		Marshal.ReleaseComObject (qf);  	}  	qf = null;  	if (opField != null) {  		Marshal.ReleaseComObject (opField);  	}  	opField = null;  	if (feat != null) {  		Marshal.ReleaseComObject (feat);  	}  	feat = null;  	GC.Collect ();  	GC.WaitForFullGCComplete (300);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetOperableValveOIDs,The following statement contains a magic number: try {  	foreach (IFeatureClass valveFC in valveFCs) {  		//Find field  		int[] userId;  		int operableFieldPos = valveFC.FindField (operableFieldNameValves);  		qf = new QueryFilterClass ();  		qf.SubFields = valveFC.OIDFieldName;  		if (operableFieldPos > -1 && opValues.Length == 2 && opValues [0] != "") {  			opField = valveFC.Fields.get_Field (operableFieldPos);  			if (opField.Type == esriFieldType.esriFieldTypeInteger || opField.Type == esriFieldType.esriFieldTypeSmallInteger) {  				qf.WhereClause = "(" + operableFieldNameValves + " <> " + opValues [0] + " or " + operableFieldNameValves + " Is Null )";  			} else {  				qf.WhereClause = "(" + operableFieldNameValves + " <> '" + opValues [0] + "' or " + operableFieldNameValves + " Is Null )";  			}  		}  		if (addSQL != "") {  			if (qf.WhereClause == "") {  				qf.WhereClause = addSQL;  			} else {  				qf.WhereClause = qf.WhereClause + " AND " + addSQL;  			}  		}  		fCursor = valveFC.Search (qf' true);  		feat = fCursor.NextFeature ();  		int selCount = valveFC.FeatureCount (qf);  		userId = new int[selCount];  		if (selCount != 0) {  			for (int i = 0; i < selCount; i++) {  				//userId.Add(feat.OID);  				userId.SetValue (feat.OID' i);  				Marshal.ReleaseComObject (feat);  				feat = fCursor.NextFeature ();  			}  		}  		userIds.Add (userId);  		if (fCursor != null) {  			Marshal.ReleaseComObject (fCursor);  		}  		fCursor = null;  		GC.Collect ();  		GC.WaitForFullGCComplete (300);  	}  	return userIds;  	//.ToArray();  	//return userIds;  } catch (Exception ex) {  	return null;  } finally {  	if (fCursor != null) {  		Marshal.ReleaseComObject (fCursor);  	}  	fCursor = null;  	userIds = null;  	if (qf != null) {  		Marshal.ReleaseComObject (qf);  	}  	qf = null;  	if (opField != null) {  		Marshal.ReleaseComObject (opField);  	}  	opField = null;  	if (feat != null) {  		Marshal.ReleaseComObject (feat);  	}  	feat = null;  	GC.Collect ();  	GC.WaitForFullGCComplete (300);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetOperableValveOIDs,The following statement contains a magic number: try {  	foreach (IFeatureClass valveFC in valveFCs) {  		//Find field  		int[] userId;  		int operableFieldPos = valveFC.FindField (operableFieldNameValves);  		qf = new QueryFilterClass ();  		qf.SubFields = valveFC.OIDFieldName;  		if (operableFieldPos > -1 && opValues.Length == 2 && opValues [0] != "") {  			opField = valveFC.Fields.get_Field (operableFieldPos);  			if (opField.Type == esriFieldType.esriFieldTypeInteger || opField.Type == esriFieldType.esriFieldTypeSmallInteger) {  				qf.WhereClause = "(" + operableFieldNameValves + " <> " + opValues [0] + " or " + operableFieldNameValves + " Is Null )";  			} else {  				qf.WhereClause = "(" + operableFieldNameValves + " <> '" + opValues [0] + "' or " + operableFieldNameValves + " Is Null )";  			}  		}  		if (addSQL != "") {  			if (qf.WhereClause == "") {  				qf.WhereClause = addSQL;  			} else {  				qf.WhereClause = qf.WhereClause + " AND " + addSQL;  			}  		}  		fCursor = valveFC.Search (qf' true);  		feat = fCursor.NextFeature ();  		int selCount = valveFC.FeatureCount (qf);  		userId = new int[selCount];  		if (selCount != 0) {  			for (int i = 0; i < selCount; i++) {  				//userId.Add(feat.OID);  				userId.SetValue (feat.OID' i);  				Marshal.ReleaseComObject (feat);  				feat = fCursor.NextFeature ();  			}  		}  		userIds.Add (userId);  		if (fCursor != null) {  			Marshal.ReleaseComObject (fCursor);  		}  		fCursor = null;  		GC.Collect ();  		GC.WaitForFullGCComplete (300);  	}  	return userIds;  	//.ToArray();  	//return userIds;  } catch (Exception ex) {  	return null;  } finally {  	if (fCursor != null) {  		Marshal.ReleaseComObject (fCursor);  	}  	fCursor = null;  	userIds = null;  	if (qf != null) {  		Marshal.ReleaseComObject (qf);  	}  	qf = null;  	if (opField != null) {  		Marshal.ReleaseComObject (opField);  	}  	opField = null;  	if (feat != null) {  		Marshal.ReleaseComObject (feat);  	}  	feat = null;  	GC.Collect ();  	GC.WaitForFullGCComplete (300);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetOperableValveOIDs,The following statement contains a magic number: foreach (IFeatureClass valveFC in valveFCs) {  	//Find field  	int[] userId;  	int operableFieldPos = valveFC.FindField (operableFieldNameValves);  	qf = new QueryFilterClass ();  	qf.SubFields = valveFC.OIDFieldName;  	if (operableFieldPos > -1 && opValues.Length == 2 && opValues [0] != "") {  		opField = valveFC.Fields.get_Field (operableFieldPos);  		if (opField.Type == esriFieldType.esriFieldTypeInteger || opField.Type == esriFieldType.esriFieldTypeSmallInteger) {  			qf.WhereClause = "(" + operableFieldNameValves + " <> " + opValues [0] + " or " + operableFieldNameValves + " Is Null )";  		} else {  			qf.WhereClause = "(" + operableFieldNameValves + " <> '" + opValues [0] + "' or " + operableFieldNameValves + " Is Null )";  		}  	}  	if (addSQL != "") {  		if (qf.WhereClause == "") {  			qf.WhereClause = addSQL;  		} else {  			qf.WhereClause = qf.WhereClause + " AND " + addSQL;  		}  	}  	fCursor = valveFC.Search (qf' true);  	feat = fCursor.NextFeature ();  	int selCount = valveFC.FeatureCount (qf);  	userId = new int[selCount];  	if (selCount != 0) {  		for (int i = 0; i < selCount; i++) {  			//userId.Add(feat.OID);  			userId.SetValue (feat.OID' i);  			Marshal.ReleaseComObject (feat);  			feat = fCursor.NextFeature ();  		}  	}  	userIds.Add (userId);  	if (fCursor != null) {  		Marshal.ReleaseComObject (fCursor);  	}  	fCursor = null;  	GC.Collect ();  	GC.WaitForFullGCComplete (300);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetOperableValveOIDs,The following statement contains a magic number: foreach (IFeatureClass valveFC in valveFCs) {  	//Find field  	int[] userId;  	int operableFieldPos = valveFC.FindField (operableFieldNameValves);  	qf = new QueryFilterClass ();  	qf.SubFields = valveFC.OIDFieldName;  	if (operableFieldPos > -1 && opValues.Length == 2 && opValues [0] != "") {  		opField = valveFC.Fields.get_Field (operableFieldPos);  		if (opField.Type == esriFieldType.esriFieldTypeInteger || opField.Type == esriFieldType.esriFieldTypeSmallInteger) {  			qf.WhereClause = "(" + operableFieldNameValves + " <> " + opValues [0] + " or " + operableFieldNameValves + " Is Null )";  		} else {  			qf.WhereClause = "(" + operableFieldNameValves + " <> '" + opValues [0] + "' or " + operableFieldNameValves + " Is Null )";  		}  	}  	if (addSQL != "") {  		if (qf.WhereClause == "") {  			qf.WhereClause = addSQL;  		} else {  			qf.WhereClause = qf.WhereClause + " AND " + addSQL;  		}  	}  	fCursor = valveFC.Search (qf' true);  	feat = fCursor.NextFeature ();  	int selCount = valveFC.FeatureCount (qf);  	userId = new int[selCount];  	if (selCount != 0) {  		for (int i = 0; i < selCount; i++) {  			//userId.Add(feat.OID);  			userId.SetValue (feat.OID' i);  			Marshal.ReleaseComObject (feat);  			feat = fCursor.NextFeature ();  		}  	}  	userIds.Add (userId);  	if (fCursor != null) {  		Marshal.ReleaseComObject (fCursor);  	}  	fCursor = null;  	GC.Collect ();  	GC.WaitForFullGCComplete (300);  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetOperableValveOIDs,The following statement contains a magic number: if (operableFieldPos > -1 && opValues.Length == 2 && opValues [0] != "") {  	opField = valveFC.Fields.get_Field (operableFieldPos);  	if (opField.Type == esriFieldType.esriFieldTypeInteger || opField.Type == esriFieldType.esriFieldTypeSmallInteger) {  		qf.WhereClause = "(" + operableFieldNameValves + " <> " + opValues [0] + " or " + operableFieldNameValves + " Is Null )";  	} else {  		qf.WhereClause = "(" + operableFieldNameValves + " <> '" + opValues [0] + "' or " + operableFieldNameValves + " Is Null )";  	}  }  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetOperableValveOIDs,The following statement contains a magic number: GC.WaitForFullGCComplete (300);  
Magic Number,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetOperableValveOIDs,The following statement contains a magic number: GC.WaitForFullGCComplete (300);  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: if (inFeature.Shape.GeometryType == esriGeometryType.esriGeometryPoint) {  	try {  		// double diameter = -1;  		List<double> angles = new List<double> ();  		List<double> diameters = new List<double> ();  		List<Boolean> flipDirections = new List<Boolean> ();  		IPoint pnt = (ESRI.ArcGIS.Geometry.IPoint)inFeature.ShapeCopy;  		IMxDocument pMxDoc = (IMxDocument)_app.Document;  		double snapdistnet = Globals.ConvertPixelsToMap (2' pMxDoc.FocusMap);  		// IMxDocument pMxDoc = (IMxDocument)_app.Document;  		// VBRotate rotFunc = new VBRotate();  		Rotate rotFunc = new Rotate ();  		if (!(inFeature is INetworkFeature)) {  			rotationAngle = rotFunc.RotatePoint (pMxDoc.FocusMap' pMxDoc.SearchTolerance' inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  		} else {  			rotationAngle = rotFunc.RotatePointByNetwork (pMxDoc.FocusMap' (INetworkFeature)inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  		}  		//If needed' convert to geographic degrees(zero north clockwise)  		if (rotationAngle != null) {  			if (rotationAngle > 360)  				rotationAngle -= 360;  			if (rotationAngle < 0)  				rotationAngle += 360;  			rotationAngle += m_spinAngle;  			if (rotationAngle > 360)  				rotationAngle -= 360;  			if (rotationAngle < 0)  				rotationAngle += 360;  		}  	} catch (Exception ex) {  		MessageBox.Show ("Error Rotation Feature at " + inFeature.Class.AliasName + " with Object ID:" + inFeature.OID + "\n" + ex.ToString ());  		return -1;  	}  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: if (inFeature.Shape.GeometryType == esriGeometryType.esriGeometryPoint) {  	try {  		// double diameter = -1;  		List<double> angles = new List<double> ();  		List<double> diameters = new List<double> ();  		List<Boolean> flipDirections = new List<Boolean> ();  		IPoint pnt = (ESRI.ArcGIS.Geometry.IPoint)inFeature.ShapeCopy;  		IMxDocument pMxDoc = (IMxDocument)_app.Document;  		double snapdistnet = Globals.ConvertPixelsToMap (2' pMxDoc.FocusMap);  		// IMxDocument pMxDoc = (IMxDocument)_app.Document;  		// VBRotate rotFunc = new VBRotate();  		Rotate rotFunc = new Rotate ();  		if (!(inFeature is INetworkFeature)) {  			rotationAngle = rotFunc.RotatePoint (pMxDoc.FocusMap' pMxDoc.SearchTolerance' inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  		} else {  			rotationAngle = rotFunc.RotatePointByNetwork (pMxDoc.FocusMap' (INetworkFeature)inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  		}  		//If needed' convert to geographic degrees(zero north clockwise)  		if (rotationAngle != null) {  			if (rotationAngle > 360)  				rotationAngle -= 360;  			if (rotationAngle < 0)  				rotationAngle += 360;  			rotationAngle += m_spinAngle;  			if (rotationAngle > 360)  				rotationAngle -= 360;  			if (rotationAngle < 0)  				rotationAngle += 360;  		}  	} catch (Exception ex) {  		MessageBox.Show ("Error Rotation Feature at " + inFeature.Class.AliasName + " with Object ID:" + inFeature.OID + "\n" + ex.ToString ());  		return -1;  	}  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: if (inFeature.Shape.GeometryType == esriGeometryType.esriGeometryPoint) {  	try {  		// double diameter = -1;  		List<double> angles = new List<double> ();  		List<double> diameters = new List<double> ();  		List<Boolean> flipDirections = new List<Boolean> ();  		IPoint pnt = (ESRI.ArcGIS.Geometry.IPoint)inFeature.ShapeCopy;  		IMxDocument pMxDoc = (IMxDocument)_app.Document;  		double snapdistnet = Globals.ConvertPixelsToMap (2' pMxDoc.FocusMap);  		// IMxDocument pMxDoc = (IMxDocument)_app.Document;  		// VBRotate rotFunc = new VBRotate();  		Rotate rotFunc = new Rotate ();  		if (!(inFeature is INetworkFeature)) {  			rotationAngle = rotFunc.RotatePoint (pMxDoc.FocusMap' pMxDoc.SearchTolerance' inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  		} else {  			rotationAngle = rotFunc.RotatePointByNetwork (pMxDoc.FocusMap' (INetworkFeature)inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  		}  		//If needed' convert to geographic degrees(zero north clockwise)  		if (rotationAngle != null) {  			if (rotationAngle > 360)  				rotationAngle -= 360;  			if (rotationAngle < 0)  				rotationAngle += 360;  			rotationAngle += m_spinAngle;  			if (rotationAngle > 360)  				rotationAngle -= 360;  			if (rotationAngle < 0)  				rotationAngle += 360;  		}  	} catch (Exception ex) {  		MessageBox.Show ("Error Rotation Feature at " + inFeature.Class.AliasName + " with Object ID:" + inFeature.OID + "\n" + ex.ToString ());  		return -1;  	}  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: if (inFeature.Shape.GeometryType == esriGeometryType.esriGeometryPoint) {  	try {  		// double diameter = -1;  		List<double> angles = new List<double> ();  		List<double> diameters = new List<double> ();  		List<Boolean> flipDirections = new List<Boolean> ();  		IPoint pnt = (ESRI.ArcGIS.Geometry.IPoint)inFeature.ShapeCopy;  		IMxDocument pMxDoc = (IMxDocument)_app.Document;  		double snapdistnet = Globals.ConvertPixelsToMap (2' pMxDoc.FocusMap);  		// IMxDocument pMxDoc = (IMxDocument)_app.Document;  		// VBRotate rotFunc = new VBRotate();  		Rotate rotFunc = new Rotate ();  		if (!(inFeature is INetworkFeature)) {  			rotationAngle = rotFunc.RotatePoint (pMxDoc.FocusMap' pMxDoc.SearchTolerance' inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  		} else {  			rotationAngle = rotFunc.RotatePointByNetwork (pMxDoc.FocusMap' (INetworkFeature)inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  		}  		//If needed' convert to geographic degrees(zero north clockwise)  		if (rotationAngle != null) {  			if (rotationAngle > 360)  				rotationAngle -= 360;  			if (rotationAngle < 0)  				rotationAngle += 360;  			rotationAngle += m_spinAngle;  			if (rotationAngle > 360)  				rotationAngle -= 360;  			if (rotationAngle < 0)  				rotationAngle += 360;  		}  	} catch (Exception ex) {  		MessageBox.Show ("Error Rotation Feature at " + inFeature.Class.AliasName + " with Object ID:" + inFeature.OID + "\n" + ex.ToString ());  		return -1;  	}  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: if (inFeature.Shape.GeometryType == esriGeometryType.esriGeometryPoint) {  	try {  		// double diameter = -1;  		List<double> angles = new List<double> ();  		List<double> diameters = new List<double> ();  		List<Boolean> flipDirections = new List<Boolean> ();  		IPoint pnt = (ESRI.ArcGIS.Geometry.IPoint)inFeature.ShapeCopy;  		IMxDocument pMxDoc = (IMxDocument)_app.Document;  		double snapdistnet = Globals.ConvertPixelsToMap (2' pMxDoc.FocusMap);  		// IMxDocument pMxDoc = (IMxDocument)_app.Document;  		// VBRotate rotFunc = new VBRotate();  		Rotate rotFunc = new Rotate ();  		if (!(inFeature is INetworkFeature)) {  			rotationAngle = rotFunc.RotatePoint (pMxDoc.FocusMap' pMxDoc.SearchTolerance' inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  		} else {  			rotationAngle = rotFunc.RotatePointByNetwork (pMxDoc.FocusMap' (INetworkFeature)inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  		}  		//If needed' convert to geographic degrees(zero north clockwise)  		if (rotationAngle != null) {  			if (rotationAngle > 360)  				rotationAngle -= 360;  			if (rotationAngle < 0)  				rotationAngle += 360;  			rotationAngle += m_spinAngle;  			if (rotationAngle > 360)  				rotationAngle -= 360;  			if (rotationAngle < 0)  				rotationAngle += 360;  		}  	} catch (Exception ex) {  		MessageBox.Show ("Error Rotation Feature at " + inFeature.Class.AliasName + " with Object ID:" + inFeature.OID + "\n" + ex.ToString ());  		return -1;  	}  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: if (inFeature.Shape.GeometryType == esriGeometryType.esriGeometryPoint) {  	try {  		// double diameter = -1;  		List<double> angles = new List<double> ();  		List<double> diameters = new List<double> ();  		List<Boolean> flipDirections = new List<Boolean> ();  		IPoint pnt = (ESRI.ArcGIS.Geometry.IPoint)inFeature.ShapeCopy;  		IMxDocument pMxDoc = (IMxDocument)_app.Document;  		double snapdistnet = Globals.ConvertPixelsToMap (2' pMxDoc.FocusMap);  		// IMxDocument pMxDoc = (IMxDocument)_app.Document;  		// VBRotate rotFunc = new VBRotate();  		Rotate rotFunc = new Rotate ();  		if (!(inFeature is INetworkFeature)) {  			rotationAngle = rotFunc.RotatePoint (pMxDoc.FocusMap' pMxDoc.SearchTolerance' inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  		} else {  			rotationAngle = rotFunc.RotatePointByNetwork (pMxDoc.FocusMap' (INetworkFeature)inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  		}  		//If needed' convert to geographic degrees(zero north clockwise)  		if (rotationAngle != null) {  			if (rotationAngle > 360)  				rotationAngle -= 360;  			if (rotationAngle < 0)  				rotationAngle += 360;  			rotationAngle += m_spinAngle;  			if (rotationAngle > 360)  				rotationAngle -= 360;  			if (rotationAngle < 0)  				rotationAngle += 360;  		}  	} catch (Exception ex) {  		MessageBox.Show ("Error Rotation Feature at " + inFeature.Class.AliasName + " with Object ID:" + inFeature.OID + "\n" + ex.ToString ());  		return -1;  	}  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: if (inFeature.Shape.GeometryType == esriGeometryType.esriGeometryPoint) {  	try {  		// double diameter = -1;  		List<double> angles = new List<double> ();  		List<double> diameters = new List<double> ();  		List<Boolean> flipDirections = new List<Boolean> ();  		IPoint pnt = (ESRI.ArcGIS.Geometry.IPoint)inFeature.ShapeCopy;  		IMxDocument pMxDoc = (IMxDocument)_app.Document;  		double snapdistnet = Globals.ConvertPixelsToMap (2' pMxDoc.FocusMap);  		// IMxDocument pMxDoc = (IMxDocument)_app.Document;  		// VBRotate rotFunc = new VBRotate();  		Rotate rotFunc = new Rotate ();  		if (!(inFeature is INetworkFeature)) {  			rotationAngle = rotFunc.RotatePoint (pMxDoc.FocusMap' pMxDoc.SearchTolerance' inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  		} else {  			rotationAngle = rotFunc.RotatePointByNetwork (pMxDoc.FocusMap' (INetworkFeature)inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  		}  		//If needed' convert to geographic degrees(zero north clockwise)  		if (rotationAngle != null) {  			if (rotationAngle > 360)  				rotationAngle -= 360;  			if (rotationAngle < 0)  				rotationAngle += 360;  			rotationAngle += m_spinAngle;  			if (rotationAngle > 360)  				rotationAngle -= 360;  			if (rotationAngle < 0)  				rotationAngle += 360;  		}  	} catch (Exception ex) {  		MessageBox.Show ("Error Rotation Feature at " + inFeature.Class.AliasName + " with Object ID:" + inFeature.OID + "\n" + ex.ToString ());  		return -1;  	}  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: try {  	// double diameter = -1;  	List<double> angles = new List<double> ();  	List<double> diameters = new List<double> ();  	List<Boolean> flipDirections = new List<Boolean> ();  	IPoint pnt = (ESRI.ArcGIS.Geometry.IPoint)inFeature.ShapeCopy;  	IMxDocument pMxDoc = (IMxDocument)_app.Document;  	double snapdistnet = Globals.ConvertPixelsToMap (2' pMxDoc.FocusMap);  	// IMxDocument pMxDoc = (IMxDocument)_app.Document;  	// VBRotate rotFunc = new VBRotate();  	Rotate rotFunc = new Rotate ();  	if (!(inFeature is INetworkFeature)) {  		rotationAngle = rotFunc.RotatePoint (pMxDoc.FocusMap' pMxDoc.SearchTolerance' inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  	} else {  		rotationAngle = rotFunc.RotatePointByNetwork (pMxDoc.FocusMap' (INetworkFeature)inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  	}  	//If needed' convert to geographic degrees(zero north clockwise)  	if (rotationAngle != null) {  		if (rotationAngle > 360)  			rotationAngle -= 360;  		if (rotationAngle < 0)  			rotationAngle += 360;  		rotationAngle += m_spinAngle;  		if (rotationAngle > 360)  			rotationAngle -= 360;  		if (rotationAngle < 0)  			rotationAngle += 360;  	}  } catch (Exception ex) {  	MessageBox.Show ("Error Rotation Feature at " + inFeature.Class.AliasName + " with Object ID:" + inFeature.OID + "\n" + ex.ToString ());  	return -1;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: try {  	// double diameter = -1;  	List<double> angles = new List<double> ();  	List<double> diameters = new List<double> ();  	List<Boolean> flipDirections = new List<Boolean> ();  	IPoint pnt = (ESRI.ArcGIS.Geometry.IPoint)inFeature.ShapeCopy;  	IMxDocument pMxDoc = (IMxDocument)_app.Document;  	double snapdistnet = Globals.ConvertPixelsToMap (2' pMxDoc.FocusMap);  	// IMxDocument pMxDoc = (IMxDocument)_app.Document;  	// VBRotate rotFunc = new VBRotate();  	Rotate rotFunc = new Rotate ();  	if (!(inFeature is INetworkFeature)) {  		rotationAngle = rotFunc.RotatePoint (pMxDoc.FocusMap' pMxDoc.SearchTolerance' inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  	} else {  		rotationAngle = rotFunc.RotatePointByNetwork (pMxDoc.FocusMap' (INetworkFeature)inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  	}  	//If needed' convert to geographic degrees(zero north clockwise)  	if (rotationAngle != null) {  		if (rotationAngle > 360)  			rotationAngle -= 360;  		if (rotationAngle < 0)  			rotationAngle += 360;  		rotationAngle += m_spinAngle;  		if (rotationAngle > 360)  			rotationAngle -= 360;  		if (rotationAngle < 0)  			rotationAngle += 360;  	}  } catch (Exception ex) {  	MessageBox.Show ("Error Rotation Feature at " + inFeature.Class.AliasName + " with Object ID:" + inFeature.OID + "\n" + ex.ToString ());  	return -1;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: try {  	// double diameter = -1;  	List<double> angles = new List<double> ();  	List<double> diameters = new List<double> ();  	List<Boolean> flipDirections = new List<Boolean> ();  	IPoint pnt = (ESRI.ArcGIS.Geometry.IPoint)inFeature.ShapeCopy;  	IMxDocument pMxDoc = (IMxDocument)_app.Document;  	double snapdistnet = Globals.ConvertPixelsToMap (2' pMxDoc.FocusMap);  	// IMxDocument pMxDoc = (IMxDocument)_app.Document;  	// VBRotate rotFunc = new VBRotate();  	Rotate rotFunc = new Rotate ();  	if (!(inFeature is INetworkFeature)) {  		rotationAngle = rotFunc.RotatePoint (pMxDoc.FocusMap' pMxDoc.SearchTolerance' inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  	} else {  		rotationAngle = rotFunc.RotatePointByNetwork (pMxDoc.FocusMap' (INetworkFeature)inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  	}  	//If needed' convert to geographic degrees(zero north clockwise)  	if (rotationAngle != null) {  		if (rotationAngle > 360)  			rotationAngle -= 360;  		if (rotationAngle < 0)  			rotationAngle += 360;  		rotationAngle += m_spinAngle;  		if (rotationAngle > 360)  			rotationAngle -= 360;  		if (rotationAngle < 0)  			rotationAngle += 360;  	}  } catch (Exception ex) {  	MessageBox.Show ("Error Rotation Feature at " + inFeature.Class.AliasName + " with Object ID:" + inFeature.OID + "\n" + ex.ToString ());  	return -1;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: try {  	// double diameter = -1;  	List<double> angles = new List<double> ();  	List<double> diameters = new List<double> ();  	List<Boolean> flipDirections = new List<Boolean> ();  	IPoint pnt = (ESRI.ArcGIS.Geometry.IPoint)inFeature.ShapeCopy;  	IMxDocument pMxDoc = (IMxDocument)_app.Document;  	double snapdistnet = Globals.ConvertPixelsToMap (2' pMxDoc.FocusMap);  	// IMxDocument pMxDoc = (IMxDocument)_app.Document;  	// VBRotate rotFunc = new VBRotate();  	Rotate rotFunc = new Rotate ();  	if (!(inFeature is INetworkFeature)) {  		rotationAngle = rotFunc.RotatePoint (pMxDoc.FocusMap' pMxDoc.SearchTolerance' inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  	} else {  		rotationAngle = rotFunc.RotatePointByNetwork (pMxDoc.FocusMap' (INetworkFeature)inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  	}  	//If needed' convert to geographic degrees(zero north clockwise)  	if (rotationAngle != null) {  		if (rotationAngle > 360)  			rotationAngle -= 360;  		if (rotationAngle < 0)  			rotationAngle += 360;  		rotationAngle += m_spinAngle;  		if (rotationAngle > 360)  			rotationAngle -= 360;  		if (rotationAngle < 0)  			rotationAngle += 360;  	}  } catch (Exception ex) {  	MessageBox.Show ("Error Rotation Feature at " + inFeature.Class.AliasName + " with Object ID:" + inFeature.OID + "\n" + ex.ToString ());  	return -1;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: try {  	// double diameter = -1;  	List<double> angles = new List<double> ();  	List<double> diameters = new List<double> ();  	List<Boolean> flipDirections = new List<Boolean> ();  	IPoint pnt = (ESRI.ArcGIS.Geometry.IPoint)inFeature.ShapeCopy;  	IMxDocument pMxDoc = (IMxDocument)_app.Document;  	double snapdistnet = Globals.ConvertPixelsToMap (2' pMxDoc.FocusMap);  	// IMxDocument pMxDoc = (IMxDocument)_app.Document;  	// VBRotate rotFunc = new VBRotate();  	Rotate rotFunc = new Rotate ();  	if (!(inFeature is INetworkFeature)) {  		rotationAngle = rotFunc.RotatePoint (pMxDoc.FocusMap' pMxDoc.SearchTolerance' inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  	} else {  		rotationAngle = rotFunc.RotatePointByNetwork (pMxDoc.FocusMap' (INetworkFeature)inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  	}  	//If needed' convert to geographic degrees(zero north clockwise)  	if (rotationAngle != null) {  		if (rotationAngle > 360)  			rotationAngle -= 360;  		if (rotationAngle < 0)  			rotationAngle += 360;  		rotationAngle += m_spinAngle;  		if (rotationAngle > 360)  			rotationAngle -= 360;  		if (rotationAngle < 0)  			rotationAngle += 360;  	}  } catch (Exception ex) {  	MessageBox.Show ("Error Rotation Feature at " + inFeature.Class.AliasName + " with Object ID:" + inFeature.OID + "\n" + ex.ToString ());  	return -1;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: try {  	// double diameter = -1;  	List<double> angles = new List<double> ();  	List<double> diameters = new List<double> ();  	List<Boolean> flipDirections = new List<Boolean> ();  	IPoint pnt = (ESRI.ArcGIS.Geometry.IPoint)inFeature.ShapeCopy;  	IMxDocument pMxDoc = (IMxDocument)_app.Document;  	double snapdistnet = Globals.ConvertPixelsToMap (2' pMxDoc.FocusMap);  	// IMxDocument pMxDoc = (IMxDocument)_app.Document;  	// VBRotate rotFunc = new VBRotate();  	Rotate rotFunc = new Rotate ();  	if (!(inFeature is INetworkFeature)) {  		rotationAngle = rotFunc.RotatePoint (pMxDoc.FocusMap' pMxDoc.SearchTolerance' inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  	} else {  		rotationAngle = rotFunc.RotatePointByNetwork (pMxDoc.FocusMap' (INetworkFeature)inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  	}  	//If needed' convert to geographic degrees(zero north clockwise)  	if (rotationAngle != null) {  		if (rotationAngle > 360)  			rotationAngle -= 360;  		if (rotationAngle < 0)  			rotationAngle += 360;  		rotationAngle += m_spinAngle;  		if (rotationAngle > 360)  			rotationAngle -= 360;  		if (rotationAngle < 0)  			rotationAngle += 360;  	}  } catch (Exception ex) {  	MessageBox.Show ("Error Rotation Feature at " + inFeature.Class.AliasName + " with Object ID:" + inFeature.OID + "\n" + ex.ToString ());  	return -1;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: try {  	// double diameter = -1;  	List<double> angles = new List<double> ();  	List<double> diameters = new List<double> ();  	List<Boolean> flipDirections = new List<Boolean> ();  	IPoint pnt = (ESRI.ArcGIS.Geometry.IPoint)inFeature.ShapeCopy;  	IMxDocument pMxDoc = (IMxDocument)_app.Document;  	double snapdistnet = Globals.ConvertPixelsToMap (2' pMxDoc.FocusMap);  	// IMxDocument pMxDoc = (IMxDocument)_app.Document;  	// VBRotate rotFunc = new VBRotate();  	Rotate rotFunc = new Rotate ();  	if (!(inFeature is INetworkFeature)) {  		rotationAngle = rotFunc.RotatePoint (pMxDoc.FocusMap' pMxDoc.SearchTolerance' inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  	} else {  		rotationAngle = rotFunc.RotatePointByNetwork (pMxDoc.FocusMap' (INetworkFeature)inFeature' m_rotationType == esriSymbolRotationType.esriRotateSymbolArithmetic' m_diameterFieldName' m_onlyLayerName);  	}  	//If needed' convert to geographic degrees(zero north clockwise)  	if (rotationAngle != null) {  		if (rotationAngle > 360)  			rotationAngle -= 360;  		if (rotationAngle < 0)  			rotationAngle += 360;  		rotationAngle += m_spinAngle;  		if (rotationAngle > 360)  			rotationAngle -= 360;  		if (rotationAngle < 0)  			rotationAngle += 360;  	}  } catch (Exception ex) {  	MessageBox.Show ("Error Rotation Feature at " + inFeature.Class.AliasName + " with Object ID:" + inFeature.OID + "\n" + ex.ToString ());  	return -1;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: if (rotationAngle != null) {  	if (rotationAngle > 360)  		rotationAngle -= 360;  	if (rotationAngle < 0)  		rotationAngle += 360;  	rotationAngle += m_spinAngle;  	if (rotationAngle > 360)  		rotationAngle -= 360;  	if (rotationAngle < 0)  		rotationAngle += 360;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: if (rotationAngle != null) {  	if (rotationAngle > 360)  		rotationAngle -= 360;  	if (rotationAngle < 0)  		rotationAngle += 360;  	rotationAngle += m_spinAngle;  	if (rotationAngle > 360)  		rotationAngle -= 360;  	if (rotationAngle < 0)  		rotationAngle += 360;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: if (rotationAngle != null) {  	if (rotationAngle > 360)  		rotationAngle -= 360;  	if (rotationAngle < 0)  		rotationAngle += 360;  	rotationAngle += m_spinAngle;  	if (rotationAngle > 360)  		rotationAngle -= 360;  	if (rotationAngle < 0)  		rotationAngle += 360;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: if (rotationAngle != null) {  	if (rotationAngle > 360)  		rotationAngle -= 360;  	if (rotationAngle < 0)  		rotationAngle += 360;  	rotationAngle += m_spinAngle;  	if (rotationAngle > 360)  		rotationAngle -= 360;  	if (rotationAngle < 0)  		rotationAngle += 360;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: if (rotationAngle != null) {  	if (rotationAngle > 360)  		rotationAngle -= 360;  	if (rotationAngle < 0)  		rotationAngle += 360;  	rotationAngle += m_spinAngle;  	if (rotationAngle > 360)  		rotationAngle -= 360;  	if (rotationAngle < 0)  		rotationAngle += 360;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: if (rotationAngle != null) {  	if (rotationAngle > 360)  		rotationAngle -= 360;  	if (rotationAngle < 0)  		rotationAngle += 360;  	rotationAngle += m_spinAngle;  	if (rotationAngle > 360)  		rotationAngle -= 360;  	if (rotationAngle < 0)  		rotationAngle += 360;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: if (rotationAngle > 360)  	rotationAngle -= 360;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: if (rotationAngle > 360)  	rotationAngle -= 360;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: rotationAngle -= 360;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: if (rotationAngle < 0)  	rotationAngle += 360;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: rotationAngle += 360;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: if (rotationAngle > 360)  	rotationAngle -= 360;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: if (rotationAngle > 360)  	rotationAngle -= 360;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: rotationAngle -= 360;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: if (rotationAngle < 0)  	rotationAngle += 360;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetRotationUsingConnectedEdges,The following statement contains a magic number: rotationAngle += 360;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,DegreeToRadian,The following statement contains a magic number: return Math.PI * angle / 180.0;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetAngleOfSegment,The following statement contains a magic number: outAngle = (180 - (line.Angle * 180) / 3.14159265358979);  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetAngleOfSegment,The following statement contains a magic number: outAngle = (180 - (line.Angle * 180) / 3.14159265358979);  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetAngleOfSegment,The following statement contains a magic number: outAngle = (180 - (line.Angle * 180) / 3.14159265358979);  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetAngleOfSegment,The following statement contains a magic number: if (outAngle < 0) {  	outAngle += 360;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetAngleOfSegment,The following statement contains a magic number: outAngle += 360;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetAngleOfSegment,The following statement contains a magic number: outAngle = (180 - (line.Angle * 180) / 3.14159265358979);  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetAngleOfSegment,The following statement contains a magic number: outAngle = (180 - (line.Angle * 180) / 3.14159265358979);  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetAngleOfSegment,The following statement contains a magic number: outAngle = (180 - (line.Angle * 180) / 3.14159265358979);  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetAngleOfSegment,The following statement contains a magic number: if (outAngle < 0) {  	outAngle += 360;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetAngleOfSegment,The following statement contains a magic number: outAngle += 360;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetAngleOfSegment,The following statement contains a magic number: if (outAngle > 360) {  	outAngle -= 360;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetAngleOfSegment,The following statement contains a magic number: if (outAngle > 360) {  	outAngle -= 360;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetAngleOfSegment,The following statement contains a magic number: outAngle -= 360;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetAngleOfSegment2,The following statement contains a magic number: outAngle = (int)System.Math.Round (((180 * line.Angle) / pi)' 0);  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetAngleOfSegment2,The following statement contains a magic number: if (outAngle < 0) {  	outAngle += 360;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,GetAngleOfSegment2,The following statement contains a magic number: outAngle += 360;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,IsStraight,The following statement contains a magic number: if (testAngle > 180)  	testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,IsStraight,The following statement contains a magic number: if (testAngle > 180)  	testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,IsStraight,The following statement contains a magic number: testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,FindTee,The following statement contains a magic number: if (testAngle > 180)  	testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,FindTee,The following statement contains a magic number: if (testAngle > 180)  	testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,FindTee,The following statement contains a magic number: testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,FindTee,The following statement contains a magic number: if (testAngle > 180)  	testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,FindTee,The following statement contains a magic number: if (testAngle > 180)  	testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,FindTee,The following statement contains a magic number: testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,FindTee,The following statement contains a magic number: if (testAngle > 180)  	testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,FindTee,The following statement contains a magic number: if (testAngle > 180)  	testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,FindTee,The following statement contains a magic number: testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,FindTee,The following statement contains a magic number: if (testAngle <= tolerance)  	return 2;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,FindTee,The following statement contains a magic number: return 2;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,FindTee,The following statement contains a magic number: return 2;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (testAngle > 180)  	testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (testAngle > 180)  	testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (testAngle <= tolerance || 5 >= 180 - testAngle) {  	if (angleB < angleA) {  		if (angleC < angleB || angleC > angleA) {  			return angleB + 180;  		} else {  			return angleB;  		}  	} else if (angleA < angleB) {  		if (angleC < angleA || angleC > angleB) {  			return angleB;  		} else {  			return angleB + 180;  		}  	} else {  		if (angleC < angleA || angleC > angleB) {  			return angleB;  		} else {  			return angleB + 180;  		}  	}  	//if (angleA < angleC)  	//{  	//    return angleA;  	//}  	//else  	//   return  angleA + 180;  	//if (angleC < 90)  	//    return angleA + 90;  	//else if (angleC < 180)  	//    return angleC + 90;  	//else if (angleC < 270)  	//    return angleC - 90;  	//else if (angleC < 360)  	//    return angleC - 270;  	//if (angleA > angleC)  	//    return angleA + 180;  	//else  	//    return angleA ;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (testAngle <= tolerance || 5 >= 180 - testAngle) {  	if (angleB < angleA) {  		if (angleC < angleB || angleC > angleA) {  			return angleB + 180;  		} else {  			return angleB;  		}  	} else if (angleA < angleB) {  		if (angleC < angleA || angleC > angleB) {  			return angleB;  		} else {  			return angleB + 180;  		}  	} else {  		if (angleC < angleA || angleC > angleB) {  			return angleB;  		} else {  			return angleB + 180;  		}  	}  	//if (angleA < angleC)  	//{  	//    return angleA;  	//}  	//else  	//   return  angleA + 180;  	//if (angleC < 90)  	//    return angleA + 90;  	//else if (angleC < 180)  	//    return angleC + 90;  	//else if (angleC < 270)  	//    return angleC - 90;  	//else if (angleC < 360)  	//    return angleC - 270;  	//if (angleA > angleC)  	//    return angleA + 180;  	//else  	//    return angleA ;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (testAngle <= tolerance || 5 >= 180 - testAngle) {  	if (angleB < angleA) {  		if (angleC < angleB || angleC > angleA) {  			return angleB + 180;  		} else {  			return angleB;  		}  	} else if (angleA < angleB) {  		if (angleC < angleA || angleC > angleB) {  			return angleB;  		} else {  			return angleB + 180;  		}  	} else {  		if (angleC < angleA || angleC > angleB) {  			return angleB;  		} else {  			return angleB + 180;  		}  	}  	//if (angleA < angleC)  	//{  	//    return angleA;  	//}  	//else  	//   return  angleA + 180;  	//if (angleC < 90)  	//    return angleA + 90;  	//else if (angleC < 180)  	//    return angleC + 90;  	//else if (angleC < 270)  	//    return angleC - 90;  	//else if (angleC < 360)  	//    return angleC - 270;  	//if (angleA > angleC)  	//    return angleA + 180;  	//else  	//    return angleA ;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (testAngle <= tolerance || 5 >= 180 - testAngle) {  	if (angleB < angleA) {  		if (angleC < angleB || angleC > angleA) {  			return angleB + 180;  		} else {  			return angleB;  		}  	} else if (angleA < angleB) {  		if (angleC < angleA || angleC > angleB) {  			return angleB;  		} else {  			return angleB + 180;  		}  	} else {  		if (angleC < angleA || angleC > angleB) {  			return angleB;  		} else {  			return angleB + 180;  		}  	}  	//if (angleA < angleC)  	//{  	//    return angleA;  	//}  	//else  	//   return  angleA + 180;  	//if (angleC < 90)  	//    return angleA + 90;  	//else if (angleC < 180)  	//    return angleC + 90;  	//else if (angleC < 270)  	//    return angleC - 90;  	//else if (angleC < 360)  	//    return angleC - 270;  	//if (angleA > angleC)  	//    return angleA + 180;  	//else  	//    return angleA ;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (testAngle <= tolerance || 5 >= 180 - testAngle) {  	if (angleB < angleA) {  		if (angleC < angleB || angleC > angleA) {  			return angleB + 180;  		} else {  			return angleB;  		}  	} else if (angleA < angleB) {  		if (angleC < angleA || angleC > angleB) {  			return angleB;  		} else {  			return angleB + 180;  		}  	} else {  		if (angleC < angleA || angleC > angleB) {  			return angleB;  		} else {  			return angleB + 180;  		}  	}  	//if (angleA < angleC)  	//{  	//    return angleA;  	//}  	//else  	//   return  angleA + 180;  	//if (angleC < 90)  	//    return angleA + 90;  	//else if (angleC < 180)  	//    return angleC + 90;  	//else if (angleC < 270)  	//    return angleC - 90;  	//else if (angleC < 360)  	//    return angleC - 270;  	//if (angleA > angleC)  	//    return angleA + 180;  	//else  	//    return angleA ;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (angleB < angleA) {  	if (angleC < angleB || angleC > angleA) {  		return angleB + 180;  	} else {  		return angleB;  	}  } else if (angleA < angleB) {  	if (angleC < angleA || angleC > angleB) {  		return angleB;  	} else {  		return angleB + 180;  	}  } else {  	if (angleC < angleA || angleC > angleB) {  		return angleB;  	} else {  		return angleB + 180;  	}  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (angleB < angleA) {  	if (angleC < angleB || angleC > angleA) {  		return angleB + 180;  	} else {  		return angleB;  	}  } else if (angleA < angleB) {  	if (angleC < angleA || angleC > angleB) {  		return angleB;  	} else {  		return angleB + 180;  	}  } else {  	if (angleC < angleA || angleC > angleB) {  		return angleB;  	} else {  		return angleB + 180;  	}  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (angleB < angleA) {  	if (angleC < angleB || angleC > angleA) {  		return angleB + 180;  	} else {  		return angleB;  	}  } else if (angleA < angleB) {  	if (angleC < angleA || angleC > angleB) {  		return angleB;  	} else {  		return angleB + 180;  	}  } else {  	if (angleC < angleA || angleC > angleB) {  		return angleB;  	} else {  		return angleB + 180;  	}  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (angleC < angleB || angleC > angleA) {  	return angleB + 180;  } else {  	return angleB;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: return angleB + 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (angleA < angleB) {  	if (angleC < angleA || angleC > angleB) {  		return angleB;  	} else {  		return angleB + 180;  	}  } else {  	if (angleC < angleA || angleC > angleB) {  		return angleB;  	} else {  		return angleB + 180;  	}  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (angleA < angleB) {  	if (angleC < angleA || angleC > angleB) {  		return angleB;  	} else {  		return angleB + 180;  	}  } else {  	if (angleC < angleA || angleC > angleB) {  		return angleB;  	} else {  		return angleB + 180;  	}  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (angleC < angleA || angleC > angleB) {  	return angleB;  } else {  	return angleB + 180;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: return angleB + 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (angleC < angleA || angleC > angleB) {  	return angleB;  } else {  	return angleB + 180;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: return angleB + 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (testAngle > 180)  	testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (testAngle > 180)  	testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (testAngle <= tolerance || 5 >= 180 - testAngle) {  	if (angleB < angleC) {  		if (angleA < angleB || angleA > angleC) {  			return angleB + 180;  		} else {  			return angleB;  		}  	} else if (angleC < angleB) {  		if (angleA < angleC || angleA > angleB) {  			return angleB;  		} else {  			return angleB + 180;  		}  	}  	//if (angleB < angleA)  	//{  	//    return angleB + 180;  	//}  	//else  	//    return angleB ;  	// return angleA;  	//if (angleA < 90)  	//    return angleA - 90;  	//else if (angleA < 180)  	//    return angleA - 90;  	//else if (angleA < 270)  	//    return angleA - 90;  	//else if (angleA < 360)  	//    return angleA - 270;  	//if (angleB > angleA)  	//    return angleB + 180;  	//else  	//    return angleB;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (testAngle <= tolerance || 5 >= 180 - testAngle) {  	if (angleB < angleC) {  		if (angleA < angleB || angleA > angleC) {  			return angleB + 180;  		} else {  			return angleB;  		}  	} else if (angleC < angleB) {  		if (angleA < angleC || angleA > angleB) {  			return angleB;  		} else {  			return angleB + 180;  		}  	}  	//if (angleB < angleA)  	//{  	//    return angleB + 180;  	//}  	//else  	//    return angleB ;  	// return angleA;  	//if (angleA < 90)  	//    return angleA - 90;  	//else if (angleA < 180)  	//    return angleA - 90;  	//else if (angleA < 270)  	//    return angleA - 90;  	//else if (angleA < 360)  	//    return angleA - 270;  	//if (angleB > angleA)  	//    return angleB + 180;  	//else  	//    return angleB;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (testAngle <= tolerance || 5 >= 180 - testAngle) {  	if (angleB < angleC) {  		if (angleA < angleB || angleA > angleC) {  			return angleB + 180;  		} else {  			return angleB;  		}  	} else if (angleC < angleB) {  		if (angleA < angleC || angleA > angleB) {  			return angleB;  		} else {  			return angleB + 180;  		}  	}  	//if (angleB < angleA)  	//{  	//    return angleB + 180;  	//}  	//else  	//    return angleB ;  	// return angleA;  	//if (angleA < 90)  	//    return angleA - 90;  	//else if (angleA < 180)  	//    return angleA - 90;  	//else if (angleA < 270)  	//    return angleA - 90;  	//else if (angleA < 360)  	//    return angleA - 270;  	//if (angleB > angleA)  	//    return angleB + 180;  	//else  	//    return angleB;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (testAngle <= tolerance || 5 >= 180 - testAngle) {  	if (angleB < angleC) {  		if (angleA < angleB || angleA > angleC) {  			return angleB + 180;  		} else {  			return angleB;  		}  	} else if (angleC < angleB) {  		if (angleA < angleC || angleA > angleB) {  			return angleB;  		} else {  			return angleB + 180;  		}  	}  	//if (angleB < angleA)  	//{  	//    return angleB + 180;  	//}  	//else  	//    return angleB ;  	// return angleA;  	//if (angleA < 90)  	//    return angleA - 90;  	//else if (angleA < 180)  	//    return angleA - 90;  	//else if (angleA < 270)  	//    return angleA - 90;  	//else if (angleA < 360)  	//    return angleA - 270;  	//if (angleB > angleA)  	//    return angleB + 180;  	//else  	//    return angleB;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (angleB < angleC) {  	if (angleA < angleB || angleA > angleC) {  		return angleB + 180;  	} else {  		return angleB;  	}  } else if (angleC < angleB) {  	if (angleA < angleC || angleA > angleB) {  		return angleB;  	} else {  		return angleB + 180;  	}  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (angleB < angleC) {  	if (angleA < angleB || angleA > angleC) {  		return angleB + 180;  	} else {  		return angleB;  	}  } else if (angleC < angleB) {  	if (angleA < angleC || angleA > angleB) {  		return angleB;  	} else {  		return angleB + 180;  	}  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (angleA < angleB || angleA > angleC) {  	return angleB + 180;  } else {  	return angleB;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: return angleB + 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (angleC < angleB) {  	if (angleA < angleC || angleA > angleB) {  		return angleB;  	} else {  		return angleB + 180;  	}  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (angleA < angleC || angleA > angleB) {  	return angleB;  } else {  	return angleB + 180;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: return angleB + 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (testAngle > 180)  	testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (testAngle > 180)  	testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: testAngle -= 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (testAngle <= tolerance || 5 >= 180 - testAngle) {  	if (angleA < angleC) {  		if (angleB < angleA || angleB > angleC) {  			return angleA + 180;  		} else {  			return angleA;  		}  	} else if (angleC < angleA) {  		if (angleB < angleC || angleB > angleA) {  			return angleC + 180;  		} else {  			return angleC;  		}  	}  	//if (angleB < angleA || angleB > angleC)  	//    return angleA + 180;  	//else if (angleB < angleC || angleB > angleA)  	//        return angleA + 180;  	//else  	//    return angleA;  	// return angleB;  	//if (angleB < 90)  	//    return angleB - 90;  	//else if (angleB < 180)  	//    return angleB + 90;  	//else if (angleB < 270)  	//    return angleB - 90;  	//else if (angleB < 360)  	//    return angleB - 270;  	//if (angleA > angleB)  	//    return angleA + 180;  	//else  	//    return angleA;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (testAngle <= tolerance || 5 >= 180 - testAngle) {  	if (angleA < angleC) {  		if (angleB < angleA || angleB > angleC) {  			return angleA + 180;  		} else {  			return angleA;  		}  	} else if (angleC < angleA) {  		if (angleB < angleC || angleB > angleA) {  			return angleC + 180;  		} else {  			return angleC;  		}  	}  	//if (angleB < angleA || angleB > angleC)  	//    return angleA + 180;  	//else if (angleB < angleC || angleB > angleA)  	//        return angleA + 180;  	//else  	//    return angleA;  	// return angleB;  	//if (angleB < 90)  	//    return angleB - 90;  	//else if (angleB < 180)  	//    return angleB + 90;  	//else if (angleB < 270)  	//    return angleB - 90;  	//else if (angleB < 360)  	//    return angleB - 270;  	//if (angleA > angleB)  	//    return angleA + 180;  	//else  	//    return angleA;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (testAngle <= tolerance || 5 >= 180 - testAngle) {  	if (angleA < angleC) {  		if (angleB < angleA || angleB > angleC) {  			return angleA + 180;  		} else {  			return angleA;  		}  	} else if (angleC < angleA) {  		if (angleB < angleC || angleB > angleA) {  			return angleC + 180;  		} else {  			return angleC;  		}  	}  	//if (angleB < angleA || angleB > angleC)  	//    return angleA + 180;  	//else if (angleB < angleC || angleB > angleA)  	//        return angleA + 180;  	//else  	//    return angleA;  	// return angleB;  	//if (angleB < 90)  	//    return angleB - 90;  	//else if (angleB < 180)  	//    return angleB + 90;  	//else if (angleB < 270)  	//    return angleB - 90;  	//else if (angleB < 360)  	//    return angleB - 270;  	//if (angleA > angleB)  	//    return angleA + 180;  	//else  	//    return angleA;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (testAngle <= tolerance || 5 >= 180 - testAngle) {  	if (angleA < angleC) {  		if (angleB < angleA || angleB > angleC) {  			return angleA + 180;  		} else {  			return angleA;  		}  	} else if (angleC < angleA) {  		if (angleB < angleC || angleB > angleA) {  			return angleC + 180;  		} else {  			return angleC;  		}  	}  	//if (angleB < angleA || angleB > angleC)  	//    return angleA + 180;  	//else if (angleB < angleC || angleB > angleA)  	//        return angleA + 180;  	//else  	//    return angleA;  	// return angleB;  	//if (angleB < 90)  	//    return angleB - 90;  	//else if (angleB < 180)  	//    return angleB + 90;  	//else if (angleB < 270)  	//    return angleB - 90;  	//else if (angleB < 360)  	//    return angleB - 270;  	//if (angleA > angleB)  	//    return angleA + 180;  	//else  	//    return angleA;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (angleA < angleC) {  	if (angleB < angleA || angleB > angleC) {  		return angleA + 180;  	} else {  		return angleA;  	}  } else if (angleC < angleA) {  	if (angleB < angleC || angleB > angleA) {  		return angleC + 180;  	} else {  		return angleC;  	}  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (angleA < angleC) {  	if (angleB < angleA || angleB > angleC) {  		return angleA + 180;  	} else {  		return angleA;  	}  } else if (angleC < angleA) {  	if (angleB < angleC || angleB > angleA) {  		return angleC + 180;  	} else {  		return angleC;  	}  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (angleB < angleA || angleB > angleC) {  	return angleA + 180;  } else {  	return angleA;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: return angleA + 180;  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (angleC < angleA) {  	if (angleB < angleC || angleB > angleA) {  		return angleC + 180;  	} else {  		return angleC;  	}  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: if (angleB < angleC || angleB > angleA) {  	return angleC + 180;  } else {  	return angleC;  }  
Magic Number,A4LGSharedFunctions,RotationCalculator,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\RotationCalculator.cs,TeeAngle,The following statement contains a magic number: return angleC + 180;  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,setWidth,The following statement contains a magic number: if (Width < 180) {  	this.Width = 280;  } else {  	this.Width = Width + 100;  }  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,setWidth,The following statement contains a magic number: if (Width < 180) {  	this.Width = 280;  } else {  	this.Width = Width + 100;  }  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,setWidth,The following statement contains a magic number: if (Width < 180) {  	this.Width = 280;  } else {  	this.Width = Width + 100;  }  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,setWidth,The following statement contains a magic number: this.Width = 280;  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,setWidth,The following statement contains a magic number: this.Width = Width + 100;  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,setWidth,The following statement contains a magic number: cboSelectTemplate.Width = this.Width - 50 - cboSelectTemplate.Left;  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,SelectTemplateForm_Resize,The following statement contains a magic number: cboSelectTemplate.Width = this.Width - 50 - cboSelectTemplate.Left;  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,InitializeComponent,The following statement contains a magic number: this.lblLayer.Location = new System.Drawing.Point (15' 16);  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,InitializeComponent,The following statement contains a magic number: this.lblLayer.Location = new System.Drawing.Point (15' 16);  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,InitializeComponent,The following statement contains a magic number: this.lblLayer.Size = new System.Drawing.Size (35' 13);  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,InitializeComponent,The following statement contains a magic number: this.lblLayer.Size = new System.Drawing.Size (35' 13);  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,InitializeComponent,The following statement contains a magic number: this.cboSelectTemplate.Location = new System.Drawing.Point (15' 40);  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,InitializeComponent,The following statement contains a magic number: this.cboSelectTemplate.Location = new System.Drawing.Point (15' 40);  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,InitializeComponent,The following statement contains a magic number: this.cboSelectTemplate.Size = new System.Drawing.Size (277' 21);  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,InitializeComponent,The following statement contains a magic number: this.cboSelectTemplate.Size = new System.Drawing.Size (277' 21);  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSelect.Location = new System.Drawing.Point (15' 67);  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSelect.Location = new System.Drawing.Point (15' 67);  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSelect.Size = new System.Drawing.Size (75' 23);  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSelect.Size = new System.Drawing.Size (75' 23);  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSelect.TabIndex = 2;  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (419' 169);  
Magic Number,A4LGSharedFunctions,SelectTemplateForm,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\SelectTemplateForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (419' 169);  
Duplicate Code,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,AddTwoJunctionFlagsToTraceSolver,The method contains a code clone-set at the following line numbers (starting from the method definition): ((41' 85)' (89' 133))
Duplicate Code,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,CreatePolylineFromPointsNewTurn,The method contains a code clone-set at the following line numbers (starting from the method definition): ((109' 134)' (134' 159))
Duplicate Code,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayerFromMapDataset,The method contains a code clone-set at the following line numbers (starting from the method definition): ((44' 80)' (84' 120))
Duplicate Code,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayerNotInMemory,The method contains a code clone-set at the following line numbers (starting from the method definition): ((48' 87)' (92' 131))
Duplicate Code,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayer,The method contains a code clone-set at the following line numbers (starting from the method definition): ((41' 77)' (81' 117))
Duplicate Code,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FindLayerInWorkspace,The method contains a code clone-set at the following line numbers (starting from the method definition): ((39' 67)' (71' 99))
Missing Default,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetFieldStats,The following switch statement is missing a default case: switch (statType) {  case statsType.Sum: {  	return statisticsResults.Sum.ToString ();  	break;  }  case statsType.Count: {  	return statisticsResults.Count.ToString ();  	break;  }  case statsType.Max: {  	return statisticsResults.Maximum.ToString ();  	break;  }  case statsType.Mean: {  	return statisticsResults.Mean.ToString ();  	break;  }  case statsType.Min: {  	return statisticsResults.Minimum.ToString ();  	break;  }  case statsType.StandardDev: {  	return statisticsResults.StandardDeviation.ToString ();  	break;  }  }  
Missing Default,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,FlashGeometry,The following switch statement is missing a default case: switch (geometry.GeometryType) {  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPolygon: {  	//Set the flash geometry's symbol.  	simpleFillSymbol = new ESRI.ArcGIS.Display.SimpleFillSymbolClass ();  	simpleFillSymbol.Color = color;  	symbol = simpleFillSymbol as ESRI.ArcGIS.Display.ISymbol;  	// Dynamic Cast  	symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  	//Flash the input polygon geometry.  	display.SetSymbol (symbol);  	display.DrawPolygon (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolygon (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolygon (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolygon (geometry);  	break;  }  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPolyline: {  	//Set the flash geometry's symbol.  	simpleLineSymbol = new ESRI.ArcGIS.Display.SimpleLineSymbolClass ();  	simpleLineSymbol.Width = 4;  	simpleLineSymbol.Color = color;  	symbol = simpleLineSymbol as ESRI.ArcGIS.Display.ISymbol;  	// Dynamic Cast  	symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  	//Flash the input polyline geometry.  	display.SetSymbol (symbol);  	display.DrawPolyline (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolyline (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolyline (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPolyline (geometry);  	break;  }  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPoint: {  	//Set the flash geometry's symbol.  	simpleMarkerSymbol = new ESRI.ArcGIS.Display.SimpleMarkerSymbolClass ();  	simpleMarkerSymbol.Style = ESRI.ArcGIS.Display.esriSimpleMarkerStyle.esriSMSCircle;  	simpleMarkerSymbol.Size = 12;  	simpleMarkerSymbol.Color = color;  	symbol = simpleMarkerSymbol as ESRI.ArcGIS.Display.ISymbol;  	// Dynamic Cast  	symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  	//Flash the input point geometry.  	display.SetSymbol (symbol);  	display.DrawPoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawPoint (geometry);  	break;  }  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryMultipoint: {  	//Set the flash geometry's symbol.  	simpleMarkerSymbol = new ESRI.ArcGIS.Display.SimpleMarkerSymbolClass ();  	simpleMarkerSymbol.Style = ESRI.ArcGIS.Display.esriSimpleMarkerStyle.esriSMSCircle;  	simpleMarkerSymbol.Size = 12;  	simpleMarkerSymbol.Color = color;  	symbol = simpleMarkerSymbol as ESRI.ArcGIS.Display.ISymbol;  	// Dynamic Cast  	symbol.ROP2 = ESRI.ArcGIS.Display.esriRasterOpCode.esriROPNotXOrPen;  	//Flash the input multipoint geometry.  	display.SetSymbol (symbol);  	display.DrawMultipoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawMultipoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawMultipoint (geometry);  	System.Threading.Thread.Sleep (delay);  	display.DrawMultipoint (geometry);  	break;  }  }  
Missing Default,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,GetGeomCenter,The following switch statement is missing a default case: switch (geo.GeometryType) {  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPoint:  	//pCenterPoint = geo as ESRI.ArcGIS.Geometry.IPoint;  	pCenterPoints.Add (geo as ESRI.ArcGIS.Geometry.IPoint);  	break;  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPolyline:  	pl = (ESRI.ArcGIS.Geometry.IPolyline)geo;  	pCenterPoint = new ESRI.ArcGIS.Geometry.Point ();  	//int prtIdx;  	//int segIdx;  	//bool bSplit;  	//pl.SplitAtDistance(50' true' false' out bSplit' out prtIdx' out segIdx);  	pl.QueryPoint (ESRI.ArcGIS.Geometry.esriSegmentExtension.esriNoExtension' .5' true' pCenterPoint);  	pCenterPoints.Add (pCenterPoint);  	pl = null;  	break;  case ESRI.ArcGIS.Geometry.esriGeometryType.esriGeometryPolygon:  	pPoly = geo as ESRI.ArcGIS.Geometry.IPolygon4;  	pPoly.SimplifySpaghetti ();  	if (pPoly.ExteriorRingCount > 1) {  		//Comps = new IPolygon[pPoly.ExteriorRingCount];  		pGeoBag = pPoly.ConnectedComponentBag;  		enumGeometry = pGeoBag as IEnumGeometry;  		enumGeometry.Reset ();  		geometry = enumGeometry.Next ();  		while (geometry != null) {  			pArea = geometry as ESRI.ArcGIS.Geometry.IArea;  			pCenterPoint = pArea.Centroid;  			pCenterPoints.Add (pCenterPoint);  			geometry = enumGeometry.Next ();  		}  	} else {  		pArea = geo as ESRI.ArcGIS.Geometry.IArea;  		pCenterPoint = pArea.Centroid;  		pCenterPoints.Add (pCenterPoint);  		pArea = null;  	}  	break;  }  
Missing Default,A4LGSharedFunctions,Globals,F:\newReposMay17\Esri_local-government-desktop-addins\ArcGISTemplateSharedFunctions\Globals.cs,ConvertUnitType2,The following switch statement is missing a default case: switch ((linearUnit.FactoryCode)) {  case 109006:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriCentimeters;  case 9102:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimalDegrees;  case 109005:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriDecimeters;  case 9003:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriFeet;  case 109008:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriInches;  case 9036:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriKilometers;  case 9001:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMeters;  case 9035:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMiles;  case 109007:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriMillimeters;  case 9030:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriNauticalMiles;  case 109002:  	return ESRI.ArcGIS.esriSystem.esriUnits.esriYards;  }  
