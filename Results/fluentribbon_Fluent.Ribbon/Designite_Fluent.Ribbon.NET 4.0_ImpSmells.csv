Implementation smell,Namespace,Class,File,Method,Description
Long Method,Fluent,RibbonToolBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonToolBar.cs,CustomLayout,The method has 131 lines of code.
Long Method,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The method has 187 lines of code.
Long Method,Fluent,KeyTipService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\KeyTipService.cs,OnWindowPreviewKeyDown,The method has 106 lines of code.
Long Method,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,OnContextMenuOpened,The method has 113 lines of code.
Long Method,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The method has 168 lines of code.
Long Method,Fluent,RibbonTabsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabsContainer.cs,MeasureOverride,The method has 248 lines of code.
Complex Method,Fluent,Backstage,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Backstage.cs,Show,Cyclomatic complexity of the method is 12
Complex Method,Fluent,Backstage,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Backstage.cs,Hide,Cyclomatic complexity of the method is 11
Complex Method,Fluent,ColorGradientItemTemplateSelector,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,SelectTemplate,Cyclomatic complexity of the method is 10
Complex Method,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,OnApplyTemplate,Cyclomatic complexity of the method is 17
Complex Method,Fluent,ComboBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ComboBox.cs,OnKeyDown,Cyclomatic complexity of the method is 12
Complex Method,Fluent,GalleryPanel,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\GalleryPanel.cs,Refresh,Cyclomatic complexity of the method is 11
Complex Method,Fluent,PopupService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\PopupService.cs,OnLostMouseCapture,Cyclomatic complexity of the method is 8
Complex Method,Fluent,StatusBarPanel,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\StatusBarPanel.cs,MeasureOverride,Cyclomatic complexity of the method is 11
Complex Method,Fluent,InRibbonGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\InRibbonGallery.cs,OnApplyTemplate,Cyclomatic complexity of the method is 15
Complex Method,Fluent,InRibbonGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\InRibbonGallery.cs,OnDropDownOpened,Cyclomatic complexity of the method is 9
Complex Method,Fluent,RibbonToolBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonToolBar.cs,CustomLayout,Cyclomatic complexity of the method is 21
Complex Method,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,Cyclomatic complexity of the method is 8
Complex Method,Fluent,QuickAccessToolBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\QuickAccessToolBar.cs,OnApplyTemplate,Cyclomatic complexity of the method is 13
Complex Method,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,OnContextMenuOpened,Cyclomatic complexity of the method is 10
Complex Method,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,OnApplyTemplate,Cyclomatic complexity of the method is 13
Complex Method,Fluent,RibbonContextualGroupsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonContextualGroupsContainer.cs,MeasureOverride,Cyclomatic complexity of the method is 13
Complex Method,Fluent,RibbonTabsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabsContainer.cs,MeasureOverride,Cyclomatic complexity of the method is 30
Complex Method,Fluent,RibbonGroupsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonGroupsContainer.cs,MeasureOverride,Cyclomatic complexity of the method is 10
Complex Method,Fluent.Metro.Behaviours,StylizedBehaviors,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Metro\Behaviours\StylizedBehaviors.cs,OnPropertyChanged,Cyclomatic complexity of the method is 9
Long Parameter List,Fluent,KeyTipService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\KeyTipService.cs,WindowProc,The method has 5 parameters. Parameters: hwnd' msg' wParam' lParam' handled
Long Parameter List,Fluent,RibbonControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonControl.cs,Bind,The method has 5 parameters. Parameters: source' target' path' property' mode
Long Parameter List,Fluent,RibbonControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonControl.cs,Bind,The method has 6 parameters. Parameters: source' target' path' property' mode' updateSourceTrigger
Long Parameter List,Fluent,RibbonControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonControl.cs,Bind,The method has 5 parameters. Parameters: source' target' path' property' mode
Long Parameter List,Fluent,RibbonControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonControl.cs,Bind,The method has 6 parameters. Parameters: source' target' path' property' mode' updateSourceTrigger
Long Identifier,Fluent,Backstage,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Backstage.cs,,The length of the parameter IsOpenAnimationEnabledProperty is 30.
Long Identifier,Fluent,BackstageTabControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\BackstageTabControl.cs,,The length of the parameter ContentTemplateSelectorProperty is 31.
Long Identifier,Fluent,BackstageTabControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\BackstageTabControl.cs,,The length of the parameter SelectedContentStringFormatPropertyKey is 38.
Long Identifier,Fluent,BackstageTabControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\BackstageTabControl.cs,,The length of the parameter SelectedContentStringFormatProperty is 35.
Long Identifier,Fluent,BackstageTabControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\BackstageTabControl.cs,,The length of the parameter SelectedContentTemplatePropertyKey is 34.
Long Identifier,Fluent,BackstageTabControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\BackstageTabControl.cs,,The length of the parameter SelectedContentTemplateProperty is 31.
Long Identifier,Fluent,BackstageTabControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\BackstageTabControl.cs,,The length of the parameter SelectedContentTemplateSelectorPropertyKey is 42.
Long Identifier,Fluent,BackstageTabControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\BackstageTabControl.cs,,The length of the parameter SelectedContentTemplateSelectorProperty is 39.
Long Identifier,Fluent,BackstageTabControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\BackstageTabControl.cs,,The length of the parameter IsWindowSteeringHelperEnabledProperty is 37.
Long Identifier,Fluent,Button,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Button.cs,,The length of the parameter CanAddToQuickAccessToolBarProperty is 34.
Long Identifier,Fluent,CheckBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\CheckBox.cs,,The length of the parameter CanAddToQuickAccessToolBarProperty is 34.
Long Identifier,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,,The length of the parameter IsAutomaticColorButtonVisibleProperty is 37.
Long Identifier,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,,The length of the parameter IsNoColorButtonVisibleProperty is 30.
Long Identifier,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,,The length of the parameter IsMoreColorsButtonVisibleProperty is 33.
Long Identifier,Fluent,ComboBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ComboBox.cs,,The length of the parameter CanAddToQuickAccessToolBarProperty is 34.
Long Identifier,Fluent,GalleryPanel,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\GalleryPanel.cs,,The length of the parameter ItemContainerGeneratorProperty is 30.
Long Identifier,Fluent,RadioButton,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RadioButton.cs,,The length of the parameter CanAddToQuickAccessToolBarProperty is 34.
Long Identifier,Fluent,StatusBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\StatusBar.cs,,The length of the parameter waitingForItemContainerGenerator is 32.
Long Identifier,Fluent,TextBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\TextBox.cs,,The length of the parameter CanAddToQuickAccessToolBarProperty is 34.
Long Identifier,Fluent,Gallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Gallery.cs,,The length of the parameter SelectedFilterTitlePropertyKey is 30.
Long Identifier,Fluent,Gallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Gallery.cs,,The length of the parameter SelectedFilterGroupsPropertyKey is 31.
Long Identifier,Fluent,InRibbonGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\InRibbonGallery.cs,,The length of the parameter SelectedFilterTitlePropertyKey is 30.
Long Identifier,Fluent,InRibbonGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\InRibbonGallery.cs,,The length of the parameter SelectedFilterGroupsPropertyKey is 31.
Long Identifier,Fluent,InRibbonGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\InRibbonGallery.cs,,The length of the parameter CanAddToQuickAccessToolBarProperty is 34.
Long Identifier,Fluent,RibbonToolBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonToolBar.cs,CustomLayout,The length of the parameter ribbonToolBarControlDefinition is 30.
Long Identifier,Fluent,RibbonToolBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonToolBar.cs,CustomLayout,The length of the parameter ribbonToolBarControlGroupDefinition is 35.
Long Identifier,Fluent,RibbonToolBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonToolBar.cs,,The length of the parameter rebuildVisualAndLogicalChildren is 31.
Long Identifier,Fluent,RibbonWindow,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonWindow.cs,,The length of the parameter IsAutomaticCollapseEnabledProperty is 34.
Long Identifier,Fluent,RibbonWindow,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonWindow.cs,,The length of the parameter IgnoreTaskbarOnMaximizeProperty is 31.
Long Identifier,Fluent,SplitButton,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\SplitButton.cs,,The length of the parameter CanAddButtonToQuickAccessToolBarProperty is 40.
Long Identifier,Fluent,DropDownButton,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\DropDownButton.cs,,The length of the parameter ClosePopupOnMouseDownDelayProperty is 34.
Long Identifier,Fluent,DropDownButton,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\DropDownButton.cs,,The length of the parameter CanAddToQuickAccessToolBarProperty is 34.
Long Identifier,Fluent,MenuItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\MenuItem.cs,,The length of the parameter CanAddToQuickAccessToolBarProperty is 34.
Long Identifier,Fluent,QuickAccessToolBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\QuickAccessToolBar.cs,,The length of the parameter CanQuickAccessLocationChangingProperty is 38.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter addToQuickAccessMenuItemDictionary is 34.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter addGroupToQuickAccessMenuItemDictionary is 39.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter addMenuToQuickAccessMenuItemDictionary is 38.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter addGalleryToQuickAccessMenuItemDictionary is 41.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter removeFromQuickAccessMenuItemDictionary is 39.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter showQuickAccessToolbarBelowTheRibbonMenuItemDictionary is 54.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter showQuickAccessToolbarAboveTheRibbonMenuItemDictionary is 54.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter minimizeTheRibbonMenuItemDictionary is 35.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter customizeQuickAccessToolbarMenuItemDictionary is 45.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter customizeTheRibbonMenuItemDictionary is 36.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter ShowQuickAccessToolBarAboveRibbonProperty is 41.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter QuickAccessToolBarHeightProperty is 32.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter CanCustomizeQuickAccessToolBarProperty is 38.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter CanCustomizeQuickAccessToolBarItemsProperty is 43.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter IsQuickAccessToolBarMenuDropDownVisibleProperty is 47.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter IsAutomaticCollapseEnabledProperty is 34.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter IsQuickAccessToolBarVisibleProperty is 35.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter CanQuickAccessLocationChangingProperty is 38.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter IsMouseWheelScrollingEnabledProperty is 36.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter ToggleMinimizeTheRibbonCommand is 30.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter CustomizeQuickAccessToolbarCommand is 34.
Long Identifier,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,,The length of the parameter AutomaticStateManagementProperty is 32.
Long Identifier,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,,The length of the parameter isAtLeastOneRequiredControlPresent is 34.
Long Identifier,Fluent,RibbonControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonControl.cs,,The length of the parameter CanAddToQuickAccessToolBarProperty is 34.
Long Identifier,Fluent,RibbonTabControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabControl.cs,,The length of the parameter IsMouseWheelScrollingEnabledProperty is 36.
Long Identifier,Fluent,RibbonGroupBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonGroupBox.cs,,The length of the parameter updateChildSizesItemContainerGeneratorAction is 44.
Long Identifier,Fluent,RibbonGroupBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonGroupBox.cs,,The length of the parameter DialogLauncherButtonKeyTipKeysProperty is 38.
Long Identifier,Fluent,RibbonGroupBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonGroupBox.cs,,The length of the parameter LauncherCommandParameterProperty is 32.
Long Identifier,Fluent,RibbonGroupBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonGroupBox.cs,,The length of the parameter CanAddToQuickAccessToolBarProperty is 34.
Long Identifier,Fluent,ToggleButton,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ToggleButton.cs,,The length of the parameter CanAddToQuickAccessToolBarProperty is 34.
Long Identifier,Fluent.Converters,StaticConverters,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Converters\StaticConverters.cs,,The length of the parameter ColorToSolidColorBrushValueConverter is 36.
Long Statement,Fluent,BackstageAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\BackstageAdorner.cs,MeasureOverride,The length of the statement  "            this.backstageContent.Measure(new Size(this.AdornedElement.RenderSize.Width' Math.Max(0' this.AdornedElement.RenderSize.Height))); " is 130.
Long Statement,Fluent,Backstage,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Backstage.cs,OnContentChanged,The length of the statement  "                    BindingOperations.SetBinding(dependencyObject' VisibilityProperty' new Binding { Path = new PropertyPath(VisibilityProperty)' Source = backstage }); " is 148.
Long Statement,Fluent,Backstage,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Backstage.cs,CreateAndAttachBackstageAdorner,The length of the statement  "            layer.CommandBindings.Add(new CommandBinding(RibbonCommands.OpenBackstage' HandleOpenBackstageCommandExecuted' HandleOpenBackstageCommandCanExecute)); " is 150.
Long Statement,Fluent,Backstage,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Backstage.cs,OnDelayedShow,The length of the statement  "            // If we don't run this in the background setting IsOpen=true on application start we don't have access to the Bastage from the BackstageTabControl. " is 148.
Long Statement,Fluent,BackstageTabItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\BackstageTabItem.cs,OnIsSelectedChanged,The length of the statement  "                    && ReferenceEquals(container.TabControlParent.ItemContainerGenerator.ContainerFromItem(container.TabControlParent.SelectedItem)' container) == false) " is 149.
Long Statement,Fluent,BackstageTabItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\BackstageTabItem.cs,OnIsSelectedChanged,The length of the statement  "                    container.TabControlParent.SelectedItem = container.TabControlParent.ItemContainerGenerator.ItemFromContainer(container); " is 121.
Long Statement,Fluent,BackstageTabItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\BackstageTabItem.cs,UnselectSelectedItem,The length of the statement  "            var backstageTabItem = backstageTabControl.ItemContainerGenerator.ContainerFromItem(backstageTabControl.SelectedItem) as BackstageTabItem; " is 138.
Long Statement,Fluent,ComboBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ComboBox.cs,BringSelectedItemIntoView,The length of the statement  "            var containerFromItem = this.quickAccessCombo.ItemContainerGenerator.ContainerFromItem(this.quickAccessCombo.SelectedItem) as FrameworkElement; " is 143.
Long Statement,Fluent,ComboBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ComboBox.cs,OnKeyDown,The length of the statement  "                if (this.Menu.Items.Contains(this.Menu.ItemContainerGenerator.ItemFromContainer((DependencyObject)Keyboard.FocusedElement))) " is 124.
Long Statement,Fluent,ComboBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ComboBox.cs,OnKeyDown,The length of the statement  "                        var indexOfMenuSelectedItem = this.Menu.ItemContainerGenerator.IndexFromContainer((DependencyObject)Keyboard.FocusedElement); " is 125.
Long Statement,Fluent,ComboBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ComboBox.cs,OnKeyDown,The length of the statement  "                        var indexOfMenuSelectedItem = this.Menu.ItemContainerGenerator.IndexFromContainer((DependencyObject)Keyboard.FocusedElement); " is 125.
Long Statement,Fluent,ComboBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ComboBox.cs,OnResizeBothDelta,The length of the statement  "                this.scrollViewer.Width = Math.Max(0' Math.Max(this.scrollViewer.Width + e.HorizontalChange' this.ActualWidth - deltaBorders)); " is 127.
Long Statement,Fluent,ComboBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ComboBox.cs,OnResizeBothDelta,The length of the statement  "                this.scrollViewer.Width = Math.Max(0' Math.Max(monitorRight - this.PointToScreen(default(Point)).X - deltaX' this.ActualWidth - deltaBorders)); " is 143.
Long Statement,Fluent,RibbonLocalization,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Localization\RibbonLocalization.cs,LoadCulture,The length of the statement  "            Trace.WriteLine($"Localization for culture \"{requestedCulture.DisplayName}\" with culture name \"{requestedCulture.Name}\" and LCID \"{requestedCulture.LCID}\" could not be found. Falling back to english."); " is 208.
Long Statement,Fluent,RibbonStateStorage,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Data\RibbonStateStorage.cs,Save,The length of the statement  "                using (var stream = new IsolatedStorageFileStream(this.IsolatedStorageFileName' FileMode.Create' FileAccess.Write' storage)) " is 124.
Long Statement,Fluent,RibbonStateStorage,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Data\RibbonStateStorage.cs,CreateStateData,The length of the statement  "                    Debug.WriteLine($"Control \"{controlName}\" of type \"{element.Key.GetType().Name}\" is not found in logical tree during QAT saving"); " is 134.
Long Statement,Fluent,RibbonStateStorage,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Data\RibbonStateStorage.cs,Load,The length of the statement  "                    using (var stream = new IsolatedStorageFileStream(this.IsolatedStorageFileName' FileMode.Open' FileAccess.Read' storage)) " is 121.
Long Statement,Fluent,ContextMenuService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\ContextMenuService.cs,Attach,The length of the statement  "            System.Windows.Controls.ContextMenuService.ShowOnDisabledProperty.OverrideMetadata(type' new FrameworkPropertyMetadata(BooleanBoxes.TrueBox)); " is 142.
Long Statement,Fluent,ContextMenuService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\ContextMenuService.cs,Attach,The length of the statement  "            FrameworkElement.ContextMenuProperty.OverrideMetadata(type' new FrameworkPropertyMetadata(OnContextMenuChanged' CoerceContextMenu)); " is 132.
Long Statement,Fluent,GalleryGroupContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\GalleryGroupContainer.cs,UpdateMinAndMaxWidth,The length of the statement  "                    Debug.WriteLine("Panel with IsItemsHost = true is not found in GalleryGroupContainer (probably the style is not correct or haven't attached yet)"); " is 147.
Long Statement,Fluent,GalleryPanel,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\GalleryPanel.cs,Refresh,The length of the statement  "                    RibbonControl.Bind(this' galleryGroupContainer' nameof(this.Orientation)' GalleryGroupContainer.OrientationProperty' BindingMode.OneWay); " is 137.
Long Statement,Fluent,GalleryPanel,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\GalleryPanel.cs,Refresh,The length of the statement  "                    RibbonControl.Bind(this' galleryGroupContainer' nameof(this.ItemWidth)' GalleryGroupContainer.ItemWidthProperty' BindingMode.OneWay); " is 133.
Long Statement,Fluent,GalleryPanel,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\GalleryPanel.cs,Refresh,The length of the statement  "                    RibbonControl.Bind(this' galleryGroupContainer' nameof(this.ItemHeight)' GalleryGroupContainer.ItemHeightProperty' BindingMode.OneWay); " is 135.
Long Statement,Fluent,GalleryPanel,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\GalleryPanel.cs,Refresh,The length of the statement  "                    RibbonControl.Bind(this' galleryGroupContainer' nameof(this.MaxItemsInRow)' GalleryGroupContainer.MaxItemsInRowProperty' BindingMode.OneWay); " is 141.
Long Statement,Fluent,GalleryPanel,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\GalleryPanel.cs,Refresh,The length of the statement  "                    RibbonControl.Bind(this' galleryGroupContainer' nameof(this.MinItemsInRow)' GalleryGroupContainer.MinItemsInRowProperty' BindingMode.OneWay); " is 141.
Long Statement,Fluent,GalleryPanel,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\GalleryPanel.cs,ArrangeOverride,The length of the statement  "                    placeholder.Target.Arrange(new Rect(leftTop.X' leftTop.Y' placeholder.ArrangedSize.Width' placeholder.ArrangedSize.Height)); " is 124.
Long Statement,Fluent,PopupService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\PopupService.cs,Attach,The length of the statement  "            EventManager.RegisterClassHandler(classType' Mouse.PreviewMouseDownOutsideCapturedElementEvent' new MouseButtonEventHandler(OnClickThroughThunk)); " is 146.
Long Statement,Fluent,PopupService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\PopupService.cs,Attach,The length of the statement  "            EventManager.RegisterClassHandler(classType' DismissPopupEvent' new EventHandler<DismissPopupEventArgs>(OnDismissPopup)); " is 121.
Long Statement,Fluent,PopupService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\PopupService.cs,Attach,The length of the statement  "            EventManager.RegisterClassHandler(classType' FrameworkElement.ContextMenuOpeningEvent' new ContextMenuEventHandler(OnContextMenuOpened)' true); " is 143.
Long Statement,Fluent,PopupService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\PopupService.cs,Attach,The length of the statement  "            EventManager.RegisterClassHandler(classType' FrameworkElement.ContextMenuClosingEvent' new ContextMenuEventHandler(OnContextMenuClosed)' true); " is 143.
Long Statement,Fluent,PopupService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\PopupService.cs,Attach,The length of the statement  "            EventManager.RegisterClassHandler(classType' UIElement.LostMouseCaptureEvent' new MouseEventHandler(OnLostMouseCapture)); " is 121.
Long Statement,Fluent,PopupService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\PopupService.cs,OnClickThroughThunk,The length of the statement  "            ////Debug.WriteLine(string.Format("OnClickThroughThunk: sender = {0}; originalSource = {1}; mouse capture = {2}"' sender' e.OriginalSource' Mouse.Captured)); " is 157.
Long Statement,Fluent,StatusBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\StatusBar.cs,RecreateMenu,The length of the statement  "            RibbonControl.Bind(RibbonLocalization.Current.Localization' this.contextMenu.Items[0] as FrameworkElement' nameof(RibbonLocalizationBase.CustomizeStatusBar)' HeaderedItemsControl.HeaderProperty' BindingMode.OneWay); " is 215.
Long Statement,Fluent,StatusBarPanel,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\StatusBarPanel.cs,ArrangeOverride,The length of the statement  "                    this.rightChildren[i].Arrange(new Rect(finalSize.Width - rightShift' 0' this.rightChildren[i].DesiredSize.Width' finalSize.Height)); " is 132.
Long Statement,Fluent,TextBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\TextBox.cs,ForwardBindingsForQAT,The length of the statement  "            RibbonControl.Bind(source' target' nameof(this.Text)' TextProperty' BindingMode.TwoWay' UpdateSourceTrigger.PropertyChanged); " is 125.
Long Statement,Fluent,Gallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Gallery.cs,GetFilterMenuItem,The length of the statement  "            return this.groupsMenuButton.Items.Cast<MenuItem>().FirstOrDefault(item => (item != null) && (item.Header.ToString() == filter.Title)); " is 135.
Long Statement,Fluent,GalleryItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\GalleryItem.cs,OnMouseLeftButtonUp,The length of the statement  "            if (position.X >= 0.0 && position.X <= this.ActualWidth && position.Y >= 0.0 && position.Y <= this.ActualHeight && e.ClickCount == 1) " is 133.
Long Statement,Fluent,IconConverter,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Converters\IconConverter.cs,Convert,The length of the statement  "                    return GetDefaultIcon(p.MainWindowHandle/*(new WindowInteropHelper(Application.Current.MainWindow)).Handle*/) as BitmapFrame; " is 125.
Long Statement,Fluent,IconConverter,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Converters\IconConverter.cs,GetDefaultIcon,The length of the statement  "                        zero = NativeMethods.LoadImage(IntPtr.Zero' new IntPtr(0x7f00)' 1' (int)SystemParameters.SmallIconWidth' (int)SystemParameters.SmallIconHeight' 0x8000); " is 152.
Long Statement,Fluent,IconConverter,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Converters\IconConverter.cs,GetDefaultIcon,The length of the statement  "                        return BitmapFrame.Create(Imaging.CreateBitmapSourceFromHIcon(zero' Int32Rect.Empty' BitmapSizeOptions.FromWidthAndHeight((int)SystemParameters.SmallIconWidth' (int)SystemParameters.SmallIconHeight))); " is 201.
Long Statement,Fluent,InRibbonGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\InRibbonGallery.cs,OnResizeVerticalDelta,The length of the statement  "            this.scrollViewer.Height = Math.Max(this.layoutRoot.ActualHeight' Math.Min(Math.Max(this.galleryPanel.GetItemSize().Height' this.scrollViewer.Height + e.VerticalChange)' this.MaxDropDownHeight)); " is 195.
Long Statement,Fluent,InRibbonGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\InRibbonGallery.cs,CreateQuickAccessItem,The length of the statement  "            RibbonControl.Bind(this' gallery' nameof(this.MinItemsInDropDownRow)' MinItemsInDropDownRowProperty' BindingMode.OneWay); " is 121.
Long Statement,Fluent,InRibbonGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\InRibbonGallery.cs,CreateQuickAccessItem,The length of the statement  "            RibbonControl.Bind(this' gallery' nameof(this.MaxItemsInDropDownRow)' MaxItemsInDropDownRowProperty' BindingMode.OneWay); " is 121.
Long Statement,Fluent,RibbonWindow,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonWindow.cs,InitializeWindowChromeBehavior,The length of the statement  "            BindingOperations.SetBinding(behavior' WindowChromeBehavior.ResizeBorderThicknessProperty' new Binding { Path = new PropertyPath(ResizeBorderThicknessProperty)' Source = this }); " is 178.
Long Statement,Fluent,RibbonWindow,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonWindow.cs,InitializeWindowChromeBehavior,The length of the statement  "            BindingOperations.SetBinding(behavior' WindowChromeBehavior.GlassFrameThicknessProperty' new Binding { Path = new PropertyPath(GlassFrameThicknessProperty)' Source = this }); " is 174.
Long Statement,Fluent,RibbonWindow,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonWindow.cs,InitializeWindowChromeBehavior,The length of the statement  "            BindingOperations.SetBinding(behavior' WindowChromeBehavior.IgnoreTaskbarOnMaximizeProperty' new Binding { Path = new PropertyPath(IgnoreTaskbarOnMaximizeProperty)' Source = this }); " is 182.
Long Statement,Fluent,Spinner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Spinner.cs,OnValueChanged,The length of the statement  "            spinner.ValueChanged?.Invoke(spinner' new RoutedPropertyChangedEventArgs<double>((double)e.OldValue' (double)e.NewValue)); " is 122.
Long Statement,Fluent,Spinner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Spinner.cs,ValueToTextBoxText,The length of the statement  "            var newText = (string)this.TextToValueConverter.ConvertBack(this.Value' typeof(string)' this.Format' CultureInfo.CurrentCulture); " is 129.
Long Statement,Fluent,Spinner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Spinner.cs,TextBoxTextToValue,The length of the statement  "            var newValue = (double)this.TextToValueConverter.Convert(this.textBox.Text' typeof(double)' converterParam' CultureInfo.CurrentCulture); " is 136.
Long Statement,Fluent,ToggleButtonHelper,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Helpers\ToggleButtonHelper.cs,UncheckToggleButton,The length of the statement  "                dependencyObject.SetCurrentValue(System.Windows.Controls.Primitives.ToggleButton.IsCheckedProperty' BooleanBoxes.FalseBox); " is 123.
Long Statement,Fluent,ToolTipService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\ToolTipService.cs,Attach,The length of the statement  "            System.Windows.Controls.ToolTipService.ShowOnDisabledProperty.OverrideMetadata(type' new FrameworkPropertyMetadata(BooleanBoxes.TrueBox)); " is 138.
Long Statement,Fluent,ToolTipService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\ToolTipService.cs,Attach,The length of the statement  "            System.Windows.Controls.ToolTipService.InitialShowDelayProperty.OverrideMetadata(type' new FrameworkPropertyMetadata(900)); " is 123.
Long Statement,Fluent,ToolTipService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\ToolTipService.cs,Attach,The length of the statement  "            System.Windows.Controls.ToolTipService.BetweenShowDelayProperty.OverrideMetadata(type' new FrameworkPropertyMetadata(IntBoxes.Zero)); " is 133.
Long Statement,Fluent,ToolTipService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\ToolTipService.cs,Attach,The length of the statement  "            System.Windows.Controls.ToolTipService.ShowDurationProperty.OverrideMetadata(type' new FrameworkPropertyMetadata(20000)); " is 121.
Long Statement,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,GenerateAndAddGroupBoxKeyTipInformation,The length of the statement  "            this.LogDebug("Found KeyTipped RibbonGroupBox \"{0}\" with keys \"{1}\"."' keyTipInformation.AssociatedElement' keyTipInformation.Keys); " is 136.
Long Statement,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,GenerateAndAddRegularKeyTipInformations,The length of the statement  "                this.LogDebug("Found KeyTipped element \"{0}\" with keys \"{1}\"."' keyTipInformation.AssociatedElement' keyTipInformation.Keys); " is 129.
Long Statement,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,Forward,The length of the statement  "            // Panels aren't good elements to adorn. For example' trying to display KeyTips on MenuItems in SplitButton fails if using a panel. " is 131.
Long Statement,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,TryGetKeyTipInformation,The length of the statement  "            return this.keyTipInformations.FirstOrDefault(x => x.IsEnabled && x.Visibility == Visibility.Visible && keys.Equals(x.Keys' StringComparison.CurrentCultureIgnoreCase)); " is 168.
Long Statement,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The length of the statement  "            var groupBox = this.oneOfAssociatedElements as RibbonGroupBox ?? UIHelper.GetParent<RibbonGroupBox>(this.oneOfAssociatedElements); " is 130.
Long Statement,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The length of the statement  "                keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed; " is 125.
Long Statement,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The length of the statement  "                else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed) " is 135.
Long Statement,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,IsTextBoxShapedControl,The length of the statement  "            return element is Spinner || element is System.Windows.Controls.ComboBox || element is System.Windows.Controls.TextBox || element is System.Windows.Controls.CheckBox; " is 166.
Long Statement,Fluent,DropDownButton,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\DropDownButton.cs,OnKeyDown,The length of the statement  "                        && this.IsDropDownOpen == false) // Only handle this for initial navigation. Further navigation is handled by the dropdown itself " is 129.
Long Statement,Fluent,DropDownButton,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\DropDownButton.cs,OnKeyDown,The length of the statement  "                        && this.IsDropDownOpen == false) // Only handle this for initial navigation. Further navigation is handled by the dropdown itself " is 129.
Long Statement,Fluent,DropDownButton,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\DropDownButton.cs,OnResizeBothDelta,The length of the statement  "            this.scrollViewer.Height = Math.Min(Math.Max(this.ActualHeight' this.scrollViewer.Height + e.VerticalChange)' this.MaxDropDownHeight); " is 134.
Long Statement,Fluent,DropDownButton,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\DropDownButton.cs,OnResizeVerticalDelta,The length of the statement  "            this.scrollViewer.Height = Math.Min(Math.Max(this.ActualHeight' this.scrollViewer.Height + e.VerticalChange)' this.MaxDropDownHeight); " is 134.
Long Statement,Fluent,KeyTipService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\KeyTipService.cs,OnWindowPreviewKeyDown,The length of the statement  "                    // In office: If you navigate by keyboard (in menus) and keytips are shown they are shown or hidden based on the menu you are in. " is 129.
Long Statement,Fluent,KeyTipService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\KeyTipService.cs,OnWindowPreviewKeyDown,The length of the statement  "                    // Implementing navigation the way office does would require complex focus/state tracking etc. so i decided to just terminate keytips and not restore focus. " is 156.
Long Statement,Fluent,KeyTipService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\KeyTipService.cs,GetBackstage,The length of the statement  "            var control = this.ribbon.Menu as Backstage ?? UIHelper.FindImmediateVisualChild<Backstage>(this.ribbon.Menu' obj => obj.Visibility == Visibility.Visible); " is 155.
Long Statement,Fluent,KeyTipService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\KeyTipService.cs,GetApplicationMenu,The length of the statement  "            var control = this.ribbon.Menu as ApplicationMenu ?? UIHelper.FindImmediateVisualChild<ApplicationMenu>(this.ribbon.Menu' obj => obj.Visibility == Visibility.Visible); " is 167.
Long Statement,Fluent,MenuItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\MenuItem.cs,OnClick,The length of the statement  "            // In case IsCheckable is true and GroupName is not empty we revert the value for IsChecked back to true to prevent unchecking all items in the group " is 149.
Long Statement,Fluent,MenuItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\MenuItem.cs,OnClick,The length of the statement  "                this.RunInDispatcherAsync(() => this.SetCurrentValue(IsCheckedProperty' BooleanBoxes.TrueBox)' DispatcherPriority.Background); " is 126.
Long Statement,Fluent,MenuItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\MenuItem.cs,OnResizeBothDelta,The length of the statement  "                this.menuPanel.Height = Math.Min(Math.Max(this.menuPanel.MinHeight' this.menuPanel.Height + e.VerticalChange)' this.MaxDropDownHeight); " is 135.
Long Statement,Fluent,MenuItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\MenuItem.cs,OnResizeVerticalDelta,The length of the statement  "                this.menuPanel.Height = Math.Min(Math.Max(this.menuPanel.MinHeight' this.menuPanel.Height + e.VerticalChange)' this.MaxDropDownHeight); " is 135.
Long Statement,Fluent,QuickAccessMenuItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\QuickAccessMenuItem.cs,OnTargetChanged,The length of the statement  "                RibbonControl.Bind(ribbonControl' quickAccessMenuItem' nameof(IRibbonControl.Header)' HeaderProperty' BindingMode.OneWay); " is 122.
Long Statement,Fluent,QuickAccessItemsProvider,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\QuickAccessMenuItem.cs,GetQuickAccessItem,The length of the statement  "                throw new ArgumentException("The contol " + element.GetType().Name + " is not able to provide a quick access toolbar item"); " is 124.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            addToQuickAccessMenuItemDictionary.Add(Thread.CurrentThread.ManagedThreadId' new System.Windows.Controls.MenuItem { Command = AddToQuickAccessCommand }); " is 153.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            RibbonControl.Bind(RibbonLocalization.Current.Localization' AddToQuickAccessMenuItem' nameof(RibbonLocalizationBase.RibbonContextMenuAddItem)' HeaderedItemsControl.HeaderProperty' BindingMode.OneWay); " is 200.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            RibbonControl.Bind(RibbonContextMenu' AddToQuickAccessMenuItem' nameof(System.Windows.Controls.ContextMenu.PlacementTarget)' System.Windows.Controls.MenuItem.CommandParameterProperty' BindingMode.OneWay); " is 204.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            addGroupToQuickAccessMenuItemDictionary.Add(Thread.CurrentThread.ManagedThreadId' new System.Windows.Controls.MenuItem { Command = AddToQuickAccessCommand }); " is 158.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            RibbonControl.Bind(RibbonLocalization.Current.Localization' AddGroupToQuickAccessMenuItem' nameof(RibbonLocalizationBase.RibbonContextMenuAddGroup)' HeaderedItemsControl.HeaderProperty' BindingMode.OneWay); " is 206.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            RibbonControl.Bind(RibbonContextMenu' AddGroupToQuickAccessMenuItem' nameof(System.Windows.Controls.ContextMenu.PlacementTarget)' System.Windows.Controls.MenuItem.CommandParameterProperty' BindingMode.OneWay); " is 209.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            addMenuToQuickAccessMenuItemDictionary.Add(Thread.CurrentThread.ManagedThreadId' new System.Windows.Controls.MenuItem { Command = AddToQuickAccessCommand }); " is 157.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            RibbonControl.Bind(RibbonLocalization.Current.Localization' AddMenuToQuickAccessMenuItem' nameof(RibbonLocalizationBase.RibbonContextMenuAddMenu)' HeaderedItemsControl.HeaderProperty' BindingMode.OneWay); " is 204.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            RibbonControl.Bind(RibbonContextMenu' AddMenuToQuickAccessMenuItem' nameof(System.Windows.Controls.ContextMenu.PlacementTarget)' System.Windows.Controls.MenuItem.CommandParameterProperty' BindingMode.OneWay); " is 208.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            addGalleryToQuickAccessMenuItemDictionary.Add(Thread.CurrentThread.ManagedThreadId' new System.Windows.Controls.MenuItem { Command = AddToQuickAccessCommand }); " is 160.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            RibbonControl.Bind(RibbonLocalization.Current.Localization' AddGalleryToQuickAccessMenuItem' nameof(RibbonLocalizationBase.RibbonContextMenuAddGallery)' HeaderedItemsControl.HeaderProperty' BindingMode.OneWay); " is 210.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            RibbonControl.Bind(RibbonContextMenu' AddGalleryToQuickAccessMenuItem' nameof(System.Windows.Controls.ContextMenu.PlacementTarget)' System.Windows.Controls.MenuItem.CommandParameterProperty' BindingMode.OneWay); " is 211.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            removeFromQuickAccessMenuItemDictionary.Add(Thread.CurrentThread.ManagedThreadId' new System.Windows.Controls.MenuItem { Command = RemoveFromQuickAccessCommand }); " is 163.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            RibbonControl.Bind(RibbonLocalization.Current.Localization' RemoveFromQuickAccessMenuItem' nameof(RibbonLocalizationBase.RibbonContextMenuRemoveItem)' HeaderedItemsControl.HeaderProperty' BindingMode.OneWay); " is 208.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            RibbonControl.Bind(RibbonContextMenu' RemoveFromQuickAccessMenuItem' nameof(System.Windows.Controls.ContextMenu.PlacementTarget)' System.Windows.Controls.MenuItem.CommandParameterProperty' BindingMode.OneWay); " is 209.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            customizeQuickAccessToolbarMenuItemDictionary.Add(Thread.CurrentThread.ManagedThreadId' new System.Windows.Controls.MenuItem { Command = CustomizeQuickAccessToolbarCommand }); " is 175.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            RibbonControl.Bind(RibbonLocalization.Current.Localization' CustomizeQuickAccessToolbarMenuItem' nameof(RibbonLocalizationBase.RibbonContextMenuCustomizeQuickAccessToolBar)' HeaderedItemsControl.HeaderProperty' BindingMode.OneWay); " is 231.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            RibbonControl.Bind(RibbonContextMenu' CustomizeQuickAccessToolbarMenuItem' nameof(System.Windows.Controls.ContextMenu.PlacementTarget)' System.Windows.Controls.MenuItem.CommandParameterProperty' BindingMode.OneWay); " is 215.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            showQuickAccessToolbarBelowTheRibbonMenuItemDictionary.Add(Thread.CurrentThread.ManagedThreadId' new System.Windows.Controls.MenuItem { Command = ShowQuickAccessBelowCommand }); " is 177.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            RibbonControl.Bind(RibbonLocalization.Current.Localization' ShowQuickAccessToolbarBelowTheRibbonMenuItem' nameof(RibbonLocalizationBase.RibbonContextMenuShowBelow)' HeaderedItemsControl.HeaderProperty' BindingMode.OneWay); " is 222.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            RibbonControl.Bind(RibbonContextMenu' ShowQuickAccessToolbarBelowTheRibbonMenuItem' nameof(System.Windows.Controls.ContextMenu.PlacementTarget)' System.Windows.Controls.MenuItem.CommandParameterProperty' BindingMode.OneWay); " is 224.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            showQuickAccessToolbarAboveTheRibbonMenuItemDictionary.Add(Thread.CurrentThread.ManagedThreadId' new System.Windows.Controls.MenuItem { Command = ShowQuickAccessAboveCommand }); " is 177.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            RibbonControl.Bind(RibbonLocalization.Current.Localization' ShowQuickAccessToolbarAboveTheRibbonMenuItem' nameof(RibbonLocalizationBase.RibbonContextMenuShowAbove)' HeaderedItemsControl.HeaderProperty' BindingMode.OneWay); " is 222.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            RibbonControl.Bind(RibbonContextMenu' ShowQuickAccessToolbarAboveTheRibbonMenuItem' nameof(System.Windows.Controls.ContextMenu.PlacementTarget)' System.Windows.Controls.MenuItem.CommandParameterProperty' BindingMode.OneWay); " is 224.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            customizeTheRibbonMenuItemDictionary.Add(Thread.CurrentThread.ManagedThreadId' new System.Windows.Controls.MenuItem { Command = CustomizeTheRibbonCommand }); " is 157.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            RibbonControl.Bind(RibbonLocalization.Current.Localization' CustomizeTheRibbonMenuItem' nameof(RibbonLocalizationBase.RibbonContextMenuCustomizeRibbon)' HeaderedItemsControl.HeaderProperty' BindingMode.OneWay); " is 210.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            RibbonControl.Bind(RibbonContextMenu' CustomizeTheRibbonMenuItem' nameof(System.Windows.Controls.ContextMenu.PlacementTarget)' System.Windows.Controls.MenuItem.CommandParameterProperty' BindingMode.OneWay); " is 206.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            minimizeTheRibbonMenuItemDictionary.Add(Thread.CurrentThread.ManagedThreadId' new System.Windows.Controls.MenuItem { Command = ToggleMinimizeTheRibbonCommand }); " is 161.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            RibbonControl.Bind(RibbonLocalization.Current.Localization' MinimizeTheRibbonMenuItem' nameof(RibbonLocalizationBase.RibbonContextMenuMinimizeRibbon)' HeaderedItemsControl.HeaderProperty' BindingMode.OneWay); " is 208.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,InitRibbonContextMenu,The length of the statement  "            RibbonControl.Bind(RibbonContextMenu' MinimizeTheRibbonMenuItem' nameof(System.Windows.Controls.ContextMenu.PlacementTarget)' System.Windows.Controls.MenuItem.CommandParameterProperty' BindingMode.OneWay); " is 205.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,OnContextMenuOpened,The length of the statement  "                        // Check for value because remove is only possible in the context menu of items in QA which represent the value for QA-items " is 124.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,OnApplyTemplate,The length of the statement  "                this.TabControl.SetBinding(RibbonTabControl.IsMinimizedProperty' new Binding(nameof(this.IsMinimized)) { Source = this' Mode = BindingMode.TwoWay }); " is 149.
Long Statement,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,OnApplyTemplate,The length of the statement  "                this.TabControl.SetBinding(RibbonTabControl.ContentGapHeightProperty' new Binding(nameof(this.ContentGapHeight)) { Source = this' Mode = BindingMode.OneWay }); " is 159.
Long Statement,Fluent,RibbonContextualTabGroup,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonContextualTabGroup.cs,UpdateInnerVisibility,The length of the statement  "            this.InnerVisibility = this.Visibility == Visibility.Visible && this.Items.Any(item => item.Visibility == Visibility.Visible) " is 125.
Long Statement,Fluent,RibbonContextualGroupsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonContextualGroupsContainer.cs,ArrangeOverride,The length of the statement  "                finalRect.Height = Math.Max(finalSize.Height' this.sizes[index].Height); //Math.Max(finalSize.Height' item.DesiredSize.Height); " is 127.
Long Statement,Fluent,RibbonContextualGroupsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonContextualGroupsContainer.cs,MeasureOverride,The length of the statement  "                var visibleItems = contextualGroup.Items.Where(item => item.Visibility == Visibility.Visible && DoubleUtil.AreClose(item.DesiredSize.Width' 0) == false).ToList(); " is 162.
Long Statement,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The length of the statement  "                    this.quickAccessToolbarRect = new Rect(0' 0' Math.Max(0' constraint.Width - 50)' this.quickAccessToolbarHolder.DesiredSize.Height); " is 131.
Long Statement,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The length of the statement  "                    this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height); " is 144.
Long Statement,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The length of the statement  "                        this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height); " is 159.
Long Statement,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The length of the statement  "                        this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidth / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height); " is 237.
Long Statement,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The length of the statement  "                        this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height); " is 225.
Long Statement,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The length of the statement  "                var itemsRectWidth = Math.Min(this.itemsContainer.DesiredSize.Width' Math.Max(0' Math.Min(endX' constraint.Width) - startX)); " is 125.
Long Statement,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The length of the statement  "                this.quickAccessToolbarRect = new Rect(0' 0' Math.Min(quickAccessToolbarWidth' startX)' this.quickAccessToolbarHolder.DesiredSize.Height); " is 138.
Long Statement,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The length of the statement  "                    this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height); " is 144.
Long Statement,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The length of the statement  "                                this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height); " is 145.
Long Statement,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The length of the statement  "                                this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height); " is 144.
Long Statement,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The length of the statement  "                            var fitsRightButNotLeft = allTextWidthRight >= this.headerHolder.DesiredSize.Width && allTextWidthLeft < this.headerHolder.DesiredSize.Width; " is 141.
Long Statement,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The length of the statement  "                            if (((startX - quickAccessToolbarWidth < 150 || fitsRightButNotLeft) && (startX - quickAccessToolbarWidth > 0) && (startX - quickAccessToolbarWidth < constraint.Width - endX)) || (endX < constraint.Width / 2)) " is 209.
Long Statement,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The length of the statement  "                                this.headerRect = new Rect(Math.Min(Math.Max(endX' (constraint.Width / 2) - (this.headerHolder.DesiredSize.Width / 2))' constraint.Width)' 0' Math.Min(allTextWidthRight' this.headerHolder.DesiredSize.Width)' constraint.Height); " is 227.
Long Statement,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The length of the statement  "                                this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidthLeft / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidthLeft' this.headerHolder.DesiredSize.Width)' constraint.Height); " is 245.
Long Statement,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The length of the statement  "                                this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height); " is 225.
Long Statement,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The length of the statement  "                                this.headerRect = new Rect(Math.Min(Math.Max(endX' constraint.Width - this.headerHolder.DesiredSize.Width)' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height); " is 210.
Long Statement,Fluent,ScreenTip,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ScreenTip.cs,CustomPopupPlacementMethod,The length of the statement  "                var belowY = decoratorChild.TranslatePoint(new Point(0' ((FrameworkElement)decoratorChild).ActualHeight)' this.PlacementTarget).Y; " is 130.
Long Statement,Fluent,ScreenTip,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ScreenTip.cs,CustomPopupPlacementMethod,The length of the statement  "                new CustomPopupPlacement(new Point(rightToLeftOffset' this.PlacementTarget.RenderSize.Height + 1)' PopupPrimaryAxis.Horizontal)' " is 128.
Long Statement,Fluent,RibbonTabsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabsContainer.cs,MeasureOverride,The length of the statement  "            var contextualTabs = this.InternalChildren.Cast<RibbonTabItem>().Where(x => x.IsContextual && (x.Visibility != Visibility.Collapsed) && (x.Group.Visibility != Visibility.Collapsed)) " is 181.
Long Statement,Fluent,RibbonTabsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabsContainer.cs,MeasureOverride,The length of the statement  "            var regularTabs = this.InternalChildren.Cast<RibbonTabItem>().Where(x => !x.IsContextual && (x.Visibility != Visibility.Collapsed)) " is 131.
Long Statement,Fluent,RibbonTabsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabsContainer.cs,MeasureOverride,The length of the statement  "                    tab.Measure(new Size(Math.Max(0' tab.DesiredSize.Width - decreaseValue)' tab.DesiredSize.Height)); // tab.Width = Math.Max(0' tab.ActualWidth - decreaseValue); " is 159.
Long Statement,Fluent,RibbonTabsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabsContainer.cs,SetHorizontalOffset,The length of the statement  "            var newValue = CoerceOffset(ValidateInputOffset(offset' nameof(this.HorizontalOffset))' this.scrollData.ExtentWidth' this.scrollData.ViewportWidth); " is 148.
Long Statement,Fluent,RibbonTabsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabsContainer.cs,VerifyScrollData,The length of the statement  "            // To fix 20762 we are manipulating the extentWidth by checking if all regular (non contextual) tabs are at their minimum width. " is 128.
Long Statement,Fluent,RibbonControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonControl.cs,BindQuickAccessItem,The length of the statement  "                    Bind(source' element' nameof(ICommandSource.CommandParameter)' System.Windows.Controls.MenuItem.CommandParameterProperty' BindingMode.OneWay); " is 142.
Long Statement,Fluent,RibbonControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonControl.cs,BindQuickAccessItem,The length of the statement  "                    Bind(source' element' nameof(ICommandSource.CommandTarget)' System.Windows.Controls.MenuItem.CommandTargetProperty' BindingMode.OneWay); " is 136.
Long Statement,Fluent,RibbonControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonControl.cs,BindQuickAccessItem,The length of the statement  "                    Bind(source' element' nameof(ICommandSource.Command)' System.Windows.Controls.MenuItem.CommandProperty' BindingMode.OneWay); " is 124.
Long Statement,Fluent,RibbonControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonControl.cs,BindQuickAccessItem,The length of the statement  "                    Bind(source' element' nameof(ICommandSource.CommandParameter)' ButtonBase.CommandParameterProperty' BindingMode.OneWay); " is 120.
Long Statement,Fluent,RibbonControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonControl.cs,BindQuickAccessItem,The length of the statement  "            Bind(source' element' new PropertyPath(FocusManager.IsFocusScopeProperty)' FocusManager.IsFocusScopeProperty' BindingMode.OneWay); " is 130.
Long Statement,Fluent,RibbonControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonControl.cs,GetControlWorkArea,The length of the statement  "                return new Rect(monitorInfo.rcWork.Left' monitorInfo.rcWork.Top' monitorInfo.rcWork.Right - monitorInfo.rcWork.Left' monitorInfo.rcWork.Bottom - monitorInfo.rcWork.Top); " is 169.
Long Statement,Fluent,RibbonControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonControl.cs,GetControlMonitor,The length of the statement  "                return new Rect(monitorInfo.rcMonitor.Left' monitorInfo.rcMonitor.Top' monitorInfo.rcMonitor.Right - monitorInfo.rcMonitor.Left' monitorInfo.rcMonitor.Bottom - monitorInfo.rcMonitor.Top); " is 187.
Long Statement,Fluent,RibbonTabControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabControl.cs,OnKeyDown,The length of the statement  "                        startIndex = this.ItemContainerGenerator.IndexFromContainer(this.ItemContainerGenerator.ContainerFromItem(this.SelectedItem)); " is 126.
Long Statement,Fluent,RibbonTabControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabControl.cs,ProcessMouseWheel,The length of the statement  "                .Where(x => x.Visibility == Visibility.Visible && x.IsEnabled && (x.IsContextual == false || (x.IsContextual && x.Group.Visibility == Visibility.Visible))) " is 155.
Long Statement,Fluent,RibbonTabControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabControl.cs,ProcessMouseWheel,The length of the statement  "            var tabs = this.Items.OfType<object>().Select(x => this.ItemContainerGenerator.ContainerFromItem(x)).OfType<RibbonTabItem>() " is 124.
Long Statement,Fluent,RibbonTabControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabControl.cs,ProcessMouseWheel,The length of the statement  "                .Where(x => x.Visibility == Visibility.Visible && x.IsEnabled && (x.IsContextual == false || (x.IsContextual && x.Group.Visibility == Visibility.Visible))) " is 155.
Long Statement,Fluent,RibbonTabControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabControl.cs,CustomPopupPlacementMethod,The length of the statement  "                new CustomPopupPlacement(new Point(startPoint.X - tabItemPos.X + offset.X' targetsize.Height + offset.Y)' PopupPrimaryAxis.Vertical)' " is 133.
Long Statement,Fluent,RibbonTabControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabControl.cs,CustomPopupPlacementMethod,The length of the statement  "                new CustomPopupPlacement(new Point(startPoint.X - tabItemPos.X + offset.X' -1 * (targetsize.Height + offset.Y + ((ScrollViewer)this.SelectedContent).ActualHeight))' PopupPrimaryAxis.Vertical) " is 191.
Long Statement,Fluent,RibbonGroupBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonGroupBox.cs,CreateQuickAccessItem,The length of the statement  "            RibbonControl.Bind(this' groupBox' nameof(this.ItemTemplateSelector)' ItemTemplateSelectorProperty' BindingMode.OneWay); " is 120.
Long Statement,Fluent,RibbonGroupBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonGroupBox.cs,CreateQuickAccessItem,The length of the statement  "            RibbonControl.Bind(this' groupBox' nameof(this.LauncherCommandParameter)' LauncherCommandParameterProperty' BindingMode.OneWay); " is 128.
Long Statement,Fluent,RibbonGroupBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonGroupBox.cs,CreateQuickAccessItem,The length of the statement  "            RibbonControl.Bind(this' groupBox' nameof(this.LauncherCommandTarget)' LauncherCommandTargetProperty' BindingMode.OneWay); " is 122.
Long Statement,Fluent,RibbonGroupBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonGroupBox.cs,CreateQuickAccessItem,The length of the statement  "            RibbonControl.Bind(this' groupBox' nameof(this.LauncherKeys)' DialogLauncherButtonKeyTipKeysProperty' BindingMode.OneWay); " is 122.
Long Statement,Fluent,RibbonGroupsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonGroupsContainer.cs,SetHorizontalOffset,The length of the statement  "            var newValue = CoerceOffset(ValidateInputOffset(offset' nameof(this.HorizontalOffset))' this.scrollData.ExtentWidth' this.scrollData.ViewportWidth); " is 148.
Long Statement,Fluent,RibbonTabItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabItem.cs,MeasureOverride,The length of the statement  "            this.contentContainer.Padding = new Thickness(this.Indent' this.contentContainer.Padding.Top' this.Indent' this.contentContainer.Padding.Bottom); " is 145.
Long Statement,Fluent,RibbonTabItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabItem.cs,MeasureOverride,The length of the statement  "            var totalWidth = this.contentContainer.DesiredSize.Width - this.contentContainer.Margin.Left - this.contentContainer.Margin.Right; " is 130.
Long Statement,Fluent,RibbonTabItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabItem.cs,MeasureOverride,The length of the statement  "                this.contentContainer.Padding = new Thickness(newPaddings' this.contentContainer.Padding.Top' newPaddings' this.contentContainer.Padding.Bottom); " is 145.
Long Statement,Fluent,RibbonTabItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabItem.cs,MeasureOverride,The length of the statement  "                        baseConstraint.Width = headerWidth + (this.Indent * 2) + this.contentContainer.Margin.Left + this.contentContainer.Margin.Right; " is 128.
Long Statement,Fluent,ThemeManager,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\ThemeManager\ThemeManager.cs,GetAccent,The length of the statement  "            var builtInAccent = Accents.FirstOrDefault(x => AreResourceDictionarySourcesEqual(x.Resources.Source' resources.Source)); " is 121.
Long Statement,Fluent,ThemeManager,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\ThemeManager\ThemeManager.cs,ChangeAppStyle,The length of the statement  "                    var oldAccentResource = resources.MergedDictionaries.Where(x => x.Source != null).FirstOrDefault(d => d.Source.ToString().ToLower() == key); " is 140.
Long Statement,Fluent,ThemeManager,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\ThemeManager\ThemeManager.cs,ChangeAppStyle,The length of the statement  "                    var oldThemeResource = resources.MergedDictionaries.Where(x => x.Source != null).FirstOrDefault(d => d.Source.ToString().ToLower() == key); " is 139.
Long Statement,Fluent.Converters,ColorToSolidColorBrushValueConverter,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Converters\ColorToSolidColorBrushConverter.cs,Convert,The length of the statement  "            throw new InvalidOperationException($"Unsupported type [{value.GetType().Name}]' ColorToSolidColorBrushValueConverter.Convert()"); " is 130.
Long Statement,Fluent.Converters,ColorToSolidColorBrushValueConverter,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Converters\ColorToSolidColorBrushConverter.cs,ConvertBack,The length of the statement  "            throw new InvalidOperationException($"Unsupported type [{value.GetType().Name}]' ColorToSolidColorBrushValueConverter.Convert()"); " is 130.
Long Statement,Fluent.Converters,ObjectToImageConverter,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Converters\ObjectToImageConverter.cs,CreateImage,The length of the statement  "                Source = new BitmapImage(new Uri(imagePath' UriKind.RelativeOrAbsolute)' new RequestCachePolicy(RequestCacheLevel.NoCacheNoStore)) " is 130.
Complex Conditional,Fluent,ComboBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ComboBox.cs,OnPreviewKeyDown,The conditional expression  "this.IsEditable && ((e.Key == Key.Down) || (e.Key == Key.Up)) && !this.IsDropDownOpen"  is complex.
Complex Conditional,Fluent,GalleryPanel,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\GalleryPanel.cs,Refresh,The conditional expression  "(this.IsGrouped == false || (this.GroupBy == null && this.GroupByAdvanced == null))                  && this.galleryGroupContainers.Count != 0"  is complex.
Complex Conditional,Fluent,PopupService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\PopupService.cs,OnLostMouseCapture,The conditional expression  "e.OriginalSource != null                      && Mouse.Captured == null                      && (IsPopupRoot(e.OriginalSource) || IsAncestorOf(popup.Child' e.OriginalSource as DependencyObject))"  is complex.
Complex Conditional,Fluent,GalleryItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\GalleryItem.cs,OnMouseLeftButtonUp,The conditional expression  "position.X >= 0.0 && position.X <= this.ActualWidth && position.Y >= 0.0 && position.Y <= this.ActualHeight && e.ClickCount == 1"  is complex.
Complex Conditional,Fluent,IconConverter,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Converters\IconConverter.cs,Convert,The conditional expression  "Application.Current != null                      && Application.Current.CheckAccess()                      && Application.Current.MainWindow != null                      && Application.Current.MainWindow.CheckAccess()"  is complex.
Complex Conditional,Fluent,IconConverter,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Converters\IconConverter.cs,GetThumbnail,The conditional expression  "frame != null                      && frame.PixelWidth == 16                      && frame.PixelHeight == 16                      && (frame.Format == PixelFormats.Bgra32 || frame.Format == PixelFormats.Bgr24)"  is complex.
Complex Conditional,Fluent,KeyTipService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\KeyTipService.cs,WindowProc,The conditional expression  "msg == (int)WM.NCACTIVATE // mouse clicks in non client area                  || (msg == (int)WM.ACTIVATE && wParam == IntPtr.Zero) // the window is deactivated                                                                             // >= WM_NCLBUTTONDOWN <= WM_NCXBUTTONDBLCLK                  || (msg >= 161 && msg <= 173) // mouse click (non client area)                  || (msg >= 513 && msg <= 521)"  is complex.
Complex Conditional,Fluent,KeyTipService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\KeyTipService.cs,OnWindowPreviewKeyDown,The conditional expression  "(e.Key != Key.System && this.activeAdornerChain == null)                      || e.SystemKey == Key.Escape                      || (e.KeyboardDevice.Modifiers != ModifierKeys.Alt && this.activeAdornerChain == null)"  is complex.
Complex Conditional,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,OnAddToQuickAccessCommandCanExecute,The conditional expression  "ribbon != null                  && ribbon.IsQuickAccessToolBarVisible                  && QuickAccessItemsProvider.IsSupported(e.Parameter as UIElement)                  && ribbon.IsInQuickAccessToolBar(e.Parameter as UIElement) == false"  is complex.
Complex Conditional,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The conditional expression  "((startX - quickAccessToolbarWidth < 150 || fitsRightButNotLeft) && (startX - quickAccessToolbarWidth > 0) && (startX - quickAccessToolbarWidth < constraint.Width - endX)) || (endX < constraint.Width / 2)"  is complex.
Complex Conditional,Fluent,ScreenTip,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ScreenTip.cs,CustomPopupPlacementMethod,The conditional expression  "notQuickAccessItem                  && this.IsRibbonAligned                  && notContextMenuChild                  && topLevelElement is Window == false                  && decoratorChild != null"  is complex.
Complex Conditional,Fluent,RibbonTabsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabsContainer.cs,MakeVisible,The conditional expression  "rectangle.IsEmpty                  || visual == null                  || ReferenceEquals(visual' this)                  || this.IsAncestorOf(visual) == false"  is complex.
Complex Conditional,Fluent,RibbonTabsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabsContainer.cs,ComputeScrollOffsetWithMinimalScroll,The conditional expression  "(fAbove && !fLarger)                 || (fBelow && fLarger)"  is complex.
Complex Conditional,Fluent,RibbonGroupsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonGroupsContainer.cs,MakeVisible,The conditional expression  "rectangle.IsEmpty                  || visual == null                  || ReferenceEquals(visual' this)                  || !this.IsAncestorOf(visual)"  is complex.
Complex Conditional,Fluent,RibbonGroupsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonGroupsContainer.cs,ComputeScrollOffsetWithMinimalScroll,The conditional expression  "(fAbove && !fLarger)                 || (fBelow && fLarger)"  is complex.
Complex Conditional,Fluent.Converters,SpinnerTextToValueConverter,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Converters\SpinnerTextToValueConverter.cs,TextToDouble,The conditional expression  "char.IsDigit(symbol) ||                      symbol == ''' ||                      symbol == '.' ||                      (symbol == '-' && stringBuilder.Length == 0)"  is complex.
Complex Conditional,Fluent.Converters,ObjectToImageConverter,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Converters\ObjectToImageConverter.cs,ExtractImage,The conditional expression  "Application.Current != null                  && Application.Current.CheckAccess()                  && Application.Current.MainWindow != null                  && Application.Current.MainWindow.CheckAccess()"  is complex.
Complex Conditional,Fluent.Helpers,WindowSteeringHelper,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Helpers\WindowSteeringHelper.cs,HandleMouseLeftButtonDown,The conditional expression  "handleStateChange                  && e.ClickCount == 2                  && (window.ResizeMode == ResizeMode.CanResize || window.ResizeMode == ResizeMode.CanResizeWithGrip)"  is complex.
Magic Number,Fluent,Backstage,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Backstage.cs,Show,The following statement contains a magic number: if (window != null)              {                  window.KeyDown += this.HandleWindowKeyDown;                    if (this.savedWindowMinWidth < 500)                  {                      window.MinWidth = 500;                  }                    if (this.savedWindowMinHeight < 400)                  {                      window.MinHeight = 400;                  }                    window.SizeChanged += this.OnWindowSizeChanged;                    // We have to collapse WindowsFormsHost while Backstage is open                  this.CollapseWindowsFormsHosts(window);              }
Magic Number,Fluent,Backstage,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Backstage.cs,Show,The following statement contains a magic number: if (window != null)              {                  window.KeyDown += this.HandleWindowKeyDown;                    if (this.savedWindowMinWidth < 500)                  {                      window.MinWidth = 500;                  }                    if (this.savedWindowMinHeight < 400)                  {                      window.MinHeight = 400;                  }                    window.SizeChanged += this.OnWindowSizeChanged;                    // We have to collapse WindowsFormsHost while Backstage is open                  this.CollapseWindowsFormsHosts(window);              }
Magic Number,Fluent,Backstage,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Backstage.cs,Show,The following statement contains a magic number: if (window != null)              {                  window.KeyDown += this.HandleWindowKeyDown;                    if (this.savedWindowMinWidth < 500)                  {                      window.MinWidth = 500;                  }                    if (this.savedWindowMinHeight < 400)                  {                      window.MinHeight = 400;                  }                    window.SizeChanged += this.OnWindowSizeChanged;                    // We have to collapse WindowsFormsHost while Backstage is open                  this.CollapseWindowsFormsHosts(window);              }
Magic Number,Fluent,Backstage,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Backstage.cs,Show,The following statement contains a magic number: if (window != null)              {                  window.KeyDown += this.HandleWindowKeyDown;                    if (this.savedWindowMinWidth < 500)                  {                      window.MinWidth = 500;                  }                    if (this.savedWindowMinHeight < 400)                  {                      window.MinHeight = 400;                  }                    window.SizeChanged += this.OnWindowSizeChanged;                    // We have to collapse WindowsFormsHost while Backstage is open                  this.CollapseWindowsFormsHosts(window);              }
Magic Number,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,ConvertFromWin32Color,The following statement contains a magic number: var g = (color & 0x0000FF00) >> 8;
Magic Number,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,ConvertFromWin32Color,The following statement contains a magic number: var b = (color & 0x00FF0000) >> 16;
Magic Number,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,ConvertFromWin32Color,The following statement contains a magic number: return Color.FromArgb(255' (byte)r' (byte)g' (byte)b);
Magic Number,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,GetBrightness,The following statement contains a magic number: return summ / (255.0 * 3.0);
Magic Number,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,GetBrightness,The following statement contains a magic number: return summ / (255.0 * 3.0);
Magic Number,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,Lighter,The following statement contains a magic number: var totalAvailability = (255.0 * 3.0) - color.R + color.G + color.B;
Magic Number,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,Lighter,The following statement contains a magic number: var totalAvailability = (255.0 * 3.0) - color.R + color.G + color.B;
Magic Number,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,Lighter,The following statement contains a magic number: if (color.R + color.G + color.B == 0)              {                  redAvailability = 1.0 / 3.0;                  greenAvailability = 1.0 / 3.0;                  blueAvailability = 1.0 / 3.0;                  needToBeAdded = power * 255.0 * 3.0;              }              else              {                  redAvailability = (255.0 - color.R) / totalAvailability;                  greenAvailability = (255.0 - color.G) / totalAvailability;                  blueAvailability = (255.0 - color.B) / totalAvailability;                  needToBeAdded = ((double)color.R + color.G + color.B) * (power - 1);              }
Magic Number,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,Lighter,The following statement contains a magic number: if (color.R + color.G + color.B == 0)              {                  redAvailability = 1.0 / 3.0;                  greenAvailability = 1.0 / 3.0;                  blueAvailability = 1.0 / 3.0;                  needToBeAdded = power * 255.0 * 3.0;              }              else              {                  redAvailability = (255.0 - color.R) / totalAvailability;                  greenAvailability = (255.0 - color.G) / totalAvailability;                  blueAvailability = (255.0 - color.B) / totalAvailability;                  needToBeAdded = ((double)color.R + color.G + color.B) * (power - 1);              }
Magic Number,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,Lighter,The following statement contains a magic number: if (color.R + color.G + color.B == 0)              {                  redAvailability = 1.0 / 3.0;                  greenAvailability = 1.0 / 3.0;                  blueAvailability = 1.0 / 3.0;                  needToBeAdded = power * 255.0 * 3.0;              }              else              {                  redAvailability = (255.0 - color.R) / totalAvailability;                  greenAvailability = (255.0 - color.G) / totalAvailability;                  blueAvailability = (255.0 - color.B) / totalAvailability;                  needToBeAdded = ((double)color.R + color.G + color.B) * (power - 1);              }
Magic Number,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,Lighter,The following statement contains a magic number: if (color.R + color.G + color.B == 0)              {                  redAvailability = 1.0 / 3.0;                  greenAvailability = 1.0 / 3.0;                  blueAvailability = 1.0 / 3.0;                  needToBeAdded = power * 255.0 * 3.0;              }              else              {                  redAvailability = (255.0 - color.R) / totalAvailability;                  greenAvailability = (255.0 - color.G) / totalAvailability;                  blueAvailability = (255.0 - color.B) / totalAvailability;                  needToBeAdded = ((double)color.R + color.G + color.B) * (power - 1);              }
Magic Number,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,Lighter,The following statement contains a magic number: if (color.R + color.G + color.B == 0)              {                  redAvailability = 1.0 / 3.0;                  greenAvailability = 1.0 / 3.0;                  blueAvailability = 1.0 / 3.0;                  needToBeAdded = power * 255.0 * 3.0;              }              else              {                  redAvailability = (255.0 - color.R) / totalAvailability;                  greenAvailability = (255.0 - color.G) / totalAvailability;                  blueAvailability = (255.0 - color.B) / totalAvailability;                  needToBeAdded = ((double)color.R + color.G + color.B) * (power - 1);              }
Magic Number,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,Lighter,The following statement contains a magic number: if (color.R + color.G + color.B == 0)              {                  redAvailability = 1.0 / 3.0;                  greenAvailability = 1.0 / 3.0;                  blueAvailability = 1.0 / 3.0;                  needToBeAdded = power * 255.0 * 3.0;              }              else              {                  redAvailability = (255.0 - color.R) / totalAvailability;                  greenAvailability = (255.0 - color.G) / totalAvailability;                  blueAvailability = (255.0 - color.B) / totalAvailability;                  needToBeAdded = ((double)color.R + color.G + color.B) * (power - 1);              }
Magic Number,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,Lighter,The following statement contains a magic number: if (color.R + color.G + color.B == 0)              {                  redAvailability = 1.0 / 3.0;                  greenAvailability = 1.0 / 3.0;                  blueAvailability = 1.0 / 3.0;                  needToBeAdded = power * 255.0 * 3.0;              }              else              {                  redAvailability = (255.0 - color.R) / totalAvailability;                  greenAvailability = (255.0 - color.G) / totalAvailability;                  blueAvailability = (255.0 - color.B) / totalAvailability;                  needToBeAdded = ((double)color.R + color.G + color.B) * (power - 1);              }
Magic Number,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,Lighter,The following statement contains a magic number: if (color.R + color.G + color.B == 0)              {                  redAvailability = 1.0 / 3.0;                  greenAvailability = 1.0 / 3.0;                  blueAvailability = 1.0 / 3.0;                  needToBeAdded = power * 255.0 * 3.0;              }              else              {                  redAvailability = (255.0 - color.R) / totalAvailability;                  greenAvailability = (255.0 - color.G) / totalAvailability;                  blueAvailability = (255.0 - color.B) / totalAvailability;                  needToBeAdded = ((double)color.R + color.G + color.B) * (power - 1);              }
Magic Number,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,GetGradient,The following statement contains a magic number: const double lowBrightness = 0.15;
Magic Number,Fluent,ColorGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ColorGallery.cs,GetGradient,The following statement contains a magic number: const double highBrightness = 0.85;
Magic Number,Fluent,ComboBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ComboBox.cs,OnDropDownOpened,The following statement contains a magic number: var initialHeight = Math.Min(RibbonControl.GetControlWorkArea(this).Height * 2 / 3' this.MaxDropDownHeight);
Magic Number,Fluent,ComboBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\ComboBox.cs,OnDropDownOpened,The following statement contains a magic number: var initialHeight = Math.Min(RibbonControl.GetControlWorkArea(this).Height * 2 / 3' this.MaxDropDownHeight);
Magic Number,Fluent,RibbonStateStorage,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Data\RibbonStateStorage.cs,LoadState,The following statement contains a magic number: if (splitted.Length != 2)              {                  return;              }
Magic Number,Fluent,GalleryGroupContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\GalleryGroupContainer.cs,UpdateMinAndMaxWidth,The following statement contains a magic number: this.RealItemsPanel.MinWidth = (Math.Min(this.Items.Count' this.MinItemsInRow) * itemWidth) + 0.1;
Magic Number,Fluent,GalleryGroupContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\GalleryGroupContainer.cs,UpdateMinAndMaxWidth,The following statement contains a magic number: this.RealItemsPanel.MaxWidth = (Math.Min(this.Items.Count' this.MaxItemsInRow) * itemWidth) + 0.1;
Magic Number,Fluent,RibbonControlSizeDefinition,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Data\RibbonControlSizeDefinition.cs,RibbonControlSizeDefinition,The following statement contains a magic number: this.Small = ToRibbonControlSize(splitted[2]);
Magic Number,Fluent,RibbonControlSizeDefinition,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Data\RibbonControlSizeDefinition.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = (int)this.Large;                  hashCode = (hashCode * 397) ^ (int)this.Middle;                  hashCode = (hashCode * 397) ^ (int)this.Small;                  return hashCode;              }
Magic Number,Fluent,RibbonControlSizeDefinition,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Data\RibbonControlSizeDefinition.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = (int)this.Large;                  hashCode = (hashCode * 397) ^ (int)this.Middle;                  hashCode = (hashCode * 397) ^ (int)this.Small;                  return hashCode;              }
Magic Number,Fluent,IconConverter,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Converters\IconConverter.cs,GetThumbnail,The following statement contains a magic number: try              {                  if (frame != null                      && frame.PixelWidth == 16                      && frame.PixelHeight == 16                      && (frame.Format == PixelFormats.Bgra32 || frame.Format == PixelFormats.Bgr24))                  {                      return frame;                  }                    return null;              }              catch (Exception)              {                  return null;              }
Magic Number,Fluent,IconConverter,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Converters\IconConverter.cs,GetThumbnail,The following statement contains a magic number: try              {                  if (frame != null                      && frame.PixelWidth == 16                      && frame.PixelHeight == 16                      && (frame.Format == PixelFormats.Bgra32 || frame.Format == PixelFormats.Bgr24))                  {                      return frame;                  }                    return null;              }              catch (Exception)              {                  return null;              }
Magic Number,Fluent,IconConverter,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Converters\IconConverter.cs,GetDefaultIcon,The following statement contains a magic number: if (hwnd != IntPtr.Zero)              {                  try                  {  #pragma warning disable 618                      var zero = NativeMethods.SendMessage(hwnd' WM.GETICON' new IntPtr(2)' IntPtr.Zero);                        if (zero == IntPtr.Zero)                      {                          zero = NativeMethods.GetClassLong(hwnd' -34);                      }                        if (zero == IntPtr.Zero)                      {                          zero = NativeMethods.LoadImage(IntPtr.Zero' new IntPtr(0x7f00)' 1' (int)SystemParameters.SmallIconWidth' (int)SystemParameters.SmallIconHeight' 0x8000);                      }                        if (zero != IntPtr.Zero)                      {                          return BitmapFrame.Create(Imaging.CreateBitmapSourceFromHIcon(zero' Int32Rect.Empty' BitmapSizeOptions.FromWidthAndHeight((int)SystemParameters.SmallIconWidth' (int)SystemParameters.SmallIconHeight)));                      }  #pragma warning restore 618                  }                  catch                  {                      return null;                  }              }
Magic Number,Fluent,IconConverter,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Converters\IconConverter.cs,GetDefaultIcon,The following statement contains a magic number: if (hwnd != IntPtr.Zero)              {                  try                  {  #pragma warning disable 618                      var zero = NativeMethods.SendMessage(hwnd' WM.GETICON' new IntPtr(2)' IntPtr.Zero);                        if (zero == IntPtr.Zero)                      {                          zero = NativeMethods.GetClassLong(hwnd' -34);                      }                        if (zero == IntPtr.Zero)                      {                          zero = NativeMethods.LoadImage(IntPtr.Zero' new IntPtr(0x7f00)' 1' (int)SystemParameters.SmallIconWidth' (int)SystemParameters.SmallIconHeight' 0x8000);                      }                        if (zero != IntPtr.Zero)                      {                          return BitmapFrame.Create(Imaging.CreateBitmapSourceFromHIcon(zero' Int32Rect.Empty' BitmapSizeOptions.FromWidthAndHeight((int)SystemParameters.SmallIconWidth' (int)SystemParameters.SmallIconHeight)));                      }  #pragma warning restore 618                  }                  catch                  {                      return null;                  }              }
Magic Number,Fluent,RibbonWindow,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonWindow.cs,HandleIconMouseDown,The following statement contains a magic number: switch (e.ChangedButton)              {                  case MouseButton.Left:                      if (e.ClickCount == 1)                      {                          e.Handled = true;                            WindowSteeringHelper.ShowSystemMenu(this' this.PointToScreen(new Point(0' this.TitleBarHeight)));                      }                      else if (e.ClickCount == 2)                      {                          e.Handled = true;    #pragma warning disable 618                          ControlzEx.Windows.Shell.SystemCommands.CloseWindow(this);  #pragma warning restore 618                      }                        break;                    case MouseButton.Right:                      e.Handled = true;                        WindowSteeringHelper.ShowSystemMenu(this' e);                      break;              }
Magic Number,Fluent,ToolTipService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\ToolTipService.cs,Attach,The following statement contains a magic number: System.Windows.Controls.ToolTipService.InitialShowDelayProperty.OverrideMetadata(type' new FrameworkPropertyMetadata(900));
Magic Number,Fluent,ToolTipService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\ToolTipService.cs,Attach,The following statement contains a magic number: System.Windows.Controls.ToolTipService.ShowDurationProperty.OverrideMetadata(type' new FrameworkPropertyMetadata(20000));
Magic Number,Fluent,TwoLineLabel,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\TwoLineLabel.cs,UpdateTextRun,The following statement contains a magic number: var hyphenIndex = text.IndexOf((char)173);
Magic Number,Fluent,TwoLineLabel,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\TwoLineLabel.cs,UpdateTextRun,The following statement contains a magic number: if (hyphenIndex >= 0)              {                  this.textRun.Text = text.Substring(0' hyphenIndex) + "-";                  this.textRun2.Text = text.Substring(hyphenIndex) + " ";              }              else              {                  var centerIndex = this.Text.Length / 2;                  // Find spaces nearest to center from left and right                  var leftSpaceIndex = text.LastIndexOf(" "' centerIndex' centerIndex' StringComparison.CurrentCulture);                  var rightSpaceIndex = text.IndexOf(" "' centerIndex' StringComparison.CurrentCulture);                    if (leftSpaceIndex == -1                      && rightSpaceIndex == -1)                  {                      this.textRun.Text = this.Text;                      this.textRun2.Text = string.Empty;                  }                  else if (leftSpaceIndex == -1)                  {                      // Finds only space from right. New line adds on it                      this.textRun.Text = text.Substring(0' rightSpaceIndex);                      this.textRun2.Text = text.Substring(rightSpaceIndex) + " ";                  }                  else if (rightSpaceIndex == -1)                  {                      // Finds only space from left. New line adds on it                      this.textRun.Text = text.Substring(0' leftSpaceIndex);                      this.textRun2.Text = text.Substring(leftSpaceIndex) + " ";                  }                  else                  {                      // Find nearest to center space and add new line on it                      if (Math.Abs(centerIndex - leftSpaceIndex) < Math.Abs(centerIndex - rightSpaceIndex))                      {                          this.textRun.Text = text.Substring(0' leftSpaceIndex);                          this.textRun2.Text = text.Substring(leftSpaceIndex) + " ";                      }                      else                      {                          this.textRun.Text = text.Substring(0' rightSpaceIndex);                          this.textRun2.Text = text.Substring(rightSpaceIndex) + " ";                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: if (panel != null)              {                  var height = groupBox.GetLayoutRoot().DesiredSize.Height;                  rows = new[]                         {                             groupBox.GetLayoutRoot().TranslatePoint(new Point(0' 0)' this.AdornedElement).Y'                             groupBox.GetLayoutRoot().TranslatePoint(new Point(0' panel.DesiredSize.Height / 2.0)' this.AdornedElement).Y'                             groupBox.GetLayoutRoot().TranslatePoint(new Point(0' panel.DesiredSize.Height)' this.AdornedElement).Y'                             groupBox.GetLayoutRoot().TranslatePoint(new Point(0' height + 1)' this.AdornedElement).Y                         };              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following statement contains a magic number: foreach (var keyTipInformation in this.keyTipInformations)              {                  // Skip invisible keytips                  if (keyTipInformation.Visibility != Visibility.Visible)                  {                      continue;                  }                    // Update KeyTip Visibility                  var visualTargetIsVisible = keyTipInformation.VisualTarget.IsVisible;                  var visualTargetInVisualTree = VisualTreeHelper.GetParent(keyTipInformation.VisualTarget) != null;                  keyTipInformation.Visibility = visualTargetIsVisible && visualTargetInVisualTree ? Visibility.Visible : Visibility.Collapsed;                    keyTipInformation.KeyTip.Margin = KeyTip.GetMargin(keyTipInformation.AssociatedElement);                    if (IsWithinQuickAccessToolbar(keyTipInformation.AssociatedElement))                  {                      var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                      var y = keyTipInformation.VisualTarget.DesiredSize.Height - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                        if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                      {                          switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Name == "PART_DialogLauncherButton")                  {                      // Dialog Launcher Button Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                                           (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                                           0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[3]);                  }                  else if (KeyTip.GetAutoPlacement(keyTipInformation.AssociatedElement) == false)                  {                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                        var elementSize = keyTipInformation.VisualTarget.RenderSize;                        double x = 0' y = 0;                        switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }                        switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(x' y)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is InRibbonGallery && !((InRibbonGallery)keyTipInformation.AssociatedElement).IsCollapsed)                  {                      // InRibbonGallery Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      if (rows == null)                      {                          continue;                      }                        keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                elementSize.Width - (keyTipSize.Width / 2.0)'                                                                                0)' this.AdornedElement);                      keyTipInformation.Position = new Point(keyTipInformation.Position.X' rows[2] - (keyTipSize.Height / 2));                  }                  else if (keyTipInformation.AssociatedElement is RibbonTabItem || keyTipInformation.AssociatedElement is Backstage)                  {                      // Ribbon Tab Item Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.RenderSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(new Point(                                                                                (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0)'                                                                                elementSize.Height - (keyTipSize.Height / 2.0))' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement is MenuItem)                  {                      // MenuItem Exclusive Placement                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      keyTipInformation.Position = keyTipInformation.VisualTarget.TranslatePoint(                                                                      new Point(                                                                                (elementSize.Height / 3.0) + 2'                                                                                (elementSize.Height / 4.0) + 2)' this.AdornedElement);                  }                  else if (keyTipInformation.AssociatedElement.Parent is BackstageTabControl)                  {                      // Backstage Items Exclusive Placement                      var keyTipSize = keyTipInformation.KeyTip.DesiredSize;                      var elementSize = keyTipInformation.VisualTarget.DesiredSize;                      var parent = (UIElement)keyTipInformation.VisualTarget.Parent;                      var positionInParent = keyTipInformation.VisualTarget.TranslatePoint(default(Point)' parent);                      keyTipInformation.Position = parent.TranslatePoint(                                                         new Point(                                                                   5'                                                                   positionInParent.Y + ((elementSize.Height / 2.0) - keyTipSize.Height))' this.AdornedElement);                  }                  else                  {                      if (RibbonProperties.GetSize(keyTipInformation.AssociatedElement) != RibbonControlSize.Large                          || IsTextBoxShapedControl(keyTipInformation.AssociatedElement))                      {                          var withinRibbonToolbar = IsWithinRibbonToolbarInTwoLine(keyTipInformation.VisualTarget);                          var x = keyTipInformation.KeyTip.DesiredSize.Width / 2.0;                          var y = keyTipInformation.KeyTip.DesiredSize.Height / 2.0;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            // Snapping to rows if it present                          if (rows != null)                          {                              var index = 0;                              var mindistance = Math.Abs(rows[0] - translatedPoint.Y);                              for (var j = 1; j < rows.Length; j++)                              {                                  if (withinRibbonToolbar                                      && j == 1)                                  {                                      continue;                                  }                                    var distance = Math.Abs(rows[j] - translatedPoint.Y);                                  if (distance < mindistance)                                  {                                      mindistance = distance;                                      index = j;                                  }                              }                                translatedPoint.Y = rows[index] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                      else                      {                          var x = (keyTipInformation.VisualTarget.DesiredSize.Width / 2.0) - (keyTipInformation.KeyTip.DesiredSize.Width / 2.0);                          var y = keyTipInformation.VisualTarget.DesiredSize.Height - 8;                          var point = new Point(x' y);                          var translatedPoint = keyTipInformation.VisualTarget.TranslatePoint(point' this.AdornedElement);                            if (rows != null)                          {                              translatedPoint.Y = rows[2] - (keyTipInformation.KeyTip.DesiredSize.Height / 2.0);                          }                            keyTipInformation.Position = translatedPoint;                      }                  }              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,IsWithinRibbonToolbarInTwoLine,The following statement contains a magic number: if (definition.RowCount == 2                  || definition.Rows.Count == 2)              {                  return true;              }
Magic Number,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,IsWithinRibbonToolbarInTwoLine,The following statement contains a magic number: if (definition.RowCount == 2                  || definition.Rows.Count == 2)              {                  return true;              }
Magic Number,Fluent,KeyTipService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\KeyTipService.cs,KeyTipService,The following statement contains a magic number: this.timer = new DispatcherTimer(TimeSpan.FromSeconds(0.7)' DispatcherPriority.SystemIdle' this.OnDelayedShow' Dispatcher.CurrentDispatcher);
Magic Number,Fluent,KeyTipService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\KeyTipService.cs,WindowProc,The following statement contains a magic number: if (msg == (int)WM.NCACTIVATE // mouse clicks in non client area                  || (msg == (int)WM.ACTIVATE && wParam == IntPtr.Zero) // the window is deactivated                                                                             // >= WM_NCLBUTTONDOWN <= WM_NCXBUTTONDBLCLK                  || (msg >= 161 && msg <= 173) // mouse click (non client area)                  || (msg >= 513 && msg <= 521)) // mouse click              {                  if (this.activeAdornerChain != null                      && this.activeAdornerChain.IsAdornerChainAlive)                  {                      this.Terminate();                  }              }
Magic Number,Fluent,KeyTipService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\KeyTipService.cs,WindowProc,The following statement contains a magic number: if (msg == (int)WM.NCACTIVATE // mouse clicks in non client area                  || (msg == (int)WM.ACTIVATE && wParam == IntPtr.Zero) // the window is deactivated                                                                             // >= WM_NCLBUTTONDOWN <= WM_NCXBUTTONDBLCLK                  || (msg >= 161 && msg <= 173) // mouse click (non client area)                  || (msg >= 513 && msg <= 521)) // mouse click              {                  if (this.activeAdornerChain != null                      && this.activeAdornerChain.IsAdornerChainAlive)                  {                      this.Terminate();                  }              }
Magic Number,Fluent,KeyTipService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\KeyTipService.cs,WindowProc,The following statement contains a magic number: if (msg == (int)WM.NCACTIVATE // mouse clicks in non client area                  || (msg == (int)WM.ACTIVATE && wParam == IntPtr.Zero) // the window is deactivated                                                                             // >= WM_NCLBUTTONDOWN <= WM_NCXBUTTONDBLCLK                  || (msg >= 161 && msg <= 173) // mouse click (non client area)                  || (msg >= 513 && msg <= 521)) // mouse click              {                  if (this.activeAdornerChain != null                      && this.activeAdornerChain.IsAdornerChainAlive)                  {                      this.Terminate();                  }              }
Magic Number,Fluent,KeyTipService,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Services\KeyTipService.cs,WindowProc,The following statement contains a magic number: if (msg == (int)WM.NCACTIVATE // mouse clicks in non client area                  || (msg == (int)WM.ACTIVATE && wParam == IntPtr.Zero) // the window is deactivated                                                                             // >= WM_NCLBUTTONDOWN <= WM_NCXBUTTONDBLCLK                  || (msg >= 161 && msg <= 173) // mouse click (non client area)                  || (msg >= 513 && msg <= 521)) // mouse click              {                  if (this.activeAdornerChain != null                      && this.activeAdornerChain.IsAdornerChainAlive)                  {                      this.Terminate();                  }              }
Magic Number,Fluent,QuickAccessToolBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\QuickAccessToolBar.cs,DefaultUpdateKeyTips,The following statement contains a magic number: for (var i = 0; i < Math.Min(9' quickAccessToolBar.Items.Count); i++)              {                  // 1' 2' 3' ... ' 9                  KeyTip.SetKeys(quickAccessToolBar.Items[i]' (i + 1).ToString(CultureInfo.InvariantCulture));              }
Magic Number,Fluent,QuickAccessToolBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\QuickAccessToolBar.cs,DefaultUpdateKeyTips,The following statement contains a magic number: for (var i = 9; i < Math.Min(18' quickAccessToolBar.Items.Count); i++)              {                  // 09' 08' 07' ... ' 01                  KeyTip.SetKeys(quickAccessToolBar.Items[i]' "0" + (18 - i).ToString(CultureInfo.InvariantCulture));              }
Magic Number,Fluent,QuickAccessToolBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\QuickAccessToolBar.cs,DefaultUpdateKeyTips,The following statement contains a magic number: for (var i = 9; i < Math.Min(18' quickAccessToolBar.Items.Count); i++)              {                  // 09' 08' 07' ... ' 01                  KeyTip.SetKeys(quickAccessToolBar.Items[i]' "0" + (18 - i).ToString(CultureInfo.InvariantCulture));              }
Magic Number,Fluent,QuickAccessToolBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\QuickAccessToolBar.cs,DefaultUpdateKeyTips,The following statement contains a magic number: for (var i = 9; i < Math.Min(18' quickAccessToolBar.Items.Count); i++)              {                  // 09' 08' 07' ... ' 01                  KeyTip.SetKeys(quickAccessToolBar.Items[i]' "0" + (18 - i).ToString(CultureInfo.InvariantCulture));              }
Magic Number,Fluent,QuickAccessToolBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\QuickAccessToolBar.cs,DefaultUpdateKeyTips,The following statement contains a magic number: for (var i = 18; i < Math.Min(9 + 9 + 26' quickAccessToolBar.Items.Count); i++)              {                  // 0A' 0B' 0C' ... ' 0Z                  KeyTip.SetKeys(quickAccessToolBar.Items[i]' "0" + startChar++);              }
Magic Number,Fluent,QuickAccessToolBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\QuickAccessToolBar.cs,DefaultUpdateKeyTips,The following statement contains a magic number: for (var i = 18; i < Math.Min(9 + 9 + 26' quickAccessToolBar.Items.Count); i++)              {                  // 0A' 0B' 0C' ... ' 0Z                  KeyTip.SetKeys(quickAccessToolBar.Items[i]' "0" + startChar++);              }
Magic Number,Fluent,QuickAccessToolBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\QuickAccessToolBar.cs,DefaultUpdateKeyTips,The following statement contains a magic number: for (var i = 18; i < Math.Min(9 + 9 + 26' quickAccessToolBar.Items.Count); i++)              {                  // 0A' 0B' 0C' ... ' 0Z                  KeyTip.SetKeys(quickAccessToolBar.Items[i]' "0" + startChar++);              }
Magic Number,Fluent,QuickAccessToolBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\QuickAccessToolBar.cs,DefaultUpdateKeyTips,The following statement contains a magic number: for (var i = 18; i < Math.Min(9 + 9 + 26' quickAccessToolBar.Items.Count); i++)              {                  // 0A' 0B' 0C' ... ' 0Z                  KeyTip.SetKeys(quickAccessToolBar.Items[i]' "0" + startChar++);              }
Magic Number,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The following statement contains a magic number: if (this.IsCollapsed)              {                  // Collapse QuickAccessToolbar                  this.quickAccessToolbarRect = new Rect(0' 0' 0' 0);                    // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    this.headerHolder.Measure(new Size(constraint.Width' constraint.Height));                  this.headerRect = new Rect(0' 0' this.headerHolder.DesiredSize.Width' constraint.Height);              }              else if (visibleGroups.Count == 0                  || canRibbonTabControlScroll)              {                  // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    // Set quick launch toolbar and header position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    if (constraint.Width <= this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' Math.Max(0' constraint.Width - 50)' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                  }                    if (constraint.Width > this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.headerHolder.Measure(infinity);                      var allTextWidth = constraint.Width - this.quickAccessToolbarHolder.DesiredSize.Width;                        if (this.HeaderAlignment == HorizontalAlignment.Left)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Center)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidth / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Right)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Stretch)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' allTextWidth' constraint.Height);                      }                  }                  else                  {                      this.headerRect = new Rect(Math.Max(0' constraint.Width - 50)' 0' 50' constraint.Height);                  }              }              else              {                  var pointZero = default(Point);                    // get initial StartX value                  var startX = visibleGroups.First().FirstVisibleItem.TranslatePoint(pointZero' this).X;                  var endX = 0D;                    //Get minimum x point (workaround)                  foreach (var group in visibleGroups)                  {                      var currentStartX = group.FirstVisibleItem.TranslatePoint(pointZero' this).X;                        if (currentStartX < startX)                      {                          startX = currentStartX;                      }                        var lastItem = group.LastVisibleItem;                      var currentEndX = lastItem.TranslatePoint(new Point(lastItem.DesiredSize.Width' 0)' this).X;                        if (currentEndX > endX)                      {                          endX = currentEndX;                      }                  }                    // Ensure that startX and endX are never negative                  startX = Math.Max(0' startX);                  endX = Math.Max(0' endX);                    // Ensure that startX respect min width of QuickAccessToolBar                  startX = Math.Max(startX' this.QuickAccessToolBar?.MinWidth ?? 0);                    // Set contextual groups position and size                  this.itemsContainer.Measure(infinity);                  var itemsRectWidth = Math.Min(this.itemsContainer.DesiredSize.Width' Math.Max(0' Math.Min(endX' constraint.Width) - startX));                  this.itemsRect = new Rect(startX' 0' itemsRectWidth' constraint.Height);                    // Set quick launch toolbar position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    var quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  this.quickAccessToolbarRect = new Rect(0' 0' Math.Min(quickAccessToolbarWidth' startX)' this.quickAccessToolbarHolder.DesiredSize.Height);                    if (quickAccessToolbarWidth > startX)                  {                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  }                    // Set header                  this.headerHolder.Measure(infinity);                    switch (this.HeaderAlignment)                  {                      case HorizontalAlignment.Left:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Center:                          {                              var allTextWidthRight = Math.Max(0' constraint.Width - endX);                              var allTextWidthLeft = Math.Max(0' startX - quickAccessToolbarWidth);                              var fitsRightButNotLeft = allTextWidthRight >= this.headerHolder.DesiredSize.Width && allTextWidthLeft < this.headerHolder.DesiredSize.Width;                                if (((startX - quickAccessToolbarWidth < 150 || fitsRightButNotLeft) && (startX - quickAccessToolbarWidth > 0) && (startX - quickAccessToolbarWidth < constraint.Width - endX)) || (endX < constraint.Width / 2))                              {                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' (constraint.Width / 2) - (this.headerHolder.DesiredSize.Width / 2))' constraint.Width)' 0' Math.Min(allTextWidthRight' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidthLeft / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidthLeft' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Right:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = Math.Max(0' startX - quickAccessToolbarWidth);                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' constraint.Width - this.headerHolder.DesiredSize.Width)' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Stretch:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' allTextWidth' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' allTextWidth' constraint.Height);                              }                          }                            break;                  }              }
Magic Number,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The following statement contains a magic number: if (this.IsCollapsed)              {                  // Collapse QuickAccessToolbar                  this.quickAccessToolbarRect = new Rect(0' 0' 0' 0);                    // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    this.headerHolder.Measure(new Size(constraint.Width' constraint.Height));                  this.headerRect = new Rect(0' 0' this.headerHolder.DesiredSize.Width' constraint.Height);              }              else if (visibleGroups.Count == 0                  || canRibbonTabControlScroll)              {                  // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    // Set quick launch toolbar and header position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    if (constraint.Width <= this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' Math.Max(0' constraint.Width - 50)' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                  }                    if (constraint.Width > this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.headerHolder.Measure(infinity);                      var allTextWidth = constraint.Width - this.quickAccessToolbarHolder.DesiredSize.Width;                        if (this.HeaderAlignment == HorizontalAlignment.Left)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Center)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidth / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Right)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Stretch)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' allTextWidth' constraint.Height);                      }                  }                  else                  {                      this.headerRect = new Rect(Math.Max(0' constraint.Width - 50)' 0' 50' constraint.Height);                  }              }              else              {                  var pointZero = default(Point);                    // get initial StartX value                  var startX = visibleGroups.First().FirstVisibleItem.TranslatePoint(pointZero' this).X;                  var endX = 0D;                    //Get minimum x point (workaround)                  foreach (var group in visibleGroups)                  {                      var currentStartX = group.FirstVisibleItem.TranslatePoint(pointZero' this).X;                        if (currentStartX < startX)                      {                          startX = currentStartX;                      }                        var lastItem = group.LastVisibleItem;                      var currentEndX = lastItem.TranslatePoint(new Point(lastItem.DesiredSize.Width' 0)' this).X;                        if (currentEndX > endX)                      {                          endX = currentEndX;                      }                  }                    // Ensure that startX and endX are never negative                  startX = Math.Max(0' startX);                  endX = Math.Max(0' endX);                    // Ensure that startX respect min width of QuickAccessToolBar                  startX = Math.Max(startX' this.QuickAccessToolBar?.MinWidth ?? 0);                    // Set contextual groups position and size                  this.itemsContainer.Measure(infinity);                  var itemsRectWidth = Math.Min(this.itemsContainer.DesiredSize.Width' Math.Max(0' Math.Min(endX' constraint.Width) - startX));                  this.itemsRect = new Rect(startX' 0' itemsRectWidth' constraint.Height);                    // Set quick launch toolbar position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    var quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  this.quickAccessToolbarRect = new Rect(0' 0' Math.Min(quickAccessToolbarWidth' startX)' this.quickAccessToolbarHolder.DesiredSize.Height);                    if (quickAccessToolbarWidth > startX)                  {                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  }                    // Set header                  this.headerHolder.Measure(infinity);                    switch (this.HeaderAlignment)                  {                      case HorizontalAlignment.Left:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Center:                          {                              var allTextWidthRight = Math.Max(0' constraint.Width - endX);                              var allTextWidthLeft = Math.Max(0' startX - quickAccessToolbarWidth);                              var fitsRightButNotLeft = allTextWidthRight >= this.headerHolder.DesiredSize.Width && allTextWidthLeft < this.headerHolder.DesiredSize.Width;                                if (((startX - quickAccessToolbarWidth < 150 || fitsRightButNotLeft) && (startX - quickAccessToolbarWidth > 0) && (startX - quickAccessToolbarWidth < constraint.Width - endX)) || (endX < constraint.Width / 2))                              {                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' (constraint.Width / 2) - (this.headerHolder.DesiredSize.Width / 2))' constraint.Width)' 0' Math.Min(allTextWidthRight' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidthLeft / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidthLeft' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Right:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = Math.Max(0' startX - quickAccessToolbarWidth);                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' constraint.Width - this.headerHolder.DesiredSize.Width)' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Stretch:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' allTextWidth' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' allTextWidth' constraint.Height);                              }                          }                            break;                  }              }
Magic Number,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The following statement contains a magic number: if (this.IsCollapsed)              {                  // Collapse QuickAccessToolbar                  this.quickAccessToolbarRect = new Rect(0' 0' 0' 0);                    // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    this.headerHolder.Measure(new Size(constraint.Width' constraint.Height));                  this.headerRect = new Rect(0' 0' this.headerHolder.DesiredSize.Width' constraint.Height);              }              else if (visibleGroups.Count == 0                  || canRibbonTabControlScroll)              {                  // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    // Set quick launch toolbar and header position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    if (constraint.Width <= this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' Math.Max(0' constraint.Width - 50)' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                  }                    if (constraint.Width > this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.headerHolder.Measure(infinity);                      var allTextWidth = constraint.Width - this.quickAccessToolbarHolder.DesiredSize.Width;                        if (this.HeaderAlignment == HorizontalAlignment.Left)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Center)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidth / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Right)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Stretch)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' allTextWidth' constraint.Height);                      }                  }                  else                  {                      this.headerRect = new Rect(Math.Max(0' constraint.Width - 50)' 0' 50' constraint.Height);                  }              }              else              {                  var pointZero = default(Point);                    // get initial StartX value                  var startX = visibleGroups.First().FirstVisibleItem.TranslatePoint(pointZero' this).X;                  var endX = 0D;                    //Get minimum x point (workaround)                  foreach (var group in visibleGroups)                  {                      var currentStartX = group.FirstVisibleItem.TranslatePoint(pointZero' this).X;                        if (currentStartX < startX)                      {                          startX = currentStartX;                      }                        var lastItem = group.LastVisibleItem;                      var currentEndX = lastItem.TranslatePoint(new Point(lastItem.DesiredSize.Width' 0)' this).X;                        if (currentEndX > endX)                      {                          endX = currentEndX;                      }                  }                    // Ensure that startX and endX are never negative                  startX = Math.Max(0' startX);                  endX = Math.Max(0' endX);                    // Ensure that startX respect min width of QuickAccessToolBar                  startX = Math.Max(startX' this.QuickAccessToolBar?.MinWidth ?? 0);                    // Set contextual groups position and size                  this.itemsContainer.Measure(infinity);                  var itemsRectWidth = Math.Min(this.itemsContainer.DesiredSize.Width' Math.Max(0' Math.Min(endX' constraint.Width) - startX));                  this.itemsRect = new Rect(startX' 0' itemsRectWidth' constraint.Height);                    // Set quick launch toolbar position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    var quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  this.quickAccessToolbarRect = new Rect(0' 0' Math.Min(quickAccessToolbarWidth' startX)' this.quickAccessToolbarHolder.DesiredSize.Height);                    if (quickAccessToolbarWidth > startX)                  {                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  }                    // Set header                  this.headerHolder.Measure(infinity);                    switch (this.HeaderAlignment)                  {                      case HorizontalAlignment.Left:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Center:                          {                              var allTextWidthRight = Math.Max(0' constraint.Width - endX);                              var allTextWidthLeft = Math.Max(0' startX - quickAccessToolbarWidth);                              var fitsRightButNotLeft = allTextWidthRight >= this.headerHolder.DesiredSize.Width && allTextWidthLeft < this.headerHolder.DesiredSize.Width;                                if (((startX - quickAccessToolbarWidth < 150 || fitsRightButNotLeft) && (startX - quickAccessToolbarWidth > 0) && (startX - quickAccessToolbarWidth < constraint.Width - endX)) || (endX < constraint.Width / 2))                              {                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' (constraint.Width / 2) - (this.headerHolder.DesiredSize.Width / 2))' constraint.Width)' 0' Math.Min(allTextWidthRight' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidthLeft / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidthLeft' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Right:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = Math.Max(0' startX - quickAccessToolbarWidth);                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' constraint.Width - this.headerHolder.DesiredSize.Width)' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Stretch:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' allTextWidth' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' allTextWidth' constraint.Height);                              }                          }                            break;                  }              }
Magic Number,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The following statement contains a magic number: if (this.IsCollapsed)              {                  // Collapse QuickAccessToolbar                  this.quickAccessToolbarRect = new Rect(0' 0' 0' 0);                    // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    this.headerHolder.Measure(new Size(constraint.Width' constraint.Height));                  this.headerRect = new Rect(0' 0' this.headerHolder.DesiredSize.Width' constraint.Height);              }              else if (visibleGroups.Count == 0                  || canRibbonTabControlScroll)              {                  // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    // Set quick launch toolbar and header position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    if (constraint.Width <= this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' Math.Max(0' constraint.Width - 50)' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                  }                    if (constraint.Width > this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.headerHolder.Measure(infinity);                      var allTextWidth = constraint.Width - this.quickAccessToolbarHolder.DesiredSize.Width;                        if (this.HeaderAlignment == HorizontalAlignment.Left)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Center)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidth / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Right)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Stretch)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' allTextWidth' constraint.Height);                      }                  }                  else                  {                      this.headerRect = new Rect(Math.Max(0' constraint.Width - 50)' 0' 50' constraint.Height);                  }              }              else              {                  var pointZero = default(Point);                    // get initial StartX value                  var startX = visibleGroups.First().FirstVisibleItem.TranslatePoint(pointZero' this).X;                  var endX = 0D;                    //Get minimum x point (workaround)                  foreach (var group in visibleGroups)                  {                      var currentStartX = group.FirstVisibleItem.TranslatePoint(pointZero' this).X;                        if (currentStartX < startX)                      {                          startX = currentStartX;                      }                        var lastItem = group.LastVisibleItem;                      var currentEndX = lastItem.TranslatePoint(new Point(lastItem.DesiredSize.Width' 0)' this).X;                        if (currentEndX > endX)                      {                          endX = currentEndX;                      }                  }                    // Ensure that startX and endX are never negative                  startX = Math.Max(0' startX);                  endX = Math.Max(0' endX);                    // Ensure that startX respect min width of QuickAccessToolBar                  startX = Math.Max(startX' this.QuickAccessToolBar?.MinWidth ?? 0);                    // Set contextual groups position and size                  this.itemsContainer.Measure(infinity);                  var itemsRectWidth = Math.Min(this.itemsContainer.DesiredSize.Width' Math.Max(0' Math.Min(endX' constraint.Width) - startX));                  this.itemsRect = new Rect(startX' 0' itemsRectWidth' constraint.Height);                    // Set quick launch toolbar position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    var quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  this.quickAccessToolbarRect = new Rect(0' 0' Math.Min(quickAccessToolbarWidth' startX)' this.quickAccessToolbarHolder.DesiredSize.Height);                    if (quickAccessToolbarWidth > startX)                  {                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  }                    // Set header                  this.headerHolder.Measure(infinity);                    switch (this.HeaderAlignment)                  {                      case HorizontalAlignment.Left:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Center:                          {                              var allTextWidthRight = Math.Max(0' constraint.Width - endX);                              var allTextWidthLeft = Math.Max(0' startX - quickAccessToolbarWidth);                              var fitsRightButNotLeft = allTextWidthRight >= this.headerHolder.DesiredSize.Width && allTextWidthLeft < this.headerHolder.DesiredSize.Width;                                if (((startX - quickAccessToolbarWidth < 150 || fitsRightButNotLeft) && (startX - quickAccessToolbarWidth > 0) && (startX - quickAccessToolbarWidth < constraint.Width - endX)) || (endX < constraint.Width / 2))                              {                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' (constraint.Width / 2) - (this.headerHolder.DesiredSize.Width / 2))' constraint.Width)' 0' Math.Min(allTextWidthRight' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidthLeft / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidthLeft' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Right:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = Math.Max(0' startX - quickAccessToolbarWidth);                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' constraint.Width - this.headerHolder.DesiredSize.Width)' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Stretch:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' allTextWidth' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' allTextWidth' constraint.Height);                              }                          }                            break;                  }              }
Magic Number,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The following statement contains a magic number: if (this.IsCollapsed)              {                  // Collapse QuickAccessToolbar                  this.quickAccessToolbarRect = new Rect(0' 0' 0' 0);                    // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    this.headerHolder.Measure(new Size(constraint.Width' constraint.Height));                  this.headerRect = new Rect(0' 0' this.headerHolder.DesiredSize.Width' constraint.Height);              }              else if (visibleGroups.Count == 0                  || canRibbonTabControlScroll)              {                  // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    // Set quick launch toolbar and header position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    if (constraint.Width <= this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' Math.Max(0' constraint.Width - 50)' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                  }                    if (constraint.Width > this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.headerHolder.Measure(infinity);                      var allTextWidth = constraint.Width - this.quickAccessToolbarHolder.DesiredSize.Width;                        if (this.HeaderAlignment == HorizontalAlignment.Left)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Center)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidth / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Right)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Stretch)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' allTextWidth' constraint.Height);                      }                  }                  else                  {                      this.headerRect = new Rect(Math.Max(0' constraint.Width - 50)' 0' 50' constraint.Height);                  }              }              else              {                  var pointZero = default(Point);                    // get initial StartX value                  var startX = visibleGroups.First().FirstVisibleItem.TranslatePoint(pointZero' this).X;                  var endX = 0D;                    //Get minimum x point (workaround)                  foreach (var group in visibleGroups)                  {                      var currentStartX = group.FirstVisibleItem.TranslatePoint(pointZero' this).X;                        if (currentStartX < startX)                      {                          startX = currentStartX;                      }                        var lastItem = group.LastVisibleItem;                      var currentEndX = lastItem.TranslatePoint(new Point(lastItem.DesiredSize.Width' 0)' this).X;                        if (currentEndX > endX)                      {                          endX = currentEndX;                      }                  }                    // Ensure that startX and endX are never negative                  startX = Math.Max(0' startX);                  endX = Math.Max(0' endX);                    // Ensure that startX respect min width of QuickAccessToolBar                  startX = Math.Max(startX' this.QuickAccessToolBar?.MinWidth ?? 0);                    // Set contextual groups position and size                  this.itemsContainer.Measure(infinity);                  var itemsRectWidth = Math.Min(this.itemsContainer.DesiredSize.Width' Math.Max(0' Math.Min(endX' constraint.Width) - startX));                  this.itemsRect = new Rect(startX' 0' itemsRectWidth' constraint.Height);                    // Set quick launch toolbar position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    var quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  this.quickAccessToolbarRect = new Rect(0' 0' Math.Min(quickAccessToolbarWidth' startX)' this.quickAccessToolbarHolder.DesiredSize.Height);                    if (quickAccessToolbarWidth > startX)                  {                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  }                    // Set header                  this.headerHolder.Measure(infinity);                    switch (this.HeaderAlignment)                  {                      case HorizontalAlignment.Left:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Center:                          {                              var allTextWidthRight = Math.Max(0' constraint.Width - endX);                              var allTextWidthLeft = Math.Max(0' startX - quickAccessToolbarWidth);                              var fitsRightButNotLeft = allTextWidthRight >= this.headerHolder.DesiredSize.Width && allTextWidthLeft < this.headerHolder.DesiredSize.Width;                                if (((startX - quickAccessToolbarWidth < 150 || fitsRightButNotLeft) && (startX - quickAccessToolbarWidth > 0) && (startX - quickAccessToolbarWidth < constraint.Width - endX)) || (endX < constraint.Width / 2))                              {                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' (constraint.Width / 2) - (this.headerHolder.DesiredSize.Width / 2))' constraint.Width)' 0' Math.Min(allTextWidthRight' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidthLeft / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidthLeft' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Right:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = Math.Max(0' startX - quickAccessToolbarWidth);                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' constraint.Width - this.headerHolder.DesiredSize.Width)' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Stretch:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' allTextWidth' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' allTextWidth' constraint.Height);                              }                          }                            break;                  }              }
Magic Number,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The following statement contains a magic number: if (this.IsCollapsed)              {                  // Collapse QuickAccessToolbar                  this.quickAccessToolbarRect = new Rect(0' 0' 0' 0);                    // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    this.headerHolder.Measure(new Size(constraint.Width' constraint.Height));                  this.headerRect = new Rect(0' 0' this.headerHolder.DesiredSize.Width' constraint.Height);              }              else if (visibleGroups.Count == 0                  || canRibbonTabControlScroll)              {                  // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    // Set quick launch toolbar and header position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    if (constraint.Width <= this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' Math.Max(0' constraint.Width - 50)' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                  }                    if (constraint.Width > this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.headerHolder.Measure(infinity);                      var allTextWidth = constraint.Width - this.quickAccessToolbarHolder.DesiredSize.Width;                        if (this.HeaderAlignment == HorizontalAlignment.Left)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Center)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidth / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Right)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Stretch)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' allTextWidth' constraint.Height);                      }                  }                  else                  {                      this.headerRect = new Rect(Math.Max(0' constraint.Width - 50)' 0' 50' constraint.Height);                  }              }              else              {                  var pointZero = default(Point);                    // get initial StartX value                  var startX = visibleGroups.First().FirstVisibleItem.TranslatePoint(pointZero' this).X;                  var endX = 0D;                    //Get minimum x point (workaround)                  foreach (var group in visibleGroups)                  {                      var currentStartX = group.FirstVisibleItem.TranslatePoint(pointZero' this).X;                        if (currentStartX < startX)                      {                          startX = currentStartX;                      }                        var lastItem = group.LastVisibleItem;                      var currentEndX = lastItem.TranslatePoint(new Point(lastItem.DesiredSize.Width' 0)' this).X;                        if (currentEndX > endX)                      {                          endX = currentEndX;                      }                  }                    // Ensure that startX and endX are never negative                  startX = Math.Max(0' startX);                  endX = Math.Max(0' endX);                    // Ensure that startX respect min width of QuickAccessToolBar                  startX = Math.Max(startX' this.QuickAccessToolBar?.MinWidth ?? 0);                    // Set contextual groups position and size                  this.itemsContainer.Measure(infinity);                  var itemsRectWidth = Math.Min(this.itemsContainer.DesiredSize.Width' Math.Max(0' Math.Min(endX' constraint.Width) - startX));                  this.itemsRect = new Rect(startX' 0' itemsRectWidth' constraint.Height);                    // Set quick launch toolbar position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    var quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  this.quickAccessToolbarRect = new Rect(0' 0' Math.Min(quickAccessToolbarWidth' startX)' this.quickAccessToolbarHolder.DesiredSize.Height);                    if (quickAccessToolbarWidth > startX)                  {                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  }                    // Set header                  this.headerHolder.Measure(infinity);                    switch (this.HeaderAlignment)                  {                      case HorizontalAlignment.Left:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Center:                          {                              var allTextWidthRight = Math.Max(0' constraint.Width - endX);                              var allTextWidthLeft = Math.Max(0' startX - quickAccessToolbarWidth);                              var fitsRightButNotLeft = allTextWidthRight >= this.headerHolder.DesiredSize.Width && allTextWidthLeft < this.headerHolder.DesiredSize.Width;                                if (((startX - quickAccessToolbarWidth < 150 || fitsRightButNotLeft) && (startX - quickAccessToolbarWidth > 0) && (startX - quickAccessToolbarWidth < constraint.Width - endX)) || (endX < constraint.Width / 2))                              {                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' (constraint.Width / 2) - (this.headerHolder.DesiredSize.Width / 2))' constraint.Width)' 0' Math.Min(allTextWidthRight' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidthLeft / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidthLeft' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Right:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = Math.Max(0' startX - quickAccessToolbarWidth);                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' constraint.Width - this.headerHolder.DesiredSize.Width)' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Stretch:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' allTextWidth' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' allTextWidth' constraint.Height);                              }                          }                            break;                  }              }
Magic Number,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The following statement contains a magic number: if (this.IsCollapsed)              {                  // Collapse QuickAccessToolbar                  this.quickAccessToolbarRect = new Rect(0' 0' 0' 0);                    // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    this.headerHolder.Measure(new Size(constraint.Width' constraint.Height));                  this.headerRect = new Rect(0' 0' this.headerHolder.DesiredSize.Width' constraint.Height);              }              else if (visibleGroups.Count == 0                  || canRibbonTabControlScroll)              {                  // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    // Set quick launch toolbar and header position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    if (constraint.Width <= this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' Math.Max(0' constraint.Width - 50)' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                  }                    if (constraint.Width > this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.headerHolder.Measure(infinity);                      var allTextWidth = constraint.Width - this.quickAccessToolbarHolder.DesiredSize.Width;                        if (this.HeaderAlignment == HorizontalAlignment.Left)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Center)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidth / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Right)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Stretch)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' allTextWidth' constraint.Height);                      }                  }                  else                  {                      this.headerRect = new Rect(Math.Max(0' constraint.Width - 50)' 0' 50' constraint.Height);                  }              }              else              {                  var pointZero = default(Point);                    // get initial StartX value                  var startX = visibleGroups.First().FirstVisibleItem.TranslatePoint(pointZero' this).X;                  var endX = 0D;                    //Get minimum x point (workaround)                  foreach (var group in visibleGroups)                  {                      var currentStartX = group.FirstVisibleItem.TranslatePoint(pointZero' this).X;                        if (currentStartX < startX)                      {                          startX = currentStartX;                      }                        var lastItem = group.LastVisibleItem;                      var currentEndX = lastItem.TranslatePoint(new Point(lastItem.DesiredSize.Width' 0)' this).X;                        if (currentEndX > endX)                      {                          endX = currentEndX;                      }                  }                    // Ensure that startX and endX are never negative                  startX = Math.Max(0' startX);                  endX = Math.Max(0' endX);                    // Ensure that startX respect min width of QuickAccessToolBar                  startX = Math.Max(startX' this.QuickAccessToolBar?.MinWidth ?? 0);                    // Set contextual groups position and size                  this.itemsContainer.Measure(infinity);                  var itemsRectWidth = Math.Min(this.itemsContainer.DesiredSize.Width' Math.Max(0' Math.Min(endX' constraint.Width) - startX));                  this.itemsRect = new Rect(startX' 0' itemsRectWidth' constraint.Height);                    // Set quick launch toolbar position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    var quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  this.quickAccessToolbarRect = new Rect(0' 0' Math.Min(quickAccessToolbarWidth' startX)' this.quickAccessToolbarHolder.DesiredSize.Height);                    if (quickAccessToolbarWidth > startX)                  {                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  }                    // Set header                  this.headerHolder.Measure(infinity);                    switch (this.HeaderAlignment)                  {                      case HorizontalAlignment.Left:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Center:                          {                              var allTextWidthRight = Math.Max(0' constraint.Width - endX);                              var allTextWidthLeft = Math.Max(0' startX - quickAccessToolbarWidth);                              var fitsRightButNotLeft = allTextWidthRight >= this.headerHolder.DesiredSize.Width && allTextWidthLeft < this.headerHolder.DesiredSize.Width;                                if (((startX - quickAccessToolbarWidth < 150 || fitsRightButNotLeft) && (startX - quickAccessToolbarWidth > 0) && (startX - quickAccessToolbarWidth < constraint.Width - endX)) || (endX < constraint.Width / 2))                              {                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' (constraint.Width / 2) - (this.headerHolder.DesiredSize.Width / 2))' constraint.Width)' 0' Math.Min(allTextWidthRight' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidthLeft / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidthLeft' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Right:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = Math.Max(0' startX - quickAccessToolbarWidth);                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' constraint.Width - this.headerHolder.DesiredSize.Width)' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Stretch:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' allTextWidth' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' allTextWidth' constraint.Height);                              }                          }                            break;                  }              }
Magic Number,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The following statement contains a magic number: if (this.IsCollapsed)              {                  // Collapse QuickAccessToolbar                  this.quickAccessToolbarRect = new Rect(0' 0' 0' 0);                    // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    this.headerHolder.Measure(new Size(constraint.Width' constraint.Height));                  this.headerRect = new Rect(0' 0' this.headerHolder.DesiredSize.Width' constraint.Height);              }              else if (visibleGroups.Count == 0                  || canRibbonTabControlScroll)              {                  // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    // Set quick launch toolbar and header position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    if (constraint.Width <= this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' Math.Max(0' constraint.Width - 50)' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                  }                    if (constraint.Width > this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.headerHolder.Measure(infinity);                      var allTextWidth = constraint.Width - this.quickAccessToolbarHolder.DesiredSize.Width;                        if (this.HeaderAlignment == HorizontalAlignment.Left)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Center)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidth / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Right)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Stretch)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' allTextWidth' constraint.Height);                      }                  }                  else                  {                      this.headerRect = new Rect(Math.Max(0' constraint.Width - 50)' 0' 50' constraint.Height);                  }              }              else              {                  var pointZero = default(Point);                    // get initial StartX value                  var startX = visibleGroups.First().FirstVisibleItem.TranslatePoint(pointZero' this).X;                  var endX = 0D;                    //Get minimum x point (workaround)                  foreach (var group in visibleGroups)                  {                      var currentStartX = group.FirstVisibleItem.TranslatePoint(pointZero' this).X;                        if (currentStartX < startX)                      {                          startX = currentStartX;                      }                        var lastItem = group.LastVisibleItem;                      var currentEndX = lastItem.TranslatePoint(new Point(lastItem.DesiredSize.Width' 0)' this).X;                        if (currentEndX > endX)                      {                          endX = currentEndX;                      }                  }                    // Ensure that startX and endX are never negative                  startX = Math.Max(0' startX);                  endX = Math.Max(0' endX);                    // Ensure that startX respect min width of QuickAccessToolBar                  startX = Math.Max(startX' this.QuickAccessToolBar?.MinWidth ?? 0);                    // Set contextual groups position and size                  this.itemsContainer.Measure(infinity);                  var itemsRectWidth = Math.Min(this.itemsContainer.DesiredSize.Width' Math.Max(0' Math.Min(endX' constraint.Width) - startX));                  this.itemsRect = new Rect(startX' 0' itemsRectWidth' constraint.Height);                    // Set quick launch toolbar position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    var quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  this.quickAccessToolbarRect = new Rect(0' 0' Math.Min(quickAccessToolbarWidth' startX)' this.quickAccessToolbarHolder.DesiredSize.Height);                    if (quickAccessToolbarWidth > startX)                  {                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  }                    // Set header                  this.headerHolder.Measure(infinity);                    switch (this.HeaderAlignment)                  {                      case HorizontalAlignment.Left:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Center:                          {                              var allTextWidthRight = Math.Max(0' constraint.Width - endX);                              var allTextWidthLeft = Math.Max(0' startX - quickAccessToolbarWidth);                              var fitsRightButNotLeft = allTextWidthRight >= this.headerHolder.DesiredSize.Width && allTextWidthLeft < this.headerHolder.DesiredSize.Width;                                if (((startX - quickAccessToolbarWidth < 150 || fitsRightButNotLeft) && (startX - quickAccessToolbarWidth > 0) && (startX - quickAccessToolbarWidth < constraint.Width - endX)) || (endX < constraint.Width / 2))                              {                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' (constraint.Width / 2) - (this.headerHolder.DesiredSize.Width / 2))' constraint.Width)' 0' Math.Min(allTextWidthRight' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidthLeft / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidthLeft' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Right:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = Math.Max(0' startX - quickAccessToolbarWidth);                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' constraint.Width - this.headerHolder.DesiredSize.Width)' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Stretch:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' allTextWidth' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' allTextWidth' constraint.Height);                              }                          }                            break;                  }              }
Magic Number,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The following statement contains a magic number: if (this.IsCollapsed)              {                  // Collapse QuickAccessToolbar                  this.quickAccessToolbarRect = new Rect(0' 0' 0' 0);                    // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    this.headerHolder.Measure(new Size(constraint.Width' constraint.Height));                  this.headerRect = new Rect(0' 0' this.headerHolder.DesiredSize.Width' constraint.Height);              }              else if (visibleGroups.Count == 0                  || canRibbonTabControlScroll)              {                  // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    // Set quick launch toolbar and header position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    if (constraint.Width <= this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' Math.Max(0' constraint.Width - 50)' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                  }                    if (constraint.Width > this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.headerHolder.Measure(infinity);                      var allTextWidth = constraint.Width - this.quickAccessToolbarHolder.DesiredSize.Width;                        if (this.HeaderAlignment == HorizontalAlignment.Left)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Center)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidth / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Right)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Stretch)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' allTextWidth' constraint.Height);                      }                  }                  else                  {                      this.headerRect = new Rect(Math.Max(0' constraint.Width - 50)' 0' 50' constraint.Height);                  }              }              else              {                  var pointZero = default(Point);                    // get initial StartX value                  var startX = visibleGroups.First().FirstVisibleItem.TranslatePoint(pointZero' this).X;                  var endX = 0D;                    //Get minimum x point (workaround)                  foreach (var group in visibleGroups)                  {                      var currentStartX = group.FirstVisibleItem.TranslatePoint(pointZero' this).X;                        if (currentStartX < startX)                      {                          startX = currentStartX;                      }                        var lastItem = group.LastVisibleItem;                      var currentEndX = lastItem.TranslatePoint(new Point(lastItem.DesiredSize.Width' 0)' this).X;                        if (currentEndX > endX)                      {                          endX = currentEndX;                      }                  }                    // Ensure that startX and endX are never negative                  startX = Math.Max(0' startX);                  endX = Math.Max(0' endX);                    // Ensure that startX respect min width of QuickAccessToolBar                  startX = Math.Max(startX' this.QuickAccessToolBar?.MinWidth ?? 0);                    // Set contextual groups position and size                  this.itemsContainer.Measure(infinity);                  var itemsRectWidth = Math.Min(this.itemsContainer.DesiredSize.Width' Math.Max(0' Math.Min(endX' constraint.Width) - startX));                  this.itemsRect = new Rect(startX' 0' itemsRectWidth' constraint.Height);                    // Set quick launch toolbar position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    var quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  this.quickAccessToolbarRect = new Rect(0' 0' Math.Min(quickAccessToolbarWidth' startX)' this.quickAccessToolbarHolder.DesiredSize.Height);                    if (quickAccessToolbarWidth > startX)                  {                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  }                    // Set header                  this.headerHolder.Measure(infinity);                    switch (this.HeaderAlignment)                  {                      case HorizontalAlignment.Left:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Center:                          {                              var allTextWidthRight = Math.Max(0' constraint.Width - endX);                              var allTextWidthLeft = Math.Max(0' startX - quickAccessToolbarWidth);                              var fitsRightButNotLeft = allTextWidthRight >= this.headerHolder.DesiredSize.Width && allTextWidthLeft < this.headerHolder.DesiredSize.Width;                                if (((startX - quickAccessToolbarWidth < 150 || fitsRightButNotLeft) && (startX - quickAccessToolbarWidth > 0) && (startX - quickAccessToolbarWidth < constraint.Width - endX)) || (endX < constraint.Width / 2))                              {                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' (constraint.Width / 2) - (this.headerHolder.DesiredSize.Width / 2))' constraint.Width)' 0' Math.Min(allTextWidthRight' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidthLeft / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidthLeft' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Right:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = Math.Max(0' startX - quickAccessToolbarWidth);                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' constraint.Width - this.headerHolder.DesiredSize.Width)' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Stretch:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' allTextWidth' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' allTextWidth' constraint.Height);                              }                          }                            break;                  }              }
Magic Number,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The following statement contains a magic number: if (this.IsCollapsed)              {                  // Collapse QuickAccessToolbar                  this.quickAccessToolbarRect = new Rect(0' 0' 0' 0);                    // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    this.headerHolder.Measure(new Size(constraint.Width' constraint.Height));                  this.headerRect = new Rect(0' 0' this.headerHolder.DesiredSize.Width' constraint.Height);              }              else if (visibleGroups.Count == 0                  || canRibbonTabControlScroll)              {                  // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    // Set quick launch toolbar and header position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    if (constraint.Width <= this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' Math.Max(0' constraint.Width - 50)' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                  }                    if (constraint.Width > this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.headerHolder.Measure(infinity);                      var allTextWidth = constraint.Width - this.quickAccessToolbarHolder.DesiredSize.Width;                        if (this.HeaderAlignment == HorizontalAlignment.Left)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Center)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidth / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Right)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Stretch)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' allTextWidth' constraint.Height);                      }                  }                  else                  {                      this.headerRect = new Rect(Math.Max(0' constraint.Width - 50)' 0' 50' constraint.Height);                  }              }              else              {                  var pointZero = default(Point);                    // get initial StartX value                  var startX = visibleGroups.First().FirstVisibleItem.TranslatePoint(pointZero' this).X;                  var endX = 0D;                    //Get minimum x point (workaround)                  foreach (var group in visibleGroups)                  {                      var currentStartX = group.FirstVisibleItem.TranslatePoint(pointZero' this).X;                        if (currentStartX < startX)                      {                          startX = currentStartX;                      }                        var lastItem = group.LastVisibleItem;                      var currentEndX = lastItem.TranslatePoint(new Point(lastItem.DesiredSize.Width' 0)' this).X;                        if (currentEndX > endX)                      {                          endX = currentEndX;                      }                  }                    // Ensure that startX and endX are never negative                  startX = Math.Max(0' startX);                  endX = Math.Max(0' endX);                    // Ensure that startX respect min width of QuickAccessToolBar                  startX = Math.Max(startX' this.QuickAccessToolBar?.MinWidth ?? 0);                    // Set contextual groups position and size                  this.itemsContainer.Measure(infinity);                  var itemsRectWidth = Math.Min(this.itemsContainer.DesiredSize.Width' Math.Max(0' Math.Min(endX' constraint.Width) - startX));                  this.itemsRect = new Rect(startX' 0' itemsRectWidth' constraint.Height);                    // Set quick launch toolbar position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    var quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  this.quickAccessToolbarRect = new Rect(0' 0' Math.Min(quickAccessToolbarWidth' startX)' this.quickAccessToolbarHolder.DesiredSize.Height);                    if (quickAccessToolbarWidth > startX)                  {                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  }                    // Set header                  this.headerHolder.Measure(infinity);                    switch (this.HeaderAlignment)                  {                      case HorizontalAlignment.Left:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Center:                          {                              var allTextWidthRight = Math.Max(0' constraint.Width - endX);                              var allTextWidthLeft = Math.Max(0' startX - quickAccessToolbarWidth);                              var fitsRightButNotLeft = allTextWidthRight >= this.headerHolder.DesiredSize.Width && allTextWidthLeft < this.headerHolder.DesiredSize.Width;                                if (((startX - quickAccessToolbarWidth < 150 || fitsRightButNotLeft) && (startX - quickAccessToolbarWidth > 0) && (startX - quickAccessToolbarWidth < constraint.Width - endX)) || (endX < constraint.Width / 2))                              {                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' (constraint.Width / 2) - (this.headerHolder.DesiredSize.Width / 2))' constraint.Width)' 0' Math.Min(allTextWidthRight' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidthLeft / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidthLeft' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Right:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = Math.Max(0' startX - quickAccessToolbarWidth);                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' constraint.Width - this.headerHolder.DesiredSize.Width)' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Stretch:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' allTextWidth' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' allTextWidth' constraint.Height);                              }                          }                            break;                  }              }
Magic Number,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The following statement contains a magic number: if (this.IsCollapsed)              {                  // Collapse QuickAccessToolbar                  this.quickAccessToolbarRect = new Rect(0' 0' 0' 0);                    // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    this.headerHolder.Measure(new Size(constraint.Width' constraint.Height));                  this.headerRect = new Rect(0' 0' this.headerHolder.DesiredSize.Width' constraint.Height);              }              else if (visibleGroups.Count == 0                  || canRibbonTabControlScroll)              {                  // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    // Set quick launch toolbar and header position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    if (constraint.Width <= this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' Math.Max(0' constraint.Width - 50)' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                  }                    if (constraint.Width > this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.headerHolder.Measure(infinity);                      var allTextWidth = constraint.Width - this.quickAccessToolbarHolder.DesiredSize.Width;                        if (this.HeaderAlignment == HorizontalAlignment.Left)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Center)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidth / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Right)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Stretch)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' allTextWidth' constraint.Height);                      }                  }                  else                  {                      this.headerRect = new Rect(Math.Max(0' constraint.Width - 50)' 0' 50' constraint.Height);                  }              }              else              {                  var pointZero = default(Point);                    // get initial StartX value                  var startX = visibleGroups.First().FirstVisibleItem.TranslatePoint(pointZero' this).X;                  var endX = 0D;                    //Get minimum x point (workaround)                  foreach (var group in visibleGroups)                  {                      var currentStartX = group.FirstVisibleItem.TranslatePoint(pointZero' this).X;                        if (currentStartX < startX)                      {                          startX = currentStartX;                      }                        var lastItem = group.LastVisibleItem;                      var currentEndX = lastItem.TranslatePoint(new Point(lastItem.DesiredSize.Width' 0)' this).X;                        if (currentEndX > endX)                      {                          endX = currentEndX;                      }                  }                    // Ensure that startX and endX are never negative                  startX = Math.Max(0' startX);                  endX = Math.Max(0' endX);                    // Ensure that startX respect min width of QuickAccessToolBar                  startX = Math.Max(startX' this.QuickAccessToolBar?.MinWidth ?? 0);                    // Set contextual groups position and size                  this.itemsContainer.Measure(infinity);                  var itemsRectWidth = Math.Min(this.itemsContainer.DesiredSize.Width' Math.Max(0' Math.Min(endX' constraint.Width) - startX));                  this.itemsRect = new Rect(startX' 0' itemsRectWidth' constraint.Height);                    // Set quick launch toolbar position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    var quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  this.quickAccessToolbarRect = new Rect(0' 0' Math.Min(quickAccessToolbarWidth' startX)' this.quickAccessToolbarHolder.DesiredSize.Height);                    if (quickAccessToolbarWidth > startX)                  {                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  }                    // Set header                  this.headerHolder.Measure(infinity);                    switch (this.HeaderAlignment)                  {                      case HorizontalAlignment.Left:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Center:                          {                              var allTextWidthRight = Math.Max(0' constraint.Width - endX);                              var allTextWidthLeft = Math.Max(0' startX - quickAccessToolbarWidth);                              var fitsRightButNotLeft = allTextWidthRight >= this.headerHolder.DesiredSize.Width && allTextWidthLeft < this.headerHolder.DesiredSize.Width;                                if (((startX - quickAccessToolbarWidth < 150 || fitsRightButNotLeft) && (startX - quickAccessToolbarWidth > 0) && (startX - quickAccessToolbarWidth < constraint.Width - endX)) || (endX < constraint.Width / 2))                              {                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' (constraint.Width / 2) - (this.headerHolder.DesiredSize.Width / 2))' constraint.Width)' 0' Math.Min(allTextWidthRight' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidthLeft / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidthLeft' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Right:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = Math.Max(0' startX - quickAccessToolbarWidth);                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' constraint.Width - this.headerHolder.DesiredSize.Width)' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Stretch:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' allTextWidth' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' allTextWidth' constraint.Height);                              }                          }                            break;                  }              }
Magic Number,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The following statement contains a magic number: if (this.IsCollapsed)              {                  // Collapse QuickAccessToolbar                  this.quickAccessToolbarRect = new Rect(0' 0' 0' 0);                    // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    this.headerHolder.Measure(new Size(constraint.Width' constraint.Height));                  this.headerRect = new Rect(0' 0' this.headerHolder.DesiredSize.Width' constraint.Height);              }              else if (visibleGroups.Count == 0                  || canRibbonTabControlScroll)              {                  // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    // Set quick launch toolbar and header position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    if (constraint.Width <= this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' Math.Max(0' constraint.Width - 50)' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                  }                    if (constraint.Width > this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.headerHolder.Measure(infinity);                      var allTextWidth = constraint.Width - this.quickAccessToolbarHolder.DesiredSize.Width;                        if (this.HeaderAlignment == HorizontalAlignment.Left)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Center)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidth / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Right)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Stretch)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' allTextWidth' constraint.Height);                      }                  }                  else                  {                      this.headerRect = new Rect(Math.Max(0' constraint.Width - 50)' 0' 50' constraint.Height);                  }              }              else              {                  var pointZero = default(Point);                    // get initial StartX value                  var startX = visibleGroups.First().FirstVisibleItem.TranslatePoint(pointZero' this).X;                  var endX = 0D;                    //Get minimum x point (workaround)                  foreach (var group in visibleGroups)                  {                      var currentStartX = group.FirstVisibleItem.TranslatePoint(pointZero' this).X;                        if (currentStartX < startX)                      {                          startX = currentStartX;                      }                        var lastItem = group.LastVisibleItem;                      var currentEndX = lastItem.TranslatePoint(new Point(lastItem.DesiredSize.Width' 0)' this).X;                        if (currentEndX > endX)                      {                          endX = currentEndX;                      }                  }                    // Ensure that startX and endX are never negative                  startX = Math.Max(0' startX);                  endX = Math.Max(0' endX);                    // Ensure that startX respect min width of QuickAccessToolBar                  startX = Math.Max(startX' this.QuickAccessToolBar?.MinWidth ?? 0);                    // Set contextual groups position and size                  this.itemsContainer.Measure(infinity);                  var itemsRectWidth = Math.Min(this.itemsContainer.DesiredSize.Width' Math.Max(0' Math.Min(endX' constraint.Width) - startX));                  this.itemsRect = new Rect(startX' 0' itemsRectWidth' constraint.Height);                    // Set quick launch toolbar position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    var quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  this.quickAccessToolbarRect = new Rect(0' 0' Math.Min(quickAccessToolbarWidth' startX)' this.quickAccessToolbarHolder.DesiredSize.Height);                    if (quickAccessToolbarWidth > startX)                  {                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  }                    // Set header                  this.headerHolder.Measure(infinity);                    switch (this.HeaderAlignment)                  {                      case HorizontalAlignment.Left:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Center:                          {                              var allTextWidthRight = Math.Max(0' constraint.Width - endX);                              var allTextWidthLeft = Math.Max(0' startX - quickAccessToolbarWidth);                              var fitsRightButNotLeft = allTextWidthRight >= this.headerHolder.DesiredSize.Width && allTextWidthLeft < this.headerHolder.DesiredSize.Width;                                if (((startX - quickAccessToolbarWidth < 150 || fitsRightButNotLeft) && (startX - quickAccessToolbarWidth > 0) && (startX - quickAccessToolbarWidth < constraint.Width - endX)) || (endX < constraint.Width / 2))                              {                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' (constraint.Width / 2) - (this.headerHolder.DesiredSize.Width / 2))' constraint.Width)' 0' Math.Min(allTextWidthRight' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidthLeft / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidthLeft' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Right:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = Math.Max(0' startX - quickAccessToolbarWidth);                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' constraint.Width - this.headerHolder.DesiredSize.Width)' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Stretch:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' allTextWidth' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' allTextWidth' constraint.Height);                              }                          }                            break;                  }              }
Magic Number,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The following statement contains a magic number: if (this.IsCollapsed)              {                  // Collapse QuickAccessToolbar                  this.quickAccessToolbarRect = new Rect(0' 0' 0' 0);                    // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    this.headerHolder.Measure(new Size(constraint.Width' constraint.Height));                  this.headerRect = new Rect(0' 0' this.headerHolder.DesiredSize.Width' constraint.Height);              }              else if (visibleGroups.Count == 0                  || canRibbonTabControlScroll)              {                  // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    // Set quick launch toolbar and header position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    if (constraint.Width <= this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' Math.Max(0' constraint.Width - 50)' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                  }                    if (constraint.Width > this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.headerHolder.Measure(infinity);                      var allTextWidth = constraint.Width - this.quickAccessToolbarHolder.DesiredSize.Width;                        if (this.HeaderAlignment == HorizontalAlignment.Left)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Center)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidth / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Right)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Stretch)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' allTextWidth' constraint.Height);                      }                  }                  else                  {                      this.headerRect = new Rect(Math.Max(0' constraint.Width - 50)' 0' 50' constraint.Height);                  }              }              else              {                  var pointZero = default(Point);                    // get initial StartX value                  var startX = visibleGroups.First().FirstVisibleItem.TranslatePoint(pointZero' this).X;                  var endX = 0D;                    //Get minimum x point (workaround)                  foreach (var group in visibleGroups)                  {                      var currentStartX = group.FirstVisibleItem.TranslatePoint(pointZero' this).X;                        if (currentStartX < startX)                      {                          startX = currentStartX;                      }                        var lastItem = group.LastVisibleItem;                      var currentEndX = lastItem.TranslatePoint(new Point(lastItem.DesiredSize.Width' 0)' this).X;                        if (currentEndX > endX)                      {                          endX = currentEndX;                      }                  }                    // Ensure that startX and endX are never negative                  startX = Math.Max(0' startX);                  endX = Math.Max(0' endX);                    // Ensure that startX respect min width of QuickAccessToolBar                  startX = Math.Max(startX' this.QuickAccessToolBar?.MinWidth ?? 0);                    // Set contextual groups position and size                  this.itemsContainer.Measure(infinity);                  var itemsRectWidth = Math.Min(this.itemsContainer.DesiredSize.Width' Math.Max(0' Math.Min(endX' constraint.Width) - startX));                  this.itemsRect = new Rect(startX' 0' itemsRectWidth' constraint.Height);                    // Set quick launch toolbar position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    var quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  this.quickAccessToolbarRect = new Rect(0' 0' Math.Min(quickAccessToolbarWidth' startX)' this.quickAccessToolbarHolder.DesiredSize.Height);                    if (quickAccessToolbarWidth > startX)                  {                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  }                    // Set header                  this.headerHolder.Measure(infinity);                    switch (this.HeaderAlignment)                  {                      case HorizontalAlignment.Left:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Center:                          {                              var allTextWidthRight = Math.Max(0' constraint.Width - endX);                              var allTextWidthLeft = Math.Max(0' startX - quickAccessToolbarWidth);                              var fitsRightButNotLeft = allTextWidthRight >= this.headerHolder.DesiredSize.Width && allTextWidthLeft < this.headerHolder.DesiredSize.Width;                                if (((startX - quickAccessToolbarWidth < 150 || fitsRightButNotLeft) && (startX - quickAccessToolbarWidth > 0) && (startX - quickAccessToolbarWidth < constraint.Width - endX)) || (endX < constraint.Width / 2))                              {                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' (constraint.Width / 2) - (this.headerHolder.DesiredSize.Width / 2))' constraint.Width)' 0' Math.Min(allTextWidthRight' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidthLeft / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidthLeft' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Right:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = Math.Max(0' startX - quickAccessToolbarWidth);                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' constraint.Width - this.headerHolder.DesiredSize.Width)' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Stretch:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' allTextWidth' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' allTextWidth' constraint.Height);                              }                          }                            break;                  }              }
Magic Number,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The following statement contains a magic number: if (this.IsCollapsed)              {                  // Collapse QuickAccessToolbar                  this.quickAccessToolbarRect = new Rect(0' 0' 0' 0);                    // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    this.headerHolder.Measure(new Size(constraint.Width' constraint.Height));                  this.headerRect = new Rect(0' 0' this.headerHolder.DesiredSize.Width' constraint.Height);              }              else if (visibleGroups.Count == 0                  || canRibbonTabControlScroll)              {                  // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    // Set quick launch toolbar and header position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    if (constraint.Width <= this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' Math.Max(0' constraint.Width - 50)' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                  }                    if (constraint.Width > this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.headerHolder.Measure(infinity);                      var allTextWidth = constraint.Width - this.quickAccessToolbarHolder.DesiredSize.Width;                        if (this.HeaderAlignment == HorizontalAlignment.Left)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Center)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidth / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Right)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Stretch)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' allTextWidth' constraint.Height);                      }                  }                  else                  {                      this.headerRect = new Rect(Math.Max(0' constraint.Width - 50)' 0' 50' constraint.Height);                  }              }              else              {                  var pointZero = default(Point);                    // get initial StartX value                  var startX = visibleGroups.First().FirstVisibleItem.TranslatePoint(pointZero' this).X;                  var endX = 0D;                    //Get minimum x point (workaround)                  foreach (var group in visibleGroups)                  {                      var currentStartX = group.FirstVisibleItem.TranslatePoint(pointZero' this).X;                        if (currentStartX < startX)                      {                          startX = currentStartX;                      }                        var lastItem = group.LastVisibleItem;                      var currentEndX = lastItem.TranslatePoint(new Point(lastItem.DesiredSize.Width' 0)' this).X;                        if (currentEndX > endX)                      {                          endX = currentEndX;                      }                  }                    // Ensure that startX and endX are never negative                  startX = Math.Max(0' startX);                  endX = Math.Max(0' endX);                    // Ensure that startX respect min width of QuickAccessToolBar                  startX = Math.Max(startX' this.QuickAccessToolBar?.MinWidth ?? 0);                    // Set contextual groups position and size                  this.itemsContainer.Measure(infinity);                  var itemsRectWidth = Math.Min(this.itemsContainer.DesiredSize.Width' Math.Max(0' Math.Min(endX' constraint.Width) - startX));                  this.itemsRect = new Rect(startX' 0' itemsRectWidth' constraint.Height);                    // Set quick launch toolbar position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    var quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  this.quickAccessToolbarRect = new Rect(0' 0' Math.Min(quickAccessToolbarWidth' startX)' this.quickAccessToolbarHolder.DesiredSize.Height);                    if (quickAccessToolbarWidth > startX)                  {                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  }                    // Set header                  this.headerHolder.Measure(infinity);                    switch (this.HeaderAlignment)                  {                      case HorizontalAlignment.Left:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Center:                          {                              var allTextWidthRight = Math.Max(0' constraint.Width - endX);                              var allTextWidthLeft = Math.Max(0' startX - quickAccessToolbarWidth);                              var fitsRightButNotLeft = allTextWidthRight >= this.headerHolder.DesiredSize.Width && allTextWidthLeft < this.headerHolder.DesiredSize.Width;                                if (((startX - quickAccessToolbarWidth < 150 || fitsRightButNotLeft) && (startX - quickAccessToolbarWidth > 0) && (startX - quickAccessToolbarWidth < constraint.Width - endX)) || (endX < constraint.Width / 2))                              {                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' (constraint.Width / 2) - (this.headerHolder.DesiredSize.Width / 2))' constraint.Width)' 0' Math.Min(allTextWidthRight' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidthLeft / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidthLeft' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Right:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = Math.Max(0' startX - quickAccessToolbarWidth);                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' constraint.Width - this.headerHolder.DesiredSize.Width)' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Stretch:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' allTextWidth' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' allTextWidth' constraint.Height);                              }                          }                            break;                  }              }
Magic Number,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The following statement contains a magic number: if (this.IsCollapsed)              {                  // Collapse QuickAccessToolbar                  this.quickAccessToolbarRect = new Rect(0' 0' 0' 0);                    // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    this.headerHolder.Measure(new Size(constraint.Width' constraint.Height));                  this.headerRect = new Rect(0' 0' this.headerHolder.DesiredSize.Width' constraint.Height);              }              else if (visibleGroups.Count == 0                  || canRibbonTabControlScroll)              {                  // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    // Set quick launch toolbar and header position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    if (constraint.Width <= this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' Math.Max(0' constraint.Width - 50)' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                  }                    if (constraint.Width > this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.headerHolder.Measure(infinity);                      var allTextWidth = constraint.Width - this.quickAccessToolbarHolder.DesiredSize.Width;                        if (this.HeaderAlignment == HorizontalAlignment.Left)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Center)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidth / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Right)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Stretch)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' allTextWidth' constraint.Height);                      }                  }                  else                  {                      this.headerRect = new Rect(Math.Max(0' constraint.Width - 50)' 0' 50' constraint.Height);                  }              }              else              {                  var pointZero = default(Point);                    // get initial StartX value                  var startX = visibleGroups.First().FirstVisibleItem.TranslatePoint(pointZero' this).X;                  var endX = 0D;                    //Get minimum x point (workaround)                  foreach (var group in visibleGroups)                  {                      var currentStartX = group.FirstVisibleItem.TranslatePoint(pointZero' this).X;                        if (currentStartX < startX)                      {                          startX = currentStartX;                      }                        var lastItem = group.LastVisibleItem;                      var currentEndX = lastItem.TranslatePoint(new Point(lastItem.DesiredSize.Width' 0)' this).X;                        if (currentEndX > endX)                      {                          endX = currentEndX;                      }                  }                    // Ensure that startX and endX are never negative                  startX = Math.Max(0' startX);                  endX = Math.Max(0' endX);                    // Ensure that startX respect min width of QuickAccessToolBar                  startX = Math.Max(startX' this.QuickAccessToolBar?.MinWidth ?? 0);                    // Set contextual groups position and size                  this.itemsContainer.Measure(infinity);                  var itemsRectWidth = Math.Min(this.itemsContainer.DesiredSize.Width' Math.Max(0' Math.Min(endX' constraint.Width) - startX));                  this.itemsRect = new Rect(startX' 0' itemsRectWidth' constraint.Height);                    // Set quick launch toolbar position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    var quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  this.quickAccessToolbarRect = new Rect(0' 0' Math.Min(quickAccessToolbarWidth' startX)' this.quickAccessToolbarHolder.DesiredSize.Height);                    if (quickAccessToolbarWidth > startX)                  {                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  }                    // Set header                  this.headerHolder.Measure(infinity);                    switch (this.HeaderAlignment)                  {                      case HorizontalAlignment.Left:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Center:                          {                              var allTextWidthRight = Math.Max(0' constraint.Width - endX);                              var allTextWidthLeft = Math.Max(0' startX - quickAccessToolbarWidth);                              var fitsRightButNotLeft = allTextWidthRight >= this.headerHolder.DesiredSize.Width && allTextWidthLeft < this.headerHolder.DesiredSize.Width;                                if (((startX - quickAccessToolbarWidth < 150 || fitsRightButNotLeft) && (startX - quickAccessToolbarWidth > 0) && (startX - quickAccessToolbarWidth < constraint.Width - endX)) || (endX < constraint.Width / 2))                              {                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' (constraint.Width / 2) - (this.headerHolder.DesiredSize.Width / 2))' constraint.Width)' 0' Math.Min(allTextWidthRight' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidthLeft / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidthLeft' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Right:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = Math.Max(0' startX - quickAccessToolbarWidth);                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' constraint.Width - this.headerHolder.DesiredSize.Width)' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Stretch:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' allTextWidth' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' allTextWidth' constraint.Height);                              }                          }                            break;                  }              }
Magic Number,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The following statement contains a magic number: if (this.IsCollapsed)              {                  // Collapse QuickAccessToolbar                  this.quickAccessToolbarRect = new Rect(0' 0' 0' 0);                    // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    this.headerHolder.Measure(new Size(constraint.Width' constraint.Height));                  this.headerRect = new Rect(0' 0' this.headerHolder.DesiredSize.Width' constraint.Height);              }              else if (visibleGroups.Count == 0                  || canRibbonTabControlScroll)              {                  // Collapse itemRect                  this.itemsRect = new Rect(0' 0' 0' 0);                    // Set quick launch toolbar and header position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    if (constraint.Width <= this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' Math.Max(0' constraint.Width - 50)' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                  }                    if (constraint.Width > this.quickAccessToolbarHolder.DesiredSize.Width + 50)                  {                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      this.headerHolder.Measure(infinity);                      var allTextWidth = constraint.Width - this.quickAccessToolbarHolder.DesiredSize.Width;                        if (this.HeaderAlignment == HorizontalAlignment.Left)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Center)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidth / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Right)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                      }                      else if (this.HeaderAlignment == HorizontalAlignment.Stretch)                      {                          this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width' 0' allTextWidth' constraint.Height);                      }                  }                  else                  {                      this.headerRect = new Rect(Math.Max(0' constraint.Width - 50)' 0' 50' constraint.Height);                  }              }              else              {                  var pointZero = default(Point);                    // get initial StartX value                  var startX = visibleGroups.First().FirstVisibleItem.TranslatePoint(pointZero' this).X;                  var endX = 0D;                    //Get minimum x point (workaround)                  foreach (var group in visibleGroups)                  {                      var currentStartX = group.FirstVisibleItem.TranslatePoint(pointZero' this).X;                        if (currentStartX < startX)                      {                          startX = currentStartX;                      }                        var lastItem = group.LastVisibleItem;                      var currentEndX = lastItem.TranslatePoint(new Point(lastItem.DesiredSize.Width' 0)' this).X;                        if (currentEndX > endX)                      {                          endX = currentEndX;                      }                  }                    // Ensure that startX and endX are never negative                  startX = Math.Max(0' startX);                  endX = Math.Max(0' endX);                    // Ensure that startX respect min width of QuickAccessToolBar                  startX = Math.Max(startX' this.QuickAccessToolBar?.MinWidth ?? 0);                    // Set contextual groups position and size                  this.itemsContainer.Measure(infinity);                  var itemsRectWidth = Math.Min(this.itemsContainer.DesiredSize.Width' Math.Max(0' Math.Min(endX' constraint.Width) - startX));                  this.itemsRect = new Rect(startX' 0' itemsRectWidth' constraint.Height);                    // Set quick launch toolbar position and size                  this.quickAccessToolbarHolder.Measure(infinity);                    var quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  this.quickAccessToolbarRect = new Rect(0' 0' Math.Min(quickAccessToolbarWidth' startX)' this.quickAccessToolbarHolder.DesiredSize.Height);                    if (quickAccessToolbarWidth > startX)                  {                      this.quickAccessToolbarHolder.Measure(this.quickAccessToolbarRect.Size);                      this.quickAccessToolbarRect = new Rect(0' 0' this.quickAccessToolbarHolder.DesiredSize.Width' this.quickAccessToolbarHolder.DesiredSize.Height);                      quickAccessToolbarWidth = this.quickAccessToolbarHolder.DesiredSize.Width;                  }                    // Set header                  this.headerHolder.Measure(infinity);                    switch (this.HeaderAlignment)                  {                      case HorizontalAlignment.Left:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Center:                          {                              var allTextWidthRight = Math.Max(0' constraint.Width - endX);                              var allTextWidthLeft = Math.Max(0' startX - quickAccessToolbarWidth);                              var fitsRightButNotLeft = allTextWidthRight >= this.headerHolder.DesiredSize.Width && allTextWidthLeft < this.headerHolder.DesiredSize.Width;                                if (((startX - quickAccessToolbarWidth < 150 || fitsRightButNotLeft) && (startX - quickAccessToolbarWidth > 0) && (startX - quickAccessToolbarWidth < constraint.Width - endX)) || (endX < constraint.Width / 2))                              {                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' (constraint.Width / 2) - (this.headerHolder.DesiredSize.Width / 2))' constraint.Width)' 0' Math.Min(allTextWidthRight' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidthLeft / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidthLeft' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Right:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = Math.Max(0' startX - quickAccessToolbarWidth);                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' constraint.Width - this.headerHolder.DesiredSize.Width)' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Stretch:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' allTextWidth' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' allTextWidth' constraint.Height);                              }                          }                            break;                  }              }
Magic Number,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The following statement contains a magic number: this.headerRect.Width = this.headerRect.Width + 2;
Magic Number,Fluent,RibbonTabsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabsContainer.cs,MeasureOverride,The following statement contains a magic number: if (overflowWidth < regularTabsCount * whitespace * 2)              {                  var decreaseValue = overflowWidth / regularTabsCount;                  foreach (var tab in regularTabs)                  {                      tab.Measure(new Size(Math.Max(0' tab.DesiredSize.Width - decreaseValue)' tab.DesiredSize.Height)); // tab.Width = Math.Max(0' tab.ActualWidth - decreaseValue);                  }                    desiredSize = this.GetChildrenDesiredSize();                  if (desiredSize.Width > availableSize.Width)                  {                      desiredSize.Width = availableSize.Width;                  }                    // Add separator lines between                  // tabs to assist readability                  this.UpdateSeparators(false' false);                  this.VerifyScrollData(availableSize.Width' desiredSize.Width);                  return desiredSize;              }
Magic Number,Fluent,RibbonTabsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabsContainer.cs,MeasureOverride,The following statement contains a magic number: if (overflowWidth < childrenCount * whitespace * 2)              {                  var regularTabsWhitespace = regularTabsCount * whitespace * 2.0;                  var decreaseValue = (overflowWidth - regularTabsWhitespace) / contextualTabsCount;                    foreach (var tab in regularTabs)                  {                      //if (!tab.IsContextual)                      {                          var widthBeforeMeasure = tab.DesiredSize.Width;                          tab.Measure(new Size(Math.Max(0' tab.DesiredSize.Width - (whitespace * 2.0))' tab.DesiredSize.Height));                          overflowWidth -= widthBeforeMeasure - tab.DesiredSize.Width;                      }                  }                    foreach (var tab in contextualTabs.Reverse<RibbonTabItem>())                  {                      //if (tab.IsContextual)                      {                          var widthBeforeMeasure = tab.DesiredSize.Width;                          tab.Measure(new Size(Math.Max(0' tab.DesiredSize.Width - decreaseValue)' tab.DesiredSize.Height));                            // Contextual tabs may overreduce' so check that                          overflowWidth -= widthBeforeMeasure - tab.DesiredSize.Width;                            if (overflowWidth < 0)                          {                              break;                          }                      }                  }                    desiredSize = this.GetChildrenDesiredSize();                    if (desiredSize.Width > availableSize.Width)                  {                      desiredSize.Width = availableSize.Width;                  }                    // Add separator lines between                  // tabs to assist readability                  this.UpdateSeparators(true' false);                  this.VerifyScrollData(availableSize.Width' desiredSize.Width);                  return desiredSize;              }
Magic Number,Fluent,RibbonTabsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabsContainer.cs,MeasureOverride,The following statement contains a magic number: if (overflowWidth < childrenCount * whitespace * 2)              {                  var regularTabsWhitespace = regularTabsCount * whitespace * 2.0;                  var decreaseValue = (overflowWidth - regularTabsWhitespace) / contextualTabsCount;                    foreach (var tab in regularTabs)                  {                      //if (!tab.IsContextual)                      {                          var widthBeforeMeasure = tab.DesiredSize.Width;                          tab.Measure(new Size(Math.Max(0' tab.DesiredSize.Width - (whitespace * 2.0))' tab.DesiredSize.Height));                          overflowWidth -= widthBeforeMeasure - tab.DesiredSize.Width;                      }                  }                    foreach (var tab in contextualTabs.Reverse<RibbonTabItem>())                  {                      //if (tab.IsContextual)                      {                          var widthBeforeMeasure = tab.DesiredSize.Width;                          tab.Measure(new Size(Math.Max(0' tab.DesiredSize.Width - decreaseValue)' tab.DesiredSize.Height));                            // Contextual tabs may overreduce' so check that                          overflowWidth -= widthBeforeMeasure - tab.DesiredSize.Width;                            if (overflowWidth < 0)                          {                              break;                          }                      }                  }                    desiredSize = this.GetChildrenDesiredSize();                    if (desiredSize.Width > availableSize.Width)                  {                      desiredSize.Width = availableSize.Width;                  }                    // Add separator lines between                  // tabs to assist readability                  this.UpdateSeparators(true' false);                  this.VerifyScrollData(availableSize.Width' desiredSize.Width);                  return desiredSize;              }
Magic Number,Fluent,RibbonTabsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabsContainer.cs,MeasureOverride,The following statement contains a magic number: if (overflowWidth < childrenCount * whitespace * 2)              {                  var regularTabsWhitespace = regularTabsCount * whitespace * 2.0;                  var decreaseValue = (overflowWidth - regularTabsWhitespace) / contextualTabsCount;                    foreach (var tab in regularTabs)                  {                      //if (!tab.IsContextual)                      {                          var widthBeforeMeasure = tab.DesiredSize.Width;                          tab.Measure(new Size(Math.Max(0' tab.DesiredSize.Width - (whitespace * 2.0))' tab.DesiredSize.Height));                          overflowWidth -= widthBeforeMeasure - tab.DesiredSize.Width;                      }                  }                    foreach (var tab in contextualTabs.Reverse<RibbonTabItem>())                  {                      //if (tab.IsContextual)                      {                          var widthBeforeMeasure = tab.DesiredSize.Width;                          tab.Measure(new Size(Math.Max(0' tab.DesiredSize.Width - decreaseValue)' tab.DesiredSize.Height));                            // Contextual tabs may overreduce' so check that                          overflowWidth -= widthBeforeMeasure - tab.DesiredSize.Width;                            if (overflowWidth < 0)                          {                              break;                          }                      }                  }                    desiredSize = this.GetChildrenDesiredSize();                    if (desiredSize.Width > availableSize.Width)                  {                      desiredSize.Width = availableSize.Width;                  }                    // Add separator lines between                  // tabs to assist readability                  this.UpdateSeparators(true' false);                  this.VerifyScrollData(availableSize.Width' desiredSize.Width);                  return desiredSize;              }
Magic Number,Fluent,RibbonTabsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabsContainer.cs,MeasureOverride,The following statement contains a magic number: foreach (var tab in regularTabs)              {                  //if (!tab.IsContextual)                  {                      var widthBeforeMeasure = tab.DesiredSize.Width;                      tab.Measure(new Size(Math.Max(0' tab.DesiredSize.Width - (whitespace * 2.0))' tab.DesiredSize.Height));                      overflowWidth -= widthBeforeMeasure - tab.DesiredSize.Width;                  }              }
Magic Number,Fluent,RibbonTabsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabsContainer.cs,MeasureOverride,The following statement contains a magic number: foreach (var tab in contextualTabs.Reverse<RibbonTabItem>())              {                  //if (tab.IsContextual)                  {                      var widthBeforeMeasure = tab.DesiredSize.Width;                      tab.Measure(new Size(Math.Max(0' tab.DesiredSize.Width - (whitespace * 2.0))' tab.DesiredSize.Height));                        // Contextual tabs may overreduce' so check that                      overflowWidth -= widthBeforeMeasure - tab.DesiredSize.Width;                        if (overflowWidth < 0)                      {                          desiredSize = this.GetChildrenDesiredSize();                          if (desiredSize.Width > availableSize.Width)                          {                              desiredSize.Width = availableSize.Width;                          }                            // Add separator lines between                          // tabs to assist readability                          this.UpdateSeparators(true' false);                          this.VerifyScrollData(availableSize.Width' desiredSize.Width);                          return desiredSize;                      }                  }              }
Magic Number,Fluent,RibbonTabsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabsContainer.cs,LineLeft,The following statement contains a magic number: this.SetHorizontalOffset(this.HorizontalOffset - 16.0);
Magic Number,Fluent,RibbonTabsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabsContainer.cs,LineRight,The following statement contains a magic number: this.SetHorizontalOffset(this.HorizontalOffset + 16.0);
Magic Number,Fluent,RibbonControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonControl.cs,BindQuickAccessItem,The following statement contains a magic number: if (ribbonControl?.Icon != null)              {                  var iconVisual = ribbonControl.Icon as Visual;                  if (iconVisual != null)                  {                      var rect = new Rectangle                      {                          Width = 16'                          Height = 16'                          Fill = new VisualBrush(iconVisual)                      };                      ((IRibbonControl)element).Icon = rect;                  }                  else                  {                      Bind(source' element' nameof(IRibbonControl.Icon)' IconProperty' BindingMode.OneWay);                  }              }
Magic Number,Fluent,RibbonControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonControl.cs,BindQuickAccessItem,The following statement contains a magic number: if (ribbonControl?.Icon != null)              {                  var iconVisual = ribbonControl.Icon as Visual;                  if (iconVisual != null)                  {                      var rect = new Rectangle                      {                          Width = 16'                          Height = 16'                          Fill = new VisualBrush(iconVisual)                      };                      ((IRibbonControl)element).Icon = rect;                  }                  else                  {                      Bind(source' element' nameof(IRibbonControl.Icon)' IconProperty' BindingMode.OneWay);                  }              }
Magic Number,Fluent,RibbonGroupBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonGroupBox.cs,CreateQuickAccessItem,The following statement contains a magic number: if (this.Icon != null)              {                  var iconVisual = this.Icon as Visual;                  if (iconVisual != null)                  {                      var rect = new Rectangle                      {                          Width = 16'                          Height = 16'                          Fill = new VisualBrush(iconVisual)                      };                      groupBox.Icon = rect;                  }                  else                  {                      RibbonControl.Bind(this' groupBox' nameof(this.Icon)' RibbonControl.IconProperty' BindingMode.OneWay);                  }              }
Magic Number,Fluent,RibbonGroupBox,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonGroupBox.cs,CreateQuickAccessItem,The following statement contains a magic number: if (this.Icon != null)              {                  var iconVisual = this.Icon as Visual;                  if (iconVisual != null)                  {                      var rect = new Rectangle                      {                          Width = 16'                          Height = 16'                          Fill = new VisualBrush(iconVisual)                      };                      groupBox.Icon = rect;                  }                  else                  {                      RibbonControl.Bind(this' groupBox' nameof(this.Icon)' RibbonControl.IconProperty' BindingMode.OneWay);                  }              }
Magic Number,Fluent,RibbonGroupsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonGroupsContainer.cs,FindGroup,The following statement contains a magic number: if (name.StartsWith("("' StringComparison.OrdinalIgnoreCase))              {                  name = name.Substring(1' name.Length - 2);              }
Magic Number,Fluent,RibbonGroupsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonGroupsContainer.cs,LineLeft,The following statement contains a magic number: this.SetHorizontalOffset(this.HorizontalOffset - 16.0);
Magic Number,Fluent,RibbonGroupsContainer,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonGroupsContainer.cs,LineRight,The following statement contains a magic number: this.SetHorizontalOffset(this.HorizontalOffset + 16.0);
Magic Number,Fluent,RibbonTabItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabItem.cs,RibbonTabItem,The following statement contains a magic number: System.Windows.Controls.ToolTipService.InitialShowDelayProperty.OverrideMetadata(typeof(RibbonTabItem)' new FrameworkPropertyMetadata(2000));
Magic Number,Fluent,RibbonTabItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabItem.cs,MeasureOverride,The following statement contains a magic number: if (totalWidth < headerWidth + (this.Indent * 2))              {                  var newPaddings = Math.Max(0' (totalWidth - headerWidth) / 2);                  this.contentContainer.Padding = new Thickness(newPaddings' this.contentContainer.Padding.Top' newPaddings' this.contentContainer.Padding.Bottom);              }              else              {                  if (DoubleUtil.AreClose(this.desiredWidth' 0) == false)                  {                      // If header width is larger then tab increase tab width                      if (constraint.Width > this.desiredWidth                          && this.desiredWidth > totalWidth)                      {                          baseConstraint.Width = this.desiredWidth;                      }                      else                      {                          baseConstraint.Width = headerWidth + (this.Indent * 2) + this.contentContainer.Margin.Left + this.contentContainer.Margin.Right;                      }                  }              }
Magic Number,Fluent,RibbonTabItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabItem.cs,MeasureOverride,The following statement contains a magic number: if (totalWidth < headerWidth + (this.Indent * 2))              {                  var newPaddings = Math.Max(0' (totalWidth - headerWidth) / 2);                  this.contentContainer.Padding = new Thickness(newPaddings' this.contentContainer.Padding.Top' newPaddings' this.contentContainer.Padding.Bottom);              }              else              {                  if (DoubleUtil.AreClose(this.desiredWidth' 0) == false)                  {                      // If header width is larger then tab increase tab width                      if (constraint.Width > this.desiredWidth                          && this.desiredWidth > totalWidth)                      {                          baseConstraint.Width = this.desiredWidth;                      }                      else                      {                          baseConstraint.Width = headerWidth + (this.Indent * 2) + this.contentContainer.Margin.Left + this.contentContainer.Margin.Right;                      }                  }              }
Magic Number,Fluent,RibbonTabItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabItem.cs,MeasureOverride,The following statement contains a magic number: if (totalWidth < headerWidth + (this.Indent * 2))              {                  var newPaddings = Math.Max(0' (totalWidth - headerWidth) / 2);                  this.contentContainer.Padding = new Thickness(newPaddings' this.contentContainer.Padding.Top' newPaddings' this.contentContainer.Padding.Bottom);              }              else              {                  if (DoubleUtil.AreClose(this.desiredWidth' 0) == false)                  {                      // If header width is larger then tab increase tab width                      if (constraint.Width > this.desiredWidth                          && this.desiredWidth > totalWidth)                      {                          baseConstraint.Width = this.desiredWidth;                      }                      else                      {                          baseConstraint.Width = headerWidth + (this.Indent * 2) + this.contentContainer.Margin.Left + this.contentContainer.Margin.Right;                      }                  }              }
Magic Number,Fluent,RibbonTabItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabItem.cs,OnMouseLeftButtonDown,The following statement contains a magic number: if (ReferenceEquals(e.Source' this)                  && e.ClickCount == 2)              {                  e.Handled = true;                    if (this.TabControlParent != null)                  {                      var canMinimize = this.TabControlParent.CanMinimize;                      if (canMinimize)                      {                          this.TabControlParent.IsMinimized = !this.TabControlParent.IsMinimized;                      }                  }              }              else if (ReferenceEquals(e.Source' this)                  || this.IsSelected == false)              {                  if (this.Visibility == Visibility.Visible)                  {                      if (this.TabControlParent != null)                      {                          var newItem = this.TabControlParent.ItemContainerGenerator.ItemFromContainer(this);                            if (ReferenceEquals(this.TabControlParent.SelectedTabItem' newItem))                          {                              this.TabControlParent.IsDropDownOpen = !this.TabControlParent.IsDropDownOpen;                          }                          else                          {                              this.TabControlParent.SelectedItem = newItem;                          }                            this.TabControlParent.RaiseRequestBackstageClose();                      }                      else                      {                          this.IsSelected = true;                      }                        this.SetFocus();                        e.Handled = true;                  }              }
Magic Number,Fluent,WindowCommands,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Metro\Controls\WindowCommands.cs,GetCaption,The following statement contains a magic number: var sb = new StringBuilder(256);
Magic Number,Fluent.Converters,ThicknessConverter,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Converters\ThicknessConverter.cs,Convert,The following statement contains a magic number: var right = TryConvertSingleValue(values[2]);
Magic Number,Fluent.Converters,ThicknessConverter,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Converters\ThicknessConverter.cs,Convert,The following statement contains a magic number: var bottom = TryConvertSingleValue(values[3]);
Magic Number,Fluent.Helpers,WindowSteeringHelper,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Helpers\WindowSteeringHelper.cs,HandleMouseLeftButtonDown,The following statement contains a magic number: if (handleDragMove                  && e.ClickCount == 1)              {                  e.Handled = true;                    // taken from DragMove internal code                  window.VerifyAccess();                    // for the touch usage                  UnsafeNativeMethods.ReleaseCapture();                    var criticalHandle = (IntPtr)criticalHandlePropertyInfo.GetValue(window' emptyObjectArray);                  // DragMove works too' but not on maximized windows                  NativeMethods.SendMessage(criticalHandle' WM.SYSCOMMAND' (IntPtr)SC.MOUSEMOVE' IntPtr.Zero);                  NativeMethods.SendMessage(criticalHandle' WM.LBUTTONUP' IntPtr.Zero' IntPtr.Zero);              }              else if (handleStateChange                  && e.ClickCount == 2                  && (window.ResizeMode == ResizeMode.CanResize || window.ResizeMode == ResizeMode.CanResizeWithGrip))              {                  e.Handled = true;                    if (window.WindowState == WindowState.Normal)                  {                      ControlzEx.Windows.Shell.SystemCommands.MaximizeWindow(window);                  }                  else                  {                      ControlzEx.Windows.Shell.SystemCommands.RestoreWindow(window);                  }              }
Magic Number,Fluent.Internal,KeyEventUtility,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Internal\KeyEventUtility.cs,GetStringFromKey,The following statement contains a magic number: var keyboardState = new byte[256];
Magic Number,Fluent.Internal,DoubleUtil,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Internal\DoubleUtil.cs,AreClose,The following statement contains a magic number: var eps = (Math.Abs(value1) + Math.Abs(value2) + 10.0) * DBL_EPSILON;
Duplicate Code,Fluent,InRibbonGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\InRibbonGallery.cs,OnFilterCollectionChanged,The method contains a code clone-set at the following line numbers (starting from the method definition): ((8' 30)' (45' 67))
Missing Default,Fluent,StatusBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\StatusBar.cs,OnItemsChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                  {                      foreach (var newItem in e.NewItems)                      {                          var container = this.ItemContainerGenerator.ContainerFromItem(newItem);                          var containerIndex = this.ItemContainerGenerator.IndexFromContainer(container);                          var item = container as StatusBarItem;                            if (item != null)                          {                              item.Checked += this.OnItemChecked;                              item.Unchecked += this.OnItemUnchecked;                              this.contextMenu.Items.Insert(containerIndex' new StatusBarMenuItem(item));                          }                          else                          {                              this.contextMenu.Items.Insert(containerIndex' new Separator());                          }                      }                        break;                  }                    case NotifyCollectionChangedAction.Move:                      {                          for (var i = 0; i < e.NewItems.Count; i++)                          {                              var menuItem = this.contextMenu.Items[e.OldStartingIndex + 1];                              this.contextMenu.Items.Remove(e.OldStartingIndex + 1);                              this.contextMenu.Items.Insert(e.NewStartingIndex + i + 1' menuItem);                          }                            break;                      }                    case NotifyCollectionChangedAction.Remove:                      {                          for (var i = 0; i < e.OldItems.Count; i++)                          {                              var menuItem = this.contextMenu.Items[e.OldStartingIndex + 1] as StatusBarMenuItem;                              if (menuItem != null)                              {                                  menuItem.StatusBarItem.Checked += this.OnItemChecked;                                  menuItem.StatusBarItem.Unchecked += this.OnItemUnchecked;                              }                                this.contextMenu.Items.RemoveAt(e.OldStartingIndex + 1);                          }                            break;                      }                    case NotifyCollectionChangedAction.Replace:                      {                          for (var i = 0; i < e.OldItems.Count; i++)                          {                              var menuItem = this.contextMenu.Items[e.OldStartingIndex + 1] as StatusBarMenuItem;                              if (menuItem != null)                              {                                  menuItem.StatusBarItem.Checked += this.OnItemChecked;                                  menuItem.StatusBarItem.Unchecked += this.OnItemUnchecked;                              }                                this.contextMenu.Items.RemoveAt(e.OldStartingIndex + 1);                          }                            for (var i = 0; i < e.NewItems.Count; i++)                          {                              var item = this.ItemContainerGenerator.ContainerFromItem(e.NewItems[i]) as StatusBarItem;                              if (item != null)                              {                                  item.Checked += this.OnItemChecked;                                  item.Unchecked += this.OnItemUnchecked;                                  this.contextMenu.Items.Insert(e.NewStartingIndex + i + 1' new StatusBarMenuItem(item));                              }                              else                              {                                  this.contextMenu.Items.Insert(e.NewStartingIndex + i + 1' new Separator());                              }                          }                            break;                      }                    case NotifyCollectionChangedAction.Reset:                      {                          this.RecreateMenu();                          break;                      }              }
Missing Default,Fluent,Gallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Gallery.cs,OnFilterCollectionChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      for (var i = 0; i < e.NewItems.Count; i++)                      {                          if (this.groupsMenuButton != null)                          {                              var filter = (GalleryGroupFilter)e.NewItems[i];                              var menuItem = new MenuItem                                             {                                                 Header = filter.Title'                                                 Tag = filter                                             };                                if (ReferenceEquals(filter' this.SelectedFilter))                              {                                  menuItem.IsChecked = true;                              }                                menuItem.Click += this.OnFilterMenuItemClick;                              this.groupsMenuButton.Items.Insert(e.NewStartingIndex + i' menuItem);                          }                      }                        break;                  case NotifyCollectionChangedAction.Remove:                      foreach (var item in e.OldItems)                      {                          if (this.groupsMenuButton != null)                          {                              this.groupsMenuButton.Items.Remove(this.GetFilterMenuItem(item as GalleryGroupFilter));                          }                      }                        break;                    case NotifyCollectionChangedAction.Replace:                      foreach (var item in e.OldItems)                      {                          if (this.groupsMenuButton != null)                          {                              this.groupsMenuButton.Items.Remove(this.GetFilterMenuItem(item as GalleryGroupFilter));                          }                      }                        foreach (var item in e.NewItems.OfType<GalleryGroupFilter>())                      {                          if (this.groupsMenuButton != null)                          {                              var filter = item;                              var menuItem = new MenuItem                                             {                                                 Header = filter.Title'                                                 Tag = filter                                             };                                if (ReferenceEquals(filter' this.SelectedFilter))                              {                                  menuItem.IsChecked = true;                              }                                menuItem.Click += this.OnFilterMenuItemClick;                              this.groupsMenuButton.Items.Add(menuItem);                          }                      }                        break;              }
Missing Default,Fluent,InRibbonGallery,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\InRibbonGallery.cs,OnFilterCollectionChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      foreach (var item in e.NewItems.OfType<GalleryGroupFilter>())                      {                          if (this.groupsMenuButton != null)                          {                              var filter = item;                              var menuItem = new MenuItem                              {                                  Header = filter.Title'                                  Tag = filter'                                  IsDefinitive = false                              };                                if (ReferenceEquals(filter' this.SelectedFilter))                              {                                  menuItem.IsChecked = true;                              }                                menuItem.Click += this.OnFilterMenuItemClick;                              this.groupsMenuButton.Items.Add(menuItem);                          }                      }                        break;                  case NotifyCollectionChangedAction.Remove:                      foreach (var item in e.OldItems.OfType<GalleryGroupFilter>())                      {                          this.groupsMenuButton?.Items.Remove(this.GetFilterMenuItem(item));                      }                        break;                    case NotifyCollectionChangedAction.Replace:                      foreach (var item in e.OldItems.OfType<GalleryGroupFilter>())                      {                          this.groupsMenuButton?.Items.Remove(this.GetFilterMenuItem(item));                      }                        foreach (var item in e.NewItems.OfType<GalleryGroupFilter>())                      {                          if (this.groupsMenuButton != null)                          {                              var filter = item;                              var menuItem = new MenuItem                              {                                  Header = filter.Title'                                  Tag = filter'                                  IsDefinitive = false                              };                                if (ReferenceEquals(filter' this.SelectedFilter))                              {                                  menuItem.IsChecked = true;                              }                                menuItem.Click += this.OnFilterMenuItemClick;                              this.groupsMenuButton.Items.Add(menuItem);                          }                      }                        break;                  case NotifyCollectionChangedAction.Reset:                      this.groupsMenuButton?.Items.Clear();                      break;              }
Missing Default,Fluent,RibbonWindow,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonWindow.cs,HandleIconMouseDown,The following switch statement is missing a default case: switch (e.ChangedButton)              {                  case MouseButton.Left:                      if (e.ClickCount == 1)                      {                          e.Handled = true;                            WindowSteeringHelper.ShowSystemMenu(this' this.PointToScreen(new Point(0' this.TitleBarHeight)));                      }                      else if (e.ClickCount == 2)                      {                          e.Handled = true;    #pragma warning disable 618                          ControlzEx.Windows.Shell.SystemCommands.CloseWindow(this);  #pragma warning restore 618                      }                        break;                    case MouseButton.Right:                      e.Handled = true;                        WindowSteeringHelper.ShowSystemMenu(this' e);                      break;              }
Missing Default,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following switch statement is missing a default case: switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                          {                              case HorizontalAlignment.Left:                                  x = 0;                                  break;                              case HorizontalAlignment.Right:                                  x = keyTipInformation.VisualTarget.DesiredSize.Width - keyTipInformation.KeyTip.DesiredSize.Width;                                  break;                          }
Missing Default,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following switch statement is missing a default case: switch (KeyTip.GetHorizontalAlignment(keyTipInformation.AssociatedElement))                      {                          case HorizontalAlignment.Left:                              break;                          case HorizontalAlignment.Right:                              x = elementSize.Width - keyTipSize.Width;                              break;                          case HorizontalAlignment.Center:                          case HorizontalAlignment.Stretch:                              x = (elementSize.Width / 2.0) - (keyTipSize.Width / 2.0);                              break;                      }
Missing Default,Fluent,KeyTipAdorner,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Adorners\KeyTipAdorner.cs,UpdateKeyTipPositions,The following switch statement is missing a default case: switch (KeyTip.GetVerticalAlignment(keyTipInformation.AssociatedElement))                      {                          case VerticalAlignment.Top:                              break;                          case VerticalAlignment.Bottom:                              y = elementSize.Height - keyTipSize.Height;                              break;                          case VerticalAlignment.Center:                          case VerticalAlignment.Stretch:                              y = (elementSize.Height / 2.0) - (keyTipSize.Height / 2.0);                              break;                      }
Missing Default,Fluent,DropDownButton,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\DropDownButton.cs,OnDropDownPopupKeyDown,The following switch statement is missing a default case: switch (e.Key)              {                  case Key.Escape:                      this.IsDropDownOpen = false;                      handled = true;                      break;              }
Missing Default,Fluent,DropDownButton,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\DropDownButton.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key)              {                  case Key.Down:                      if (this.HasItems                          && this.IsDropDownOpen == false) // Only handle this for initial navigation. Further navigation is handled by the dropdown itself                      {                          this.IsDropDownOpen = true;                            var container = this.ItemContainerGenerator.ContainerFromIndex(0);                            NavigateToContainer(container);                            handled = true;                      }                        break;                    case Key.Up:                      if (this.HasItems                          && this.IsDropDownOpen == false) // Only handle this for initial navigation. Further navigation is handled by the dropdown itself                      {                          this.IsDropDownOpen = true;                            var container = this.ItemContainerGenerator.ContainerFromIndex(this.Items.Count - 1);                            NavigateToContainer(container);                            handled = true;                      }                        break;                    case Key.Escape:                      if (this.IsDropDownOpen)                      {                          this.IsDropDownOpen = false;                          handled = true;                      }                        break;                    case Key.Enter:                  case Key.Space:                      this.IsDropDownOpen = !this.IsDropDownOpen;                      handled = true;                      break;              }
Missing Default,Fluent,QuickAccessToolBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\QuickAccessToolBar.cs,OnQuickAccessItemsCollectionChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      for (var i = 0; i < e.NewItems.Count; i++)                      {                          if (this.menuDownButton != null)                          {                              this.menuDownButton.Items.Insert(e.NewStartingIndex + i + 1' e.NewItems[i]);                          }                          else                          {                              this.AddLogicalChild(e.NewItems[i]);                          }                      }                        break;                    case NotifyCollectionChangedAction.Remove:                      foreach (var item in e.OldItems)                      {                          if (this.menuDownButton != null)                          {                              this.menuDownButton.Items.Remove(item);                          }                          else                          {                              this.RemoveLogicalChild(item);                          }                      }                        break;                    case NotifyCollectionChangedAction.Replace:                      foreach (var item in e.OldItems)                      {                          if (this.menuDownButton != null)                          {                              this.menuDownButton.Items.Remove(item);                          }                          else                          {                              this.RemoveLogicalChild(item);                          }                      }                        var ii = 0;                      foreach (var item in e.NewItems)                      {                          if (this.menuDownButton != null)                          {                              this.menuDownButton.Items.Insert(e.NewStartingIndex + ii + 1' item);                          }                          else                          {                              this.AddLogicalChild(item);                          }                            ii++;                      }                        break;              }
Missing Default,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,OnContextualGroupsCollectionChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      for (var i = 0; i < e.NewItems.Count; i++)                      {                          this.TitleBar?.Items.Insert(e.NewStartingIndex + i' e.NewItems[i]);                      }                        break;                    case NotifyCollectionChangedAction.Remove:                      foreach (var item in e.OldItems)                      {                          this.TitleBar?.Items.Remove(item);                      }                        break;                    case NotifyCollectionChangedAction.Replace:                      foreach (var item in e.OldItems)                      {                          this.TitleBar?.Items.Remove(item);                      }                        foreach (var item in e.NewItems)                      {                          this.TitleBar?.Items.Add(item);                      }                        break;                  case NotifyCollectionChangedAction.Reset:                      this.TitleBar?.Items.Clear();                      break;              }
Missing Default,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,OnTabsCollectionChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      for (var i = 0; i < e.NewItems.Count; i++)                      {                          this.TabControl.Items.Insert(e.NewStartingIndex + i' e.NewItems[i]);                      }                        break;                    case NotifyCollectionChangedAction.Remove:                      foreach (var item in e.OldItems)                      {                          this.TabControl.Items.Remove(item);                      }                        break;                    case NotifyCollectionChangedAction.Replace:                      foreach (var item in e.OldItems)                      {                          this.TabControl.Items.Remove(item);                      }                        foreach (var item in e.NewItems)                      {                          this.TabControl.Items.Add(item);                      }                        break;                    case NotifyCollectionChangedAction.Reset:                      this.TabControl.Items.Clear();                      break;              }
Missing Default,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,OnToolbarItemsCollectionChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      for (var i = 0; i < e.NewItems.Count; i++)                      {                          this.TabControl?.ToolBarItems.Insert(e.NewStartingIndex + i' (UIElement)e.NewItems[i]);                      }                        break;                    case NotifyCollectionChangedAction.Remove:                      foreach (var item in e.OldItems)                      {                          this.TabControl?.ToolBarItems.Remove(item as UIElement);                      }                        break;                    case NotifyCollectionChangedAction.Replace:                      foreach (var item in e.OldItems)                      {                          this.TabControl?.ToolBarItems.Remove(item as UIElement);                      }                        foreach (var item in e.NewItems)                      {                          this.TabControl?.ToolBarItems.Add(item as UIElement);                      }                        break;              }
Missing Default,Fluent,Ribbon,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\Ribbon.cs,OnQuickAccessItemsCollectionChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      for (var i = 0; i < e.NewItems.Count; i++)                      {                          var menuItem = (QuickAccessMenuItem)e.NewItems[i];                          this.QuickAccessToolBar?.QuickAccessItems.Insert(e.NewStartingIndex + i' menuItem);                          menuItem.Ribbon = this;                      }                        break;                    case NotifyCollectionChangedAction.Remove:                      foreach (var item in e.OldItems.OfType<QuickAccessMenuItem>())                      {                          var menuItem = item;                          this.QuickAccessToolBar?.QuickAccessItems.Remove(menuItem);                          menuItem.Ribbon = null;                      }                        break;                    case NotifyCollectionChangedAction.Replace:                      foreach (var item in e.OldItems.OfType<QuickAccessMenuItem>())                      {                          var menuItem = item;                          this.QuickAccessToolBar?.QuickAccessItems.Remove(menuItem);                          menuItem.Ribbon = null;                      }                        foreach (var item in e.NewItems.OfType<QuickAccessMenuItem>())                      {                          var menuItem = item;                          this.QuickAccessToolBar?.QuickAccessItems.Add(menuItem);                          menuItem.Ribbon = this;                      }                        break;              }
Missing Default,Fluent,RibbonTitleBar,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTitleBar.cs,Update,The following switch statement is missing a default case: switch (this.HeaderAlignment)                  {                      case HorizontalAlignment.Left:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Center:                          {                              var allTextWidthRight = Math.Max(0' constraint.Width - endX);                              var allTextWidthLeft = Math.Max(0' startX - quickAccessToolbarWidth);                              var fitsRightButNotLeft = allTextWidthRight >= this.headerHolder.DesiredSize.Width && allTextWidthLeft < this.headerHolder.DesiredSize.Width;                                if (((startX - quickAccessToolbarWidth < 150 || fitsRightButNotLeft) && (startX - quickAccessToolbarWidth > 0) && (startX - quickAccessToolbarWidth < constraint.Width - endX)) || (endX < constraint.Width / 2))                              {                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' (constraint.Width / 2) - (this.headerHolder.DesiredSize.Width / 2))' constraint.Width)' 0' Math.Min(allTextWidthRight' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' (allTextWidthLeft / 2) - (this.headerHolder.DesiredSize.Width / 2))' 0' Math.Min(allTextWidthLeft' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Right:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = Math.Max(0' startX - quickAccessToolbarWidth);                                  this.headerRect = new Rect(this.quickAccessToolbarHolder.DesiredSize.Width + Math.Max(0' allTextWidth - this.headerHolder.DesiredSize.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(Math.Max(endX' constraint.Width - this.headerHolder.DesiredSize.Width)' constraint.Width)' 0' Math.Min(allTextWidth' this.headerHolder.DesiredSize.Width)' constraint.Height);                              }                          }                            break;                        case HorizontalAlignment.Stretch:                          {                              if (startX - quickAccessToolbarWidth > 150)                              {                                  var allTextWidth = startX - quickAccessToolbarWidth;                                  this.headerRect = new Rect(this.quickAccessToolbarRect.Width' 0' allTextWidth' constraint.Height);                              }                              else                              {                                  var allTextWidth = Math.Max(0' constraint.Width - endX);                                  this.headerRect = new Rect(Math.Min(endX' constraint.Width)' 0' allTextWidth' constraint.Height);                              }                          }                            break;                  }
Missing Default,Fluent,RibbonTabControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabControl.cs,OnToolbarItemsCollectionChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      for (var i = 0; i < e.NewItems.Count; i++)                      {                          this.ToolbarPanel.Children.Insert(e.NewStartingIndex + i' (UIElement)e.NewItems[i]);                      }                        break;                    case NotifyCollectionChangedAction.Remove:                      foreach (var obj3 in e.OldItems.OfType<UIElement>())                      {                          this.ToolbarPanel.Children.Remove(obj3);                      }                        break;                    case NotifyCollectionChangedAction.Replace:                      foreach (var obj4 in e.OldItems.OfType<UIElement>())                      {                          this.ToolbarPanel.Children.Remove(obj4);                      }                        foreach (var obj5 in e.NewItems.OfType<UIElement>())                      {                          this.ToolbarPanel.Children.Add(obj5);                      }                        break;                    case NotifyCollectionChangedAction.Reset:                      this.ToolbarPanel.Children.Clear();                      foreach (var toolBarItem in this.ToolBarItems)                      {                          this.ToolbarPanel.Children.Add(toolBarItem);                      }                        break;              }
Missing Default,Fluent,RibbonTabControl,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabControl.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key)              {                  case Key.Escape:                      if (this.IsDropDownOpen)                      {                          this.IsDropDownOpen = false;                      }                        break;                    case Key.Tab:                      if ((e.KeyboardDevice.Modifiers & ModifierKeys.Control) == ModifierKeys.Control)                      {                          startIndex = this.ItemContainerGenerator.IndexFromContainer(this.ItemContainerGenerator.ContainerFromItem(this.SelectedItem));                          if ((e.KeyboardDevice.Modifiers & ModifierKeys.Shift) == ModifierKeys.Shift)                          {                              direction = -1;                          }                          else                          {                              direction = 1;                          }                      }                        break;                  case Key.Home:                      direction = 1;                      startIndex = -1;                      break;                  case Key.End:                      direction = -1;                      startIndex = this.Items.Count;                      break;              }
Missing Default,Fluent,RibbonTabItem,C:\repos\fluentribbon_Fluent.Ribbon\Fluent.Ribbon\Controls\RibbonTabItem.cs,OnGroupsCollectionChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      for (var i = 0; i < e.NewItems.Count; i++)                      {                          this.groupsInnerContainer.Children.Insert(e.NewStartingIndex + i' (UIElement)e.NewItems[i]);                      }                        break;                    case NotifyCollectionChangedAction.Remove:                      foreach (var item in e.OldItems.OfType<UIElement>())                      {                          this.groupsInnerContainer.Children.Remove(item);                      }                        break;                    case NotifyCollectionChangedAction.Replace:                      foreach (var item in e.OldItems.OfType<UIElement>())                      {                          this.groupsInnerContainer.Children.Remove(item);                      }                        foreach (var item in e.NewItems.OfType<UIElement>())                      {                          this.groupsInnerContainer.Children.Add(item);                      }                        break;                    case NotifyCollectionChangedAction.Reset:                      this.groupsInnerContainer.Children.Clear();                        foreach (var group in this.groups)                      {                          this.groupsInnerContainer.Children.Add(group);                      }                        break;              }
