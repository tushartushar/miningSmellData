Implementation smell,Namespace,Class,File,Method,Description
Complex Method,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,Cyclomatic complexity of the method is 10
Complex Method,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,Cyclomatic complexity of the method is 12
Complex Method,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,Cyclomatic complexity of the method is 27
Complex Method,AssetImporter,Loader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\Loader.cs,LoadFile,Cyclomatic complexity of the method is 27
Complex Method,AssetImporter,Loader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\Loader.cs,LoadBaseFormat,Cyclomatic complexity of the method is 23
Complex Method,AssetImporter,LstLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LstLoader.cs,Load,Cyclomatic complexity of the method is 9
Complex Method,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,ReadImage,Cyclomatic complexity of the method is 10
Complex Method,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,Cyclomatic complexity of the method is 24
Complex Method,AssetImporter.Loaders,SoundLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\SoundLoader.cs,Load,Cyclomatic complexity of the method is 10
Long Parameter List,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,Load,The method has 8 parameters.
Long Parameter List,AssetImporter,WaveLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\WaveLoader.cs,Load,The method has 5 parameters.
Long Parameter List,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,WriteMidi,The method has 5 parameters.
Long Statement,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The length of the statement  "				playerBitmapLoader.Load (32' heights [index]' 16' yOffsets [index]' color [i % 6]' rowDataOffsets [index]' destinationDirectory' resourceName + i); " is 147.
Long Statement,AssetImporter,FontLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\FontLoader.cs,Load,The length of the statement  "	(new XmlSerializer (typeof(Font))).Serialize (File.Open (Path.Combine (destination' fontName + ".xml")' FileMode.Create)' font); " is 128.
Long Statement,AssetImporter,WaveLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\WaveLoader.cs,Load,The length of the statement  "	using (var binaryWriter = new BinaryWriter (File.Open (Path.Combine (destinationDirectory' names [resourceName]) + ".wav"' FileMode.Create))) { " is 143.
Long Statement,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,WriteMidi,The length of the statement  "		// xmi2mid.cpp uses std::sort which is not guaranteed to be stable' but it just happens that it did preserve order in that particular case' " is 139.
Long Statement,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,Load,The length of the statement  "		Load (destinationDirectory' Path.GetFileNameWithoutExtension (sourceFile)' binaryReader' (uint)new FileInfo (sourceFile).Length); " is 129.
Magic Number,AssetImporter,BinaryExtensions,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\BinaryExtensions.cs,BE_ReadUInt24,The following statement contains a magic number: temp = new byte[4] {  	temp [2]'  	temp [1]'  	temp [0]'  	0x00  };  
Magic Number,AssetImporter,BinaryExtensions,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\BinaryExtensions.cs,BE_ReadUInt24,The following statement contains a magic number: temp = new byte[4] {  	temp [2]'  	temp [1]'  	temp [0]'  	0x00  };  
Magic Number,AssetImporter,BinaryExtensions,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\BinaryExtensions.cs,ReadUInt32_VariableLength,The following statement contains a magic number: for (int i = 0; i < 4; ++i) {  	byte nextByte = b.ReadByte ();  	value = (value << 7) | (uint)(nextByte & 0x7F);  	if ((nextByte & 0x80) == 0)  		break;  }  
Magic Number,AssetImporter,BinaryExtensions,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\BinaryExtensions.cs,ReadUInt32_VariableLength,The following statement contains a magic number: for (int i = 0; i < 4; ++i) {  	byte nextByte = b.ReadByte ();  	value = (value << 7) | (uint)(nextByte & 0x7F);  	if ((nextByte & 0x80) == 0)  		break;  }  
Magic Number,AssetImporter,BinaryExtensions,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\BinaryExtensions.cs,ReadUInt32_VariableLength,The following statement contains a magic number: value = (value << 7) | (uint)(nextByte & 0x7F);  
Magic Number,AssetImporter,BinaryExtensions,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\BinaryExtensions.cs,WriteUInt32_VariableLength,The following statement contains a magic number: for (; (value >>= 7) != 0; ++byteCount) {  	buffer = (buffer << 8) | 0x80 | (value & 0x7F);  }  
Magic Number,AssetImporter,BinaryExtensions,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\BinaryExtensions.cs,WriteUInt32_VariableLength,The following statement contains a magic number: for (; (value >>= 7) != 0; ++byteCount) {  	buffer = (buffer << 8) | 0x80 | (value & 0x7F);  }  
Magic Number,AssetImporter,BinaryExtensions,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\BinaryExtensions.cs,WriteUInt32_VariableLength,The following statement contains a magic number: buffer = (buffer << 8) | 0x80 | (value & 0x7F);  
Magic Number,AssetImporter,BinaryExtensions,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\BinaryExtensions.cs,WriteUInt32_VariableLength,The following statement contains a magic number: for (int i = 0; i < byteCount; ++i) {  	byte temp = (byte)(buffer & 0xFF);  	b.Write (temp);  	buffer >>= 8;  }  
Magic Number,AssetImporter,BinaryExtensions,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\BinaryExtensions.cs,WriteUInt32_VariableLength,The following statement contains a magic number: buffer >>= 8;  
Magic Number,AssetImporter,ActLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\ActLoader.cs,Load,The following statement contains a magic number: if (new FileInfo (sourceFileName).Length != 768) {  	throw new InvalidDataException ();  }  
Magic Number,AssetImporter,ActLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\ActLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (sourceFileName' FileMode.Open))) {  	for (int i = 0; i < 256; ++i) {  		colors [i] = new Rgba {  			R = binaryReader.ReadByte ()'  			G = binaryReader.ReadByte ()'  			B = binaryReader.ReadByte ()'  			A = byte.MaxValue  		};  	}  }  
Magic Number,AssetImporter,ActLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\ActLoader.cs,Load,The following statement contains a magic number: for (int i = 0; i < 256; ++i) {  	colors [i] = new Rgba {  		R = binaryReader.ReadByte ()'  		G = binaryReader.ReadByte ()'  		B = binaryReader.ReadByte ()'  		A = byte.MaxValue  	};  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (fileName' FileMode.Open))) {  	var form = new string (binaryReader.ReadChars (4));  	if (form != "FORM") {  		throw new InvalidDataException ();  	}  	uint fileLength = binaryReader.ReadUInt32 ();  	var PBM_ = new string (binaryReader.ReadChars (4));  	if (PBM_ != "PBM ") {  		throw new InvalidDataException ();  	}  	while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  		var id = new string (binaryReader.ReadChars (4));  		uint chunkLength = binaryReader.BE_ReadUInt32 ();  		if (chunkLength % 2 != 0) {  			++chunkLength;  		}  		byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  		if (id == "CMAP" && chunkLength == 256 * 3) {  			var rgba = new Rgba[256];  			for (int i = 0; i < 256; ++i) {  				rgba [i] = new Rgba {  					R = chunk [3 * i]'  					G = chunk [3 * i + 1]'  					B = chunk [3 * i + 2]'  					A = byte.MaxValue  				};  			}  			var newPalette = new Palette (rgba);  			PaletteLoader.Palettes.Add (newPalette);  			if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  				PaletteLoader.DefaultPalette = newPalette;  			}  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (fileName' FileMode.Open))) {  	var form = new string (binaryReader.ReadChars (4));  	if (form != "FORM") {  		throw new InvalidDataException ();  	}  	uint fileLength = binaryReader.ReadUInt32 ();  	var PBM_ = new string (binaryReader.ReadChars (4));  	if (PBM_ != "PBM ") {  		throw new InvalidDataException ();  	}  	while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  		var id = new string (binaryReader.ReadChars (4));  		uint chunkLength = binaryReader.BE_ReadUInt32 ();  		if (chunkLength % 2 != 0) {  			++chunkLength;  		}  		byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  		if (id == "CMAP" && chunkLength == 256 * 3) {  			var rgba = new Rgba[256];  			for (int i = 0; i < 256; ++i) {  				rgba [i] = new Rgba {  					R = chunk [3 * i]'  					G = chunk [3 * i + 1]'  					B = chunk [3 * i + 2]'  					A = byte.MaxValue  				};  			}  			var newPalette = new Palette (rgba);  			PaletteLoader.Palettes.Add (newPalette);  			if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  				PaletteLoader.DefaultPalette = newPalette;  			}  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (fileName' FileMode.Open))) {  	var form = new string (binaryReader.ReadChars (4));  	if (form != "FORM") {  		throw new InvalidDataException ();  	}  	uint fileLength = binaryReader.ReadUInt32 ();  	var PBM_ = new string (binaryReader.ReadChars (4));  	if (PBM_ != "PBM ") {  		throw new InvalidDataException ();  	}  	while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  		var id = new string (binaryReader.ReadChars (4));  		uint chunkLength = binaryReader.BE_ReadUInt32 ();  		if (chunkLength % 2 != 0) {  			++chunkLength;  		}  		byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  		if (id == "CMAP" && chunkLength == 256 * 3) {  			var rgba = new Rgba[256];  			for (int i = 0; i < 256; ++i) {  				rgba [i] = new Rgba {  					R = chunk [3 * i]'  					G = chunk [3 * i + 1]'  					B = chunk [3 * i + 2]'  					A = byte.MaxValue  				};  			}  			var newPalette = new Palette (rgba);  			PaletteLoader.Palettes.Add (newPalette);  			if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  				PaletteLoader.DefaultPalette = newPalette;  			}  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (fileName' FileMode.Open))) {  	var form = new string (binaryReader.ReadChars (4));  	if (form != "FORM") {  		throw new InvalidDataException ();  	}  	uint fileLength = binaryReader.ReadUInt32 ();  	var PBM_ = new string (binaryReader.ReadChars (4));  	if (PBM_ != "PBM ") {  		throw new InvalidDataException ();  	}  	while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  		var id = new string (binaryReader.ReadChars (4));  		uint chunkLength = binaryReader.BE_ReadUInt32 ();  		if (chunkLength % 2 != 0) {  			++chunkLength;  		}  		byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  		if (id == "CMAP" && chunkLength == 256 * 3) {  			var rgba = new Rgba[256];  			for (int i = 0; i < 256; ++i) {  				rgba [i] = new Rgba {  					R = chunk [3 * i]'  					G = chunk [3 * i + 1]'  					B = chunk [3 * i + 2]'  					A = byte.MaxValue  				};  			}  			var newPalette = new Palette (rgba);  			PaletteLoader.Palettes.Add (newPalette);  			if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  				PaletteLoader.DefaultPalette = newPalette;  			}  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (fileName' FileMode.Open))) {  	var form = new string (binaryReader.ReadChars (4));  	if (form != "FORM") {  		throw new InvalidDataException ();  	}  	uint fileLength = binaryReader.ReadUInt32 ();  	var PBM_ = new string (binaryReader.ReadChars (4));  	if (PBM_ != "PBM ") {  		throw new InvalidDataException ();  	}  	while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  		var id = new string (binaryReader.ReadChars (4));  		uint chunkLength = binaryReader.BE_ReadUInt32 ();  		if (chunkLength % 2 != 0) {  			++chunkLength;  		}  		byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  		if (id == "CMAP" && chunkLength == 256 * 3) {  			var rgba = new Rgba[256];  			for (int i = 0; i < 256; ++i) {  				rgba [i] = new Rgba {  					R = chunk [3 * i]'  					G = chunk [3 * i + 1]'  					B = chunk [3 * i + 2]'  					A = byte.MaxValue  				};  			}  			var newPalette = new Palette (rgba);  			PaletteLoader.Palettes.Add (newPalette);  			if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  				PaletteLoader.DefaultPalette = newPalette;  			}  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (fileName' FileMode.Open))) {  	var form = new string (binaryReader.ReadChars (4));  	if (form != "FORM") {  		throw new InvalidDataException ();  	}  	uint fileLength = binaryReader.ReadUInt32 ();  	var PBM_ = new string (binaryReader.ReadChars (4));  	if (PBM_ != "PBM ") {  		throw new InvalidDataException ();  	}  	while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  		var id = new string (binaryReader.ReadChars (4));  		uint chunkLength = binaryReader.BE_ReadUInt32 ();  		if (chunkLength % 2 != 0) {  			++chunkLength;  		}  		byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  		if (id == "CMAP" && chunkLength == 256 * 3) {  			var rgba = new Rgba[256];  			for (int i = 0; i < 256; ++i) {  				rgba [i] = new Rgba {  					R = chunk [3 * i]'  					G = chunk [3 * i + 1]'  					B = chunk [3 * i + 2]'  					A = byte.MaxValue  				};  			}  			var newPalette = new Palette (rgba);  			PaletteLoader.Palettes.Add (newPalette);  			if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  				PaletteLoader.DefaultPalette = newPalette;  			}  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (fileName' FileMode.Open))) {  	var form = new string (binaryReader.ReadChars (4));  	if (form != "FORM") {  		throw new InvalidDataException ();  	}  	uint fileLength = binaryReader.ReadUInt32 ();  	var PBM_ = new string (binaryReader.ReadChars (4));  	if (PBM_ != "PBM ") {  		throw new InvalidDataException ();  	}  	while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  		var id = new string (binaryReader.ReadChars (4));  		uint chunkLength = binaryReader.BE_ReadUInt32 ();  		if (chunkLength % 2 != 0) {  			++chunkLength;  		}  		byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  		if (id == "CMAP" && chunkLength == 256 * 3) {  			var rgba = new Rgba[256];  			for (int i = 0; i < 256; ++i) {  				rgba [i] = new Rgba {  					R = chunk [3 * i]'  					G = chunk [3 * i + 1]'  					B = chunk [3 * i + 2]'  					A = byte.MaxValue  				};  			}  			var newPalette = new Palette (rgba);  			PaletteLoader.Palettes.Add (newPalette);  			if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  				PaletteLoader.DefaultPalette = newPalette;  			}  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (fileName' FileMode.Open))) {  	var form = new string (binaryReader.ReadChars (4));  	if (form != "FORM") {  		throw new InvalidDataException ();  	}  	uint fileLength = binaryReader.ReadUInt32 ();  	var PBM_ = new string (binaryReader.ReadChars (4));  	if (PBM_ != "PBM ") {  		throw new InvalidDataException ();  	}  	while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  		var id = new string (binaryReader.ReadChars (4));  		uint chunkLength = binaryReader.BE_ReadUInt32 ();  		if (chunkLength % 2 != 0) {  			++chunkLength;  		}  		byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  		if (id == "CMAP" && chunkLength == 256 * 3) {  			var rgba = new Rgba[256];  			for (int i = 0; i < 256; ++i) {  				rgba [i] = new Rgba {  					R = chunk [3 * i]'  					G = chunk [3 * i + 1]'  					B = chunk [3 * i + 2]'  					A = byte.MaxValue  				};  			}  			var newPalette = new Palette (rgba);  			PaletteLoader.Palettes.Add (newPalette);  			if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  				PaletteLoader.DefaultPalette = newPalette;  			}  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (fileName' FileMode.Open))) {  	var form = new string (binaryReader.ReadChars (4));  	if (form != "FORM") {  		throw new InvalidDataException ();  	}  	uint fileLength = binaryReader.ReadUInt32 ();  	var PBM_ = new string (binaryReader.ReadChars (4));  	if (PBM_ != "PBM ") {  		throw new InvalidDataException ();  	}  	while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  		var id = new string (binaryReader.ReadChars (4));  		uint chunkLength = binaryReader.BE_ReadUInt32 ();  		if (chunkLength % 2 != 0) {  			++chunkLength;  		}  		byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  		if (id == "CMAP" && chunkLength == 256 * 3) {  			var rgba = new Rgba[256];  			for (int i = 0; i < 256; ++i) {  				rgba [i] = new Rgba {  					R = chunk [3 * i]'  					G = chunk [3 * i + 1]'  					B = chunk [3 * i + 2]'  					A = byte.MaxValue  				};  			}  			var newPalette = new Palette (rgba);  			PaletteLoader.Palettes.Add (newPalette);  			if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  				PaletteLoader.DefaultPalette = newPalette;  			}  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (fileName' FileMode.Open))) {  	var form = new string (binaryReader.ReadChars (4));  	if (form != "FORM") {  		throw new InvalidDataException ();  	}  	uint fileLength = binaryReader.ReadUInt32 ();  	var PBM_ = new string (binaryReader.ReadChars (4));  	if (PBM_ != "PBM ") {  		throw new InvalidDataException ();  	}  	while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  		var id = new string (binaryReader.ReadChars (4));  		uint chunkLength = binaryReader.BE_ReadUInt32 ();  		if (chunkLength % 2 != 0) {  			++chunkLength;  		}  		byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  		if (id == "CMAP" && chunkLength == 256 * 3) {  			var rgba = new Rgba[256];  			for (int i = 0; i < 256; ++i) {  				rgba [i] = new Rgba {  					R = chunk [3 * i]'  					G = chunk [3 * i + 1]'  					B = chunk [3 * i + 2]'  					A = byte.MaxValue  				};  			}  			var newPalette = new Palette (rgba);  			PaletteLoader.Palettes.Add (newPalette);  			if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  				PaletteLoader.DefaultPalette = newPalette;  			}  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (fileName' FileMode.Open))) {  	var form = new string (binaryReader.ReadChars (4));  	if (form != "FORM") {  		throw new InvalidDataException ();  	}  	uint fileLength = binaryReader.ReadUInt32 ();  	var PBM_ = new string (binaryReader.ReadChars (4));  	if (PBM_ != "PBM ") {  		throw new InvalidDataException ();  	}  	while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  		var id = new string (binaryReader.ReadChars (4));  		uint chunkLength = binaryReader.BE_ReadUInt32 ();  		if (chunkLength % 2 != 0) {  			++chunkLength;  		}  		byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  		if (id == "CMAP" && chunkLength == 256 * 3) {  			var rgba = new Rgba[256];  			for (int i = 0; i < 256; ++i) {  				rgba [i] = new Rgba {  					R = chunk [3 * i]'  					G = chunk [3 * i + 1]'  					B = chunk [3 * i + 2]'  					A = byte.MaxValue  				};  			}  			var newPalette = new Palette (rgba);  			PaletteLoader.Palettes.Add (newPalette);  			if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  				PaletteLoader.DefaultPalette = newPalette;  			}  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (fileName' FileMode.Open))) {  	var form = new string (binaryReader.ReadChars (4));  	if (form != "FORM") {  		throw new InvalidDataException ();  	}  	uint fileLength = binaryReader.ReadUInt32 ();  	var PBM_ = new string (binaryReader.ReadChars (4));  	if (PBM_ != "PBM ") {  		throw new InvalidDataException ();  	}  	while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  		var id = new string (binaryReader.ReadChars (4));  		uint chunkLength = binaryReader.BE_ReadUInt32 ();  		if (chunkLength % 2 != 0) {  			++chunkLength;  		}  		byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  		if (id == "CMAP" && chunkLength == 256 * 3) {  			var rgba = new Rgba[256];  			for (int i = 0; i < 256; ++i) {  				rgba [i] = new Rgba {  					R = chunk [3 * i]'  					G = chunk [3 * i + 1]'  					B = chunk [3 * i + 2]'  					A = byte.MaxValue  				};  			}  			var newPalette = new Palette (rgba);  			PaletteLoader.Palettes.Add (newPalette);  			if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  				PaletteLoader.DefaultPalette = newPalette;  			}  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  	var id = new string (binaryReader.ReadChars (4));  	uint chunkLength = binaryReader.BE_ReadUInt32 ();  	if (chunkLength % 2 != 0) {  		++chunkLength;  	}  	byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  	if (id == "CMAP" && chunkLength == 256 * 3) {  		var rgba = new Rgba[256];  		for (int i = 0; i < 256; ++i) {  			rgba [i] = new Rgba {  				R = chunk [3 * i]'  				G = chunk [3 * i + 1]'  				B = chunk [3 * i + 2]'  				A = byte.MaxValue  			};  		}  		var newPalette = new Palette (rgba);  		PaletteLoader.Palettes.Add (newPalette);  		if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  			PaletteLoader.DefaultPalette = newPalette;  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  	var id = new string (binaryReader.ReadChars (4));  	uint chunkLength = binaryReader.BE_ReadUInt32 ();  	if (chunkLength % 2 != 0) {  		++chunkLength;  	}  	byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  	if (id == "CMAP" && chunkLength == 256 * 3) {  		var rgba = new Rgba[256];  		for (int i = 0; i < 256; ++i) {  			rgba [i] = new Rgba {  				R = chunk [3 * i]'  				G = chunk [3 * i + 1]'  				B = chunk [3 * i + 2]'  				A = byte.MaxValue  			};  		}  		var newPalette = new Palette (rgba);  		PaletteLoader.Palettes.Add (newPalette);  		if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  			PaletteLoader.DefaultPalette = newPalette;  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  	var id = new string (binaryReader.ReadChars (4));  	uint chunkLength = binaryReader.BE_ReadUInt32 ();  	if (chunkLength % 2 != 0) {  		++chunkLength;  	}  	byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  	if (id == "CMAP" && chunkLength == 256 * 3) {  		var rgba = new Rgba[256];  		for (int i = 0; i < 256; ++i) {  			rgba [i] = new Rgba {  				R = chunk [3 * i]'  				G = chunk [3 * i + 1]'  				B = chunk [3 * i + 2]'  				A = byte.MaxValue  			};  		}  		var newPalette = new Palette (rgba);  		PaletteLoader.Palettes.Add (newPalette);  		if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  			PaletteLoader.DefaultPalette = newPalette;  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  	var id = new string (binaryReader.ReadChars (4));  	uint chunkLength = binaryReader.BE_ReadUInt32 ();  	if (chunkLength % 2 != 0) {  		++chunkLength;  	}  	byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  	if (id == "CMAP" && chunkLength == 256 * 3) {  		var rgba = new Rgba[256];  		for (int i = 0; i < 256; ++i) {  			rgba [i] = new Rgba {  				R = chunk [3 * i]'  				G = chunk [3 * i + 1]'  				B = chunk [3 * i + 2]'  				A = byte.MaxValue  			};  		}  		var newPalette = new Palette (rgba);  		PaletteLoader.Palettes.Add (newPalette);  		if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  			PaletteLoader.DefaultPalette = newPalette;  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  	var id = new string (binaryReader.ReadChars (4));  	uint chunkLength = binaryReader.BE_ReadUInt32 ();  	if (chunkLength % 2 != 0) {  		++chunkLength;  	}  	byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  	if (id == "CMAP" && chunkLength == 256 * 3) {  		var rgba = new Rgba[256];  		for (int i = 0; i < 256; ++i) {  			rgba [i] = new Rgba {  				R = chunk [3 * i]'  				G = chunk [3 * i + 1]'  				B = chunk [3 * i + 2]'  				A = byte.MaxValue  			};  		}  		var newPalette = new Palette (rgba);  		PaletteLoader.Palettes.Add (newPalette);  		if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  			PaletteLoader.DefaultPalette = newPalette;  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  	var id = new string (binaryReader.ReadChars (4));  	uint chunkLength = binaryReader.BE_ReadUInt32 ();  	if (chunkLength % 2 != 0) {  		++chunkLength;  	}  	byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  	if (id == "CMAP" && chunkLength == 256 * 3) {  		var rgba = new Rgba[256];  		for (int i = 0; i < 256; ++i) {  			rgba [i] = new Rgba {  				R = chunk [3 * i]'  				G = chunk [3 * i + 1]'  				B = chunk [3 * i + 2]'  				A = byte.MaxValue  			};  		}  		var newPalette = new Palette (rgba);  		PaletteLoader.Palettes.Add (newPalette);  		if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  			PaletteLoader.DefaultPalette = newPalette;  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  	var id = new string (binaryReader.ReadChars (4));  	uint chunkLength = binaryReader.BE_ReadUInt32 ();  	if (chunkLength % 2 != 0) {  		++chunkLength;  	}  	byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  	if (id == "CMAP" && chunkLength == 256 * 3) {  		var rgba = new Rgba[256];  		for (int i = 0; i < 256; ++i) {  			rgba [i] = new Rgba {  				R = chunk [3 * i]'  				G = chunk [3 * i + 1]'  				B = chunk [3 * i + 2]'  				A = byte.MaxValue  			};  		}  		var newPalette = new Palette (rgba);  		PaletteLoader.Palettes.Add (newPalette);  		if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  			PaletteLoader.DefaultPalette = newPalette;  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  	var id = new string (binaryReader.ReadChars (4));  	uint chunkLength = binaryReader.BE_ReadUInt32 ();  	if (chunkLength % 2 != 0) {  		++chunkLength;  	}  	byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  	if (id == "CMAP" && chunkLength == 256 * 3) {  		var rgba = new Rgba[256];  		for (int i = 0; i < 256; ++i) {  			rgba [i] = new Rgba {  				R = chunk [3 * i]'  				G = chunk [3 * i + 1]'  				B = chunk [3 * i + 2]'  				A = byte.MaxValue  			};  		}  		var newPalette = new Palette (rgba);  		PaletteLoader.Palettes.Add (newPalette);  		if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  			PaletteLoader.DefaultPalette = newPalette;  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  	var id = new string (binaryReader.ReadChars (4));  	uint chunkLength = binaryReader.BE_ReadUInt32 ();  	if (chunkLength % 2 != 0) {  		++chunkLength;  	}  	byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  	if (id == "CMAP" && chunkLength == 256 * 3) {  		var rgba = new Rgba[256];  		for (int i = 0; i < 256; ++i) {  			rgba [i] = new Rgba {  				R = chunk [3 * i]'  				G = chunk [3 * i + 1]'  				B = chunk [3 * i + 2]'  				A = byte.MaxValue  			};  		}  		var newPalette = new Palette (rgba);  		PaletteLoader.Palettes.Add (newPalette);  		if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  			PaletteLoader.DefaultPalette = newPalette;  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length) {  	var id = new string (binaryReader.ReadChars (4));  	uint chunkLength = binaryReader.BE_ReadUInt32 ();  	if (chunkLength % 2 != 0) {  		++chunkLength;  	}  	byte[] chunk = binaryReader.ReadBytes ((int)chunkLength);  	if (id == "CMAP" && chunkLength == 256 * 3) {  		var rgba = new Rgba[256];  		for (int i = 0; i < 256; ++i) {  			rgba [i] = new Rgba {  				R = chunk [3 * i]'  				G = chunk [3 * i + 1]'  				B = chunk [3 * i + 2]'  				A = byte.MaxValue  			};  		}  		var newPalette = new Palette (rgba);  		PaletteLoader.Palettes.Add (newPalette);  		if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  			PaletteLoader.DefaultPalette = newPalette;  		}  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: if (chunkLength % 2 != 0) {  	++chunkLength;  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: if (id == "CMAP" && chunkLength == 256 * 3) {  	var rgba = new Rgba[256];  	for (int i = 0; i < 256; ++i) {  		rgba [i] = new Rgba {  			R = chunk [3 * i]'  			G = chunk [3 * i + 1]'  			B = chunk [3 * i + 2]'  			A = byte.MaxValue  		};  	}  	var newPalette = new Palette (rgba);  	PaletteLoader.Palettes.Add (newPalette);  	if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  		PaletteLoader.DefaultPalette = newPalette;  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: if (id == "CMAP" && chunkLength == 256 * 3) {  	var rgba = new Rgba[256];  	for (int i = 0; i < 256; ++i) {  		rgba [i] = new Rgba {  			R = chunk [3 * i]'  			G = chunk [3 * i + 1]'  			B = chunk [3 * i + 2]'  			A = byte.MaxValue  		};  	}  	var newPalette = new Palette (rgba);  	PaletteLoader.Palettes.Add (newPalette);  	if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  		PaletteLoader.DefaultPalette = newPalette;  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: if (id == "CMAP" && chunkLength == 256 * 3) {  	var rgba = new Rgba[256];  	for (int i = 0; i < 256; ++i) {  		rgba [i] = new Rgba {  			R = chunk [3 * i]'  			G = chunk [3 * i + 1]'  			B = chunk [3 * i + 2]'  			A = byte.MaxValue  		};  	}  	var newPalette = new Palette (rgba);  	PaletteLoader.Palettes.Add (newPalette);  	if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  		PaletteLoader.DefaultPalette = newPalette;  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: if (id == "CMAP" && chunkLength == 256 * 3) {  	var rgba = new Rgba[256];  	for (int i = 0; i < 256; ++i) {  		rgba [i] = new Rgba {  			R = chunk [3 * i]'  			G = chunk [3 * i + 1]'  			B = chunk [3 * i + 2]'  			A = byte.MaxValue  		};  	}  	var newPalette = new Palette (rgba);  	PaletteLoader.Palettes.Add (newPalette);  	if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  		PaletteLoader.DefaultPalette = newPalette;  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: if (id == "CMAP" && chunkLength == 256 * 3) {  	var rgba = new Rgba[256];  	for (int i = 0; i < 256; ++i) {  		rgba [i] = new Rgba {  			R = chunk [3 * i]'  			G = chunk [3 * i + 1]'  			B = chunk [3 * i + 2]'  			A = byte.MaxValue  		};  	}  	var newPalette = new Palette (rgba);  	PaletteLoader.Palettes.Add (newPalette);  	if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  		PaletteLoader.DefaultPalette = newPalette;  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: if (id == "CMAP" && chunkLength == 256 * 3) {  	var rgba = new Rgba[256];  	for (int i = 0; i < 256; ++i) {  		rgba [i] = new Rgba {  			R = chunk [3 * i]'  			G = chunk [3 * i + 1]'  			B = chunk [3 * i + 2]'  			A = byte.MaxValue  		};  	}  	var newPalette = new Palette (rgba);  	PaletteLoader.Palettes.Add (newPalette);  	if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  		PaletteLoader.DefaultPalette = newPalette;  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: if (id == "CMAP" && chunkLength == 256 * 3) {  	var rgba = new Rgba[256];  	for (int i = 0; i < 256; ++i) {  		rgba [i] = new Rgba {  			R = chunk [3 * i]'  			G = chunk [3 * i + 1]'  			B = chunk [3 * i + 2]'  			A = byte.MaxValue  		};  	}  	var newPalette = new Palette (rgba);  	PaletteLoader.Palettes.Add (newPalette);  	if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  		PaletteLoader.DefaultPalette = newPalette;  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: if (id == "CMAP" && chunkLength == 256 * 3) {  	var rgba = new Rgba[256];  	for (int i = 0; i < 256; ++i) {  		rgba [i] = new Rgba {  			R = chunk [3 * i]'  			G = chunk [3 * i + 1]'  			B = chunk [3 * i + 2]'  			A = byte.MaxValue  		};  	}  	var newPalette = new Palette (rgba);  	PaletteLoader.Palettes.Add (newPalette);  	if (Path.GetFileNameWithoutExtension (fileName) == "PAL5") {  		PaletteLoader.DefaultPalette = newPalette;  	}  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: for (int i = 0; i < 256; ++i) {  	rgba [i] = new Rgba {  		R = chunk [3 * i]'  		G = chunk [3 * i + 1]'  		B = chunk [3 * i + 2]'  		A = byte.MaxValue  	};  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: for (int i = 0; i < 256; ++i) {  	rgba [i] = new Rgba {  		R = chunk [3 * i]'  		G = chunk [3 * i + 1]'  		B = chunk [3 * i + 2]'  		A = byte.MaxValue  	};  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: for (int i = 0; i < 256; ++i) {  	rgba [i] = new Rgba {  		R = chunk [3 * i]'  		G = chunk [3 * i + 1]'  		B = chunk [3 * i + 2]'  		A = byte.MaxValue  	};  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: for (int i = 0; i < 256; ++i) {  	rgba [i] = new Rgba {  		R = chunk [3 * i]'  		G = chunk [3 * i + 1]'  		B = chunk [3 * i + 2]'  		A = byte.MaxValue  	};  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: for (int i = 0; i < 256; ++i) {  	rgba [i] = new Rgba {  		R = chunk [3 * i]'  		G = chunk [3 * i + 1]'  		B = chunk [3 * i + 2]'  		A = byte.MaxValue  	};  }  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: rgba [i] = new Rgba {  	R = chunk [3 * i]'  	G = chunk [3 * i + 1]'  	B = chunk [3 * i + 2]'  	A = byte.MaxValue  };  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: rgba [i] = new Rgba {  	R = chunk [3 * i]'  	G = chunk [3 * i + 1]'  	B = chunk [3 * i + 2]'  	A = byte.MaxValue  };  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: rgba [i] = new Rgba {  	R = chunk [3 * i]'  	G = chunk [3 * i + 1]'  	B = chunk [3 * i + 2]'  	A = byte.MaxValue  };  
Magic Number,AssetImporter,BbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BbmLoader.cs,Load,The following statement contains a magic number: rgba [i] = new Rgba {  	R = chunk [3 * i]'  	G = chunk [3 * i + 1]'  	B = chunk [3 * i + 2]'  	A = byte.MaxValue  };  
Magic Number,AssetImporter,BitmapRleLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BitmapRleLoader.cs,Load,The following statement contains a magic number: binaryReader.BaseStream.Seek (4' SeekOrigin.Current);  
Magic Number,AssetImporter,BitmapRleLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BitmapRleLoader.cs,Load,The following statement contains a magic number: binaryReader.BaseStream.Seek (2' SeekOrigin.Current);  
Magic Number,AssetImporter,BitmapRleLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BitmapRleLoader.cs,Load,The following statement contains a magic number: binaryReader.BaseStream.Seek (2 * height' SeekOrigin.Current);  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (sourceFile' FileMode.Open))) {  	uint header = binaryReader.BE_ReadUInt32 ();  	if (header != 0xF601F501) {  		throw new Exception (sourceFile + "is an invalid .BOB file");  	}  	// Size of the first color block  	ushort size = binaryReader.ReadUInt16 ();  	// Read first color block  	var imageData = binaryReader.ReadBytes (size);  	var playerBitmapLoader = new PlayerBitmapLoader ();  	for (int i = 0; i < 96; ++i) {  		playerBitmapLoader.Load (imageData' destinationDirectory' "untitled" + i' binaryReader);  	}  	// 6 next color blocks  	var color = new byte[6][];  	var sizes = new ushort[6];  	for (int i = 0; i < 6; ++i) {  		ushort id = binaryReader.BE_ReadUInt16 ();  		if (id != 0xF501) {  			throw new Exception (sourceFile + "is an invalid .BOB file");  		}  		sizes [i] = binaryReader.ReadUInt16 ();  		color [i] = binaryReader.ReadBytes (sizes [i]);  	}  	ushort numImagesProduced = binaryReader.ReadUInt16 ();  	// Read heights' row data offsets and yOffsets for each image to be produced  	var heights = new byte[numImagesProduced];  	var rowDataOffsets = new ushort[numImagesProduced][];  	var yOffsets = new byte[numImagesProduced];  	for (int i = 0; i < numImagesProduced; ++i) {  		ushort id = binaryReader.BE_ReadUInt16 ();  		if (id != 0xF401) {  			throw new Exception (sourceFile + "is an invalid .BOB file");  		}  		heights [i] = binaryReader.ReadByte ();  		rowDataOffsets [i] = new ushort[heights [i]];  		for (int j = 0; j < heights [i]; ++j) {  			rowDataOffsets [i] [j] = binaryReader.ReadUInt16 ();  		}  		yOffsets [i] = binaryReader.ReadByte ();  	}  	ushort itemCount = binaryReader.ReadUInt16 ();  	var used = new bool[numImagesProduced];  	// This algorithm is a bit hard to understand. Why not just loop from 0 to numImagesProduced?  	// The point is that the file specifies what to produce in a certain order' and certain images  	// are actually repeated.  	var resourceName = Path.GetFileNameWithoutExtension (sourceFile);  	for (int i = 0; i < itemCount; ++i) {  		ushort index = binaryReader.ReadUInt16 ();  		if (!used [index]) {  			playerBitmapLoader.Load (32' heights [index]' 16' yOffsets [index]' color [i % 6]' rowDataOffsets [index]' destinationDirectory' resourceName + i);  		}  		used [index] = true;  		binaryReader.BaseStream.Seek (2' SeekOrigin.Current);  	}  }  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (sourceFile' FileMode.Open))) {  	uint header = binaryReader.BE_ReadUInt32 ();  	if (header != 0xF601F501) {  		throw new Exception (sourceFile + "is an invalid .BOB file");  	}  	// Size of the first color block  	ushort size = binaryReader.ReadUInt16 ();  	// Read first color block  	var imageData = binaryReader.ReadBytes (size);  	var playerBitmapLoader = new PlayerBitmapLoader ();  	for (int i = 0; i < 96; ++i) {  		playerBitmapLoader.Load (imageData' destinationDirectory' "untitled" + i' binaryReader);  	}  	// 6 next color blocks  	var color = new byte[6][];  	var sizes = new ushort[6];  	for (int i = 0; i < 6; ++i) {  		ushort id = binaryReader.BE_ReadUInt16 ();  		if (id != 0xF501) {  			throw new Exception (sourceFile + "is an invalid .BOB file");  		}  		sizes [i] = binaryReader.ReadUInt16 ();  		color [i] = binaryReader.ReadBytes (sizes [i]);  	}  	ushort numImagesProduced = binaryReader.ReadUInt16 ();  	// Read heights' row data offsets and yOffsets for each image to be produced  	var heights = new byte[numImagesProduced];  	var rowDataOffsets = new ushort[numImagesProduced][];  	var yOffsets = new byte[numImagesProduced];  	for (int i = 0; i < numImagesProduced; ++i) {  		ushort id = binaryReader.BE_ReadUInt16 ();  		if (id != 0xF401) {  			throw new Exception (sourceFile + "is an invalid .BOB file");  		}  		heights [i] = binaryReader.ReadByte ();  		rowDataOffsets [i] = new ushort[heights [i]];  		for (int j = 0; j < heights [i]; ++j) {  			rowDataOffsets [i] [j] = binaryReader.ReadUInt16 ();  		}  		yOffsets [i] = binaryReader.ReadByte ();  	}  	ushort itemCount = binaryReader.ReadUInt16 ();  	var used = new bool[numImagesProduced];  	// This algorithm is a bit hard to understand. Why not just loop from 0 to numImagesProduced?  	// The point is that the file specifies what to produce in a certain order' and certain images  	// are actually repeated.  	var resourceName = Path.GetFileNameWithoutExtension (sourceFile);  	for (int i = 0; i < itemCount; ++i) {  		ushort index = binaryReader.ReadUInt16 ();  		if (!used [index]) {  			playerBitmapLoader.Load (32' heights [index]' 16' yOffsets [index]' color [i % 6]' rowDataOffsets [index]' destinationDirectory' resourceName + i);  		}  		used [index] = true;  		binaryReader.BaseStream.Seek (2' SeekOrigin.Current);  	}  }  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (sourceFile' FileMode.Open))) {  	uint header = binaryReader.BE_ReadUInt32 ();  	if (header != 0xF601F501) {  		throw new Exception (sourceFile + "is an invalid .BOB file");  	}  	// Size of the first color block  	ushort size = binaryReader.ReadUInt16 ();  	// Read first color block  	var imageData = binaryReader.ReadBytes (size);  	var playerBitmapLoader = new PlayerBitmapLoader ();  	for (int i = 0; i < 96; ++i) {  		playerBitmapLoader.Load (imageData' destinationDirectory' "untitled" + i' binaryReader);  	}  	// 6 next color blocks  	var color = new byte[6][];  	var sizes = new ushort[6];  	for (int i = 0; i < 6; ++i) {  		ushort id = binaryReader.BE_ReadUInt16 ();  		if (id != 0xF501) {  			throw new Exception (sourceFile + "is an invalid .BOB file");  		}  		sizes [i] = binaryReader.ReadUInt16 ();  		color [i] = binaryReader.ReadBytes (sizes [i]);  	}  	ushort numImagesProduced = binaryReader.ReadUInt16 ();  	// Read heights' row data offsets and yOffsets for each image to be produced  	var heights = new byte[numImagesProduced];  	var rowDataOffsets = new ushort[numImagesProduced][];  	var yOffsets = new byte[numImagesProduced];  	for (int i = 0; i < numImagesProduced; ++i) {  		ushort id = binaryReader.BE_ReadUInt16 ();  		if (id != 0xF401) {  			throw new Exception (sourceFile + "is an invalid .BOB file");  		}  		heights [i] = binaryReader.ReadByte ();  		rowDataOffsets [i] = new ushort[heights [i]];  		for (int j = 0; j < heights [i]; ++j) {  			rowDataOffsets [i] [j] = binaryReader.ReadUInt16 ();  		}  		yOffsets [i] = binaryReader.ReadByte ();  	}  	ushort itemCount = binaryReader.ReadUInt16 ();  	var used = new bool[numImagesProduced];  	// This algorithm is a bit hard to understand. Why not just loop from 0 to numImagesProduced?  	// The point is that the file specifies what to produce in a certain order' and certain images  	// are actually repeated.  	var resourceName = Path.GetFileNameWithoutExtension (sourceFile);  	for (int i = 0; i < itemCount; ++i) {  		ushort index = binaryReader.ReadUInt16 ();  		if (!used [index]) {  			playerBitmapLoader.Load (32' heights [index]' 16' yOffsets [index]' color [i % 6]' rowDataOffsets [index]' destinationDirectory' resourceName + i);  		}  		used [index] = true;  		binaryReader.BaseStream.Seek (2' SeekOrigin.Current);  	}  }  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (sourceFile' FileMode.Open))) {  	uint header = binaryReader.BE_ReadUInt32 ();  	if (header != 0xF601F501) {  		throw new Exception (sourceFile + "is an invalid .BOB file");  	}  	// Size of the first color block  	ushort size = binaryReader.ReadUInt16 ();  	// Read first color block  	var imageData = binaryReader.ReadBytes (size);  	var playerBitmapLoader = new PlayerBitmapLoader ();  	for (int i = 0; i < 96; ++i) {  		playerBitmapLoader.Load (imageData' destinationDirectory' "untitled" + i' binaryReader);  	}  	// 6 next color blocks  	var color = new byte[6][];  	var sizes = new ushort[6];  	for (int i = 0; i < 6; ++i) {  		ushort id = binaryReader.BE_ReadUInt16 ();  		if (id != 0xF501) {  			throw new Exception (sourceFile + "is an invalid .BOB file");  		}  		sizes [i] = binaryReader.ReadUInt16 ();  		color [i] = binaryReader.ReadBytes (sizes [i]);  	}  	ushort numImagesProduced = binaryReader.ReadUInt16 ();  	// Read heights' row data offsets and yOffsets for each image to be produced  	var heights = new byte[numImagesProduced];  	var rowDataOffsets = new ushort[numImagesProduced][];  	var yOffsets = new byte[numImagesProduced];  	for (int i = 0; i < numImagesProduced; ++i) {  		ushort id = binaryReader.BE_ReadUInt16 ();  		if (id != 0xF401) {  			throw new Exception (sourceFile + "is an invalid .BOB file");  		}  		heights [i] = binaryReader.ReadByte ();  		rowDataOffsets [i] = new ushort[heights [i]];  		for (int j = 0; j < heights [i]; ++j) {  			rowDataOffsets [i] [j] = binaryReader.ReadUInt16 ();  		}  		yOffsets [i] = binaryReader.ReadByte ();  	}  	ushort itemCount = binaryReader.ReadUInt16 ();  	var used = new bool[numImagesProduced];  	// This algorithm is a bit hard to understand. Why not just loop from 0 to numImagesProduced?  	// The point is that the file specifies what to produce in a certain order' and certain images  	// are actually repeated.  	var resourceName = Path.GetFileNameWithoutExtension (sourceFile);  	for (int i = 0; i < itemCount; ++i) {  		ushort index = binaryReader.ReadUInt16 ();  		if (!used [index]) {  			playerBitmapLoader.Load (32' heights [index]' 16' yOffsets [index]' color [i % 6]' rowDataOffsets [index]' destinationDirectory' resourceName + i);  		}  		used [index] = true;  		binaryReader.BaseStream.Seek (2' SeekOrigin.Current);  	}  }  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (sourceFile' FileMode.Open))) {  	uint header = binaryReader.BE_ReadUInt32 ();  	if (header != 0xF601F501) {  		throw new Exception (sourceFile + "is an invalid .BOB file");  	}  	// Size of the first color block  	ushort size = binaryReader.ReadUInt16 ();  	// Read first color block  	var imageData = binaryReader.ReadBytes (size);  	var playerBitmapLoader = new PlayerBitmapLoader ();  	for (int i = 0; i < 96; ++i) {  		playerBitmapLoader.Load (imageData' destinationDirectory' "untitled" + i' binaryReader);  	}  	// 6 next color blocks  	var color = new byte[6][];  	var sizes = new ushort[6];  	for (int i = 0; i < 6; ++i) {  		ushort id = binaryReader.BE_ReadUInt16 ();  		if (id != 0xF501) {  			throw new Exception (sourceFile + "is an invalid .BOB file");  		}  		sizes [i] = binaryReader.ReadUInt16 ();  		color [i] = binaryReader.ReadBytes (sizes [i]);  	}  	ushort numImagesProduced = binaryReader.ReadUInt16 ();  	// Read heights' row data offsets and yOffsets for each image to be produced  	var heights = new byte[numImagesProduced];  	var rowDataOffsets = new ushort[numImagesProduced][];  	var yOffsets = new byte[numImagesProduced];  	for (int i = 0; i < numImagesProduced; ++i) {  		ushort id = binaryReader.BE_ReadUInt16 ();  		if (id != 0xF401) {  			throw new Exception (sourceFile + "is an invalid .BOB file");  		}  		heights [i] = binaryReader.ReadByte ();  		rowDataOffsets [i] = new ushort[heights [i]];  		for (int j = 0; j < heights [i]; ++j) {  			rowDataOffsets [i] [j] = binaryReader.ReadUInt16 ();  		}  		yOffsets [i] = binaryReader.ReadByte ();  	}  	ushort itemCount = binaryReader.ReadUInt16 ();  	var used = new bool[numImagesProduced];  	// This algorithm is a bit hard to understand. Why not just loop from 0 to numImagesProduced?  	// The point is that the file specifies what to produce in a certain order' and certain images  	// are actually repeated.  	var resourceName = Path.GetFileNameWithoutExtension (sourceFile);  	for (int i = 0; i < itemCount; ++i) {  		ushort index = binaryReader.ReadUInt16 ();  		if (!used [index]) {  			playerBitmapLoader.Load (32' heights [index]' 16' yOffsets [index]' color [i % 6]' rowDataOffsets [index]' destinationDirectory' resourceName + i);  		}  		used [index] = true;  		binaryReader.BaseStream.Seek (2' SeekOrigin.Current);  	}  }  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (sourceFile' FileMode.Open))) {  	uint header = binaryReader.BE_ReadUInt32 ();  	if (header != 0xF601F501) {  		throw new Exception (sourceFile + "is an invalid .BOB file");  	}  	// Size of the first color block  	ushort size = binaryReader.ReadUInt16 ();  	// Read first color block  	var imageData = binaryReader.ReadBytes (size);  	var playerBitmapLoader = new PlayerBitmapLoader ();  	for (int i = 0; i < 96; ++i) {  		playerBitmapLoader.Load (imageData' destinationDirectory' "untitled" + i' binaryReader);  	}  	// 6 next color blocks  	var color = new byte[6][];  	var sizes = new ushort[6];  	for (int i = 0; i < 6; ++i) {  		ushort id = binaryReader.BE_ReadUInt16 ();  		if (id != 0xF501) {  			throw new Exception (sourceFile + "is an invalid .BOB file");  		}  		sizes [i] = binaryReader.ReadUInt16 ();  		color [i] = binaryReader.ReadBytes (sizes [i]);  	}  	ushort numImagesProduced = binaryReader.ReadUInt16 ();  	// Read heights' row data offsets and yOffsets for each image to be produced  	var heights = new byte[numImagesProduced];  	var rowDataOffsets = new ushort[numImagesProduced][];  	var yOffsets = new byte[numImagesProduced];  	for (int i = 0; i < numImagesProduced; ++i) {  		ushort id = binaryReader.BE_ReadUInt16 ();  		if (id != 0xF401) {  			throw new Exception (sourceFile + "is an invalid .BOB file");  		}  		heights [i] = binaryReader.ReadByte ();  		rowDataOffsets [i] = new ushort[heights [i]];  		for (int j = 0; j < heights [i]; ++j) {  			rowDataOffsets [i] [j] = binaryReader.ReadUInt16 ();  		}  		yOffsets [i] = binaryReader.ReadByte ();  	}  	ushort itemCount = binaryReader.ReadUInt16 ();  	var used = new bool[numImagesProduced];  	// This algorithm is a bit hard to understand. Why not just loop from 0 to numImagesProduced?  	// The point is that the file specifies what to produce in a certain order' and certain images  	// are actually repeated.  	var resourceName = Path.GetFileNameWithoutExtension (sourceFile);  	for (int i = 0; i < itemCount; ++i) {  		ushort index = binaryReader.ReadUInt16 ();  		if (!used [index]) {  			playerBitmapLoader.Load (32' heights [index]' 16' yOffsets [index]' color [i % 6]' rowDataOffsets [index]' destinationDirectory' resourceName + i);  		}  		used [index] = true;  		binaryReader.BaseStream.Seek (2' SeekOrigin.Current);  	}  }  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (sourceFile' FileMode.Open))) {  	uint header = binaryReader.BE_ReadUInt32 ();  	if (header != 0xF601F501) {  		throw new Exception (sourceFile + "is an invalid .BOB file");  	}  	// Size of the first color block  	ushort size = binaryReader.ReadUInt16 ();  	// Read first color block  	var imageData = binaryReader.ReadBytes (size);  	var playerBitmapLoader = new PlayerBitmapLoader ();  	for (int i = 0; i < 96; ++i) {  		playerBitmapLoader.Load (imageData' destinationDirectory' "untitled" + i' binaryReader);  	}  	// 6 next color blocks  	var color = new byte[6][];  	var sizes = new ushort[6];  	for (int i = 0; i < 6; ++i) {  		ushort id = binaryReader.BE_ReadUInt16 ();  		if (id != 0xF501) {  			throw new Exception (sourceFile + "is an invalid .BOB file");  		}  		sizes [i] = binaryReader.ReadUInt16 ();  		color [i] = binaryReader.ReadBytes (sizes [i]);  	}  	ushort numImagesProduced = binaryReader.ReadUInt16 ();  	// Read heights' row data offsets and yOffsets for each image to be produced  	var heights = new byte[numImagesProduced];  	var rowDataOffsets = new ushort[numImagesProduced][];  	var yOffsets = new byte[numImagesProduced];  	for (int i = 0; i < numImagesProduced; ++i) {  		ushort id = binaryReader.BE_ReadUInt16 ();  		if (id != 0xF401) {  			throw new Exception (sourceFile + "is an invalid .BOB file");  		}  		heights [i] = binaryReader.ReadByte ();  		rowDataOffsets [i] = new ushort[heights [i]];  		for (int j = 0; j < heights [i]; ++j) {  			rowDataOffsets [i] [j] = binaryReader.ReadUInt16 ();  		}  		yOffsets [i] = binaryReader.ReadByte ();  	}  	ushort itemCount = binaryReader.ReadUInt16 ();  	var used = new bool[numImagesProduced];  	// This algorithm is a bit hard to understand. Why not just loop from 0 to numImagesProduced?  	// The point is that the file specifies what to produce in a certain order' and certain images  	// are actually repeated.  	var resourceName = Path.GetFileNameWithoutExtension (sourceFile);  	for (int i = 0; i < itemCount; ++i) {  		ushort index = binaryReader.ReadUInt16 ();  		if (!used [index]) {  			playerBitmapLoader.Load (32' heights [index]' 16' yOffsets [index]' color [i % 6]' rowDataOffsets [index]' destinationDirectory' resourceName + i);  		}  		used [index] = true;  		binaryReader.BaseStream.Seek (2' SeekOrigin.Current);  	}  }  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (sourceFile' FileMode.Open))) {  	uint header = binaryReader.BE_ReadUInt32 ();  	if (header != 0xF601F501) {  		throw new Exception (sourceFile + "is an invalid .BOB file");  	}  	// Size of the first color block  	ushort size = binaryReader.ReadUInt16 ();  	// Read first color block  	var imageData = binaryReader.ReadBytes (size);  	var playerBitmapLoader = new PlayerBitmapLoader ();  	for (int i = 0; i < 96; ++i) {  		playerBitmapLoader.Load (imageData' destinationDirectory' "untitled" + i' binaryReader);  	}  	// 6 next color blocks  	var color = new byte[6][];  	var sizes = new ushort[6];  	for (int i = 0; i < 6; ++i) {  		ushort id = binaryReader.BE_ReadUInt16 ();  		if (id != 0xF501) {  			throw new Exception (sourceFile + "is an invalid .BOB file");  		}  		sizes [i] = binaryReader.ReadUInt16 ();  		color [i] = binaryReader.ReadBytes (sizes [i]);  	}  	ushort numImagesProduced = binaryReader.ReadUInt16 ();  	// Read heights' row data offsets and yOffsets for each image to be produced  	var heights = new byte[numImagesProduced];  	var rowDataOffsets = new ushort[numImagesProduced][];  	var yOffsets = new byte[numImagesProduced];  	for (int i = 0; i < numImagesProduced; ++i) {  		ushort id = binaryReader.BE_ReadUInt16 ();  		if (id != 0xF401) {  			throw new Exception (sourceFile + "is an invalid .BOB file");  		}  		heights [i] = binaryReader.ReadByte ();  		rowDataOffsets [i] = new ushort[heights [i]];  		for (int j = 0; j < heights [i]; ++j) {  			rowDataOffsets [i] [j] = binaryReader.ReadUInt16 ();  		}  		yOffsets [i] = binaryReader.ReadByte ();  	}  	ushort itemCount = binaryReader.ReadUInt16 ();  	var used = new bool[numImagesProduced];  	// This algorithm is a bit hard to understand. Why not just loop from 0 to numImagesProduced?  	// The point is that the file specifies what to produce in a certain order' and certain images  	// are actually repeated.  	var resourceName = Path.GetFileNameWithoutExtension (sourceFile);  	for (int i = 0; i < itemCount; ++i) {  		ushort index = binaryReader.ReadUInt16 ();  		if (!used [index]) {  			playerBitmapLoader.Load (32' heights [index]' 16' yOffsets [index]' color [i % 6]' rowDataOffsets [index]' destinationDirectory' resourceName + i);  		}  		used [index] = true;  		binaryReader.BaseStream.Seek (2' SeekOrigin.Current);  	}  }  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: for (int i = 0; i < 96; ++i) {  	playerBitmapLoader.Load (imageData' destinationDirectory' "untitled" + i' binaryReader);  }  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: for (int i = 0; i < 6; ++i) {  	ushort id = binaryReader.BE_ReadUInt16 ();  	if (id != 0xF501) {  		throw new Exception (sourceFile + "is an invalid .BOB file");  	}  	sizes [i] = binaryReader.ReadUInt16 ();  	color [i] = binaryReader.ReadBytes (sizes [i]);  }  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: for (int i = 0; i < itemCount; ++i) {  	ushort index = binaryReader.ReadUInt16 ();  	if (!used [index]) {  		playerBitmapLoader.Load (32' heights [index]' 16' yOffsets [index]' color [i % 6]' rowDataOffsets [index]' destinationDirectory' resourceName + i);  	}  	used [index] = true;  	binaryReader.BaseStream.Seek (2' SeekOrigin.Current);  }  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: for (int i = 0; i < itemCount; ++i) {  	ushort index = binaryReader.ReadUInt16 ();  	if (!used [index]) {  		playerBitmapLoader.Load (32' heights [index]' 16' yOffsets [index]' color [i % 6]' rowDataOffsets [index]' destinationDirectory' resourceName + i);  	}  	used [index] = true;  	binaryReader.BaseStream.Seek (2' SeekOrigin.Current);  }  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: for (int i = 0; i < itemCount; ++i) {  	ushort index = binaryReader.ReadUInt16 ();  	if (!used [index]) {  		playerBitmapLoader.Load (32' heights [index]' 16' yOffsets [index]' color [i % 6]' rowDataOffsets [index]' destinationDirectory' resourceName + i);  	}  	used [index] = true;  	binaryReader.BaseStream.Seek (2' SeekOrigin.Current);  }  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: for (int i = 0; i < itemCount; ++i) {  	ushort index = binaryReader.ReadUInt16 ();  	if (!used [index]) {  		playerBitmapLoader.Load (32' heights [index]' 16' yOffsets [index]' color [i % 6]' rowDataOffsets [index]' destinationDirectory' resourceName + i);  	}  	used [index] = true;  	binaryReader.BaseStream.Seek (2' SeekOrigin.Current);  }  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: if (!used [index]) {  	playerBitmapLoader.Load (32' heights [index]' 16' yOffsets [index]' color [i % 6]' rowDataOffsets [index]' destinationDirectory' resourceName + i);  }  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: if (!used [index]) {  	playerBitmapLoader.Load (32' heights [index]' 16' yOffsets [index]' color [i % 6]' rowDataOffsets [index]' destinationDirectory' resourceName + i);  }  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: if (!used [index]) {  	playerBitmapLoader.Load (32' heights [index]' 16' yOffsets [index]' color [i % 6]' rowDataOffsets [index]' destinationDirectory' resourceName + i);  }  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: playerBitmapLoader.Load (32' heights [index]' 16' yOffsets [index]' color [i % 6]' rowDataOffsets [index]' destinationDirectory' resourceName + i);  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: playerBitmapLoader.Load (32' heights [index]' 16' yOffsets [index]' color [i % 6]' rowDataOffsets [index]' destinationDirectory' resourceName + i);  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: playerBitmapLoader.Load (32' heights [index]' 16' yOffsets [index]' color [i % 6]' rowDataOffsets [index]' destinationDirectory' resourceName + i);  
Magic Number,AssetImporter,BobLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\BobLoader.cs,Load,The following statement contains a magic number: binaryReader.BaseStream.Seek (2' SeekOrigin.Current);  
Magic Number,AssetImporter,IdxLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\IdxLoader.cs,Load,The following statement contains a magic number: using (var idxFile = new BinaryReader (File.Open (idxFileName' FileMode.Open)))  	using (var datFile = new BinaryReader (File.Open (datFileName' FileMode.Open))) {  		var numEntries = idxFile.ReadUInt32 ();  		for (var i = 0; i < numEntries; ++i) {  			var name = idxFile.ReadNullTerminatedASCIIString (16);  			var offset = idxFile.ReadUInt32 ();  			idxFile.BaseStream.Seek (6' SeekOrigin.Current);  			datFile.BaseStream.Seek (offset' SeekOrigin.Begin);  			var idxBaseFormat = (BaseFormat)idxFile.ReadInt16 ();  			Entries.Add (new IdxEntry {  				Name = name'  				BaseFormat = idxBaseFormat'  				Offset = offset  			});  		}  		foreach (var entry in Entries) {  			datFile.BaseStream.Seek (entry.Offset' SeekOrigin.Begin);  			var datBaseFormat = (BaseFormat)datFile.ReadInt16 ();  			if (entry.BaseFormat != datBaseFormat) {  				throw new Exception ("WTF");  			}  			Loader.LoadBaseFormat (entry.BaseFormat' destinationDirectory' entry.Name' datFile);  		}  	}  
Magic Number,AssetImporter,IdxLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\IdxLoader.cs,Load,The following statement contains a magic number: using (var idxFile = new BinaryReader (File.Open (idxFileName' FileMode.Open)))  	using (var datFile = new BinaryReader (File.Open (datFileName' FileMode.Open))) {  		var numEntries = idxFile.ReadUInt32 ();  		for (var i = 0; i < numEntries; ++i) {  			var name = idxFile.ReadNullTerminatedASCIIString (16);  			var offset = idxFile.ReadUInt32 ();  			idxFile.BaseStream.Seek (6' SeekOrigin.Current);  			datFile.BaseStream.Seek (offset' SeekOrigin.Begin);  			var idxBaseFormat = (BaseFormat)idxFile.ReadInt16 ();  			Entries.Add (new IdxEntry {  				Name = name'  				BaseFormat = idxBaseFormat'  				Offset = offset  			});  		}  		foreach (var entry in Entries) {  			datFile.BaseStream.Seek (entry.Offset' SeekOrigin.Begin);  			var datBaseFormat = (BaseFormat)datFile.ReadInt16 ();  			if (entry.BaseFormat != datBaseFormat) {  				throw new Exception ("WTF");  			}  			Loader.LoadBaseFormat (entry.BaseFormat' destinationDirectory' entry.Name' datFile);  		}  	}  
Magic Number,AssetImporter,IdxLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\IdxLoader.cs,Load,The following statement contains a magic number: using (var datFile = new BinaryReader (File.Open (datFileName' FileMode.Open))) {  	var numEntries = idxFile.ReadUInt32 ();  	for (var i = 0; i < numEntries; ++i) {  		var name = idxFile.ReadNullTerminatedASCIIString (16);  		var offset = idxFile.ReadUInt32 ();  		idxFile.BaseStream.Seek (6' SeekOrigin.Current);  		datFile.BaseStream.Seek (offset' SeekOrigin.Begin);  		var idxBaseFormat = (BaseFormat)idxFile.ReadInt16 ();  		Entries.Add (new IdxEntry {  			Name = name'  			BaseFormat = idxBaseFormat'  			Offset = offset  		});  	}  	foreach (var entry in Entries) {  		datFile.BaseStream.Seek (entry.Offset' SeekOrigin.Begin);  		var datBaseFormat = (BaseFormat)datFile.ReadInt16 ();  		if (entry.BaseFormat != datBaseFormat) {  			throw new Exception ("WTF");  		}  		Loader.LoadBaseFormat (entry.BaseFormat' destinationDirectory' entry.Name' datFile);  	}  }  
Magic Number,AssetImporter,IdxLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\IdxLoader.cs,Load,The following statement contains a magic number: using (var datFile = new BinaryReader (File.Open (datFileName' FileMode.Open))) {  	var numEntries = idxFile.ReadUInt32 ();  	for (var i = 0; i < numEntries; ++i) {  		var name = idxFile.ReadNullTerminatedASCIIString (16);  		var offset = idxFile.ReadUInt32 ();  		idxFile.BaseStream.Seek (6' SeekOrigin.Current);  		datFile.BaseStream.Seek (offset' SeekOrigin.Begin);  		var idxBaseFormat = (BaseFormat)idxFile.ReadInt16 ();  		Entries.Add (new IdxEntry {  			Name = name'  			BaseFormat = idxBaseFormat'  			Offset = offset  		});  	}  	foreach (var entry in Entries) {  		datFile.BaseStream.Seek (entry.Offset' SeekOrigin.Begin);  		var datBaseFormat = (BaseFormat)datFile.ReadInt16 ();  		if (entry.BaseFormat != datBaseFormat) {  			throw new Exception ("WTF");  		}  		Loader.LoadBaseFormat (entry.BaseFormat' destinationDirectory' entry.Name' datFile);  	}  }  
Magic Number,AssetImporter,IdxLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\IdxLoader.cs,Load,The following statement contains a magic number: for (var i = 0; i < numEntries; ++i) {  	var name = idxFile.ReadNullTerminatedASCIIString (16);  	var offset = idxFile.ReadUInt32 ();  	idxFile.BaseStream.Seek (6' SeekOrigin.Current);  	datFile.BaseStream.Seek (offset' SeekOrigin.Begin);  	var idxBaseFormat = (BaseFormat)idxFile.ReadInt16 ();  	Entries.Add (new IdxEntry {  		Name = name'  		BaseFormat = idxBaseFormat'  		Offset = offset  	});  }  
Magic Number,AssetImporter,IdxLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\IdxLoader.cs,Load,The following statement contains a magic number: for (var i = 0; i < numEntries; ++i) {  	var name = idxFile.ReadNullTerminatedASCIIString (16);  	var offset = idxFile.ReadUInt32 ();  	idxFile.BaseStream.Seek (6' SeekOrigin.Current);  	datFile.BaseStream.Seek (offset' SeekOrigin.Begin);  	var idxBaseFormat = (BaseFormat)idxFile.ReadInt16 ();  	Entries.Add (new IdxEntry {  		Name = name'  		BaseFormat = idxBaseFormat'  		Offset = offset  	});  }  
Magic Number,AssetImporter,IdxLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\IdxLoader.cs,Load,The following statement contains a magic number: idxFile.BaseStream.Seek (6' SeekOrigin.Current);  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (sourceFile' FileMode.Open))) {  	var form = new string (binaryReader.ReadChars (4));  	if (form != "FORM") {  		throw new Exception (sourceFile + " doesn't appear to be a valid LBM");  	}  	uint length = binaryReader.ReadUInt32 ();  	var pbm = new string (binaryReader.ReadChars (4));  	if (pbm != "PBM ") {  		throw new Exception (sourceFile + " doesn't appear to be a valid LBM");  	}  	while (!readChunk (binaryReader)) {  	}  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (sourceFile' FileMode.Open))) {  	var form = new string (binaryReader.ReadChars (4));  	if (form != "FORM") {  		throw new Exception (sourceFile + " doesn't appear to be a valid LBM");  	}  	uint length = binaryReader.ReadUInt32 ();  	var pbm = new string (binaryReader.ReadChars (4));  	if (pbm != "PBM ") {  		throw new Exception (sourceFile + " doesn't appear to be a valid LBM");  	}  	while (!readChunk (binaryReader)) {  	}  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: if (length % 2 != 0) {  	++length;  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: switch (id) {  case "BMHD":  	width = binaryReader.BE_ReadUInt16 ();  	height = binaryReader.BE_ReadUInt16 ();  	binaryReader.BaseStream.Seek (4' SeekOrigin.Current);  	colorDepth = binaryReader.ReadUInt16 ();  	compression = binaryReader.ReadUInt16 ();  	binaryReader.BaseStream.Seek (length - 12' SeekOrigin.Current);  	// Skip remaining bytes of this chunk  	bmp = new Bmp (width' height);  	return false;  case "CMAP":  	if (length != 768) {  		throw new Exception ("Invalid color palette in " + lbmName);  	}  	for (int i = 0; i < 256; ++i) {  		palette [i] = new Rgba {  			R = binaryReader.ReadByte ()'  			G = binaryReader.ReadByte ()'  			B = binaryReader.ReadByte ()'  			A = byte.MaxValue  		};  	}  	return false;  case "BODY":  	if (compression != 1) {  		throw new Exception ("OMG WTF?!");  	}  	int numPixels = 0;  	bool compressed = false;  	byte compressedIndex = 0;  	for (int y = 0; y < height; ++y) {  		for (int x = 0; x < width; ++x) {  			if (numPixels == 0) {  				byte indicator = binaryReader.ReadByte ();  				compressed = indicator > 128;  				if (compressed) {  					numPixels = 255 - indicator + 2;  					compressedIndex = binaryReader.ReadByte ();  				}  				else {  					numPixels = indicator + 1;  				}  			}  			var index = compressed ? compressedIndex : binaryReader.ReadByte ();  			bmp.Data [y' x] = palette [index];  			--numPixels;  		}  	}  	return true;  default:  	binaryReader.BaseStream.Seek (length' SeekOrigin.Current);  	return false;  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: switch (id) {  case "BMHD":  	width = binaryReader.BE_ReadUInt16 ();  	height = binaryReader.BE_ReadUInt16 ();  	binaryReader.BaseStream.Seek (4' SeekOrigin.Current);  	colorDepth = binaryReader.ReadUInt16 ();  	compression = binaryReader.ReadUInt16 ();  	binaryReader.BaseStream.Seek (length - 12' SeekOrigin.Current);  	// Skip remaining bytes of this chunk  	bmp = new Bmp (width' height);  	return false;  case "CMAP":  	if (length != 768) {  		throw new Exception ("Invalid color palette in " + lbmName);  	}  	for (int i = 0; i < 256; ++i) {  		palette [i] = new Rgba {  			R = binaryReader.ReadByte ()'  			G = binaryReader.ReadByte ()'  			B = binaryReader.ReadByte ()'  			A = byte.MaxValue  		};  	}  	return false;  case "BODY":  	if (compression != 1) {  		throw new Exception ("OMG WTF?!");  	}  	int numPixels = 0;  	bool compressed = false;  	byte compressedIndex = 0;  	for (int y = 0; y < height; ++y) {  		for (int x = 0; x < width; ++x) {  			if (numPixels == 0) {  				byte indicator = binaryReader.ReadByte ();  				compressed = indicator > 128;  				if (compressed) {  					numPixels = 255 - indicator + 2;  					compressedIndex = binaryReader.ReadByte ();  				}  				else {  					numPixels = indicator + 1;  				}  			}  			var index = compressed ? compressedIndex : binaryReader.ReadByte ();  			bmp.Data [y' x] = palette [index];  			--numPixels;  		}  	}  	return true;  default:  	binaryReader.BaseStream.Seek (length' SeekOrigin.Current);  	return false;  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: switch (id) {  case "BMHD":  	width = binaryReader.BE_ReadUInt16 ();  	height = binaryReader.BE_ReadUInt16 ();  	binaryReader.BaseStream.Seek (4' SeekOrigin.Current);  	colorDepth = binaryReader.ReadUInt16 ();  	compression = binaryReader.ReadUInt16 ();  	binaryReader.BaseStream.Seek (length - 12' SeekOrigin.Current);  	// Skip remaining bytes of this chunk  	bmp = new Bmp (width' height);  	return false;  case "CMAP":  	if (length != 768) {  		throw new Exception ("Invalid color palette in " + lbmName);  	}  	for (int i = 0; i < 256; ++i) {  		palette [i] = new Rgba {  			R = binaryReader.ReadByte ()'  			G = binaryReader.ReadByte ()'  			B = binaryReader.ReadByte ()'  			A = byte.MaxValue  		};  	}  	return false;  case "BODY":  	if (compression != 1) {  		throw new Exception ("OMG WTF?!");  	}  	int numPixels = 0;  	bool compressed = false;  	byte compressedIndex = 0;  	for (int y = 0; y < height; ++y) {  		for (int x = 0; x < width; ++x) {  			if (numPixels == 0) {  				byte indicator = binaryReader.ReadByte ();  				compressed = indicator > 128;  				if (compressed) {  					numPixels = 255 - indicator + 2;  					compressedIndex = binaryReader.ReadByte ();  				}  				else {  					numPixels = indicator + 1;  				}  			}  			var index = compressed ? compressedIndex : binaryReader.ReadByte ();  			bmp.Data [y' x] = palette [index];  			--numPixels;  		}  	}  	return true;  default:  	binaryReader.BaseStream.Seek (length' SeekOrigin.Current);  	return false;  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: switch (id) {  case "BMHD":  	width = binaryReader.BE_ReadUInt16 ();  	height = binaryReader.BE_ReadUInt16 ();  	binaryReader.BaseStream.Seek (4' SeekOrigin.Current);  	colorDepth = binaryReader.ReadUInt16 ();  	compression = binaryReader.ReadUInt16 ();  	binaryReader.BaseStream.Seek (length - 12' SeekOrigin.Current);  	// Skip remaining bytes of this chunk  	bmp = new Bmp (width' height);  	return false;  case "CMAP":  	if (length != 768) {  		throw new Exception ("Invalid color palette in " + lbmName);  	}  	for (int i = 0; i < 256; ++i) {  		palette [i] = new Rgba {  			R = binaryReader.ReadByte ()'  			G = binaryReader.ReadByte ()'  			B = binaryReader.ReadByte ()'  			A = byte.MaxValue  		};  	}  	return false;  case "BODY":  	if (compression != 1) {  		throw new Exception ("OMG WTF?!");  	}  	int numPixels = 0;  	bool compressed = false;  	byte compressedIndex = 0;  	for (int y = 0; y < height; ++y) {  		for (int x = 0; x < width; ++x) {  			if (numPixels == 0) {  				byte indicator = binaryReader.ReadByte ();  				compressed = indicator > 128;  				if (compressed) {  					numPixels = 255 - indicator + 2;  					compressedIndex = binaryReader.ReadByte ();  				}  				else {  					numPixels = indicator + 1;  				}  			}  			var index = compressed ? compressedIndex : binaryReader.ReadByte ();  			bmp.Data [y' x] = palette [index];  			--numPixels;  		}  	}  	return true;  default:  	binaryReader.BaseStream.Seek (length' SeekOrigin.Current);  	return false;  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: switch (id) {  case "BMHD":  	width = binaryReader.BE_ReadUInt16 ();  	height = binaryReader.BE_ReadUInt16 ();  	binaryReader.BaseStream.Seek (4' SeekOrigin.Current);  	colorDepth = binaryReader.ReadUInt16 ();  	compression = binaryReader.ReadUInt16 ();  	binaryReader.BaseStream.Seek (length - 12' SeekOrigin.Current);  	// Skip remaining bytes of this chunk  	bmp = new Bmp (width' height);  	return false;  case "CMAP":  	if (length != 768) {  		throw new Exception ("Invalid color palette in " + lbmName);  	}  	for (int i = 0; i < 256; ++i) {  		palette [i] = new Rgba {  			R = binaryReader.ReadByte ()'  			G = binaryReader.ReadByte ()'  			B = binaryReader.ReadByte ()'  			A = byte.MaxValue  		};  	}  	return false;  case "BODY":  	if (compression != 1) {  		throw new Exception ("OMG WTF?!");  	}  	int numPixels = 0;  	bool compressed = false;  	byte compressedIndex = 0;  	for (int y = 0; y < height; ++y) {  		for (int x = 0; x < width; ++x) {  			if (numPixels == 0) {  				byte indicator = binaryReader.ReadByte ();  				compressed = indicator > 128;  				if (compressed) {  					numPixels = 255 - indicator + 2;  					compressedIndex = binaryReader.ReadByte ();  				}  				else {  					numPixels = indicator + 1;  				}  			}  			var index = compressed ? compressedIndex : binaryReader.ReadByte ();  			bmp.Data [y' x] = palette [index];  			--numPixels;  		}  	}  	return true;  default:  	binaryReader.BaseStream.Seek (length' SeekOrigin.Current);  	return false;  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: switch (id) {  case "BMHD":  	width = binaryReader.BE_ReadUInt16 ();  	height = binaryReader.BE_ReadUInt16 ();  	binaryReader.BaseStream.Seek (4' SeekOrigin.Current);  	colorDepth = binaryReader.ReadUInt16 ();  	compression = binaryReader.ReadUInt16 ();  	binaryReader.BaseStream.Seek (length - 12' SeekOrigin.Current);  	// Skip remaining bytes of this chunk  	bmp = new Bmp (width' height);  	return false;  case "CMAP":  	if (length != 768) {  		throw new Exception ("Invalid color palette in " + lbmName);  	}  	for (int i = 0; i < 256; ++i) {  		palette [i] = new Rgba {  			R = binaryReader.ReadByte ()'  			G = binaryReader.ReadByte ()'  			B = binaryReader.ReadByte ()'  			A = byte.MaxValue  		};  	}  	return false;  case "BODY":  	if (compression != 1) {  		throw new Exception ("OMG WTF?!");  	}  	int numPixels = 0;  	bool compressed = false;  	byte compressedIndex = 0;  	for (int y = 0; y < height; ++y) {  		for (int x = 0; x < width; ++x) {  			if (numPixels == 0) {  				byte indicator = binaryReader.ReadByte ();  				compressed = indicator > 128;  				if (compressed) {  					numPixels = 255 - indicator + 2;  					compressedIndex = binaryReader.ReadByte ();  				}  				else {  					numPixels = indicator + 1;  				}  			}  			var index = compressed ? compressedIndex : binaryReader.ReadByte ();  			bmp.Data [y' x] = palette [index];  			--numPixels;  		}  	}  	return true;  default:  	binaryReader.BaseStream.Seek (length' SeekOrigin.Current);  	return false;  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: switch (id) {  case "BMHD":  	width = binaryReader.BE_ReadUInt16 ();  	height = binaryReader.BE_ReadUInt16 ();  	binaryReader.BaseStream.Seek (4' SeekOrigin.Current);  	colorDepth = binaryReader.ReadUInt16 ();  	compression = binaryReader.ReadUInt16 ();  	binaryReader.BaseStream.Seek (length - 12' SeekOrigin.Current);  	// Skip remaining bytes of this chunk  	bmp = new Bmp (width' height);  	return false;  case "CMAP":  	if (length != 768) {  		throw new Exception ("Invalid color palette in " + lbmName);  	}  	for (int i = 0; i < 256; ++i) {  		palette [i] = new Rgba {  			R = binaryReader.ReadByte ()'  			G = binaryReader.ReadByte ()'  			B = binaryReader.ReadByte ()'  			A = byte.MaxValue  		};  	}  	return false;  case "BODY":  	if (compression != 1) {  		throw new Exception ("OMG WTF?!");  	}  	int numPixels = 0;  	bool compressed = false;  	byte compressedIndex = 0;  	for (int y = 0; y < height; ++y) {  		for (int x = 0; x < width; ++x) {  			if (numPixels == 0) {  				byte indicator = binaryReader.ReadByte ();  				compressed = indicator > 128;  				if (compressed) {  					numPixels = 255 - indicator + 2;  					compressedIndex = binaryReader.ReadByte ();  				}  				else {  					numPixels = indicator + 1;  				}  			}  			var index = compressed ? compressedIndex : binaryReader.ReadByte ();  			bmp.Data [y' x] = palette [index];  			--numPixels;  		}  	}  	return true;  default:  	binaryReader.BaseStream.Seek (length' SeekOrigin.Current);  	return false;  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: binaryReader.BaseStream.Seek (4' SeekOrigin.Current);  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: binaryReader.BaseStream.Seek (length - 12' SeekOrigin.Current);  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: if (length != 768) {  	throw new Exception ("Invalid color palette in " + lbmName);  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: for (int i = 0; i < 256; ++i) {  	palette [i] = new Rgba {  		R = binaryReader.ReadByte ()'  		G = binaryReader.ReadByte ()'  		B = binaryReader.ReadByte ()'  		A = byte.MaxValue  	};  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	for (int x = 0; x < width; ++x) {  		if (numPixels == 0) {  			byte indicator = binaryReader.ReadByte ();  			compressed = indicator > 128;  			if (compressed) {  				numPixels = 255 - indicator + 2;  				compressedIndex = binaryReader.ReadByte ();  			}  			else {  				numPixels = indicator + 1;  			}  		}  		var index = compressed ? compressedIndex : binaryReader.ReadByte ();  		bmp.Data [y' x] = palette [index];  		--numPixels;  	}  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	for (int x = 0; x < width; ++x) {  		if (numPixels == 0) {  			byte indicator = binaryReader.ReadByte ();  			compressed = indicator > 128;  			if (compressed) {  				numPixels = 255 - indicator + 2;  				compressedIndex = binaryReader.ReadByte ();  			}  			else {  				numPixels = indicator + 1;  			}  		}  		var index = compressed ? compressedIndex : binaryReader.ReadByte ();  		bmp.Data [y' x] = palette [index];  		--numPixels;  	}  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	for (int x = 0; x < width; ++x) {  		if (numPixels == 0) {  			byte indicator = binaryReader.ReadByte ();  			compressed = indicator > 128;  			if (compressed) {  				numPixels = 255 - indicator + 2;  				compressedIndex = binaryReader.ReadByte ();  			}  			else {  				numPixels = indicator + 1;  			}  		}  		var index = compressed ? compressedIndex : binaryReader.ReadByte ();  		bmp.Data [y' x] = palette [index];  		--numPixels;  	}  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	if (numPixels == 0) {  		byte indicator = binaryReader.ReadByte ();  		compressed = indicator > 128;  		if (compressed) {  			numPixels = 255 - indicator + 2;  			compressedIndex = binaryReader.ReadByte ();  		}  		else {  			numPixels = indicator + 1;  		}  	}  	var index = compressed ? compressedIndex : binaryReader.ReadByte ();  	bmp.Data [y' x] = palette [index];  	--numPixels;  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	if (numPixels == 0) {  		byte indicator = binaryReader.ReadByte ();  		compressed = indicator > 128;  		if (compressed) {  			numPixels = 255 - indicator + 2;  			compressedIndex = binaryReader.ReadByte ();  		}  		else {  			numPixels = indicator + 1;  		}  	}  	var index = compressed ? compressedIndex : binaryReader.ReadByte ();  	bmp.Data [y' x] = palette [index];  	--numPixels;  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	if (numPixels == 0) {  		byte indicator = binaryReader.ReadByte ();  		compressed = indicator > 128;  		if (compressed) {  			numPixels = 255 - indicator + 2;  			compressedIndex = binaryReader.ReadByte ();  		}  		else {  			numPixels = indicator + 1;  		}  	}  	var index = compressed ? compressedIndex : binaryReader.ReadByte ();  	bmp.Data [y' x] = palette [index];  	--numPixels;  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: if (numPixels == 0) {  	byte indicator = binaryReader.ReadByte ();  	compressed = indicator > 128;  	if (compressed) {  		numPixels = 255 - indicator + 2;  		compressedIndex = binaryReader.ReadByte ();  	}  	else {  		numPixels = indicator + 1;  	}  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: if (numPixels == 0) {  	byte indicator = binaryReader.ReadByte ();  	compressed = indicator > 128;  	if (compressed) {  		numPixels = 255 - indicator + 2;  		compressedIndex = binaryReader.ReadByte ();  	}  	else {  		numPixels = indicator + 1;  	}  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: if (numPixels == 0) {  	byte indicator = binaryReader.ReadByte ();  	compressed = indicator > 128;  	if (compressed) {  		numPixels = 255 - indicator + 2;  		compressedIndex = binaryReader.ReadByte ();  	}  	else {  		numPixels = indicator + 1;  	}  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: compressed = indicator > 128;  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: if (compressed) {  	numPixels = 255 - indicator + 2;  	compressedIndex = binaryReader.ReadByte ();  }  else {  	numPixels = indicator + 1;  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: if (compressed) {  	numPixels = 255 - indicator + 2;  	compressedIndex = binaryReader.ReadByte ();  }  else {  	numPixels = indicator + 1;  }  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: numPixels = 255 - indicator + 2;  
Magic Number,AssetImporter,LbmLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\LbmLoader.cs,readChunk,The following statement contains a magic number: numPixels = 255 - indicator + 2;  
Magic Number,AssetImporter,PaletteLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PaletteLoader.cs,Load,The following statement contains a magic number: binaryReader.BaseStream.Seek (2' SeekOrigin.Current);  
Magic Number,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,Load,The following statement contains a magic number: binaryReader.BaseStream.Seek (4' SeekOrigin.Current);  
Magic Number,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,Load,The following statement contains a magic number: binaryReader.BaseStream.Seek (2' SeekOrigin.Current);  
Magic Number,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,Load,The following statement contains a magic number: width = 32;  
Magic Number,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,Load,The following statement contains a magic number: xOffset = 16;  
Magic Number,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,ReadImage,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	position = rowDataOffsets [y] - (absoluteOffsets ? 0 : 2 * height);  	ushort x = 0;  	while (x < width) {  		byte shift = imageData [position++];  		if (shift < 0x40) {  			for (byte i = 0; i < shift; ++i) {  				// Set to transparent  				colorData [y' x].A = 0;  				++x;  			}  		}  		else if (shift < 0x80) {  			shift -= 0x40;  			for (byte i = 0; i < shift; ++i) {  				// Set to corresponding color in palette  				var color = palette.Colors [imageData [position++]];  				colorData [y' x] = color;  				++x;  			}  		}  		else if (shift < 0xC0) {  			shift -= 0x80;  			byte transparency = imageData [position++];  			// libsiedler2 uses this for tex_pdata. I don't know what purpose does that serve.  			for (byte i = 0; i < shift; ++i) {  				// TEST: hardcode a visible color here  				colorData [y' x] = new Rgba {  					A = (byte)(byte.MaxValue - 64 * transparency)'  					R = 255'  					B = 0'  					G = 0  				};  				++x;  			}  		}  		else {  			shift -= 0xC0;  			var color = palette.Colors [imageData [position++]];  			for (byte i = 0; i < shift; ++i) {  				colorData [y' x] = color;  				++x;  			}  		}  	}  }  
Magic Number,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,ReadImage,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	position = rowDataOffsets [y] - (absoluteOffsets ? 0 : 2 * height);  	ushort x = 0;  	while (x < width) {  		byte shift = imageData [position++];  		if (shift < 0x40) {  			for (byte i = 0; i < shift; ++i) {  				// Set to transparent  				colorData [y' x].A = 0;  				++x;  			}  		}  		else if (shift < 0x80) {  			shift -= 0x40;  			for (byte i = 0; i < shift; ++i) {  				// Set to corresponding color in palette  				var color = palette.Colors [imageData [position++]];  				colorData [y' x] = color;  				++x;  			}  		}  		else if (shift < 0xC0) {  			shift -= 0x80;  			byte transparency = imageData [position++];  			// libsiedler2 uses this for tex_pdata. I don't know what purpose does that serve.  			for (byte i = 0; i < shift; ++i) {  				// TEST: hardcode a visible color here  				colorData [y' x] = new Rgba {  					A = (byte)(byte.MaxValue - 64 * transparency)'  					R = 255'  					B = 0'  					G = 0  				};  				++x;  			}  		}  		else {  			shift -= 0xC0;  			var color = palette.Colors [imageData [position++]];  			for (byte i = 0; i < shift; ++i) {  				colorData [y' x] = color;  				++x;  			}  		}  	}  }  
Magic Number,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,ReadImage,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	position = rowDataOffsets [y] - (absoluteOffsets ? 0 : 2 * height);  	ushort x = 0;  	while (x < width) {  		byte shift = imageData [position++];  		if (shift < 0x40) {  			for (byte i = 0; i < shift; ++i) {  				// Set to transparent  				colorData [y' x].A = 0;  				++x;  			}  		}  		else if (shift < 0x80) {  			shift -= 0x40;  			for (byte i = 0; i < shift; ++i) {  				// Set to corresponding color in palette  				var color = palette.Colors [imageData [position++]];  				colorData [y' x] = color;  				++x;  			}  		}  		else if (shift < 0xC0) {  			shift -= 0x80;  			byte transparency = imageData [position++];  			// libsiedler2 uses this for tex_pdata. I don't know what purpose does that serve.  			for (byte i = 0; i < shift; ++i) {  				// TEST: hardcode a visible color here  				colorData [y' x] = new Rgba {  					A = (byte)(byte.MaxValue - 64 * transparency)'  					R = 255'  					B = 0'  					G = 0  				};  				++x;  			}  		}  		else {  			shift -= 0xC0;  			var color = palette.Colors [imageData [position++]];  			for (byte i = 0; i < shift; ++i) {  				colorData [y' x] = color;  				++x;  			}  		}  	}  }  
Magic Number,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,ReadImage,The following statement contains a magic number: position = rowDataOffsets [y] - (absoluteOffsets ? 0 : 2 * height);  
Magic Number,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,ReadImage,The following statement contains a magic number: while (x < width) {  	byte shift = imageData [position++];  	if (shift < 0x40) {  		for (byte i = 0; i < shift; ++i) {  			// Set to transparent  			colorData [y' x].A = 0;  			++x;  		}  	}  	else if (shift < 0x80) {  		shift -= 0x40;  		for (byte i = 0; i < shift; ++i) {  			// Set to corresponding color in palette  			var color = palette.Colors [imageData [position++]];  			colorData [y' x] = color;  			++x;  		}  	}  	else if (shift < 0xC0) {  		shift -= 0x80;  		byte transparency = imageData [position++];  		// libsiedler2 uses this for tex_pdata. I don't know what purpose does that serve.  		for (byte i = 0; i < shift; ++i) {  			// TEST: hardcode a visible color here  			colorData [y' x] = new Rgba {  				A = (byte)(byte.MaxValue - 64 * transparency)'  				R = 255'  				B = 0'  				G = 0  			};  			++x;  		}  	}  	else {  		shift -= 0xC0;  		var color = palette.Colors [imageData [position++]];  		for (byte i = 0; i < shift; ++i) {  			colorData [y' x] = color;  			++x;  		}  	}  }  
Magic Number,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,ReadImage,The following statement contains a magic number: while (x < width) {  	byte shift = imageData [position++];  	if (shift < 0x40) {  		for (byte i = 0; i < shift; ++i) {  			// Set to transparent  			colorData [y' x].A = 0;  			++x;  		}  	}  	else if (shift < 0x80) {  		shift -= 0x40;  		for (byte i = 0; i < shift; ++i) {  			// Set to corresponding color in palette  			var color = palette.Colors [imageData [position++]];  			colorData [y' x] = color;  			++x;  		}  	}  	else if (shift < 0xC0) {  		shift -= 0x80;  		byte transparency = imageData [position++];  		// libsiedler2 uses this for tex_pdata. I don't know what purpose does that serve.  		for (byte i = 0; i < shift; ++i) {  			// TEST: hardcode a visible color here  			colorData [y' x] = new Rgba {  				A = (byte)(byte.MaxValue - 64 * transparency)'  				R = 255'  				B = 0'  				G = 0  			};  			++x;  		}  	}  	else {  		shift -= 0xC0;  		var color = palette.Colors [imageData [position++]];  		for (byte i = 0; i < shift; ++i) {  			colorData [y' x] = color;  			++x;  		}  	}  }  
Magic Number,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,ReadImage,The following statement contains a magic number: if (shift < 0x40) {  	for (byte i = 0; i < shift; ++i) {  		// Set to transparent  		colorData [y' x].A = 0;  		++x;  	}  }  else if (shift < 0x80) {  	shift -= 0x40;  	for (byte i = 0; i < shift; ++i) {  		// Set to corresponding color in palette  		var color = palette.Colors [imageData [position++]];  		colorData [y' x] = color;  		++x;  	}  }  else if (shift < 0xC0) {  	shift -= 0x80;  	byte transparency = imageData [position++];  	// libsiedler2 uses this for tex_pdata. I don't know what purpose does that serve.  	for (byte i = 0; i < shift; ++i) {  		// TEST: hardcode a visible color here  		colorData [y' x] = new Rgba {  			A = (byte)(byte.MaxValue - 64 * transparency)'  			R = 255'  			B = 0'  			G = 0  		};  		++x;  	}  }  else {  	shift -= 0xC0;  	var color = palette.Colors [imageData [position++]];  	for (byte i = 0; i < shift; ++i) {  		colorData [y' x] = color;  		++x;  	}  }  
Magic Number,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,ReadImage,The following statement contains a magic number: if (shift < 0x40) {  	for (byte i = 0; i < shift; ++i) {  		// Set to transparent  		colorData [y' x].A = 0;  		++x;  	}  }  else if (shift < 0x80) {  	shift -= 0x40;  	for (byte i = 0; i < shift; ++i) {  		// Set to corresponding color in palette  		var color = palette.Colors [imageData [position++]];  		colorData [y' x] = color;  		++x;  	}  }  else if (shift < 0xC0) {  	shift -= 0x80;  	byte transparency = imageData [position++];  	// libsiedler2 uses this for tex_pdata. I don't know what purpose does that serve.  	for (byte i = 0; i < shift; ++i) {  		// TEST: hardcode a visible color here  		colorData [y' x] = new Rgba {  			A = (byte)(byte.MaxValue - 64 * transparency)'  			R = 255'  			B = 0'  			G = 0  		};  		++x;  	}  }  else {  	shift -= 0xC0;  	var color = palette.Colors [imageData [position++]];  	for (byte i = 0; i < shift; ++i) {  		colorData [y' x] = color;  		++x;  	}  }  
Magic Number,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,ReadImage,The following statement contains a magic number: if (shift < 0x80) {  	shift -= 0x40;  	for (byte i = 0; i < shift; ++i) {  		// Set to corresponding color in palette  		var color = palette.Colors [imageData [position++]];  		colorData [y' x] = color;  		++x;  	}  }  else if (shift < 0xC0) {  	shift -= 0x80;  	byte transparency = imageData [position++];  	// libsiedler2 uses this for tex_pdata. I don't know what purpose does that serve.  	for (byte i = 0; i < shift; ++i) {  		// TEST: hardcode a visible color here  		colorData [y' x] = new Rgba {  			A = (byte)(byte.MaxValue - 64 * transparency)'  			R = 255'  			B = 0'  			G = 0  		};  		++x;  	}  }  else {  	shift -= 0xC0;  	var color = palette.Colors [imageData [position++]];  	for (byte i = 0; i < shift; ++i) {  		colorData [y' x] = color;  		++x;  	}  }  
Magic Number,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,ReadImage,The following statement contains a magic number: if (shift < 0x80) {  	shift -= 0x40;  	for (byte i = 0; i < shift; ++i) {  		// Set to corresponding color in palette  		var color = palette.Colors [imageData [position++]];  		colorData [y' x] = color;  		++x;  	}  }  else if (shift < 0xC0) {  	shift -= 0x80;  	byte transparency = imageData [position++];  	// libsiedler2 uses this for tex_pdata. I don't know what purpose does that serve.  	for (byte i = 0; i < shift; ++i) {  		// TEST: hardcode a visible color here  		colorData [y' x] = new Rgba {  			A = (byte)(byte.MaxValue - 64 * transparency)'  			R = 255'  			B = 0'  			G = 0  		};  		++x;  	}  }  else {  	shift -= 0xC0;  	var color = palette.Colors [imageData [position++]];  	for (byte i = 0; i < shift; ++i) {  		colorData [y' x] = color;  		++x;  	}  }  
Magic Number,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,ReadImage,The following statement contains a magic number: if (shift < 0xC0) {  	shift -= 0x80;  	byte transparency = imageData [position++];  	// libsiedler2 uses this for tex_pdata. I don't know what purpose does that serve.  	for (byte i = 0; i < shift; ++i) {  		// TEST: hardcode a visible color here  		colorData [y' x] = new Rgba {  			A = (byte)(byte.MaxValue - 64 * transparency)'  			R = 255'  			B = 0'  			G = 0  		};  		++x;  	}  }  else {  	shift -= 0xC0;  	var color = palette.Colors [imageData [position++]];  	for (byte i = 0; i < shift; ++i) {  		colorData [y' x] = color;  		++x;  	}  }  
Magic Number,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,ReadImage,The following statement contains a magic number: if (shift < 0xC0) {  	shift -= 0x80;  	byte transparency = imageData [position++];  	// libsiedler2 uses this for tex_pdata. I don't know what purpose does that serve.  	for (byte i = 0; i < shift; ++i) {  		// TEST: hardcode a visible color here  		colorData [y' x] = new Rgba {  			A = (byte)(byte.MaxValue - 64 * transparency)'  			R = 255'  			B = 0'  			G = 0  		};  		++x;  	}  }  else {  	shift -= 0xC0;  	var color = palette.Colors [imageData [position++]];  	for (byte i = 0; i < shift; ++i) {  		colorData [y' x] = color;  		++x;  	}  }  
Magic Number,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,ReadImage,The following statement contains a magic number: for (byte i = 0; i < shift; ++i) {  	// TEST: hardcode a visible color here  	colorData [y' x] = new Rgba {  		A = (byte)(byte.MaxValue - 64 * transparency)'  		R = 255'  		B = 0'  		G = 0  	};  	++x;  }  
Magic Number,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,ReadImage,The following statement contains a magic number: for (byte i = 0; i < shift; ++i) {  	// TEST: hardcode a visible color here  	colorData [y' x] = new Rgba {  		A = (byte)(byte.MaxValue - 64 * transparency)'  		R = 255'  		B = 0'  		G = 0  	};  	++x;  }  
Magic Number,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,ReadImage,The following statement contains a magic number: colorData [y' x] = new Rgba {  	A = (byte)(byte.MaxValue - 64 * transparency)'  	R = 255'  	B = 0'  	G = 0  };  
Magic Number,AssetImporter,PlayerBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\PlayerBitmapLoader.cs,ReadImage,The following statement contains a magic number: colorData [y' x] = new Rgba {  	A = (byte)(byte.MaxValue - 64 * transparency)'  	R = 255'  	B = 0'  	G = 0  };  
Magic Number,AssetImporter,RawBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\RawBitmapLoader.cs,Load,The following statement contains a magic number: binaryReader.BaseStream.Seek (2' SeekOrigin.Current);  
Magic Number,AssetImporter,RawBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\RawBitmapLoader.cs,Load,The following statement contains a magic number: binaryReader.BaseStream.Seek (8' SeekOrigin.Current);  
Magic Number,AssetImporter,ShadowBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\ShadowBitmapLoader.cs,Load,The following statement contains a magic number: binaryReader.BaseStream.Seek (4' SeekOrigin.Current);  
Magic Number,AssetImporter,ShadowBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\ShadowBitmapLoader.cs,Load,The following statement contains a magic number: binaryReader.BaseStream.Seek (2' SeekOrigin.Current);  
Magic Number,AssetImporter,ShadowBitmapLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\ShadowBitmapLoader.cs,Load,The following statement contains a magic number: binaryReader.BaseStream.Seek (2 * height' SeekOrigin.Current);  
Magic Number,AssetImporter,TextureLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\TextureLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (sourceFileName' FileMode.Open))) {  	if (binaryReader.BaseStream.Length != 65536) {  		throw new Exception (sourceFileName + " is an invalid texture");  	}  	var palette = PaletteLoader.DefaultPalette;  	var bmp = new Bmp (256' 256);  	var colorData = bmp.Data;  	for (int y = 0; y < 256; ++y) {  		for (int x = 0; x < 256; ++x) {  			colorData [y' x] = palette.Colors [binaryReader.ReadByte ()];  		}  	}  	Debug.Assert (binaryReader.BaseStream.Position == binaryReader.BaseStream.Length);  	var destinationFileName = Path.Combine (destinationDirectory' Path.GetFileNameWithoutExtension (sourceFileName));  	bmp.Save (destinationFileName' ImageFormat.Png);  }  
Magic Number,AssetImporter,TextureLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\TextureLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (sourceFileName' FileMode.Open))) {  	if (binaryReader.BaseStream.Length != 65536) {  		throw new Exception (sourceFileName + " is an invalid texture");  	}  	var palette = PaletteLoader.DefaultPalette;  	var bmp = new Bmp (256' 256);  	var colorData = bmp.Data;  	for (int y = 0; y < 256; ++y) {  		for (int x = 0; x < 256; ++x) {  			colorData [y' x] = palette.Colors [binaryReader.ReadByte ()];  		}  	}  	Debug.Assert (binaryReader.BaseStream.Position == binaryReader.BaseStream.Length);  	var destinationFileName = Path.Combine (destinationDirectory' Path.GetFileNameWithoutExtension (sourceFileName));  	bmp.Save (destinationFileName' ImageFormat.Png);  }  
Magic Number,AssetImporter,TextureLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\TextureLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (sourceFileName' FileMode.Open))) {  	if (binaryReader.BaseStream.Length != 65536) {  		throw new Exception (sourceFileName + " is an invalid texture");  	}  	var palette = PaletteLoader.DefaultPalette;  	var bmp = new Bmp (256' 256);  	var colorData = bmp.Data;  	for (int y = 0; y < 256; ++y) {  		for (int x = 0; x < 256; ++x) {  			colorData [y' x] = palette.Colors [binaryReader.ReadByte ()];  		}  	}  	Debug.Assert (binaryReader.BaseStream.Position == binaryReader.BaseStream.Length);  	var destinationFileName = Path.Combine (destinationDirectory' Path.GetFileNameWithoutExtension (sourceFileName));  	bmp.Save (destinationFileName' ImageFormat.Png);  }  
Magic Number,AssetImporter,TextureLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\TextureLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (sourceFileName' FileMode.Open))) {  	if (binaryReader.BaseStream.Length != 65536) {  		throw new Exception (sourceFileName + " is an invalid texture");  	}  	var palette = PaletteLoader.DefaultPalette;  	var bmp = new Bmp (256' 256);  	var colorData = bmp.Data;  	for (int y = 0; y < 256; ++y) {  		for (int x = 0; x < 256; ++x) {  			colorData [y' x] = palette.Colors [binaryReader.ReadByte ()];  		}  	}  	Debug.Assert (binaryReader.BaseStream.Position == binaryReader.BaseStream.Length);  	var destinationFileName = Path.Combine (destinationDirectory' Path.GetFileNameWithoutExtension (sourceFileName));  	bmp.Save (destinationFileName' ImageFormat.Png);  }  
Magic Number,AssetImporter,TextureLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\TextureLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (sourceFileName' FileMode.Open))) {  	if (binaryReader.BaseStream.Length != 65536) {  		throw new Exception (sourceFileName + " is an invalid texture");  	}  	var palette = PaletteLoader.DefaultPalette;  	var bmp = new Bmp (256' 256);  	var colorData = bmp.Data;  	for (int y = 0; y < 256; ++y) {  		for (int x = 0; x < 256; ++x) {  			colorData [y' x] = palette.Colors [binaryReader.ReadByte ()];  		}  	}  	Debug.Assert (binaryReader.BaseStream.Position == binaryReader.BaseStream.Length);  	var destinationFileName = Path.Combine (destinationDirectory' Path.GetFileNameWithoutExtension (sourceFileName));  	bmp.Save (destinationFileName' ImageFormat.Png);  }  
Magic Number,AssetImporter,TextureLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\TextureLoader.cs,Load,The following statement contains a magic number: if (binaryReader.BaseStream.Length != 65536) {  	throw new Exception (sourceFileName + " is an invalid texture");  }  
Magic Number,AssetImporter,TextureLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\TextureLoader.cs,Load,The following statement contains a magic number: for (int y = 0; y < 256; ++y) {  	for (int x = 0; x < 256; ++x) {  		colorData [y' x] = palette.Colors [binaryReader.ReadByte ()];  	}  }  
Magic Number,AssetImporter,TextureLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\TextureLoader.cs,Load,The following statement contains a magic number: for (int y = 0; y < 256; ++y) {  	for (int x = 0; x < 256; ++x) {  		colorData [y' x] = palette.Colors [binaryReader.ReadByte ()];  	}  }  
Magic Number,AssetImporter,TextureLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\TextureLoader.cs,Load,The following statement contains a magic number: for (int x = 0; x < 256; ++x) {  	colorData [y' x] = palette.Colors [binaryReader.ReadByte ()];  }  
Magic Number,AssetImporter,WaveLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\WaveLoader.cs,Load,The following statement contains a magic number: wave.FileSize = (uint)(wave.Data.Length + Wave.HeaderSize - 8);  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,Load,The following statement contains a magic number: binaryReader.BaseStream.Seek (4' SeekOrigin.Current);  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,SkipToEVNT,The following statement contains a magic number: while (stringBuilder.ToString () != "EVNT") {  	stringBuilder.Append (Encoding.ASCII.GetString (binaryReader.ReadBytes (1)));  	if (stringBuilder.Length > 4) {  		stringBuilder.Remove (0' 1);  	}  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,SkipToEVNT,The following statement contains a magic number: if (stringBuilder.Length > 4) {  	stringBuilder.Remove (0' 1);  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: tempo = 500000;  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: while (!end) {  	while (true) {  		tokenType = binaryReader.ReadByte ();  		if ((tokenType & 0x80) != 0) {  			break;  		}  		else {  			tokenTime += 3 * tokenType;  		}  	}  	token = NewToken (tokenList' tokenTime' tokenType);  	binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  	token.Buffer = binaryReader.ReadBytes (1);  	binaryReader.BaseStream.Seek (-2' SeekOrigin.Current);  	switch (tokenType & 0xF0) {  	case 0xC0:  	case 0xD0:  		token.Data = binaryReader.ReadByte ();  		token.Buffer = null;  		break;  	case 0x80:  	case 0xA0:  	case 0xB0:  	case 0xE0:  		token.Data = binaryReader.ReadByte ();  		binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  		break;  	case 0x90:  		{  			byte extendedType = binaryReader.ReadByte ();  			token.Data = extendedType;  			binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  			token = NewToken (tokenList' tokenTime + (int)binaryReader.ReadUInt32_VariableLength () * 3' tokenType);  			token.Data = extendedType;  			token.Buffer = new byte[] {  				0x00  			};  		}  		break;  	case 0xF0: {  		byte extendedType = 0;  		if (token.Type == 0xFF) {  			extendedType = binaryReader.ReadByte ();  			if (extendedType == 0x2F) {  				end = true;  			}  			else if (extendedType == 0x51) {  				if (!tempoSet) {  					binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  					tempo = (int)binaryReader.BE_ReadUInt24 () * 3;  					tempoSet = true;  					binaryReader.BaseStream.Seek (-4' SeekOrigin.Current);  				}  				else {  					tokenList.RemoveAt (tokenList.Count - 1);  					uint toSkip = binaryReader.ReadUInt32_VariableLength ();  					binaryReader.BaseStream.Seek (toSkip' SeekOrigin.Current);  					break;  				}  			}  		}  		token.Data = extendedType;  		uint bufferLength = binaryReader.ReadUInt32_VariableLength ();  		token.Buffer = binaryReader.ReadBytes ((int)bufferLength);  		break;  	}  	}  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: while (!end) {  	while (true) {  		tokenType = binaryReader.ReadByte ();  		if ((tokenType & 0x80) != 0) {  			break;  		}  		else {  			tokenTime += 3 * tokenType;  		}  	}  	token = NewToken (tokenList' tokenTime' tokenType);  	binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  	token.Buffer = binaryReader.ReadBytes (1);  	binaryReader.BaseStream.Seek (-2' SeekOrigin.Current);  	switch (tokenType & 0xF0) {  	case 0xC0:  	case 0xD0:  		token.Data = binaryReader.ReadByte ();  		token.Buffer = null;  		break;  	case 0x80:  	case 0xA0:  	case 0xB0:  	case 0xE0:  		token.Data = binaryReader.ReadByte ();  		binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  		break;  	case 0x90:  		{  			byte extendedType = binaryReader.ReadByte ();  			token.Data = extendedType;  			binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  			token = NewToken (tokenList' tokenTime + (int)binaryReader.ReadUInt32_VariableLength () * 3' tokenType);  			token.Data = extendedType;  			token.Buffer = new byte[] {  				0x00  			};  		}  		break;  	case 0xF0: {  		byte extendedType = 0;  		if (token.Type == 0xFF) {  			extendedType = binaryReader.ReadByte ();  			if (extendedType == 0x2F) {  				end = true;  			}  			else if (extendedType == 0x51) {  				if (!tempoSet) {  					binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  					tempo = (int)binaryReader.BE_ReadUInt24 () * 3;  					tempoSet = true;  					binaryReader.BaseStream.Seek (-4' SeekOrigin.Current);  				}  				else {  					tokenList.RemoveAt (tokenList.Count - 1);  					uint toSkip = binaryReader.ReadUInt32_VariableLength ();  					binaryReader.BaseStream.Seek (toSkip' SeekOrigin.Current);  					break;  				}  			}  		}  		token.Data = extendedType;  		uint bufferLength = binaryReader.ReadUInt32_VariableLength ();  		token.Buffer = binaryReader.ReadBytes ((int)bufferLength);  		break;  	}  	}  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: while (!end) {  	while (true) {  		tokenType = binaryReader.ReadByte ();  		if ((tokenType & 0x80) != 0) {  			break;  		}  		else {  			tokenTime += 3 * tokenType;  		}  	}  	token = NewToken (tokenList' tokenTime' tokenType);  	binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  	token.Buffer = binaryReader.ReadBytes (1);  	binaryReader.BaseStream.Seek (-2' SeekOrigin.Current);  	switch (tokenType & 0xF0) {  	case 0xC0:  	case 0xD0:  		token.Data = binaryReader.ReadByte ();  		token.Buffer = null;  		break;  	case 0x80:  	case 0xA0:  	case 0xB0:  	case 0xE0:  		token.Data = binaryReader.ReadByte ();  		binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  		break;  	case 0x90:  		{  			byte extendedType = binaryReader.ReadByte ();  			token.Data = extendedType;  			binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  			token = NewToken (tokenList' tokenTime + (int)binaryReader.ReadUInt32_VariableLength () * 3' tokenType);  			token.Data = extendedType;  			token.Buffer = new byte[] {  				0x00  			};  		}  		break;  	case 0xF0: {  		byte extendedType = 0;  		if (token.Type == 0xFF) {  			extendedType = binaryReader.ReadByte ();  			if (extendedType == 0x2F) {  				end = true;  			}  			else if (extendedType == 0x51) {  				if (!tempoSet) {  					binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  					tempo = (int)binaryReader.BE_ReadUInt24 () * 3;  					tempoSet = true;  					binaryReader.BaseStream.Seek (-4' SeekOrigin.Current);  				}  				else {  					tokenList.RemoveAt (tokenList.Count - 1);  					uint toSkip = binaryReader.ReadUInt32_VariableLength ();  					binaryReader.BaseStream.Seek (toSkip' SeekOrigin.Current);  					break;  				}  			}  		}  		token.Data = extendedType;  		uint bufferLength = binaryReader.ReadUInt32_VariableLength ();  		token.Buffer = binaryReader.ReadBytes ((int)bufferLength);  		break;  	}  	}  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: while (!end) {  	while (true) {  		tokenType = binaryReader.ReadByte ();  		if ((tokenType & 0x80) != 0) {  			break;  		}  		else {  			tokenTime += 3 * tokenType;  		}  	}  	token = NewToken (tokenList' tokenTime' tokenType);  	binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  	token.Buffer = binaryReader.ReadBytes (1);  	binaryReader.BaseStream.Seek (-2' SeekOrigin.Current);  	switch (tokenType & 0xF0) {  	case 0xC0:  	case 0xD0:  		token.Data = binaryReader.ReadByte ();  		token.Buffer = null;  		break;  	case 0x80:  	case 0xA0:  	case 0xB0:  	case 0xE0:  		token.Data = binaryReader.ReadByte ();  		binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  		break;  	case 0x90:  		{  			byte extendedType = binaryReader.ReadByte ();  			token.Data = extendedType;  			binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  			token = NewToken (tokenList' tokenTime + (int)binaryReader.ReadUInt32_VariableLength () * 3' tokenType);  			token.Data = extendedType;  			token.Buffer = new byte[] {  				0x00  			};  		}  		break;  	case 0xF0: {  		byte extendedType = 0;  		if (token.Type == 0xFF) {  			extendedType = binaryReader.ReadByte ();  			if (extendedType == 0x2F) {  				end = true;  			}  			else if (extendedType == 0x51) {  				if (!tempoSet) {  					binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  					tempo = (int)binaryReader.BE_ReadUInt24 () * 3;  					tempoSet = true;  					binaryReader.BaseStream.Seek (-4' SeekOrigin.Current);  				}  				else {  					tokenList.RemoveAt (tokenList.Count - 1);  					uint toSkip = binaryReader.ReadUInt32_VariableLength ();  					binaryReader.BaseStream.Seek (toSkip' SeekOrigin.Current);  					break;  				}  			}  		}  		token.Data = extendedType;  		uint bufferLength = binaryReader.ReadUInt32_VariableLength ();  		token.Buffer = binaryReader.ReadBytes ((int)bufferLength);  		break;  	}  	}  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: while (!end) {  	while (true) {  		tokenType = binaryReader.ReadByte ();  		if ((tokenType & 0x80) != 0) {  			break;  		}  		else {  			tokenTime += 3 * tokenType;  		}  	}  	token = NewToken (tokenList' tokenTime' tokenType);  	binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  	token.Buffer = binaryReader.ReadBytes (1);  	binaryReader.BaseStream.Seek (-2' SeekOrigin.Current);  	switch (tokenType & 0xF0) {  	case 0xC0:  	case 0xD0:  		token.Data = binaryReader.ReadByte ();  		token.Buffer = null;  		break;  	case 0x80:  	case 0xA0:  	case 0xB0:  	case 0xE0:  		token.Data = binaryReader.ReadByte ();  		binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  		break;  	case 0x90:  		{  			byte extendedType = binaryReader.ReadByte ();  			token.Data = extendedType;  			binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  			token = NewToken (tokenList' tokenTime + (int)binaryReader.ReadUInt32_VariableLength () * 3' tokenType);  			token.Data = extendedType;  			token.Buffer = new byte[] {  				0x00  			};  		}  		break;  	case 0xF0: {  		byte extendedType = 0;  		if (token.Type == 0xFF) {  			extendedType = binaryReader.ReadByte ();  			if (extendedType == 0x2F) {  				end = true;  			}  			else if (extendedType == 0x51) {  				if (!tempoSet) {  					binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  					tempo = (int)binaryReader.BE_ReadUInt24 () * 3;  					tempoSet = true;  					binaryReader.BaseStream.Seek (-4' SeekOrigin.Current);  				}  				else {  					tokenList.RemoveAt (tokenList.Count - 1);  					uint toSkip = binaryReader.ReadUInt32_VariableLength ();  					binaryReader.BaseStream.Seek (toSkip' SeekOrigin.Current);  					break;  				}  			}  		}  		token.Data = extendedType;  		uint bufferLength = binaryReader.ReadUInt32_VariableLength ();  		token.Buffer = binaryReader.ReadBytes ((int)bufferLength);  		break;  	}  	}  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: while (true) {  	tokenType = binaryReader.ReadByte ();  	if ((tokenType & 0x80) != 0) {  		break;  	}  	else {  		tokenTime += 3 * tokenType;  	}  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: if ((tokenType & 0x80) != 0) {  	break;  }  else {  	tokenTime += 3 * tokenType;  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: tokenTime += 3 * tokenType;  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: binaryReader.BaseStream.Seek (-2' SeekOrigin.Current);  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: switch (tokenType & 0xF0) {  case 0xC0:  case 0xD0:  	token.Data = binaryReader.ReadByte ();  	token.Buffer = null;  	break;  case 0x80:  case 0xA0:  case 0xB0:  case 0xE0:  	token.Data = binaryReader.ReadByte ();  	binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  	break;  case 0x90:  	{  		byte extendedType = binaryReader.ReadByte ();  		token.Data = extendedType;  		binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  		token = NewToken (tokenList' tokenTime + (int)binaryReader.ReadUInt32_VariableLength () * 3' tokenType);  		token.Data = extendedType;  		token.Buffer = new byte[] {  			0x00  		};  	}  	break;  case 0xF0: {  	byte extendedType = 0;  	if (token.Type == 0xFF) {  		extendedType = binaryReader.ReadByte ();  		if (extendedType == 0x2F) {  			end = true;  		}  		else if (extendedType == 0x51) {  			if (!tempoSet) {  				binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  				tempo = (int)binaryReader.BE_ReadUInt24 () * 3;  				tempoSet = true;  				binaryReader.BaseStream.Seek (-4' SeekOrigin.Current);  			}  			else {  				tokenList.RemoveAt (tokenList.Count - 1);  				uint toSkip = binaryReader.ReadUInt32_VariableLength ();  				binaryReader.BaseStream.Seek (toSkip' SeekOrigin.Current);  				break;  			}  		}  	}  	token.Data = extendedType;  	uint bufferLength = binaryReader.ReadUInt32_VariableLength ();  	token.Buffer = binaryReader.ReadBytes ((int)bufferLength);  	break;  }  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: switch (tokenType & 0xF0) {  case 0xC0:  case 0xD0:  	token.Data = binaryReader.ReadByte ();  	token.Buffer = null;  	break;  case 0x80:  case 0xA0:  case 0xB0:  case 0xE0:  	token.Data = binaryReader.ReadByte ();  	binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  	break;  case 0x90:  	{  		byte extendedType = binaryReader.ReadByte ();  		token.Data = extendedType;  		binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  		token = NewToken (tokenList' tokenTime + (int)binaryReader.ReadUInt32_VariableLength () * 3' tokenType);  		token.Data = extendedType;  		token.Buffer = new byte[] {  			0x00  		};  	}  	break;  case 0xF0: {  	byte extendedType = 0;  	if (token.Type == 0xFF) {  		extendedType = binaryReader.ReadByte ();  		if (extendedType == 0x2F) {  			end = true;  		}  		else if (extendedType == 0x51) {  			if (!tempoSet) {  				binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  				tempo = (int)binaryReader.BE_ReadUInt24 () * 3;  				tempoSet = true;  				binaryReader.BaseStream.Seek (-4' SeekOrigin.Current);  			}  			else {  				tokenList.RemoveAt (tokenList.Count - 1);  				uint toSkip = binaryReader.ReadUInt32_VariableLength ();  				binaryReader.BaseStream.Seek (toSkip' SeekOrigin.Current);  				break;  			}  		}  	}  	token.Data = extendedType;  	uint bufferLength = binaryReader.ReadUInt32_VariableLength ();  	token.Buffer = binaryReader.ReadBytes ((int)bufferLength);  	break;  }  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: switch (tokenType & 0xF0) {  case 0xC0:  case 0xD0:  	token.Data = binaryReader.ReadByte ();  	token.Buffer = null;  	break;  case 0x80:  case 0xA0:  case 0xB0:  case 0xE0:  	token.Data = binaryReader.ReadByte ();  	binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  	break;  case 0x90:  	{  		byte extendedType = binaryReader.ReadByte ();  		token.Data = extendedType;  		binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  		token = NewToken (tokenList' tokenTime + (int)binaryReader.ReadUInt32_VariableLength () * 3' tokenType);  		token.Data = extendedType;  		token.Buffer = new byte[] {  			0x00  		};  	}  	break;  case 0xF0: {  	byte extendedType = 0;  	if (token.Type == 0xFF) {  		extendedType = binaryReader.ReadByte ();  		if (extendedType == 0x2F) {  			end = true;  		}  		else if (extendedType == 0x51) {  			if (!tempoSet) {  				binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  				tempo = (int)binaryReader.BE_ReadUInt24 () * 3;  				tempoSet = true;  				binaryReader.BaseStream.Seek (-4' SeekOrigin.Current);  			}  			else {  				tokenList.RemoveAt (tokenList.Count - 1);  				uint toSkip = binaryReader.ReadUInt32_VariableLength ();  				binaryReader.BaseStream.Seek (toSkip' SeekOrigin.Current);  				break;  			}  		}  	}  	token.Data = extendedType;  	uint bufferLength = binaryReader.ReadUInt32_VariableLength ();  	token.Buffer = binaryReader.ReadBytes ((int)bufferLength);  	break;  }  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: token = NewToken (tokenList' tokenTime + (int)binaryReader.ReadUInt32_VariableLength () * 3' tokenType);  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: if (token.Type == 0xFF) {  	extendedType = binaryReader.ReadByte ();  	if (extendedType == 0x2F) {  		end = true;  	}  	else if (extendedType == 0x51) {  		if (!tempoSet) {  			binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  			tempo = (int)binaryReader.BE_ReadUInt24 () * 3;  			tempoSet = true;  			binaryReader.BaseStream.Seek (-4' SeekOrigin.Current);  		}  		else {  			tokenList.RemoveAt (tokenList.Count - 1);  			uint toSkip = binaryReader.ReadUInt32_VariableLength ();  			binaryReader.BaseStream.Seek (toSkip' SeekOrigin.Current);  			break;  		}  	}  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: if (token.Type == 0xFF) {  	extendedType = binaryReader.ReadByte ();  	if (extendedType == 0x2F) {  		end = true;  	}  	else if (extendedType == 0x51) {  		if (!tempoSet) {  			binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  			tempo = (int)binaryReader.BE_ReadUInt24 () * 3;  			tempoSet = true;  			binaryReader.BaseStream.Seek (-4' SeekOrigin.Current);  		}  		else {  			tokenList.RemoveAt (tokenList.Count - 1);  			uint toSkip = binaryReader.ReadUInt32_VariableLength ();  			binaryReader.BaseStream.Seek (toSkip' SeekOrigin.Current);  			break;  		}  	}  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: if (extendedType == 0x2F) {  	end = true;  }  else if (extendedType == 0x51) {  	if (!tempoSet) {  		binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  		tempo = (int)binaryReader.BE_ReadUInt24 () * 3;  		tempoSet = true;  		binaryReader.BaseStream.Seek (-4' SeekOrigin.Current);  	}  	else {  		tokenList.RemoveAt (tokenList.Count - 1);  		uint toSkip = binaryReader.ReadUInt32_VariableLength ();  		binaryReader.BaseStream.Seek (toSkip' SeekOrigin.Current);  		break;  	}  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: if (extendedType == 0x2F) {  	end = true;  }  else if (extendedType == 0x51) {  	if (!tempoSet) {  		binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  		tempo = (int)binaryReader.BE_ReadUInt24 () * 3;  		tempoSet = true;  		binaryReader.BaseStream.Seek (-4' SeekOrigin.Current);  	}  	else {  		tokenList.RemoveAt (tokenList.Count - 1);  		uint toSkip = binaryReader.ReadUInt32_VariableLength ();  		binaryReader.BaseStream.Seek (toSkip' SeekOrigin.Current);  		break;  	}  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: if (extendedType == 0x51) {  	if (!tempoSet) {  		binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  		tempo = (int)binaryReader.BE_ReadUInt24 () * 3;  		tempoSet = true;  		binaryReader.BaseStream.Seek (-4' SeekOrigin.Current);  	}  	else {  		tokenList.RemoveAt (tokenList.Count - 1);  		uint toSkip = binaryReader.ReadUInt32_VariableLength ();  		binaryReader.BaseStream.Seek (toSkip' SeekOrigin.Current);  		break;  	}  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: if (extendedType == 0x51) {  	if (!tempoSet) {  		binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  		tempo = (int)binaryReader.BE_ReadUInt24 () * 3;  		tempoSet = true;  		binaryReader.BaseStream.Seek (-4' SeekOrigin.Current);  	}  	else {  		tokenList.RemoveAt (tokenList.Count - 1);  		uint toSkip = binaryReader.ReadUInt32_VariableLength ();  		binaryReader.BaseStream.Seek (toSkip' SeekOrigin.Current);  		break;  	}  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: if (!tempoSet) {  	binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  	tempo = (int)binaryReader.BE_ReadUInt24 () * 3;  	tempoSet = true;  	binaryReader.BaseStream.Seek (-4' SeekOrigin.Current);  }  else {  	tokenList.RemoveAt (tokenList.Count - 1);  	uint toSkip = binaryReader.ReadUInt32_VariableLength ();  	binaryReader.BaseStream.Seek (toSkip' SeekOrigin.Current);  	break;  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: if (!tempoSet) {  	binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  	tempo = (int)binaryReader.BE_ReadUInt24 () * 3;  	tempoSet = true;  	binaryReader.BaseStream.Seek (-4' SeekOrigin.Current);  }  else {  	tokenList.RemoveAt (tokenList.Count - 1);  	uint toSkip = binaryReader.ReadUInt32_VariableLength ();  	binaryReader.BaseStream.Seek (toSkip' SeekOrigin.Current);  	break;  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: tempo = (int)binaryReader.BE_ReadUInt24 () * 3;  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following statement contains a magic number: binaryReader.BaseStream.Seek (-4' SeekOrigin.Current);  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,WriteMidi,The following statement contains a magic number: binaryWriter.BE_Write ((ushort)((tempo * 3) / 25000));  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,WriteMidi,The following statement contains a magic number: binaryWriter.BE_Write ((ushort)((tempo * 3) / 25000));  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,WriteMidi,The following statement contains a magic number: binaryWriter.Write (Encoding.ASCII.GetBytes ("MTrk")' 0' 4);  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,WriteMidi,The following statement contains a magic number: binaryWriter.BaseStream.Seek (18' SeekOrigin.Begin);  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (sourceFile' FileMode.Open))) {  	var container = new string (binaryReader.ReadChars (4));  	if (container != "FORM") {  		throw new InvalidDataException (sourceFile + " is not a valid XMidi file");  	}  	binaryReader.BaseStream.Seek (4' SeekOrigin.Current);  	var format = new string (binaryReader.ReadChars (4));  	if (format != "XDIR") {  		throw new InvalidDataException (sourceFile + " is not a valid XMidi file");  	}  	Load (destinationDirectory' Path.GetFileNameWithoutExtension (sourceFile)' binaryReader' (uint)new FileInfo (sourceFile).Length);  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (sourceFile' FileMode.Open))) {  	var container = new string (binaryReader.ReadChars (4));  	if (container != "FORM") {  		throw new InvalidDataException (sourceFile + " is not a valid XMidi file");  	}  	binaryReader.BaseStream.Seek (4' SeekOrigin.Current);  	var format = new string (binaryReader.ReadChars (4));  	if (format != "XDIR") {  		throw new InvalidDataException (sourceFile + " is not a valid XMidi file");  	}  	Load (destinationDirectory' Path.GetFileNameWithoutExtension (sourceFile)' binaryReader' (uint)new FileInfo (sourceFile).Length);  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,Load,The following statement contains a magic number: using (var binaryReader = new BinaryReader (File.Open (sourceFile' FileMode.Open))) {  	var container = new string (binaryReader.ReadChars (4));  	if (container != "FORM") {  		throw new InvalidDataException (sourceFile + " is not a valid XMidi file");  	}  	binaryReader.BaseStream.Seek (4' SeekOrigin.Current);  	var format = new string (binaryReader.ReadChars (4));  	if (format != "XDIR") {  		throw new InvalidDataException (sourceFile + " is not a valid XMidi file");  	}  	Load (destinationDirectory' Path.GetFileNameWithoutExtension (sourceFile)' binaryReader' (uint)new FileInfo (sourceFile).Length);  }  
Magic Number,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,Load,The following statement contains a magic number: binaryReader.BaseStream.Seek (4' SeekOrigin.Current);  
Magic Number,AssetImporter.Loaders,SoundLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\SoundLoader.cs,Load,The following statement contains a magic number: switch (container) {  case "FORM":  case "RIFF":  	uint length = binaryReader.ReadUInt32 ();  	// this is probably not really a length' with values like 0xcccccccc  	var header = new string (binaryReader.ReadChars (4));  	switch (header) {  	case "XMID":  	case "XDIR":  		new XMidiLoader ().Load (destinationDirectory' resourceName' binaryReader' totalLength);  		break;  	case "WAVE":  		break;  	}  	break;  default:  	// Possibly a WAV but without a header  	binaryReader.BaseStream.Seek (start' SeekOrigin.Begin);  	new WaveLoader ().Load (destinationDirectory' resourceName' binaryReader' (int)totalLength' true);  	break;  }  
Missing Default,AssetImporter,XMidiLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\XMidiLoader.cs,ReadTokens,The following switch statement is missing a default case: switch (tokenType & 0xF0) {  case 0xC0:  case 0xD0:  	token.Data = binaryReader.ReadByte ();  	token.Buffer = null;  	break;  case 0x80:  case 0xA0:  case 0xB0:  case 0xE0:  	token.Data = binaryReader.ReadByte ();  	binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  	break;  case 0x90:  	{  		byte extendedType = binaryReader.ReadByte ();  		token.Data = extendedType;  		binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  		token = NewToken (tokenList' tokenTime + (int)binaryReader.ReadUInt32_VariableLength () * 3' tokenType);  		token.Data = extendedType;  		token.Buffer = new byte[] {  			0x00  		};  	}  	break;  case 0xF0: {  	byte extendedType = 0;  	if (token.Type == 0xFF) {  		extendedType = binaryReader.ReadByte ();  		if (extendedType == 0x2F) {  			end = true;  		}  		else if (extendedType == 0x51) {  			if (!tempoSet) {  				binaryReader.BaseStream.Seek (1' SeekOrigin.Current);  				tempo = (int)binaryReader.BE_ReadUInt24 () * 3;  				tempoSet = true;  				binaryReader.BaseStream.Seek (-4' SeekOrigin.Current);  			}  			else {  				tokenList.RemoveAt (tokenList.Count - 1);  				uint toSkip = binaryReader.ReadUInt32_VariableLength ();  				binaryReader.BaseStream.Seek (toSkip' SeekOrigin.Current);  				break;  			}  		}  	}  	token.Data = extendedType;  	uint bufferLength = binaryReader.ReadUInt32_VariableLength ();  	token.Buffer = binaryReader.ReadBytes ((int)bufferLength);  	break;  }  }  
Missing Default,AssetImporter.Loaders,SoundLoader,C:\repos\asik_Settlers-2-Remake\src\AssetImporter\Loader\SoundLoader.cs,Load,The following switch statement is missing a default case: switch (header) {  case "XMID":  case "XDIR":  	new XMidiLoader ().Load (destinationDirectory' resourceName' binaryReader' totalLength);  	break;  case "WAVE":  	break;  }  
