Implementation smell,Namespace,Class,File,Method,Description
Long Method,PeptidAce.Iso.UnitTests,StatsMaker,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\StatsMaker.cs,ProjectMerge,The method has 160 lines of code.
Long Method,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The method has 128 lines of code.
Long Method,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ComputeMaxFlow,The method has 115 lines of code.
Complex Method,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetCommonFragmentMz,Cyclomatic complexity of the method is 10
Complex Method,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetCombinedMatches,Cyclomatic complexity of the method is 17
Complex Method,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,Update,Cyclomatic complexity of the method is 14
Complex Method,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetSpikedPrecursors,Cyclomatic complexity of the method is 27
Complex Method,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,ComputePeptideRatios,Cyclomatic complexity of the method is 10
Complex Method,PeptidAce.Iso.Structures,PrecursorIon,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\PrecursorIon.cs,GetPrecursors,Cyclomatic complexity of the method is 11
Complex Method,PeptidAce.Iso.UnitTests,StatsMaker,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\StatsMaker.cs,ProjectMerge,Cyclomatic complexity of the method is 43
Complex Method,PeptidAce.Iso.UnitTests,Uptimizer,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\Uptimizer.cs,Run,Cyclomatic complexity of the method is 11
Complex Method,PeptidAce.ModernUI.Content,TabsPeptides,C:\repos\olivierlizotte_Iso-PeptidAce\Content\TabsPeptides.xaml.cs,OnNavigatedTo,Cyclomatic complexity of the method is 9
Complex Method,PeptidAce.ModernUI.Content,Tabs,C:\repos\olivierlizotte_Iso-PeptidAce\Content\Tabs.xaml.cs,OnNavigatedTo,Cyclomatic complexity of the method is 12
Complex Method,PeptidAce.ModernUI.Content,ResultsDeconvoluted,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsDeconvoluted.xaml.cs,UpdateContent,Cyclomatic complexity of the method is 8
Complex Method,PeptidAce.ModernUI.Content,PepIso,C:\repos\olivierlizotte_Iso-PeptidAce\Content\PepIso.xaml.cs,CheckParams,Cyclomatic complexity of the method is 9
Complex Method,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,Cyclomatic complexity of the method is 54
Complex Method,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,ExportMixedSampleResult,Cyclomatic complexity of the method is 14
Complex Method,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,ExportSpikedSampleResult,Cyclomatic complexity of the method is 12
Complex Method,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,Cyclomatic complexity of the method is 22
Complex Method,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,SolveFromSpectrum,Cyclomatic complexity of the method is 26
Complex Method,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,Solve,Cyclomatic complexity of the method is 14
Complex Method,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ExportMixedSampleResult,Cyclomatic complexity of the method is 8
Complex Method,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ExportSpikedSampleResult,Cyclomatic complexity of the method is 10
Complex Method,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,Cyclomatic complexity of the method is 16
Complex Method,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ComputePeptideRatios,Cyclomatic complexity of the method is 29
Complex Method,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,SolveFromFragmentScoreTheoMZ,Cyclomatic complexity of the method is 24
Complex Method,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,SolveFromFragmentScore,Cyclomatic complexity of the method is 9
Complex Method,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,SolveFromSpectrumBKP,Cyclomatic complexity of the method is 19
Complex Method,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ComputeMaxFlow,Cyclomatic complexity of the method is 42
Complex Method,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,FindLocalMaximumFlow,Cyclomatic complexity of the method is 8
Long Parameter List,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,CharacterizedPrecursor,The method has 5 parameters.
Long Parameter List,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetSpikedPrecursors,The method has 5 parameters.
Long Parameter List,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,NormalizeFragments,The method has 5 parameters.
Long Parameter List,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,CreateOptions,The method has 5 parameters.
Long Parameter List,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The method has 5 parameters.
Long Parameter List,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,ExportMixedSampleResult,The method has 5 parameters.
Long Parameter List,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The method has 5 parameters.
Long Parameter List,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,SolveFromSpectrum,The method has 10 parameters.
Long Parameter List,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ExportMixedSampleResult,The method has 5 parameters.
Long Parameter List,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,SolveFromFragmentScoreTheoMZ,The method has 9 parameters.
Long Parameter List,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,SolveFromFragmentScore,The method has 9 parameters.
Long Parameter List,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,SolveFromSpectrumBKP,The method has 11 parameters.
Long Parameter List,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ComputeMaxFlow,The method has 7 parameters.
Long Statement,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetCommonFragmentMz,The length of the statement  "				if (PeptidAce.Utilities.Numerics.MzDifference (cPrec.AllFragments [i].theoMz' mass' dbOptions.productMassTolerance.Units) < dbOptions.productMassTolerance.Value) " is 161.
Long Statement,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,IsValid,The length of the statement  "	return Fragments.ContainsKey (nbProductsToKeep) && NormalizedFragments.ContainsKey (nbProductsToKeep) && PrecursorLossNormalizeFactor.ContainsKey (nbProductsToKeep); " is 165.
Long Statement,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetCombinedMatches,The length of the statement  "					if (peak.Intensity > 0 && Math.Abs (Utilities.Numerics.CalculateMassError (peak.MZ' mz' dbOptions.productMassTolerance.Units)) <= dbOptions.productMassTolerance.Value) " is 167.
Long Statement,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetCombinedMatches,The length of the statement  "					newMatch.normalizedIntensity += (peakIntensity / this.eCurveIntensityPerMS.GetLocalArea (timePoint' timePoint + psm.Query.spectrum.InjectionTime)) * DicOfPsmFactor [psm]; " is 170.
Long Statement,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizingCurve,The length of the statement  "		Dictionary<CharacterizedPrecursor' PositionnalIsomerSolver.SolvedResult> finalRatios = PositionnalIsomerSolver.SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' intInTrap' query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole); " is 309.
Long Statement,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,Update,The length of the statement  "						if (Math.Abs (Utilities.Numerics.CalculateMassError (match.theoMz' key' dbOptions.productMassTolerance.Units)) <= dbOptions.productMassTolerance.Value) " is 151.
Long Statement,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetSpikedPrecursors,The length of the statement  "					if (Math.Abs (Utilities.Numerics.CalculateMassError (mz' key' dbOptions.precursorMassTolerance.Units)) <= dbOptions.precursorMassTolerance.Value) { " is 147.
Long Statement,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetSpikedPrecursors,The length of the statement  "	Dictionary<double' Dictionary<Sample' CharacterizedPrecursor>> spikes = new Dictionary<double' Dictionary<Sample' CharacterizedPrecursor>> (); " is 142.
Long Statement,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetSpikedPrecursors,The length of the statement  "		Dictionary<double' PrecursorIon> DicOfSpectrumMasses = PrecursorIon.GetPrecursors (spikedResult' spikedSample' dbOptions' mzKeys.Keys); " is 135.
Long Statement,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetSpikedPrecursors,The length of the statement  "					CharacterizedPrecursor cPrec = new CharacterizedPrecursor (spikedSample' dbOptions' bestPeptide' mzKeys [mzKey].Keys' mzKey); " is 125.
Long Statement,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,NormalizeFragments,The length of the statement  "			PrecursorLossNormalizeFactor.Add (nbProductsToKeep' GetNormalizePrecursorFactor (allCorrespondingPrec' out average' out keepNbProds)); " is 134.
Long Statement,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,GetMixedPrecursors,The length of the statement  "	Dictionary<double' PrecursorIon> DicOfSpectrumMasses = PrecursorIon.GetPrecursors (mixedResult' mixedSample' dbOptions' charPeptides.Keys); " is 139.
Long Statement,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,GetMixedPrecursors,The length of the statement  "						q.spectrum.PrecursorIntensityPerMilliSecond = mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (q.spectrum.RetentionTimeInMin * 1000.0 * 60.0); " is 151.
Long Statement,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,ComputePeptideRatios,The length of the statement  "	Dictionary<Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve>' double> dicOfCorrelations = new Dictionary<Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve>' double> (); " is 179.
Long Statement,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,ComputePeptideRatios,The length of the statement  "            Dictionary<Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve>' double> dicOfCurves = new Dictionary<Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve>' double>();" is 172.
Long Statement,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,ComputePeptideRatios,The length of the statement  "                    Dictionary<Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve>' double> dicOfCurves2 = new Dictionary<Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve>' double>();" is 173.
Long Statement,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,ComputePeptideRatios,The length of the statement  "            //*/Dictionary<CharacterizedPrecursor' ElutionCurveMerger> cumulDic = new Dictionary<CharacterizedPrecursor' ElutionCurveMerger> (); " is 132.
Long Statement,PeptidAce.Iso.Structures,PrecursorIon,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\PrecursorIon.cs,GetPrecursors,The length of the statement  "				double distance = Math.Abs (Utilities.Numerics.CalculateMassError (query.spectrum.PrecursorMZ' key' dbOptions.precursorMassTolerance.Units)); " is 141.
Long Statement,PeptidAce.Iso.Structures,PrecursorIon,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\PrecursorIon.cs,GetPrecursors,The length of the statement  "					if (!foundInKeys || distance < Math.Abs (Utilities.Numerics.CalculateMassError (query.spectrum.PrecursorMZ' foundKey' dbOptions.precursorMassTolerance.Units))) " is 159.
Long Statement,PeptidAce.Iso.Structures,PrecursorIon,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\PrecursorIon.cs,GetPrecursors,The length of the statement  "					if (Math.Abs (Utilities.Numerics.CalculateMassError (query.spectrum.PrecursorMZ' key' dbOptions.precursorMassTolerance.Units)) <= dbOptions.precursorMassTolerance.Value) " is 169.
Long Statement,PeptidAce.Iso.UnitTests,StatsMaker,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\StatsMaker.cs,ProjectMerge,The length of the statement  "	Dictionary<double' Dictionary<Sample' CharacterizedPrecursor>> characterizedPeptides = CharacterizedPrecursor.GetSpikedPrecursors (samplesSynth' SpikedResult' options' newSolver.nbMinFragments' newSolver.nbMaxFragments); " is 220.
Long Statement,PeptidAce.Iso.UnitTests,StatsMaker,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\StatsMaker.cs,ProjectMerge,The length of the statement  "		mixedPrecursors.Add (mixedSample' MixedPrecursor.GetMixedPrecursors (mixedSample' mixedResult' options' characterizedPeptides)); " is 128.
Long Statement,PeptidAce.Iso.UnitTests,StatsMaker,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\StatsMaker.cs,ProjectMerge,The length of the statement  "	Dictionary<Sample' List<Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve>>> results = new Dictionary<Sample' List<Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve>>> (); " is 181.
Long Statement,PeptidAce.Iso.UnitTests,StatsMaker,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\StatsMaker.cs,ProjectMerge,The length of the statement  "			//List<Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve>> listOfRatios = new List<Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve>>(); " is 147.
Long Statement,PeptidAce.Iso.UnitTests,StatsMaker,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\StatsMaker.cs,ProjectMerge,The length of the statement  "					Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ratios = PositionnalIsomerSolver.GetRatios (characterizedPeptides' mPrec' options' newSolver.nbMinFragments' newSolver.nbMaxFragments); " is 191.
Long Statement,PeptidAce.Iso.UnitTests,StatsMaker,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\StatsMaker.cs,ProjectMerge,The length of the statement  "		Dictionary<CharacterizedPrecursor' Dictionary<int' MaxFlowElutionCurve>> deconvoluted = new Dictionary<CharacterizedPrecursor' Dictionary<int' MaxFlowElutionCurve>> (); " is 168.
Long Statement,PeptidAce.Iso.UnitTests,PisTest,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\Uptimizer.cs,Uptimize,The length of the statement  "	DBOptions dbOptions = PositionnalIsomerSolver.CreateOptions (fastaFile' @"C:\_IRIC\Data\NB\Units2\"' 8' 0.05' new PeptidAce.Utilities.Interfaces.ConSolCommandLine ()); " is 167.
Long Statement,PeptidAce.ModernUI.Content,TabsPeptides,C:\repos\olivierlizotte_Iso-PeptidAce\Content\TabsPeptides.xaml.cs,OnNavigatedTo,The length of the statement  "					foreach (Sample sample in solverPTR.characterizedPeptides [mzKey].Keys)//foreach (Sample sample in PepIso.solver.characterizedPeptides.Keys) " is 140.
Long Statement,PeptidAce.ModernUI.Content,TabsPeptides,C:\repos\olivierlizotte_Iso-PeptidAce\Content\TabsPeptides.xaml.cs,OnNavigatedTo,The length of the statement  "								Uri source = new Uri ("/Content/ResultsPeptides.xaml?mzKey=" + mzKey.ToString () + "&Sample=" + name' UriKind.Relative); " is 120.
Long Statement,PeptidAce.ModernUI.Content,Tabs,C:\repos\olivierlizotte_Iso-PeptidAce\Content\Tabs.xaml.cs,OnNavigatedTo,The length of the statement  "								Uri source = new Uri ("/Content/ResultsDeconvoluted.xaml?mzKey=" + mzKey.ToString () + "&Sample=" + name' UriKind.Relative); " is 124.
Long Statement,PeptidAce.ModernUI.Content,ResultsDeconvoluted,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsDeconvoluted.xaml.cs,UpdateContent,The length of the statement  "                    }//*/List<double> timePoints = Utilities.ElutionCurve.GetTimePoints (64' true' mixed.eCurveIntensityCount.interpolatedTime' mixed.eCurveIntensityCount.interpolatedIntensityCount); " is 179.
Long Statement,PeptidAce.ModernUI.Content,ResultsDeconvoluted,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsDeconvoluted.xaml.cs,UpdateContent,The length of the statement  "			StackPanel1.Children.Add (new SynthPeptideUC (intensities.ToArray ()' scanTimes.ToArray ()' names.ToArray ()' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + " (Precursor " + mixed.MZ + ")")); " is 200.
Long Statement,PeptidAce.ModernUI.Content,ResultsDeconvoluted,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsDeconvoluted.xaml.cs,UpdateContent,The length of the statement  "			StackPanel1.Children.Add (new RatioUC (ratios.ToArray ()' names.ToArray ()' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + "  [" + mixed.MZ + "]")); " is 157.
Long Statement,PeptidAce.ModernUI.Content,ResultsPeptides,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsPeptides.xaml.cs,UpdateContent,The length of the statement  "			List<double> timeArray = Utilities.ElutionCurve.GetTimePoints (64' true' cPrec.eCurveIntensityCount.interpolatedTime' cPrec.eCurveIntensityCount.interpolatedIntensityCount); " is 173.
Long Statement,PeptidAce.ModernUI.Content,ResultsPeptides,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsPeptides.xaml.cs,UpdateContent,The length of the statement  "			StackPanel1.Children.Add (new SynthPeptideUC (intensities.ToArray ()' scanTimes.ToArray ()' names' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + " (Precursor " + key + ")")); " is 184.
Long Statement,PeptidAce.ModernUI.Content,ResultsMixed,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsMixed.xaml.cs,UpdateContent,The length of the statement  "			StackPanel1.Children.Add (new RatioUC (ratios.ToArray ()' names.ToArray ()' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + "  [" + mixed.MZ + "]")); " is 157.
Long Statement,PeptidAce.ModernUI.Content,PepIso,C:\repos\olivierlizotte_Iso-PeptidAce\Content\PepIso.xaml.cs,CheckParams,The length of the statement  "		msg += "\nThe minimum number of fragments cannot be smaller than the maximum number of fragments. Check Advanced Settings"; " is 123.
Long Statement,PeptidAce.ModernUI.Content,PepIso,C:\repos\olivierlizotte_Iso-PeptidAce\Content\PepIso.xaml.cs,CheckParams,The length of the statement  "		msg += "\nPlease select a Fasta file with the sequence you wich to search for. This can be the list of peptide sequences or your protein of interest. Keep this file small for faster searches."; " is 193.
Long Statement,PeptidAce.ModernUI.Content,PepIso,C:\repos\olivierlizotte_Iso-PeptidAce\Content\PepIso.xaml.cs,Button_Click_1,The length of the statement  "					AddTextOutput ("\nDone! Your results are available in 'csv' files in these folders :\n" + "\n" + Utilities.vsCSV.GetFolder (mixedFiles [0]) + "Identifications" + "\n" + Utilities.vsCSV.GetFolder (mixedFiles [0]) + "Combined" + "\n" + Utilities.vsCSV.GetFolder (mixedFiles [0]) + "Individual"); " is 293.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The length of the statement  "	SpikedResult.ExportPSMs (1' dbOptions.OutputFolder + "Identifications" + System.IO.Path.DirectorySeparatorChar + "SpikedSamplesPSMs.csv"); " is 138.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The length of the statement  "		mixedResult.ExportPSMs (1' dbOptions.OutputFolder + "Identifications" + System.IO.Path.DirectorySeparatorChar + "MixedSamplesPSMs.csv"); " is 136.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The length of the statement  "		characterizedPeptides = CharacterizedPrecursor.GetSpikedPrecursors (SpikedSamples' SpikedResult' dbOptions' nbMinFragments' nbMaxFragments); " is 140.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The length of the statement  "					curveStr += "'" + charPrec.eCurveIntensityCount.Coefficients [0] + "x^2 + " + charPrec.eCurveIntensityCount.Coefficients [1] + "x" + charPrec.eCurveIntensityCount.Coefficients [2]; " is 180.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The length of the statement  "			mixedPrecursors.Add (mixedSample' MixedPrecursor.GetMixedPrecursors (mixedSample' mixedResult' dbOptions' characterizedPeptides)); " is 130.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The length of the statement  "				List<Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve>> listOfRatios = new List<Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve>> (); " is 146.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The length of the statement  "						Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ratios = GetRatios (characterizedPeptides' mPrec' dbOptions' nbMinFragments' nbMaxFragments); " is 149.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The length of the statement  "								if (i + 1 >= cP.Peptide.StartResidueNumber && i + 1 <= cP.Peptide.EndResidueNumber && cP.Peptide.VariableModifications != null) { " is 129.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,ExportMixedSampleResult,The length of the statement  "	vsCSVWriter writerRatio = new vsCSVWriter (dbOptions.OutputFolder + @"Individual\" + vsCSV.GetFileName_NoExtension (mixedSample.sSDF) + "_" + keyMz + "MZ_" + mixedPrecursor.Queries [0].spectrum.RetentionTimeInMin + "min.csv"); " is 226.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,ExportMixedSampleResult,The length of the statement  "		line = mixedPrecursor.eCurveIntensityCount.time [i] / (1000.0 * 60.0) + "'" + mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (mixedPrecursor.eCurveIntensityCount.time [i]) + "'"; " is 188.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,ExportSpikedSampleResult,The length of the statement  "			vsCSVWriter writerRatio = new vsCSVWriter (dbOptions.OutputFolder + @"Individual\" + vsCSV.GetFileName_NoExtension (sample.sSDF) + "_" + keyMz + "MZ.csv"); " is 155.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,ExportSpikedSampleResult,The length of the statement  "				string line = query.spectrum.RetentionTimeInMin + "'" + query.spectrum.PrecursorIntensity + "'" + query.spectrum.PrecursorIntensityPerMilliSecond; " is 146.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The length of the statement  "	Dictionary<Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve>' double> DicOfCurveErrors = new Dictionary<Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve>' double> (); " is 178.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The length of the statement  "			if (Math.Abs (Utilities.Numerics.CalculateMassError (mz' mixedPrecursor.MZ' dbOptions.precursorMassTolerance.Units)) <= dbOptions.precursorMassTolerance.Value) " is 159.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The length of the statement  "			Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curves = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> (); " is 128.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The length of the statement  "				Dictionary<CharacterizedPrecursor' SolvedResult> finalRatios = SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' //query.spectrum.PrecursorIntensityPerMilliSecond * query.spectrum.InjectionTime'  " is 366.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The length of the statement  "				query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole' dbOptions.OutputFolder + "Fragments" + System.IO.Path.DirectorySeparatorChar + "Fragments_" + vsCSV.GetFileName_NoExtension (mixedPrecursor.Sample.sSDF) + "_" + mixedPrecursor.MZ + "_" + query.spectrum.ScanNumber + "_" + nbProductsToKeep + ".csv"); " is 335.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The length of the statement  "						//curves[cPep].eCurvePerMs.AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity(timeInMilliSeconds)); " is 160.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The length of the statement  "						curves [cPep].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds)); " is 162.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The length of the statement  "				Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curvesToKeep = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> (); " is 134.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The length of the statement  "	Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> averagedValues = mixedPrecursor.ComputePeptideRatios (DicOfCurveErrors); " is 128.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,SolveFromSpectrum,The length of the statement  "					dic.Add (key' isomer.NormalizedFragments [nbProductsToKeep] [key] * isomer.FragmentNormalizor [nbProductsToKeep].InterpolateIntensity (PrecursorIntensityInCTrap)); " is 163.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,SolveFromSpectrum,The length of the statement  "		Utilities.Methods.GradientDescent.SolveMaxFlowStyle (unitSpectrum' mixedSpectrum' out solution' out tmpUnderflow' ConSole' stepSize); " is 133.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,SolveFromSpectrum,The length of the statement  "		//Utilities.Methods.GradientDescent.SolveFromGradientDescent(unitSpectrum' mixedSpectrum' PrecursorIntensityInCTrap' out solution' out tmpUnderflow' ConSole); " is 158.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,SolveFromSpectrum,The length of the statement  "		Dictionary<CharacterizedPrecursor' SolvedResult> resultPerSample = new Dictionary<CharacterizedPrecursor' SolvedResult> (); " is 123.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,Solve,The length of the statement  "	characterizedPeptides = CharacterizedPrecursor.GetSpikedPrecursors (MixedSamples' mixedResult' dbOptions' nbMinFragments' nbMaxFragments); " is 138.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,Solve,The length of the statement  "				curveStr += "'" + charPrec.eCurveIntensityCount.Coefficients [0] + "x^2 + " + charPrec.eCurveIntensityCount.Coefficients [1] + "x" + charPrec.eCurveIntensityCount.Coefficients [2]; " is 180.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,Solve,The length of the statement  "		mixedPrecursors.Add (mixedSample' MixedPrecursor.GetMixedPrecursors (mixedSample' mixedResult' dbOptions' characterizedPeptides)); " is 130.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ExportMixedSampleResult,The length of the statement  "	vsCSVWriter writerRatio = new vsCSVWriter (dbOptions.OutputFolder + @"IndividualNoSpike\" + vsCSV.GetFileName_NoExtension (mixedSample.sSDF) + "_" + keyMz + "MZ_" + mixedPrecursor.Queries [0].spectrum.RetentionTimeInMin + "min.csv"); " is 233.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ExportMixedSampleResult,The length of the statement  "		line = mixedPrecursor.eCurveIntensityCount.time [i] / (1000.0 * 60.0) + "'" + mixedPrecursor.eCurveIntensityCount.intensityCount [i]; " is 133.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ExportSpikedSampleResult,The length of the statement  "			vsCSVWriter writerRatio = new vsCSVWriter (dbOptions.OutputFolder + @"IndividualNoSpike\" + vsCSV.GetFileName_NoExtension (sample.sSDF) + "_" + keyMz + "MZ.csv"); " is 162.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ExportSpikedSampleResult,The length of the statement  "				string line = query.spectrum.RetentionTimeInMin + "'" + query.spectrum.PrecursorIntensity + "'" + query.spectrum.PrecursorIntensityPerMilliSecond; " is 146.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The length of the statement  "	Dictionary<Dictionary<Peptide' MaxFlowElutionCurve>' double> DicOfCurveErrors = new Dictionary<Dictionary<Peptide' MaxFlowElutionCurve>' double> (); " is 148.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The length of the statement  "				Dictionary<PeptideSpectrumMatch' SolvedResult> finalRatios = SolveFromFragmentScore (nbProductsToKeep' precision' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' query' out underFlow' out percentError' dbOptions.ConSole); " is 349.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The length of the statement  "						curves [cPep.Peptide].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds)); " is 170.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The length of the statement  "						curves [cPep.Peptide].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (timeInMilliSeconds)); " is 170.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ComputePeptideRatios,The length of the statement  "	Dictionary<Dictionary<Peptide' MaxFlowElutionCurve>' double> dicOfCorrelations = new Dictionary<Dictionary<Peptide' MaxFlowElutionCurve>' double> (); " is 149.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ComputePeptideRatios,The length of the statement  "	Dictionary<Dictionary<Peptide' MaxFlowElutionCurve>' double> dicOfCurves = new Dictionary<Dictionary<Peptide' MaxFlowElutionCurve>' double> (); " is 143.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ComputePeptideRatios,The length of the statement  "			Dictionary<Dictionary<Peptide' MaxFlowElutionCurve>' double> dicOfCurves2 = new Dictionary<Dictionary<Peptide' MaxFlowElutionCurve>' double> (); " is 144.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,SolveFromFragmentScoreTheoMZ,The length of the statement  "	Utilities.Methods.GradientDescent.SolveMaxFlowStyle (unitSpectrum' mixedSpectrum' out solution' out tmpUnderflow' ConSole' 1); " is 126.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,SolveFromFragmentScore,The length of the statement  "	Utilities.Methods.GradientDescent.SolveMaxFlowStyle (unitSpectrum' mixedSpectrum' out solution' out tmpUnderflow' ConSole' 1); " is 126.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,SolveFromSpectrumBKP,The length of the statement  "	double error = ComputeMaxFlow (tmpRatiosToFit' expandedCapacity' tolerance' ref solutions' ref errorInPercent' ref average' ConSole); " is 133.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,SolveFromSpectrumBKP,The length of the statement  "	Dictionary<CharacterizedPrecursor' SolvedResult> resultPerSample = new Dictionary<CharacterizedPrecursor' SolvedResult> (); " is 123.
Long Statement,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetResultList,The length of the statement  "	//sumVal += (underFlow / sumOfIntensities) * precision;//Counter intuitive' but according to test samples' it is less precise " is 125.
Empty Catch Block,PeptidAce.ModernUI.Content,SettingsAppearance,C:\repos\olivierlizotte_Iso-PeptidAce\Content\Parameters.xaml.cs,TextBox_TextChanged,The method has an empty catch block.
Empty Catch Block,PeptidAce.ModernUI.Content,SettingsAppearance,C:\repos\olivierlizotte_Iso-PeptidAce\Content\Parameters.xaml.cs,TextBox_TextChanged_1,The method has an empty catch block.
Empty Catch Block,PeptidAce.ModernUI.Content,SettingsAppearance,C:\repos\olivierlizotte_Iso-PeptidAce\Content\Parameters.xaml.cs,TextBox_TextChanged_2,The method has an empty catch block.
Empty Catch Block,PeptidAce.ModernUI.Content,SettingsAppearance,C:\repos\olivierlizotte_Iso-PeptidAce\Content\Parameters.xaml.cs,TextBox_TextChanged_3,The method has an empty catch block.
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetCombinedMatches,The following statement contains a magic number: foreach (double mz in dicOfCommonFragments.Keys) {  	bool found = false;  	foreach (ProductMatch match in AllFragments)  		if (match.theoMz == mz) {  			matches.Add (new ProductMatch (match));  			found = true;  		}  	if (!found) {  		double sumPsmFactor = 0;  		ProductMatch newMatch = new ProductMatch ();  		newMatch.theoMz = mz;  		newMatch.weight = 0;  		newMatch.obsIntensity = 0;  		newMatch.normalizedIntensity = 0;  		foreach (PeptideSpectrumMatch psm in Psms) {  			double timePoint = psm.Query.spectrum.RetentionTimeInMin * 1000.0 * 60.0;  			double peakIntensity = 0.0;  			foreach (MsMsPeak peak in psm.Query.spectrum.Peaks) {  				if (peak.Intensity > 0 && Math.Abs (Utilities.Numerics.CalculateMassError (peak.MZ' mz' dbOptions.productMassTolerance.Units)) <= dbOptions.productMassTolerance.Value)  					peakIntensity += peak.Intensity;  			}  			if (peakIntensity > 0) {  				newMatch.obsIntensity += peakIntensity * DicOfPsmFactor [psm];  				newMatch.normalizedIntensity += (peakIntensity / this.eCurveIntensityPerMS.GetLocalArea (timePoint' timePoint + psm.Query.spectrum.InjectionTime)) * DicOfPsmFactor [psm];  				sumPsmFactor += DicOfPsmFactor [psm];  				newMatch.weight++;  			}  		}  		if (newMatch.weight > 0) {  			newMatch.obsIntensity /= sumPsmFactor;  			newMatch.normalizedIntensity /= sumPsmFactor;  		}  		newMatch.weight *= newMatch.normalizedIntensity;  		matches.Add (newMatch);  	}  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetCombinedMatches,The following statement contains a magic number: foreach (double mz in dicOfCommonFragments.Keys) {  	bool found = false;  	foreach (ProductMatch match in AllFragments)  		if (match.theoMz == mz) {  			matches.Add (new ProductMatch (match));  			found = true;  		}  	if (!found) {  		double sumPsmFactor = 0;  		ProductMatch newMatch = new ProductMatch ();  		newMatch.theoMz = mz;  		newMatch.weight = 0;  		newMatch.obsIntensity = 0;  		newMatch.normalizedIntensity = 0;  		foreach (PeptideSpectrumMatch psm in Psms) {  			double timePoint = psm.Query.spectrum.RetentionTimeInMin * 1000.0 * 60.0;  			double peakIntensity = 0.0;  			foreach (MsMsPeak peak in psm.Query.spectrum.Peaks) {  				if (peak.Intensity > 0 && Math.Abs (Utilities.Numerics.CalculateMassError (peak.MZ' mz' dbOptions.productMassTolerance.Units)) <= dbOptions.productMassTolerance.Value)  					peakIntensity += peak.Intensity;  			}  			if (peakIntensity > 0) {  				newMatch.obsIntensity += peakIntensity * DicOfPsmFactor [psm];  				newMatch.normalizedIntensity += (peakIntensity / this.eCurveIntensityPerMS.GetLocalArea (timePoint' timePoint + psm.Query.spectrum.InjectionTime)) * DicOfPsmFactor [psm];  				sumPsmFactor += DicOfPsmFactor [psm];  				newMatch.weight++;  			}  		}  		if (newMatch.weight > 0) {  			newMatch.obsIntensity /= sumPsmFactor;  			newMatch.normalizedIntensity /= sumPsmFactor;  		}  		newMatch.weight *= newMatch.normalizedIntensity;  		matches.Add (newMatch);  	}  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetCombinedMatches,The following statement contains a magic number: if (!found) {  	double sumPsmFactor = 0;  	ProductMatch newMatch = new ProductMatch ();  	newMatch.theoMz = mz;  	newMatch.weight = 0;  	newMatch.obsIntensity = 0;  	newMatch.normalizedIntensity = 0;  	foreach (PeptideSpectrumMatch psm in Psms) {  		double timePoint = psm.Query.spectrum.RetentionTimeInMin * 1000.0 * 60.0;  		double peakIntensity = 0.0;  		foreach (MsMsPeak peak in psm.Query.spectrum.Peaks) {  			if (peak.Intensity > 0 && Math.Abs (Utilities.Numerics.CalculateMassError (peak.MZ' mz' dbOptions.productMassTolerance.Units)) <= dbOptions.productMassTolerance.Value)  				peakIntensity += peak.Intensity;  		}  		if (peakIntensity > 0) {  			newMatch.obsIntensity += peakIntensity * DicOfPsmFactor [psm];  			newMatch.normalizedIntensity += (peakIntensity / this.eCurveIntensityPerMS.GetLocalArea (timePoint' timePoint + psm.Query.spectrum.InjectionTime)) * DicOfPsmFactor [psm];  			sumPsmFactor += DicOfPsmFactor [psm];  			newMatch.weight++;  		}  	}  	if (newMatch.weight > 0) {  		newMatch.obsIntensity /= sumPsmFactor;  		newMatch.normalizedIntensity /= sumPsmFactor;  	}  	newMatch.weight *= newMatch.normalizedIntensity;  	matches.Add (newMatch);  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetCombinedMatches,The following statement contains a magic number: if (!found) {  	double sumPsmFactor = 0;  	ProductMatch newMatch = new ProductMatch ();  	newMatch.theoMz = mz;  	newMatch.weight = 0;  	newMatch.obsIntensity = 0;  	newMatch.normalizedIntensity = 0;  	foreach (PeptideSpectrumMatch psm in Psms) {  		double timePoint = psm.Query.spectrum.RetentionTimeInMin * 1000.0 * 60.0;  		double peakIntensity = 0.0;  		foreach (MsMsPeak peak in psm.Query.spectrum.Peaks) {  			if (peak.Intensity > 0 && Math.Abs (Utilities.Numerics.CalculateMassError (peak.MZ' mz' dbOptions.productMassTolerance.Units)) <= dbOptions.productMassTolerance.Value)  				peakIntensity += peak.Intensity;  		}  		if (peakIntensity > 0) {  			newMatch.obsIntensity += peakIntensity * DicOfPsmFactor [psm];  			newMatch.normalizedIntensity += (peakIntensity / this.eCurveIntensityPerMS.GetLocalArea (timePoint' timePoint + psm.Query.spectrum.InjectionTime)) * DicOfPsmFactor [psm];  			sumPsmFactor += DicOfPsmFactor [psm];  			newMatch.weight++;  		}  	}  	if (newMatch.weight > 0) {  		newMatch.obsIntensity /= sumPsmFactor;  		newMatch.normalizedIntensity /= sumPsmFactor;  	}  	newMatch.weight *= newMatch.normalizedIntensity;  	matches.Add (newMatch);  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetCombinedMatches,The following statement contains a magic number: foreach (PeptideSpectrumMatch psm in Psms) {  	double timePoint = psm.Query.spectrum.RetentionTimeInMin * 1000.0 * 60.0;  	double peakIntensity = 0.0;  	foreach (MsMsPeak peak in psm.Query.spectrum.Peaks) {  		if (peak.Intensity > 0 && Math.Abs (Utilities.Numerics.CalculateMassError (peak.MZ' mz' dbOptions.productMassTolerance.Units)) <= dbOptions.productMassTolerance.Value)  			peakIntensity += peak.Intensity;  	}  	if (peakIntensity > 0) {  		newMatch.obsIntensity += peakIntensity * DicOfPsmFactor [psm];  		newMatch.normalizedIntensity += (peakIntensity / this.eCurveIntensityPerMS.GetLocalArea (timePoint' timePoint + psm.Query.spectrum.InjectionTime)) * DicOfPsmFactor [psm];  		sumPsmFactor += DicOfPsmFactor [psm];  		newMatch.weight++;  	}  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetCombinedMatches,The following statement contains a magic number: foreach (PeptideSpectrumMatch psm in Psms) {  	double timePoint = psm.Query.spectrum.RetentionTimeInMin * 1000.0 * 60.0;  	double peakIntensity = 0.0;  	foreach (MsMsPeak peak in psm.Query.spectrum.Peaks) {  		if (peak.Intensity > 0 && Math.Abs (Utilities.Numerics.CalculateMassError (peak.MZ' mz' dbOptions.productMassTolerance.Units)) <= dbOptions.productMassTolerance.Value)  			peakIntensity += peak.Intensity;  	}  	if (peakIntensity > 0) {  		newMatch.obsIntensity += peakIntensity * DicOfPsmFactor [psm];  		newMatch.normalizedIntensity += (peakIntensity / this.eCurveIntensityPerMS.GetLocalArea (timePoint' timePoint + psm.Query.spectrum.InjectionTime)) * DicOfPsmFactor [psm];  		sumPsmFactor += DicOfPsmFactor [psm];  		newMatch.weight++;  	}  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetCombinedMatches,The following statement contains a magic number: foreach (ProductMatch pm in matches)  	if (pm.normalizedIntensity < averageNormedIntensity * 0.1)//0.05  	 {  		pm.normalizedIntensity = 0;  		pm.obsIntensity = 0;  		pm.weight = 0;  	}  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetCombinedMatches,The following statement contains a magic number: if (pm.normalizedIntensity < averageNormedIntensity * 0.1)//0.05   {  	pm.normalizedIntensity = 0;  	pm.obsIntensity = 0;  	pm.weight = 0;  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizePrecursorFactor,The following statement contains a magic number: if (eCurveIntensityCount.Area > 0) {  	//Normalize matches based on precursor intensity differences  	double cumulArea = 0.0;  	int nbNonZero = 0;  	foreach (CharacterizedPrecursor precursor in allCorrespondingPrec) {  		if (precursor.eCurveIntensityCount.Area > 0) {  			nbNonZero++;  			cumulArea += precursor.eCurveIntensityCount.Area;  		}  	}  	if (nbNonZero > 0) {  		keep = true;  		average = cumulArea / (double)nbNonZero;  		//PrecursorLossNormalizeFactor = Math.Log(average' 2) / Math.Log(this.eCurve.Area' 2);  		PrecursorLossNormalizeFactor = Math.Log (average' 10) / Math.Log (this.eCurveIntensityCount.Area' 10);  		//PrecursorLossNormalizeFactor = average / this.eCurve.Area;  		//PrecursorLossNormalizeFactor = 1.0;  	}  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizePrecursorFactor,The following statement contains a magic number: if (eCurveIntensityCount.Area > 0) {  	//Normalize matches based on precursor intensity differences  	double cumulArea = 0.0;  	int nbNonZero = 0;  	foreach (CharacterizedPrecursor precursor in allCorrespondingPrec) {  		if (precursor.eCurveIntensityCount.Area > 0) {  			nbNonZero++;  			cumulArea += precursor.eCurveIntensityCount.Area;  		}  	}  	if (nbNonZero > 0) {  		keep = true;  		average = cumulArea / (double)nbNonZero;  		//PrecursorLossNormalizeFactor = Math.Log(average' 2) / Math.Log(this.eCurve.Area' 2);  		PrecursorLossNormalizeFactor = Math.Log (average' 10) / Math.Log (this.eCurveIntensityCount.Area' 10);  		//PrecursorLossNormalizeFactor = average / this.eCurve.Area;  		//PrecursorLossNormalizeFactor = 1.0;  	}  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizePrecursorFactor,The following statement contains a magic number: if (nbNonZero > 0) {  	keep = true;  	average = cumulArea / (double)nbNonZero;  	//PrecursorLossNormalizeFactor = Math.Log(average' 2) / Math.Log(this.eCurve.Area' 2);  	PrecursorLossNormalizeFactor = Math.Log (average' 10) / Math.Log (this.eCurveIntensityCount.Area' 10);  	//PrecursorLossNormalizeFactor = average / this.eCurve.Area;  	//PrecursorLossNormalizeFactor = 1.0;  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizePrecursorFactor,The following statement contains a magic number: if (nbNonZero > 0) {  	keep = true;  	average = cumulArea / (double)nbNonZero;  	//PrecursorLossNormalizeFactor = Math.Log(average' 2) / Math.Log(this.eCurve.Area' 2);  	PrecursorLossNormalizeFactor = Math.Log (average' 10) / Math.Log (this.eCurveIntensityCount.Area' 10);  	//PrecursorLossNormalizeFactor = average / this.eCurve.Area;  	//PrecursorLossNormalizeFactor = 1.0;  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizePrecursorFactor,The following statement contains a magic number: PrecursorLossNormalizeFactor = Math.Log (average' 10) / Math.Log (this.eCurveIntensityCount.Area' 10);  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizePrecursorFactor,The following statement contains a magic number: PrecursorLossNormalizeFactor = Math.Log (average' 10) / Math.Log (this.eCurveIntensityCount.Area' 10);  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizePrecursorFactor,The following statement contains a magic number: if (PrecursorLossNormalizeFactor > 4)  	PrecursorLossNormalizeFactor = 4;  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizePrecursorFactor,The following statement contains a magic number: if (PrecursorLossNormalizeFactor > 4)  	PrecursorLossNormalizeFactor = 4;  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizePrecursorFactor,The following statement contains a magic number: PrecursorLossNormalizeFactor = 4;  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizePrecursorFactor,The following statement contains a magic number: if (PrecursorLossNormalizeFactor < 0.25)  	PrecursorLossNormalizeFactor = 0.25;  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizePrecursorFactor,The following statement contains a magic number: if (PrecursorLossNormalizeFactor < 0.25)  	PrecursorLossNormalizeFactor = 0.25;  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizePrecursorFactor,The following statement contains a magic number: PrecursorLossNormalizeFactor = 0.25;  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizingCurve,The following statement contains a magic number: foreach (Query query in this.Queries) {  	double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  	double underFlow = 0;  	double percentError = 0;  	double intInTrap = query.spectrum.PrecursorIntensityPerMilliSecond * query.spectrum.InjectionTime;  	Dictionary<CharacterizedPrecursor' PositionnalIsomerSolver.SolvedResult> finalRatios = PositionnalIsomerSolver.SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' intInTrap' query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole);  	if (percentError < 0.5 && finalRatios [this].NbFitTimes > 0) {  		double ratio = intInTrap / finalRatios [this].NbFitTimes;  		if (ratio > 0.5 && ratio < 2)  			curve.AddPoint (intInTrap' intInTrap / finalRatios [this].NbFitTimes);  	}  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizingCurve,The following statement contains a magic number: foreach (Query query in this.Queries) {  	double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  	double underFlow = 0;  	double percentError = 0;  	double intInTrap = query.spectrum.PrecursorIntensityPerMilliSecond * query.spectrum.InjectionTime;  	Dictionary<CharacterizedPrecursor' PositionnalIsomerSolver.SolvedResult> finalRatios = PositionnalIsomerSolver.SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' intInTrap' query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole);  	if (percentError < 0.5 && finalRatios [this].NbFitTimes > 0) {  		double ratio = intInTrap / finalRatios [this].NbFitTimes;  		if (ratio > 0.5 && ratio < 2)  			curve.AddPoint (intInTrap' intInTrap / finalRatios [this].NbFitTimes);  	}  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizingCurve,The following statement contains a magic number: foreach (Query query in this.Queries) {  	double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  	double underFlow = 0;  	double percentError = 0;  	double intInTrap = query.spectrum.PrecursorIntensityPerMilliSecond * query.spectrum.InjectionTime;  	Dictionary<CharacterizedPrecursor' PositionnalIsomerSolver.SolvedResult> finalRatios = PositionnalIsomerSolver.SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' intInTrap' query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole);  	if (percentError < 0.5 && finalRatios [this].NbFitTimes > 0) {  		double ratio = intInTrap / finalRatios [this].NbFitTimes;  		if (ratio > 0.5 && ratio < 2)  			curve.AddPoint (intInTrap' intInTrap / finalRatios [this].NbFitTimes);  	}  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizingCurve,The following statement contains a magic number: foreach (Query query in this.Queries) {  	double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  	double underFlow = 0;  	double percentError = 0;  	double intInTrap = query.spectrum.PrecursorIntensityPerMilliSecond * query.spectrum.InjectionTime;  	Dictionary<CharacterizedPrecursor' PositionnalIsomerSolver.SolvedResult> finalRatios = PositionnalIsomerSolver.SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' intInTrap' query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole);  	if (percentError < 0.5 && finalRatios [this].NbFitTimes > 0) {  		double ratio = intInTrap / finalRatios [this].NbFitTimes;  		if (ratio > 0.5 && ratio < 2)  			curve.AddPoint (intInTrap' intInTrap / finalRatios [this].NbFitTimes);  	}  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizingCurve,The following statement contains a magic number: foreach (Query query in this.Queries) {  	double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  	double underFlow = 0;  	double percentError = 0;  	double intInTrap = query.spectrum.PrecursorIntensityPerMilliSecond * query.spectrum.InjectionTime;  	Dictionary<CharacterizedPrecursor' PositionnalIsomerSolver.SolvedResult> finalRatios = PositionnalIsomerSolver.SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' intInTrap' query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole);  	if (percentError < 0.5 && finalRatios [this].NbFitTimes > 0) {  		double ratio = intInTrap / finalRatios [this].NbFitTimes;  		if (ratio > 0.5 && ratio < 2)  			curve.AddPoint (intInTrap' intInTrap / finalRatios [this].NbFitTimes);  	}  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizingCurve,The following statement contains a magic number: if (percentError < 0.5 && finalRatios [this].NbFitTimes > 0) {  	double ratio = intInTrap / finalRatios [this].NbFitTimes;  	if (ratio > 0.5 && ratio < 2)  		curve.AddPoint (intInTrap' intInTrap / finalRatios [this].NbFitTimes);  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizingCurve,The following statement contains a magic number: if (percentError < 0.5 && finalRatios [this].NbFitTimes > 0) {  	double ratio = intInTrap / finalRatios [this].NbFitTimes;  	if (ratio > 0.5 && ratio < 2)  		curve.AddPoint (intInTrap' intInTrap / finalRatios [this].NbFitTimes);  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizingCurve,The following statement contains a magic number: if (percentError < 0.5 && finalRatios [this].NbFitTimes > 0) {  	double ratio = intInTrap / finalRatios [this].NbFitTimes;  	if (ratio > 0.5 && ratio < 2)  		curve.AddPoint (intInTrap' intInTrap / finalRatios [this].NbFitTimes);  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizingCurve,The following statement contains a magic number: if (ratio > 0.5 && ratio < 2)  	curve.AddPoint (intInTrap' intInTrap / finalRatios [this].NbFitTimes);  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetNormalizingCurve,The following statement contains a magic number: if (ratio > 0.5 && ratio < 2)  	curve.AddPoint (intInTrap' intInTrap / finalRatios [this].NbFitTimes);  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetSpikedPrecursors,The following statement contains a magic number: foreach (Sample spikedSample in spikedSamples) {  	Dictionary<double' PrecursorIon> DicOfSpectrumMasses = PrecursorIon.GetPrecursors (spikedResult' spikedSample' dbOptions' mzKeys.Keys);  	foreach (double mzKey in DicOfSpectrumMasses.Keys) {  		if (mzKeys.ContainsKey (mzKey)) {  			//Pick the best PSM for each sample/precursor pair  			Dictionary<Peptide' double> DicOfProbabilityScores = new Dictionary<Peptide' double> ();  			foreach (Query query in mzKeys [mzKey].Keys)  				if (query.sample == spikedSample) {  					foreach (PeptideSpectrumMatch psm in query.psms)  						if (!DicOfProbabilityScores.ContainsKey (psm.Peptide))  							DicOfProbabilityScores.Add (psm.Peptide' psm.ProbabilityScore ());  						else  							DicOfProbabilityScores [psm.Peptide] += psm.ProbabilityScore ();  				}  			Peptide bestPeptide = null;  			double bestScore = double.MinValue;  			foreach (Peptide keyPep in DicOfProbabilityScores.Keys)  				if (DicOfProbabilityScores [keyPep] > bestScore) {  					bestScore = DicOfProbabilityScores [keyPep];  					bestPeptide = keyPep;  				}  			if (bestPeptide != null) {  				CharacterizedPrecursor cPrec = new CharacterizedPrecursor (spikedSample' dbOptions' bestPeptide' mzKeys [mzKey].Keys' mzKey);  				//Don't keep precursors if they are not well characterized (unfragmented or missasigned)  				if (cPrec.AllFragments.Count >= cPrec.Peptide.Length - 2) {  					if (!spikes.ContainsKey (mzKey))  						spikes.Add (mzKey' new Dictionary<Sample' CharacterizedPrecursor> ());  					if (!spikes [mzKey].ContainsKey (spikedSample))  						spikes [mzKey].Add (spikedSample' cPrec);  					else  						Console.WriteLine ("Twice??");  				}  			}  		}  	}  	//End of foreach mzKey  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetSpikedPrecursors,The following statement contains a magic number: foreach (double mzKey in DicOfSpectrumMasses.Keys) {  	if (mzKeys.ContainsKey (mzKey)) {  		//Pick the best PSM for each sample/precursor pair  		Dictionary<Peptide' double> DicOfProbabilityScores = new Dictionary<Peptide' double> ();  		foreach (Query query in mzKeys [mzKey].Keys)  			if (query.sample == spikedSample) {  				foreach (PeptideSpectrumMatch psm in query.psms)  					if (!DicOfProbabilityScores.ContainsKey (psm.Peptide))  						DicOfProbabilityScores.Add (psm.Peptide' psm.ProbabilityScore ());  					else  						DicOfProbabilityScores [psm.Peptide] += psm.ProbabilityScore ();  			}  		Peptide bestPeptide = null;  		double bestScore = double.MinValue;  		foreach (Peptide keyPep in DicOfProbabilityScores.Keys)  			if (DicOfProbabilityScores [keyPep] > bestScore) {  				bestScore = DicOfProbabilityScores [keyPep];  				bestPeptide = keyPep;  			}  		if (bestPeptide != null) {  			CharacterizedPrecursor cPrec = new CharacterizedPrecursor (spikedSample' dbOptions' bestPeptide' mzKeys [mzKey].Keys' mzKey);  			//Don't keep precursors if they are not well characterized (unfragmented or missasigned)  			if (cPrec.AllFragments.Count >= cPrec.Peptide.Length - 2) {  				if (!spikes.ContainsKey (mzKey))  					spikes.Add (mzKey' new Dictionary<Sample' CharacterizedPrecursor> ());  				if (!spikes [mzKey].ContainsKey (spikedSample))  					spikes [mzKey].Add (spikedSample' cPrec);  				else  					Console.WriteLine ("Twice??");  			}  		}  	}  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetSpikedPrecursors,The following statement contains a magic number: if (mzKeys.ContainsKey (mzKey)) {  	//Pick the best PSM for each sample/precursor pair  	Dictionary<Peptide' double> DicOfProbabilityScores = new Dictionary<Peptide' double> ();  	foreach (Query query in mzKeys [mzKey].Keys)  		if (query.sample == spikedSample) {  			foreach (PeptideSpectrumMatch psm in query.psms)  				if (!DicOfProbabilityScores.ContainsKey (psm.Peptide))  					DicOfProbabilityScores.Add (psm.Peptide' psm.ProbabilityScore ());  				else  					DicOfProbabilityScores [psm.Peptide] += psm.ProbabilityScore ();  		}  	Peptide bestPeptide = null;  	double bestScore = double.MinValue;  	foreach (Peptide keyPep in DicOfProbabilityScores.Keys)  		if (DicOfProbabilityScores [keyPep] > bestScore) {  			bestScore = DicOfProbabilityScores [keyPep];  			bestPeptide = keyPep;  		}  	if (bestPeptide != null) {  		CharacterizedPrecursor cPrec = new CharacterizedPrecursor (spikedSample' dbOptions' bestPeptide' mzKeys [mzKey].Keys' mzKey);  		//Don't keep precursors if they are not well characterized (unfragmented or missasigned)  		if (cPrec.AllFragments.Count >= cPrec.Peptide.Length - 2) {  			if (!spikes.ContainsKey (mzKey))  				spikes.Add (mzKey' new Dictionary<Sample' CharacterizedPrecursor> ());  			if (!spikes [mzKey].ContainsKey (spikedSample))  				spikes [mzKey].Add (spikedSample' cPrec);  			else  				Console.WriteLine ("Twice??");  		}  	}  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetSpikedPrecursors,The following statement contains a magic number: if (bestPeptide != null) {  	CharacterizedPrecursor cPrec = new CharacterizedPrecursor (spikedSample' dbOptions' bestPeptide' mzKeys [mzKey].Keys' mzKey);  	//Don't keep precursors if they are not well characterized (unfragmented or missasigned)  	if (cPrec.AllFragments.Count >= cPrec.Peptide.Length - 2) {  		if (!spikes.ContainsKey (mzKey))  			spikes.Add (mzKey' new Dictionary<Sample' CharacterizedPrecursor> ());  		if (!spikes [mzKey].ContainsKey (spikedSample))  			spikes [mzKey].Add (spikedSample' cPrec);  		else  			Console.WriteLine ("Twice??");  	}  }  
Magic Number,PeptidAce.Iso.Structures,CharacterizedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\CharacterizedPrecursor.cs,GetSpikedPrecursors,The following statement contains a magic number: if (cPrec.AllFragments.Count >= cPrec.Peptide.Length - 2) {  	if (!spikes.ContainsKey (mzKey))  		spikes.Add (mzKey' new Dictionary<Sample' CharacterizedPrecursor> ());  	if (!spikes [mzKey].ContainsKey (spikedSample))  		spikes [mzKey].Add (spikedSample' cPrec);  	else  		Console.WriteLine ("Twice??");  }  
Magic Number,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,GetMixedPrecursors,The following statement contains a magic number: foreach (double key in DicOfSpectrumMasses.Keys) {  	if (charPeptides.ContainsKey (key)) {  		foreach (PrecursorIon precIon in DicOfSpectrumMasses [key].SplitBasedOnTime (dbOptions)) {  			MixedPrecursor mixedPrecursor = new MixedPrecursor (mixedSample' precIon' key);  			//Don't try to characterize mixed precursors if there is less than five scans  			if (mixedPrecursor.Queries.Count > 4) {  				foreach (Query q in mixedPrecursor.Queries)  					q.spectrum.PrecursorIntensityPerMilliSecond = mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (q.spectrum.RetentionTimeInMin * 1000.0 * 60.0);  				// + 0.5 * q.spectrum.InjectionTime);  				listOfMixedPrec.Add (mixedPrecursor);  			}  			//DicOfMixedPrecursor.Add(key' mixedPrecursor);  		}  	}  }  
Magic Number,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,GetMixedPrecursors,The following statement contains a magic number: foreach (double key in DicOfSpectrumMasses.Keys) {  	if (charPeptides.ContainsKey (key)) {  		foreach (PrecursorIon precIon in DicOfSpectrumMasses [key].SplitBasedOnTime (dbOptions)) {  			MixedPrecursor mixedPrecursor = new MixedPrecursor (mixedSample' precIon' key);  			//Don't try to characterize mixed precursors if there is less than five scans  			if (mixedPrecursor.Queries.Count > 4) {  				foreach (Query q in mixedPrecursor.Queries)  					q.spectrum.PrecursorIntensityPerMilliSecond = mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (q.spectrum.RetentionTimeInMin * 1000.0 * 60.0);  				// + 0.5 * q.spectrum.InjectionTime);  				listOfMixedPrec.Add (mixedPrecursor);  			}  			//DicOfMixedPrecursor.Add(key' mixedPrecursor);  		}  	}  }  
Magic Number,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,GetMixedPrecursors,The following statement contains a magic number: foreach (double key in DicOfSpectrumMasses.Keys) {  	if (charPeptides.ContainsKey (key)) {  		foreach (PrecursorIon precIon in DicOfSpectrumMasses [key].SplitBasedOnTime (dbOptions)) {  			MixedPrecursor mixedPrecursor = new MixedPrecursor (mixedSample' precIon' key);  			//Don't try to characterize mixed precursors if there is less than five scans  			if (mixedPrecursor.Queries.Count > 4) {  				foreach (Query q in mixedPrecursor.Queries)  					q.spectrum.PrecursorIntensityPerMilliSecond = mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (q.spectrum.RetentionTimeInMin * 1000.0 * 60.0);  				// + 0.5 * q.spectrum.InjectionTime);  				listOfMixedPrec.Add (mixedPrecursor);  			}  			//DicOfMixedPrecursor.Add(key' mixedPrecursor);  		}  	}  }  
Magic Number,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,GetMixedPrecursors,The following statement contains a magic number: if (charPeptides.ContainsKey (key)) {  	foreach (PrecursorIon precIon in DicOfSpectrumMasses [key].SplitBasedOnTime (dbOptions)) {  		MixedPrecursor mixedPrecursor = new MixedPrecursor (mixedSample' precIon' key);  		//Don't try to characterize mixed precursors if there is less than five scans  		if (mixedPrecursor.Queries.Count > 4) {  			foreach (Query q in mixedPrecursor.Queries)  				q.spectrum.PrecursorIntensityPerMilliSecond = mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (q.spectrum.RetentionTimeInMin * 1000.0 * 60.0);  			// + 0.5 * q.spectrum.InjectionTime);  			listOfMixedPrec.Add (mixedPrecursor);  		}  		//DicOfMixedPrecursor.Add(key' mixedPrecursor);  	}  }  
Magic Number,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,GetMixedPrecursors,The following statement contains a magic number: if (charPeptides.ContainsKey (key)) {  	foreach (PrecursorIon precIon in DicOfSpectrumMasses [key].SplitBasedOnTime (dbOptions)) {  		MixedPrecursor mixedPrecursor = new MixedPrecursor (mixedSample' precIon' key);  		//Don't try to characterize mixed precursors if there is less than five scans  		if (mixedPrecursor.Queries.Count > 4) {  			foreach (Query q in mixedPrecursor.Queries)  				q.spectrum.PrecursorIntensityPerMilliSecond = mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (q.spectrum.RetentionTimeInMin * 1000.0 * 60.0);  			// + 0.5 * q.spectrum.InjectionTime);  			listOfMixedPrec.Add (mixedPrecursor);  		}  		//DicOfMixedPrecursor.Add(key' mixedPrecursor);  	}  }  
Magic Number,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,GetMixedPrecursors,The following statement contains a magic number: if (charPeptides.ContainsKey (key)) {  	foreach (PrecursorIon precIon in DicOfSpectrumMasses [key].SplitBasedOnTime (dbOptions)) {  		MixedPrecursor mixedPrecursor = new MixedPrecursor (mixedSample' precIon' key);  		//Don't try to characterize mixed precursors if there is less than five scans  		if (mixedPrecursor.Queries.Count > 4) {  			foreach (Query q in mixedPrecursor.Queries)  				q.spectrum.PrecursorIntensityPerMilliSecond = mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (q.spectrum.RetentionTimeInMin * 1000.0 * 60.0);  			// + 0.5 * q.spectrum.InjectionTime);  			listOfMixedPrec.Add (mixedPrecursor);  		}  		//DicOfMixedPrecursor.Add(key' mixedPrecursor);  	}  }  
Magic Number,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,GetMixedPrecursors,The following statement contains a magic number: foreach (PrecursorIon precIon in DicOfSpectrumMasses [key].SplitBasedOnTime (dbOptions)) {  	MixedPrecursor mixedPrecursor = new MixedPrecursor (mixedSample' precIon' key);  	//Don't try to characterize mixed precursors if there is less than five scans  	if (mixedPrecursor.Queries.Count > 4) {  		foreach (Query q in mixedPrecursor.Queries)  			q.spectrum.PrecursorIntensityPerMilliSecond = mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (q.spectrum.RetentionTimeInMin * 1000.0 * 60.0);  		// + 0.5 * q.spectrum.InjectionTime);  		listOfMixedPrec.Add (mixedPrecursor);  	}  	//DicOfMixedPrecursor.Add(key' mixedPrecursor);  }  
Magic Number,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,GetMixedPrecursors,The following statement contains a magic number: foreach (PrecursorIon precIon in DicOfSpectrumMasses [key].SplitBasedOnTime (dbOptions)) {  	MixedPrecursor mixedPrecursor = new MixedPrecursor (mixedSample' precIon' key);  	//Don't try to characterize mixed precursors if there is less than five scans  	if (mixedPrecursor.Queries.Count > 4) {  		foreach (Query q in mixedPrecursor.Queries)  			q.spectrum.PrecursorIntensityPerMilliSecond = mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (q.spectrum.RetentionTimeInMin * 1000.0 * 60.0);  		// + 0.5 * q.spectrum.InjectionTime);  		listOfMixedPrec.Add (mixedPrecursor);  	}  	//DicOfMixedPrecursor.Add(key' mixedPrecursor);  }  
Magic Number,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,GetMixedPrecursors,The following statement contains a magic number: foreach (PrecursorIon precIon in DicOfSpectrumMasses [key].SplitBasedOnTime (dbOptions)) {  	MixedPrecursor mixedPrecursor = new MixedPrecursor (mixedSample' precIon' key);  	//Don't try to characterize mixed precursors if there is less than five scans  	if (mixedPrecursor.Queries.Count > 4) {  		foreach (Query q in mixedPrecursor.Queries)  			q.spectrum.PrecursorIntensityPerMilliSecond = mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (q.spectrum.RetentionTimeInMin * 1000.0 * 60.0);  		// + 0.5 * q.spectrum.InjectionTime);  		listOfMixedPrec.Add (mixedPrecursor);  	}  	//DicOfMixedPrecursor.Add(key' mixedPrecursor);  }  
Magic Number,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,GetMixedPrecursors,The following statement contains a magic number: if (mixedPrecursor.Queries.Count > 4) {  	foreach (Query q in mixedPrecursor.Queries)  		q.spectrum.PrecursorIntensityPerMilliSecond = mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (q.spectrum.RetentionTimeInMin * 1000.0 * 60.0);  	// + 0.5 * q.spectrum.InjectionTime);  	listOfMixedPrec.Add (mixedPrecursor);  }  
Magic Number,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,GetMixedPrecursors,The following statement contains a magic number: if (mixedPrecursor.Queries.Count > 4) {  	foreach (Query q in mixedPrecursor.Queries)  		q.spectrum.PrecursorIntensityPerMilliSecond = mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (q.spectrum.RetentionTimeInMin * 1000.0 * 60.0);  	// + 0.5 * q.spectrum.InjectionTime);  	listOfMixedPrec.Add (mixedPrecursor);  }  
Magic Number,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,GetMixedPrecursors,The following statement contains a magic number: if (mixedPrecursor.Queries.Count > 4) {  	foreach (Query q in mixedPrecursor.Queries)  		q.spectrum.PrecursorIntensityPerMilliSecond = mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (q.spectrum.RetentionTimeInMin * 1000.0 * 60.0);  	// + 0.5 * q.spectrum.InjectionTime);  	listOfMixedPrec.Add (mixedPrecursor);  }  
Magic Number,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,GetMixedPrecursors,The following statement contains a magic number: foreach (Query q in mixedPrecursor.Queries)  	q.spectrum.PrecursorIntensityPerMilliSecond = mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (q.spectrum.RetentionTimeInMin * 1000.0 * 60.0);  
Magic Number,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,GetMixedPrecursors,The following statement contains a magic number: foreach (Query q in mixedPrecursor.Queries)  	q.spectrum.PrecursorIntensityPerMilliSecond = mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (q.spectrum.RetentionTimeInMin * 1000.0 * 60.0);  
Magic Number,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,GetMixedPrecursors,The following statement contains a magic number: q.spectrum.PrecursorIntensityPerMilliSecond = mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (q.spectrum.RetentionTimeInMin * 1000.0 * 60.0);  
Magic Number,PeptidAce.Iso.Structures,MixedPrecursor,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\MixedPrecursor.cs,GetMixedPrecursors,The following statement contains a magic number: q.spectrum.PrecursorIntensityPerMilliSecond = mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (q.spectrum.RetentionTimeInMin * 1000.0 * 60.0);  
Magic Number,PeptidAce.Iso.Structures,PrecursorIon,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\PrecursorIon.cs,PrecursorIon,The following statement contains a magic number: foreach (Query query in this.Queries) {  	double time = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  	dicOfTimeInMsVsIntensityPerMs.Add (time' query.spectrum.PrecursorIntensityPerMilliSecond);  	dicOfTimeInMsVsIntensityCount.Add (time' query.spectrum.PrecursorIntensity);  	if (query.spectrum.PrecursorIntensity > PeakTopIntensity)  		PeakTopIntensity = query.spectrum.PrecursorIntensity;  }  
Magic Number,PeptidAce.Iso.Structures,PrecursorIon,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\PrecursorIon.cs,PrecursorIon,The following statement contains a magic number: foreach (Query query in this.Queries) {  	double time = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  	dicOfTimeInMsVsIntensityPerMs.Add (time' query.spectrum.PrecursorIntensityPerMilliSecond);  	dicOfTimeInMsVsIntensityCount.Add (time' query.spectrum.PrecursorIntensity);  	if (query.spectrum.PrecursorIntensity > PeakTopIntensity)  		PeakTopIntensity = query.spectrum.PrecursorIntensity;  }  
Magic Number,PeptidAce.Iso.Structures,PrecursorIon,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\PrecursorIon.cs,SplitBasedOnTime,The following statement contains a magic number: if (Queries.Count > 0) {  	this.Queries.Sort (Query.AscendingRetentionTimeComparison);  	List<double> timePoints = new List<double> ();  	for (int i = 1; i < Queries.Count; i++)  		timePoints.Add (Queries [i].spectrum.RetentionTimeInMin - Queries [i - 1].spectrum.RetentionTimeInMin);  	double variance = MathNet.Numerics.Statistics.Statistics.UpperQuartile (timePoints);  	Queries newQ = new Queries (dbOptions);  	newQ.Add (Queries [0]);  	for (int i = 1; i < Queries.Count; i++) {  		if (timePoints [i - 1] > 10 * variance) {  			yield return new PrecursorIon (Sample' newQ' MZ' Charge);  			newQ.Clear ();  		}  		newQ.Add (Queries [i]);  	}  	yield return new PrecursorIon (Sample' newQ' MZ' Charge);  }  
Magic Number,PeptidAce.Iso.Structures,PrecursorIon,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\PrecursorIon.cs,SplitBasedOnTime,The following statement contains a magic number: for (int i = 1; i < Queries.Count; i++) {  	if (timePoints [i - 1] > 10 * variance) {  		yield return new PrecursorIon (Sample' newQ' MZ' Charge);  		newQ.Clear ();  	}  	newQ.Add (Queries [i]);  }  
Magic Number,PeptidAce.Iso.Structures,PrecursorIon,C:\repos\olivierlizotte_Iso-PeptidAce\Structures\PrecursorIon.cs,SplitBasedOnTime,The following statement contains a magic number: if (timePoints [i - 1] > 10 * variance) {  	yield return new PrecursorIon (Sample' newQ' MZ' Charge);  	newQ.Clear ();  }  
Magic Number,PeptidAce.Iso.UnitTests,StatsMaker,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\StatsMaker.cs,ProjectMerge,The following statement contains a magic number: newSolver.precTolPpm = 15;  
Magic Number,PeptidAce.Iso.UnitTests,StatsMaker,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\StatsMaker.cs,ProjectMerge,The following statement contains a magic number: newSolver.prodTolDa = 0.05;  
Magic Number,PeptidAce.Iso.UnitTests,StatsMaker,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\StatsMaker.cs,ProjectMerge,The following statement contains a magic number: newSolver.nbMinFragments = 5;  
Magic Number,PeptidAce.Iso.UnitTests,StatsMaker,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\StatsMaker.cs,ProjectMerge,The following statement contains a magic number: newSolver.nbMaxFragments = 5;  
Magic Number,PeptidAce.Iso.UnitTests,PisTest,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\Uptimizer.cs,Uptimize,The following statement contains a magic number: dbOptions.dProduct = 0.0917981081138356;  
Magic Number,PeptidAce.Iso.UnitTests,PisTest,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\Uptimizer.cs,Uptimize,The following statement contains a magic number: dbOptions.dPrecursor = 0.345789190542786;  
Magic Number,PeptidAce.Iso.UnitTests,PisTest,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\Uptimizer.cs,Uptimize,The following statement contains a magic number: dbOptions.dMatchingProductFraction = 0.427418045898628;  
Magic Number,PeptidAce.Iso.UnitTests,PisTest,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\Uptimizer.cs,Uptimize,The following statement contains a magic number: dbOptions.dIntensityFraction = 0.429418127252449;  
Magic Number,PeptidAce.Iso.UnitTests,PisTest,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\Uptimizer.cs,Uptimize,The following statement contains a magic number: dbOptions.dProtein = 0.692270441303156;  
Magic Number,PeptidAce.Iso.UnitTests,PisTest,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\Uptimizer.cs,Uptimize,The following statement contains a magic number: dbOptions.dPeptideScore = 0.636739763262095;  
Magic Number,PeptidAce.Iso.UnitTests,PisTest,C:\repos\olivierlizotte_Iso-PeptidAce\UnitTests\Uptimizer.cs,Uptimize,The following statement contains a magic number: dbOptions.dFragmentScore = 0.0229058195943506;  
Magic Number,PeptidAce.ModernUI.Content,ResultsDeconvoluted,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsDeconvoluted.xaml.cs,UpdateContent,The following statement contains a magic number: foreach (MixedPrecursor mixed in PepIso.solver.mixedPrecursors [sample]) {  	if (mixed.PeptideRatios.Count > 0 && mixed.MZ.ToString ().CompareTo (strKey) == 0) {  		List<double[]> intensities = new List<double[]> ();  		List<string[]> scanTimes = new List<string[]> ();  		List<double> ratios = new List<double> ();  		List<string> names = new List<string> ();  		//double[] timeArray = null;  		/*                     string[] timeStr = new string[mixed.eCurve.time.Count];                      for (int i = 0; i < timeStr.Length; i++)                         timeStr[i] = ((float)(mixed.eCurve.time[i] / (1000.0 * 60.0))).ToString();//ms to min                     //scanTimes.Add(time);//                      foreach (CharacterizedPrecursor peptide in mixed.PeptideRatios.Keys)                     {                         scanTimes.Add(timeStr);                         double[] arrayInt = new double[mixed.eCurve.time.Count];                         for (int i = 0; i < arrayInt.Length; i++)                             //arrayInt[i] = mixed.PeptideRatios[peptide].eCurvePerMs.InterpolateIntensity(mixed.eCurve.interpolatedTime[i]);                             arrayInt[i] = mixed.PeptideRatios[peptide].eCurveCount.InterpolateIntensity(mixed.eCurve.interpolatedTime[i]);                         intensities.Add(arrayInt);                          ratios.Add(mixed.PeptideRatios[peptide].eCurvePerMs.Area);                          names.Add(peptide.Peptide.Sequence + "  [" + Utilities.vsCSV.GetFileName_NoExtension(peptide.Sample.sSDF) + "]");                     }//*/List<double> timePoints = Utilities.ElutionCurve.GetTimePoints (64' true' mixed.eCurveIntensityCount.interpolatedTime' mixed.eCurveIntensityCount.interpolatedIntensityCount);  		string[] timeStr = new string[timePoints.Count];  		for (int i = 0; i < timeStr.Length; i++)  			timeStr [i] = ((float)(timePoints [i] / (1000.0 * 60.0))).ToString ();  		//ms to min  		//scanTimes.Add(time);//  		foreach (CharacterizedPrecursor peptide in mixed.PeptideRatios.Keys) {  			scanTimes.Add (timeStr);  			double[] arrayInt = new double[timePoints.Count];  			for (int i = 0; i < arrayInt.Length; i++)  				//arrayInt[i] = mixed.PeptideRatios[peptide].eCurvePerMs.InterpolateIntensity(timePoints[i]);  				arrayInt [i] = mixed.PeptideRatios [peptide].eCurveCount.InterpolateIntensity (timePoints [i]);  			intensities.Add (arrayInt);  			ratios.Add (mixed.PeptideRatios [peptide].eCurvePerMs.Area);  			names.Add (peptide.Peptide.Sequence + "  [" + Utilities.vsCSV.GetFileName_NoExtension (peptide.Sample.sSDF) + "]");  		}  		//*/  		StackPanel1.Children.Add (new SynthPeptideUC (intensities.ToArray ()' scanTimes.ToArray ()' names.ToArray ()' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + " (Precursor " + mixed.MZ + ")"));  		StackPanel1.Children.Add (new RatioUC (ratios.ToArray ()' names.ToArray ()' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + "  [" + mixed.MZ + "]"));  	}  }  
Magic Number,PeptidAce.ModernUI.Content,ResultsDeconvoluted,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsDeconvoluted.xaml.cs,UpdateContent,The following statement contains a magic number: foreach (MixedPrecursor mixed in PepIso.solver.mixedPrecursors [sample]) {  	if (mixed.PeptideRatios.Count > 0 && mixed.MZ.ToString ().CompareTo (strKey) == 0) {  		List<double[]> intensities = new List<double[]> ();  		List<string[]> scanTimes = new List<string[]> ();  		List<double> ratios = new List<double> ();  		List<string> names = new List<string> ();  		//double[] timeArray = null;  		/*                     string[] timeStr = new string[mixed.eCurve.time.Count];                      for (int i = 0; i < timeStr.Length; i++)                         timeStr[i] = ((float)(mixed.eCurve.time[i] / (1000.0 * 60.0))).ToString();//ms to min                     //scanTimes.Add(time);//                      foreach (CharacterizedPrecursor peptide in mixed.PeptideRatios.Keys)                     {                         scanTimes.Add(timeStr);                         double[] arrayInt = new double[mixed.eCurve.time.Count];                         for (int i = 0; i < arrayInt.Length; i++)                             //arrayInt[i] = mixed.PeptideRatios[peptide].eCurvePerMs.InterpolateIntensity(mixed.eCurve.interpolatedTime[i]);                             arrayInt[i] = mixed.PeptideRatios[peptide].eCurveCount.InterpolateIntensity(mixed.eCurve.interpolatedTime[i]);                         intensities.Add(arrayInt);                          ratios.Add(mixed.PeptideRatios[peptide].eCurvePerMs.Area);                          names.Add(peptide.Peptide.Sequence + "  [" + Utilities.vsCSV.GetFileName_NoExtension(peptide.Sample.sSDF) + "]");                     }//*/List<double> timePoints = Utilities.ElutionCurve.GetTimePoints (64' true' mixed.eCurveIntensityCount.interpolatedTime' mixed.eCurveIntensityCount.interpolatedIntensityCount);  		string[] timeStr = new string[timePoints.Count];  		for (int i = 0; i < timeStr.Length; i++)  			timeStr [i] = ((float)(timePoints [i] / (1000.0 * 60.0))).ToString ();  		//ms to min  		//scanTimes.Add(time);//  		foreach (CharacterizedPrecursor peptide in mixed.PeptideRatios.Keys) {  			scanTimes.Add (timeStr);  			double[] arrayInt = new double[timePoints.Count];  			for (int i = 0; i < arrayInt.Length; i++)  				//arrayInt[i] = mixed.PeptideRatios[peptide].eCurvePerMs.InterpolateIntensity(timePoints[i]);  				arrayInt [i] = mixed.PeptideRatios [peptide].eCurveCount.InterpolateIntensity (timePoints [i]);  			intensities.Add (arrayInt);  			ratios.Add (mixed.PeptideRatios [peptide].eCurvePerMs.Area);  			names.Add (peptide.Peptide.Sequence + "  [" + Utilities.vsCSV.GetFileName_NoExtension (peptide.Sample.sSDF) + "]");  		}  		//*/  		StackPanel1.Children.Add (new SynthPeptideUC (intensities.ToArray ()' scanTimes.ToArray ()' names.ToArray ()' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + " (Precursor " + mixed.MZ + ")"));  		StackPanel1.Children.Add (new RatioUC (ratios.ToArray ()' names.ToArray ()' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + "  [" + mixed.MZ + "]"));  	}  }  
Magic Number,PeptidAce.ModernUI.Content,ResultsDeconvoluted,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsDeconvoluted.xaml.cs,UpdateContent,The following statement contains a magic number: foreach (MixedPrecursor mixed in PepIso.solver.mixedPrecursors [sample]) {  	if (mixed.PeptideRatios.Count > 0 && mixed.MZ.ToString ().CompareTo (strKey) == 0) {  		List<double[]> intensities = new List<double[]> ();  		List<string[]> scanTimes = new List<string[]> ();  		List<double> ratios = new List<double> ();  		List<string> names = new List<string> ();  		//double[] timeArray = null;  		/*                     string[] timeStr = new string[mixed.eCurve.time.Count];                      for (int i = 0; i < timeStr.Length; i++)                         timeStr[i] = ((float)(mixed.eCurve.time[i] / (1000.0 * 60.0))).ToString();//ms to min                     //scanTimes.Add(time);//                      foreach (CharacterizedPrecursor peptide in mixed.PeptideRatios.Keys)                     {                         scanTimes.Add(timeStr);                         double[] arrayInt = new double[mixed.eCurve.time.Count];                         for (int i = 0; i < arrayInt.Length; i++)                             //arrayInt[i] = mixed.PeptideRatios[peptide].eCurvePerMs.InterpolateIntensity(mixed.eCurve.interpolatedTime[i]);                             arrayInt[i] = mixed.PeptideRatios[peptide].eCurveCount.InterpolateIntensity(mixed.eCurve.interpolatedTime[i]);                         intensities.Add(arrayInt);                          ratios.Add(mixed.PeptideRatios[peptide].eCurvePerMs.Area);                          names.Add(peptide.Peptide.Sequence + "  [" + Utilities.vsCSV.GetFileName_NoExtension(peptide.Sample.sSDF) + "]");                     }//*/List<double> timePoints = Utilities.ElutionCurve.GetTimePoints (64' true' mixed.eCurveIntensityCount.interpolatedTime' mixed.eCurveIntensityCount.interpolatedIntensityCount);  		string[] timeStr = new string[timePoints.Count];  		for (int i = 0; i < timeStr.Length; i++)  			timeStr [i] = ((float)(timePoints [i] / (1000.0 * 60.0))).ToString ();  		//ms to min  		//scanTimes.Add(time);//  		foreach (CharacterizedPrecursor peptide in mixed.PeptideRatios.Keys) {  			scanTimes.Add (timeStr);  			double[] arrayInt = new double[timePoints.Count];  			for (int i = 0; i < arrayInt.Length; i++)  				//arrayInt[i] = mixed.PeptideRatios[peptide].eCurvePerMs.InterpolateIntensity(timePoints[i]);  				arrayInt [i] = mixed.PeptideRatios [peptide].eCurveCount.InterpolateIntensity (timePoints [i]);  			intensities.Add (arrayInt);  			ratios.Add (mixed.PeptideRatios [peptide].eCurvePerMs.Area);  			names.Add (peptide.Peptide.Sequence + "  [" + Utilities.vsCSV.GetFileName_NoExtension (peptide.Sample.sSDF) + "]");  		}  		//*/  		StackPanel1.Children.Add (new SynthPeptideUC (intensities.ToArray ()' scanTimes.ToArray ()' names.ToArray ()' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + " (Precursor " + mixed.MZ + ")"));  		StackPanel1.Children.Add (new RatioUC (ratios.ToArray ()' names.ToArray ()' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + "  [" + mixed.MZ + "]"));  	}  }  
Magic Number,PeptidAce.ModernUI.Content,ResultsDeconvoluted,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsDeconvoluted.xaml.cs,UpdateContent,The following statement contains a magic number: if (mixed.PeptideRatios.Count > 0 && mixed.MZ.ToString ().CompareTo (strKey) == 0) {  	List<double[]> intensities = new List<double[]> ();  	List<string[]> scanTimes = new List<string[]> ();  	List<double> ratios = new List<double> ();  	List<string> names = new List<string> ();  	//double[] timeArray = null;  	/*                     string[] timeStr = new string[mixed.eCurve.time.Count];                      for (int i = 0; i < timeStr.Length; i++)                         timeStr[i] = ((float)(mixed.eCurve.time[i] / (1000.0 * 60.0))).ToString();//ms to min                     //scanTimes.Add(time);//                      foreach (CharacterizedPrecursor peptide in mixed.PeptideRatios.Keys)                     {                         scanTimes.Add(timeStr);                         double[] arrayInt = new double[mixed.eCurve.time.Count];                         for (int i = 0; i < arrayInt.Length; i++)                             //arrayInt[i] = mixed.PeptideRatios[peptide].eCurvePerMs.InterpolateIntensity(mixed.eCurve.interpolatedTime[i]);                             arrayInt[i] = mixed.PeptideRatios[peptide].eCurveCount.InterpolateIntensity(mixed.eCurve.interpolatedTime[i]);                         intensities.Add(arrayInt);                          ratios.Add(mixed.PeptideRatios[peptide].eCurvePerMs.Area);                          names.Add(peptide.Peptide.Sequence + "  [" + Utilities.vsCSV.GetFileName_NoExtension(peptide.Sample.sSDF) + "]");                     }//*/List<double> timePoints = Utilities.ElutionCurve.GetTimePoints (64' true' mixed.eCurveIntensityCount.interpolatedTime' mixed.eCurveIntensityCount.interpolatedIntensityCount);  	string[] timeStr = new string[timePoints.Count];  	for (int i = 0; i < timeStr.Length; i++)  		timeStr [i] = ((float)(timePoints [i] / (1000.0 * 60.0))).ToString ();  	//ms to min  	//scanTimes.Add(time);//  	foreach (CharacterizedPrecursor peptide in mixed.PeptideRatios.Keys) {  		scanTimes.Add (timeStr);  		double[] arrayInt = new double[timePoints.Count];  		for (int i = 0; i < arrayInt.Length; i++)  			//arrayInt[i] = mixed.PeptideRatios[peptide].eCurvePerMs.InterpolateIntensity(timePoints[i]);  			arrayInt [i] = mixed.PeptideRatios [peptide].eCurveCount.InterpolateIntensity (timePoints [i]);  		intensities.Add (arrayInt);  		ratios.Add (mixed.PeptideRatios [peptide].eCurvePerMs.Area);  		names.Add (peptide.Peptide.Sequence + "  [" + Utilities.vsCSV.GetFileName_NoExtension (peptide.Sample.sSDF) + "]");  	}  	//*/  	StackPanel1.Children.Add (new SynthPeptideUC (intensities.ToArray ()' scanTimes.ToArray ()' names.ToArray ()' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + " (Precursor " + mixed.MZ + ")"));  	StackPanel1.Children.Add (new RatioUC (ratios.ToArray ()' names.ToArray ()' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + "  [" + mixed.MZ + "]"));  }  
Magic Number,PeptidAce.ModernUI.Content,ResultsDeconvoluted,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsDeconvoluted.xaml.cs,UpdateContent,The following statement contains a magic number: if (mixed.PeptideRatios.Count > 0 && mixed.MZ.ToString ().CompareTo (strKey) == 0) {  	List<double[]> intensities = new List<double[]> ();  	List<string[]> scanTimes = new List<string[]> ();  	List<double> ratios = new List<double> ();  	List<string> names = new List<string> ();  	//double[] timeArray = null;  	/*                     string[] timeStr = new string[mixed.eCurve.time.Count];                      for (int i = 0; i < timeStr.Length; i++)                         timeStr[i] = ((float)(mixed.eCurve.time[i] / (1000.0 * 60.0))).ToString();//ms to min                     //scanTimes.Add(time);//                      foreach (CharacterizedPrecursor peptide in mixed.PeptideRatios.Keys)                     {                         scanTimes.Add(timeStr);                         double[] arrayInt = new double[mixed.eCurve.time.Count];                         for (int i = 0; i < arrayInt.Length; i++)                             //arrayInt[i] = mixed.PeptideRatios[peptide].eCurvePerMs.InterpolateIntensity(mixed.eCurve.interpolatedTime[i]);                             arrayInt[i] = mixed.PeptideRatios[peptide].eCurveCount.InterpolateIntensity(mixed.eCurve.interpolatedTime[i]);                         intensities.Add(arrayInt);                          ratios.Add(mixed.PeptideRatios[peptide].eCurvePerMs.Area);                          names.Add(peptide.Peptide.Sequence + "  [" + Utilities.vsCSV.GetFileName_NoExtension(peptide.Sample.sSDF) + "]");                     }//*/List<double> timePoints = Utilities.ElutionCurve.GetTimePoints (64' true' mixed.eCurveIntensityCount.interpolatedTime' mixed.eCurveIntensityCount.interpolatedIntensityCount);  	string[] timeStr = new string[timePoints.Count];  	for (int i = 0; i < timeStr.Length; i++)  		timeStr [i] = ((float)(timePoints [i] / (1000.0 * 60.0))).ToString ();  	//ms to min  	//scanTimes.Add(time);//  	foreach (CharacterizedPrecursor peptide in mixed.PeptideRatios.Keys) {  		scanTimes.Add (timeStr);  		double[] arrayInt = new double[timePoints.Count];  		for (int i = 0; i < arrayInt.Length; i++)  			//arrayInt[i] = mixed.PeptideRatios[peptide].eCurvePerMs.InterpolateIntensity(timePoints[i]);  			arrayInt [i] = mixed.PeptideRatios [peptide].eCurveCount.InterpolateIntensity (timePoints [i]);  		intensities.Add (arrayInt);  		ratios.Add (mixed.PeptideRatios [peptide].eCurvePerMs.Area);  		names.Add (peptide.Peptide.Sequence + "  [" + Utilities.vsCSV.GetFileName_NoExtension (peptide.Sample.sSDF) + "]");  	}  	//*/  	StackPanel1.Children.Add (new SynthPeptideUC (intensities.ToArray ()' scanTimes.ToArray ()' names.ToArray ()' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + " (Precursor " + mixed.MZ + ")"));  	StackPanel1.Children.Add (new RatioUC (ratios.ToArray ()' names.ToArray ()' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + "  [" + mixed.MZ + "]"));  }  
Magic Number,PeptidAce.ModernUI.Content,ResultsDeconvoluted,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsDeconvoluted.xaml.cs,UpdateContent,The following statement contains a magic number: if (mixed.PeptideRatios.Count > 0 && mixed.MZ.ToString ().CompareTo (strKey) == 0) {  	List<double[]> intensities = new List<double[]> ();  	List<string[]> scanTimes = new List<string[]> ();  	List<double> ratios = new List<double> ();  	List<string> names = new List<string> ();  	//double[] timeArray = null;  	/*                     string[] timeStr = new string[mixed.eCurve.time.Count];                      for (int i = 0; i < timeStr.Length; i++)                         timeStr[i] = ((float)(mixed.eCurve.time[i] / (1000.0 * 60.0))).ToString();//ms to min                     //scanTimes.Add(time);//                      foreach (CharacterizedPrecursor peptide in mixed.PeptideRatios.Keys)                     {                         scanTimes.Add(timeStr);                         double[] arrayInt = new double[mixed.eCurve.time.Count];                         for (int i = 0; i < arrayInt.Length; i++)                             //arrayInt[i] = mixed.PeptideRatios[peptide].eCurvePerMs.InterpolateIntensity(mixed.eCurve.interpolatedTime[i]);                             arrayInt[i] = mixed.PeptideRatios[peptide].eCurveCount.InterpolateIntensity(mixed.eCurve.interpolatedTime[i]);                         intensities.Add(arrayInt);                          ratios.Add(mixed.PeptideRatios[peptide].eCurvePerMs.Area);                          names.Add(peptide.Peptide.Sequence + "  [" + Utilities.vsCSV.GetFileName_NoExtension(peptide.Sample.sSDF) + "]");                     }//*/List<double> timePoints = Utilities.ElutionCurve.GetTimePoints (64' true' mixed.eCurveIntensityCount.interpolatedTime' mixed.eCurveIntensityCount.interpolatedIntensityCount);  	string[] timeStr = new string[timePoints.Count];  	for (int i = 0; i < timeStr.Length; i++)  		timeStr [i] = ((float)(timePoints [i] / (1000.0 * 60.0))).ToString ();  	//ms to min  	//scanTimes.Add(time);//  	foreach (CharacterizedPrecursor peptide in mixed.PeptideRatios.Keys) {  		scanTimes.Add (timeStr);  		double[] arrayInt = new double[timePoints.Count];  		for (int i = 0; i < arrayInt.Length; i++)  			//arrayInt[i] = mixed.PeptideRatios[peptide].eCurvePerMs.InterpolateIntensity(timePoints[i]);  			arrayInt [i] = mixed.PeptideRatios [peptide].eCurveCount.InterpolateIntensity (timePoints [i]);  		intensities.Add (arrayInt);  		ratios.Add (mixed.PeptideRatios [peptide].eCurvePerMs.Area);  		names.Add (peptide.Peptide.Sequence + "  [" + Utilities.vsCSV.GetFileName_NoExtension (peptide.Sample.sSDF) + "]");  	}  	//*/  	StackPanel1.Children.Add (new SynthPeptideUC (intensities.ToArray ()' scanTimes.ToArray ()' names.ToArray ()' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + " (Precursor " + mixed.MZ + ")"));  	StackPanel1.Children.Add (new RatioUC (ratios.ToArray ()' names.ToArray ()' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + "  [" + mixed.MZ + "]"));  }  
Magic Number,PeptidAce.ModernUI.Content,ResultsDeconvoluted,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsDeconvoluted.xaml.cs,UpdateContent,The following statement contains a magic number: for (int i = 0; i < timeStr.Length; i++)  	timeStr [i] = ((float)(timePoints [i] / (1000.0 * 60.0))).ToString ();  
Magic Number,PeptidAce.ModernUI.Content,ResultsDeconvoluted,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsDeconvoluted.xaml.cs,UpdateContent,The following statement contains a magic number: for (int i = 0; i < timeStr.Length; i++)  	timeStr [i] = ((float)(timePoints [i] / (1000.0 * 60.0))).ToString ();  
Magic Number,PeptidAce.ModernUI.Content,ResultsDeconvoluted,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsDeconvoluted.xaml.cs,UpdateContent,The following statement contains a magic number: timeStr [i] = ((float)(timePoints [i] / (1000.0 * 60.0))).ToString ();  
Magic Number,PeptidAce.ModernUI.Content,ResultsDeconvoluted,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsDeconvoluted.xaml.cs,UpdateContent,The following statement contains a magic number: timeStr [i] = ((float)(timePoints [i] / (1000.0 * 60.0))).ToString ();  
Magic Number,PeptidAce.ModernUI.Content,SynthPeptideUC,C:\repos\olivierlizotte_Iso-PeptidAce\Content\SynthPeptideUC.xaml.cs,Window_Loaded,The following statement contains a magic number: if (!_dataLoaded) {  	serial1.Graphs.Clear ();  	for (int i = 0; i < titles.Length; i++) {  		AmCharts.Windows.QuickCharts.LineGraph line = new AmCharts.Windows.QuickCharts.LineGraph () {  			ValueMemberPath = "Intensities[" + i + "]"'  			Title = titles [i]  		};  		serial1.Graphs.Add (line);  	}  	serial1.DataSource = data;  	serial1.MinWidth = 600 + longestName * 6;  	_dataLoaded = true;  }  
Magic Number,PeptidAce.ModernUI.Content,SynthPeptideUC,C:\repos\olivierlizotte_Iso-PeptidAce\Content\SynthPeptideUC.xaml.cs,Window_Loaded,The following statement contains a magic number: if (!_dataLoaded) {  	serial1.Graphs.Clear ();  	for (int i = 0; i < titles.Length; i++) {  		AmCharts.Windows.QuickCharts.LineGraph line = new AmCharts.Windows.QuickCharts.LineGraph () {  			ValueMemberPath = "Intensities[" + i + "]"'  			Title = titles [i]  		};  		serial1.Graphs.Add (line);  	}  	serial1.DataSource = data;  	serial1.MinWidth = 600 + longestName * 6;  	_dataLoaded = true;  }  
Magic Number,PeptidAce.ModernUI.Content,SynthPeptideUC,C:\repos\olivierlizotte_Iso-PeptidAce\Content\SynthPeptideUC.xaml.cs,Window_Loaded,The following statement contains a magic number: serial1.MinWidth = 600 + longestName * 6;  
Magic Number,PeptidAce.ModernUI.Content,SynthPeptideUC,C:\repos\olivierlizotte_Iso-PeptidAce\Content\SynthPeptideUC.xaml.cs,Window_Loaded,The following statement contains a magic number: serial1.MinWidth = 600 + longestName * 6;  
Magic Number,PeptidAce.ModernUI.Content,RatioUC,C:\repos\olivierlizotte_Iso-PeptidAce\Content\RatioUC.xaml.cs,Window_Loaded,The following statement contains a magic number: pie1.MinWidth = 200 + longestName * 6;  
Magic Number,PeptidAce.ModernUI.Content,RatioUC,C:\repos\olivierlizotte_Iso-PeptidAce\Content\RatioUC.xaml.cs,Window_Loaded,The following statement contains a magic number: pie1.MinWidth = 200 + longestName * 6;  
Magic Number,PeptidAce.ModernUI.Content,ResultsPeptides,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsPeptides.xaml.cs,UpdateContent,The following statement contains a magic number: foreach (Sample sample in PepIso.solver.characterizedPeptides [key].Keys) {  	if (sample.Name.CompareTo (sampleName) == 0) {  		CharacterizedPrecursor cPrec = PepIso.solver.characterizedPeptides [key] [sample];  		List<string[]> scanTimes = new List<string[]> ();  		List<double> timeArray = Utilities.ElutionCurve.GetTimePoints (64' true' cPrec.eCurveIntensityCount.interpolatedTime' cPrec.eCurveIntensityCount.interpolatedIntensityCount);  		List<string> time = new List<string> (timeArray.Count);  		foreach (double timeP in timeArray)  			time.Add (((float)(timeP / (1000.0 * 60.0))).ToString ());  		scanTimes.Add (time.ToArray ());  		List<double[]> intensities = new List<double[]> ();  		double[] arrayInt = new double[timeArray.Count];  		for (int i = 0; i < arrayInt.Length; i++)  			arrayInt [i] = cPrec.eCurveIntensityCount.InterpolateIntensity (timeArray [i]);  		intensities.Add (arrayInt);  		//intensities.Add(cPrec.eCurve.intensityCount.ToArray());  		string[] names = new string[1];  		names [0] = cPrec.Peptide.Sequence + "  [" + Utilities.vsCSV.GetFileName_NoExtension (cPrec.Sample.sSDF) + "]";  		StackPanel1.Children.Add (new SynthPeptideUC (intensities.ToArray ()' scanTimes.ToArray ()' names' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + " (Precursor " + key + ")"));  	}  }  
Magic Number,PeptidAce.ModernUI.Content,ResultsPeptides,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsPeptides.xaml.cs,UpdateContent,The following statement contains a magic number: foreach (Sample sample in PepIso.solver.characterizedPeptides [key].Keys) {  	if (sample.Name.CompareTo (sampleName) == 0) {  		CharacterizedPrecursor cPrec = PepIso.solver.characterizedPeptides [key] [sample];  		List<string[]> scanTimes = new List<string[]> ();  		List<double> timeArray = Utilities.ElutionCurve.GetTimePoints (64' true' cPrec.eCurveIntensityCount.interpolatedTime' cPrec.eCurveIntensityCount.interpolatedIntensityCount);  		List<string> time = new List<string> (timeArray.Count);  		foreach (double timeP in timeArray)  			time.Add (((float)(timeP / (1000.0 * 60.0))).ToString ());  		scanTimes.Add (time.ToArray ());  		List<double[]> intensities = new List<double[]> ();  		double[] arrayInt = new double[timeArray.Count];  		for (int i = 0; i < arrayInt.Length; i++)  			arrayInt [i] = cPrec.eCurveIntensityCount.InterpolateIntensity (timeArray [i]);  		intensities.Add (arrayInt);  		//intensities.Add(cPrec.eCurve.intensityCount.ToArray());  		string[] names = new string[1];  		names [0] = cPrec.Peptide.Sequence + "  [" + Utilities.vsCSV.GetFileName_NoExtension (cPrec.Sample.sSDF) + "]";  		StackPanel1.Children.Add (new SynthPeptideUC (intensities.ToArray ()' scanTimes.ToArray ()' names' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + " (Precursor " + key + ")"));  	}  }  
Magic Number,PeptidAce.ModernUI.Content,ResultsPeptides,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsPeptides.xaml.cs,UpdateContent,The following statement contains a magic number: foreach (Sample sample in PepIso.solver.characterizedPeptides [key].Keys) {  	if (sample.Name.CompareTo (sampleName) == 0) {  		CharacterizedPrecursor cPrec = PepIso.solver.characterizedPeptides [key] [sample];  		List<string[]> scanTimes = new List<string[]> ();  		List<double> timeArray = Utilities.ElutionCurve.GetTimePoints (64' true' cPrec.eCurveIntensityCount.interpolatedTime' cPrec.eCurveIntensityCount.interpolatedIntensityCount);  		List<string> time = new List<string> (timeArray.Count);  		foreach (double timeP in timeArray)  			time.Add (((float)(timeP / (1000.0 * 60.0))).ToString ());  		scanTimes.Add (time.ToArray ());  		List<double[]> intensities = new List<double[]> ();  		double[] arrayInt = new double[timeArray.Count];  		for (int i = 0; i < arrayInt.Length; i++)  			arrayInt [i] = cPrec.eCurveIntensityCount.InterpolateIntensity (timeArray [i]);  		intensities.Add (arrayInt);  		//intensities.Add(cPrec.eCurve.intensityCount.ToArray());  		string[] names = new string[1];  		names [0] = cPrec.Peptide.Sequence + "  [" + Utilities.vsCSV.GetFileName_NoExtension (cPrec.Sample.sSDF) + "]";  		StackPanel1.Children.Add (new SynthPeptideUC (intensities.ToArray ()' scanTimes.ToArray ()' names' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + " (Precursor " + key + ")"));  	}  }  
Magic Number,PeptidAce.ModernUI.Content,ResultsPeptides,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsPeptides.xaml.cs,UpdateContent,The following statement contains a magic number: if (sample.Name.CompareTo (sampleName) == 0) {  	CharacterizedPrecursor cPrec = PepIso.solver.characterizedPeptides [key] [sample];  	List<string[]> scanTimes = new List<string[]> ();  	List<double> timeArray = Utilities.ElutionCurve.GetTimePoints (64' true' cPrec.eCurveIntensityCount.interpolatedTime' cPrec.eCurveIntensityCount.interpolatedIntensityCount);  	List<string> time = new List<string> (timeArray.Count);  	foreach (double timeP in timeArray)  		time.Add (((float)(timeP / (1000.0 * 60.0))).ToString ());  	scanTimes.Add (time.ToArray ());  	List<double[]> intensities = new List<double[]> ();  	double[] arrayInt = new double[timeArray.Count];  	for (int i = 0; i < arrayInt.Length; i++)  		arrayInt [i] = cPrec.eCurveIntensityCount.InterpolateIntensity (timeArray [i]);  	intensities.Add (arrayInt);  	//intensities.Add(cPrec.eCurve.intensityCount.ToArray());  	string[] names = new string[1];  	names [0] = cPrec.Peptide.Sequence + "  [" + Utilities.vsCSV.GetFileName_NoExtension (cPrec.Sample.sSDF) + "]";  	StackPanel1.Children.Add (new SynthPeptideUC (intensities.ToArray ()' scanTimes.ToArray ()' names' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + " (Precursor " + key + ")"));  }  
Magic Number,PeptidAce.ModernUI.Content,ResultsPeptides,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsPeptides.xaml.cs,UpdateContent,The following statement contains a magic number: if (sample.Name.CompareTo (sampleName) == 0) {  	CharacterizedPrecursor cPrec = PepIso.solver.characterizedPeptides [key] [sample];  	List<string[]> scanTimes = new List<string[]> ();  	List<double> timeArray = Utilities.ElutionCurve.GetTimePoints (64' true' cPrec.eCurveIntensityCount.interpolatedTime' cPrec.eCurveIntensityCount.interpolatedIntensityCount);  	List<string> time = new List<string> (timeArray.Count);  	foreach (double timeP in timeArray)  		time.Add (((float)(timeP / (1000.0 * 60.0))).ToString ());  	scanTimes.Add (time.ToArray ());  	List<double[]> intensities = new List<double[]> ();  	double[] arrayInt = new double[timeArray.Count];  	for (int i = 0; i < arrayInt.Length; i++)  		arrayInt [i] = cPrec.eCurveIntensityCount.InterpolateIntensity (timeArray [i]);  	intensities.Add (arrayInt);  	//intensities.Add(cPrec.eCurve.intensityCount.ToArray());  	string[] names = new string[1];  	names [0] = cPrec.Peptide.Sequence + "  [" + Utilities.vsCSV.GetFileName_NoExtension (cPrec.Sample.sSDF) + "]";  	StackPanel1.Children.Add (new SynthPeptideUC (intensities.ToArray ()' scanTimes.ToArray ()' names' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + " (Precursor " + key + ")"));  }  
Magic Number,PeptidAce.ModernUI.Content,ResultsPeptides,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsPeptides.xaml.cs,UpdateContent,The following statement contains a magic number: if (sample.Name.CompareTo (sampleName) == 0) {  	CharacterizedPrecursor cPrec = PepIso.solver.characterizedPeptides [key] [sample];  	List<string[]> scanTimes = new List<string[]> ();  	List<double> timeArray = Utilities.ElutionCurve.GetTimePoints (64' true' cPrec.eCurveIntensityCount.interpolatedTime' cPrec.eCurveIntensityCount.interpolatedIntensityCount);  	List<string> time = new List<string> (timeArray.Count);  	foreach (double timeP in timeArray)  		time.Add (((float)(timeP / (1000.0 * 60.0))).ToString ());  	scanTimes.Add (time.ToArray ());  	List<double[]> intensities = new List<double[]> ();  	double[] arrayInt = new double[timeArray.Count];  	for (int i = 0; i < arrayInt.Length; i++)  		arrayInt [i] = cPrec.eCurveIntensityCount.InterpolateIntensity (timeArray [i]);  	intensities.Add (arrayInt);  	//intensities.Add(cPrec.eCurve.intensityCount.ToArray());  	string[] names = new string[1];  	names [0] = cPrec.Peptide.Sequence + "  [" + Utilities.vsCSV.GetFileName_NoExtension (cPrec.Sample.sSDF) + "]";  	StackPanel1.Children.Add (new SynthPeptideUC (intensities.ToArray ()' scanTimes.ToArray ()' names' Utilities.vsCSV.GetFileName_NoExtension (sample.sSDF) + " (Precursor " + key + ")"));  }  
Magic Number,PeptidAce.ModernUI.Content,ResultsPeptides,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsPeptides.xaml.cs,UpdateContent,The following statement contains a magic number: foreach (double timeP in timeArray)  	time.Add (((float)(timeP / (1000.0 * 60.0))).ToString ());  
Magic Number,PeptidAce.ModernUI.Content,ResultsPeptides,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsPeptides.xaml.cs,UpdateContent,The following statement contains a magic number: foreach (double timeP in timeArray)  	time.Add (((float)(timeP / (1000.0 * 60.0))).ToString ());  
Magic Number,PeptidAce.ModernUI.Content,ResultsPeptides,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsPeptides.xaml.cs,UpdateContent,The following statement contains a magic number: time.Add (((float)(timeP / (1000.0 * 60.0))).ToString ());  
Magic Number,PeptidAce.ModernUI.Content,ResultsPeptides,C:\repos\olivierlizotte_Iso-PeptidAce\Content\ResultsPeptides.xaml.cs,UpdateContent,The following statement contains a magic number: time.Add (((float)(timeP / (1000.0 * 60.0))).ToString ());  
Magic Number,PeptidAce.ModernUI.Content,PepIso,C:\repos\olivierlizotte_Iso-PeptidAce\Content\PepIso.xaml.cs,CheckParams,The following statement contains a magic number: if (nbMaxFragments > 100)  	msg += "\nThe Maximum number of Fragments has to be smaller than 100. Check Advanced Settings";  
Magic Number,PeptidAce.ModernUI.Content,PepIso,C:\repos\olivierlizotte_Iso-PeptidAce\Content\PepIso.xaml.cs,CheckParams,The following statement contains a magic number: if (peptideFiles == null || peptideFiles.Length < 2)  	msg += "\nAt least two RAW files with individual peptides are necessary";  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,CreateOptions,The following statement contains a magic number: dbOptions.MaximumPeptideMass = 200000;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,CreateOptions,The following statement contains a magic number: dbOptions.MaximumNumberOfFragmentsPerSpectrum = 400;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,CreateOptions,The following statement contains a magic number: dbOptions.ToleratedMissedCleavages = 200;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,CreateOptions,The following statement contains a magic number: dbOptions.MinimumPeptideLength = 5;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,CreateOptions,The following statement contains a magic number: dbOptions.MaximumPeptideLength = 300;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,CreateOptions,The following statement contains a magic number: dbOptions.maximumVariableModificationIsoforms = 4096;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,CreateOptions,The following statement contains a magic number: dbOptions.NbPSMToKeep = 16;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,CreateOptions,The following statement contains a magic number: dbOptions.dProduct = 0.0917981081138356;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,CreateOptions,The following statement contains a magic number: dbOptions.dPrecursor = 0.345789190542786;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,CreateOptions,The following statement contains a magic number: dbOptions.dMatchingProductFraction = 0.427418045898628;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,CreateOptions,The following statement contains a magic number: dbOptions.dIntensityFraction = 0.429418127252449;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,CreateOptions,The following statement contains a magic number: dbOptions.dProtein = 0.692270441303156;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,CreateOptions,The following statement contains a magic number: dbOptions.dPeptideScore = 0.636739763262095;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,CreateOptions,The following statement contains a magic number: dbOptions.dFragmentScore = 0.0229058195943506;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The following statement contains a magic number: if (mixedResult == null)  	conSol.WriteLine ("OOPS! No queries could be extracted from the list of mixed spectrum files...");  else {  	mixedResult.ExportPSMs (1' dbOptions.OutputFolder + "Identifications" + System.IO.Path.DirectorySeparatorChar + "MixedSamplesPSMs.csv");  	conSol.WriteLine ("Computing gradient descents...");  	//Compute all usable spiked peptides  	characterizedPeptides = CharacterizedPrecursor.GetSpikedPrecursors (SpikedSamples' SpikedResult' dbOptions' nbMinFragments' nbMaxFragments);  	ExportSpikedSampleResult (characterizedPeptides' dbOptions);  	vsCSVWriter writerCumul = new vsCSVWriter (OutputFolder + "Results.csv");  	string titleCombined = "Mixed Sample'Precursor";  	string curveStr = "Polynomial Curve'";  	string spikedIntensityStr = "Area under the curve'";  	foreach (double precursor in characterizedPeptides.Keys)  		foreach (CharacterizedPrecursor charPrec in characterizedPeptides [precursor].Values) {  			titleCombined += "'" + charPrec.Peptide.Sequence + " Charge " + charPrec.Charge;  			if (charPrec.eCurveIntensityCount.Coefficients != null && charPrec.eCurveIntensityCount.Coefficients.Length == 3)  				curveStr += "'" + charPrec.eCurveIntensityCount.Coefficients [0] + "x^2 + " + charPrec.eCurveIntensityCount.Coefficients [1] + "x" + charPrec.eCurveIntensityCount.Coefficients [2];  			else  				curveStr += "'NA";  			spikedIntensityStr += "'" + charPrec.eCurveIntensityCount.Area;  		}  	writerCumul.AddLine (titleCombined);  	writerCumul.AddLine (curveStr);  	writerCumul.AddLine (spikedIntensityStr);  	mixedPrecursors = new Dictionary<Sample' List<MixedPrecursor>> ();  	foreach (Sample mixedSample in MixedSamples)  		mixedPrecursors.Add (mixedSample' MixedPrecursor.GetMixedPrecursors (mixedSample' mixedResult' dbOptions' characterizedPeptides));  	//Get the list of precursors to characterize  	foreach (Sample mixedSample in MixedSamples) {  		foreach (double keyMz in characterizedPeptides.Keys) {  			List<Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve>> listOfRatios = new List<Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve>> ();  			foreach (MixedPrecursor mPrec in mixedPrecursors [mixedSample])  				if (mPrec.MZ == keyMz) {  					// Compute Max Flow for this precursor  					Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ratios = GetRatios (characterizedPeptides' mPrec' dbOptions' nbMinFragments' nbMaxFragments);  					listOfRatios.Add (ratios);  					ExportMixedSampleResult (ratios' mixedSample' mPrec' keyMz' dbOptions);  				}  			bool isEmpty = true;  			string resultStr = vsCSV.GetFileName (mixedSample.sSDF) + "'" + keyMz;  			foreach (double precursor in characterizedPeptides.Keys) {  				foreach (CharacterizedPrecursor charPrec in characterizedPeptides [precursor].Values) {  					double cumulArea = 0.0;  					foreach (Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ratios in listOfRatios)  						if (ratios.ContainsKey (charPrec))  							cumulArea += ratios [charPrec].eCurvePerMs.Area;  					resultStr += "'" + cumulArea;  					if (cumulArea > 0)  						isEmpty = false;  				}  			}  			if (!isEmpty)  				writerCumul.AddLine (resultStr);  		}  	}  	writerCumul.WriteToFile ();  	//List Modifications  	Dictionary<Modification' double> dicOfIntensityPerMod = new Dictionary<Modification' double> ();  	foreach (Sample sample in mixedPrecursors.Keys)  		foreach (MixedPrecursor mP in mixedPrecursors [sample])  			foreach (CharacterizedPrecursor cP in mP.PeptideRatios.Keys)  				if (cP.Peptide.VariableModifications != null)  					foreach (Modification mod in cP.Peptide.VariableModifications.Values)  						if (!dicOfIntensityPerMod.ContainsKey (mod))  							dicOfIntensityPerMod.Add (mod' 0.0);  	//Compute site occupancy for identical sequences (real positionnal isomers)  	vsCSVWriter writerSitesOccupancy = new vsCSVWriter (OutputFolder + "Results_SiteOccupancy.csv");  	List<Protein> AllProteins = Ace.ReadProteomeFromFasta (fastaFile' false' dbOptions);  	foreach (Protein protein in AllProteins) {  		string newTitleProtein = protein.Description.Replace ('''' ' ') + "'" + protein.Sequence;  		for (int i = 0; i < protein.Sequence.Length; i++)  			newTitleProtein += "'" + protein [i].ToString ();  		writerSitesOccupancy.AddLine (newTitleProtein);  		foreach (Sample mixedSample in mixedPrecursors.Keys) {  			string coverage = "Coverage'" + mixedSample.Name;  			for (int i = 0; i < protein.Sequence.Length; i++) {  				double cumulSite = 0.0;  				newTitleProtein += "'" + protein [i].ToString ();  				foreach (MixedPrecursor mP in mixedPrecursors [mixedSample]) {  					foreach (CharacterizedPrecursor cP in mP.PeptideRatios.Keys) {  						if (i + 1 >= cP.Peptide.StartResidueNumber && i + 1 <= cP.Peptide.EndResidueNumber)  							cumulSite += mP.PeptideRatios [cP].eCurvePerMs.Area;  					}  				}  				coverage += "'" + cumulSite;  			}  			writerSitesOccupancy.AddLine (coverage);  		}  		foreach (Modification mod in dicOfIntensityPerMod.Keys) {  			Dictionary<Sample' string> dicOfLines = new Dictionary<Sample' string> ();  			for (int i = 0; i < protein.Sequence.Length; i++) {  				foreach (Sample mixedSample in mixedPrecursors.Keys) {  					double cumulModArea = 0.0;  					foreach (MixedPrecursor mP in mixedPrecursors [mixedSample]) {  						foreach (CharacterizedPrecursor cP in mP.PeptideRatios.Keys) {  							if (i + 1 >= cP.Peptide.StartResidueNumber && i + 1 <= cP.Peptide.EndResidueNumber && cP.Peptide.VariableModifications != null) {  								foreach (int pos in cP.Peptide.VariableModifications.Keys)  									if (cP.Peptide.StartResidueNumber + pos - 2 == i + 1 && cP.Peptide.VariableModifications [pos] == mod)  										cumulModArea += mP.PeptideRatios [cP].eCurvePerMs.Area;  							}  						}  					}  					if (!dicOfLines.ContainsKey (mixedSample))  						dicOfLines.Add (mixedSample' mod.Description + "'" + mixedSample.Name + "'" + cumulModArea);  					else  						dicOfLines [mixedSample] += "'" + cumulModArea;  				}  			}  			foreach (string line in dicOfLines.Values)  				writerSitesOccupancy.AddLine (line);  		}  	}  	writerSitesOccupancy.WriteToFile ();  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The following statement contains a magic number: if (mixedResult == null)  	conSol.WriteLine ("OOPS! No queries could be extracted from the list of mixed spectrum files...");  else {  	mixedResult.ExportPSMs (1' dbOptions.OutputFolder + "Identifications" + System.IO.Path.DirectorySeparatorChar + "MixedSamplesPSMs.csv");  	conSol.WriteLine ("Computing gradient descents...");  	//Compute all usable spiked peptides  	characterizedPeptides = CharacterizedPrecursor.GetSpikedPrecursors (SpikedSamples' SpikedResult' dbOptions' nbMinFragments' nbMaxFragments);  	ExportSpikedSampleResult (characterizedPeptides' dbOptions);  	vsCSVWriter writerCumul = new vsCSVWriter (OutputFolder + "Results.csv");  	string titleCombined = "Mixed Sample'Precursor";  	string curveStr = "Polynomial Curve'";  	string spikedIntensityStr = "Area under the curve'";  	foreach (double precursor in characterizedPeptides.Keys)  		foreach (CharacterizedPrecursor charPrec in characterizedPeptides [precursor].Values) {  			titleCombined += "'" + charPrec.Peptide.Sequence + " Charge " + charPrec.Charge;  			if (charPrec.eCurveIntensityCount.Coefficients != null && charPrec.eCurveIntensityCount.Coefficients.Length == 3)  				curveStr += "'" + charPrec.eCurveIntensityCount.Coefficients [0] + "x^2 + " + charPrec.eCurveIntensityCount.Coefficients [1] + "x" + charPrec.eCurveIntensityCount.Coefficients [2];  			else  				curveStr += "'NA";  			spikedIntensityStr += "'" + charPrec.eCurveIntensityCount.Area;  		}  	writerCumul.AddLine (titleCombined);  	writerCumul.AddLine (curveStr);  	writerCumul.AddLine (spikedIntensityStr);  	mixedPrecursors = new Dictionary<Sample' List<MixedPrecursor>> ();  	foreach (Sample mixedSample in MixedSamples)  		mixedPrecursors.Add (mixedSample' MixedPrecursor.GetMixedPrecursors (mixedSample' mixedResult' dbOptions' characterizedPeptides));  	//Get the list of precursors to characterize  	foreach (Sample mixedSample in MixedSamples) {  		foreach (double keyMz in characterizedPeptides.Keys) {  			List<Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve>> listOfRatios = new List<Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve>> ();  			foreach (MixedPrecursor mPrec in mixedPrecursors [mixedSample])  				if (mPrec.MZ == keyMz) {  					// Compute Max Flow for this precursor  					Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ratios = GetRatios (characterizedPeptides' mPrec' dbOptions' nbMinFragments' nbMaxFragments);  					listOfRatios.Add (ratios);  					ExportMixedSampleResult (ratios' mixedSample' mPrec' keyMz' dbOptions);  				}  			bool isEmpty = true;  			string resultStr = vsCSV.GetFileName (mixedSample.sSDF) + "'" + keyMz;  			foreach (double precursor in characterizedPeptides.Keys) {  				foreach (CharacterizedPrecursor charPrec in characterizedPeptides [precursor].Values) {  					double cumulArea = 0.0;  					foreach (Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ratios in listOfRatios)  						if (ratios.ContainsKey (charPrec))  							cumulArea += ratios [charPrec].eCurvePerMs.Area;  					resultStr += "'" + cumulArea;  					if (cumulArea > 0)  						isEmpty = false;  				}  			}  			if (!isEmpty)  				writerCumul.AddLine (resultStr);  		}  	}  	writerCumul.WriteToFile ();  	//List Modifications  	Dictionary<Modification' double> dicOfIntensityPerMod = new Dictionary<Modification' double> ();  	foreach (Sample sample in mixedPrecursors.Keys)  		foreach (MixedPrecursor mP in mixedPrecursors [sample])  			foreach (CharacterizedPrecursor cP in mP.PeptideRatios.Keys)  				if (cP.Peptide.VariableModifications != null)  					foreach (Modification mod in cP.Peptide.VariableModifications.Values)  						if (!dicOfIntensityPerMod.ContainsKey (mod))  							dicOfIntensityPerMod.Add (mod' 0.0);  	//Compute site occupancy for identical sequences (real positionnal isomers)  	vsCSVWriter writerSitesOccupancy = new vsCSVWriter (OutputFolder + "Results_SiteOccupancy.csv");  	List<Protein> AllProteins = Ace.ReadProteomeFromFasta (fastaFile' false' dbOptions);  	foreach (Protein protein in AllProteins) {  		string newTitleProtein = protein.Description.Replace ('''' ' ') + "'" + protein.Sequence;  		for (int i = 0; i < protein.Sequence.Length; i++)  			newTitleProtein += "'" + protein [i].ToString ();  		writerSitesOccupancy.AddLine (newTitleProtein);  		foreach (Sample mixedSample in mixedPrecursors.Keys) {  			string coverage = "Coverage'" + mixedSample.Name;  			for (int i = 0; i < protein.Sequence.Length; i++) {  				double cumulSite = 0.0;  				newTitleProtein += "'" + protein [i].ToString ();  				foreach (MixedPrecursor mP in mixedPrecursors [mixedSample]) {  					foreach (CharacterizedPrecursor cP in mP.PeptideRatios.Keys) {  						if (i + 1 >= cP.Peptide.StartResidueNumber && i + 1 <= cP.Peptide.EndResidueNumber)  							cumulSite += mP.PeptideRatios [cP].eCurvePerMs.Area;  					}  				}  				coverage += "'" + cumulSite;  			}  			writerSitesOccupancy.AddLine (coverage);  		}  		foreach (Modification mod in dicOfIntensityPerMod.Keys) {  			Dictionary<Sample' string> dicOfLines = new Dictionary<Sample' string> ();  			for (int i = 0; i < protein.Sequence.Length; i++) {  				foreach (Sample mixedSample in mixedPrecursors.Keys) {  					double cumulModArea = 0.0;  					foreach (MixedPrecursor mP in mixedPrecursors [mixedSample]) {  						foreach (CharacterizedPrecursor cP in mP.PeptideRatios.Keys) {  							if (i + 1 >= cP.Peptide.StartResidueNumber && i + 1 <= cP.Peptide.EndResidueNumber && cP.Peptide.VariableModifications != null) {  								foreach (int pos in cP.Peptide.VariableModifications.Keys)  									if (cP.Peptide.StartResidueNumber + pos - 2 == i + 1 && cP.Peptide.VariableModifications [pos] == mod)  										cumulModArea += mP.PeptideRatios [cP].eCurvePerMs.Area;  							}  						}  					}  					if (!dicOfLines.ContainsKey (mixedSample))  						dicOfLines.Add (mixedSample' mod.Description + "'" + mixedSample.Name + "'" + cumulModArea);  					else  						dicOfLines [mixedSample] += "'" + cumulModArea;  				}  			}  			foreach (string line in dicOfLines.Values)  				writerSitesOccupancy.AddLine (line);  		}  	}  	writerSitesOccupancy.WriteToFile ();  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The following statement contains a magic number: if (mixedResult == null)  	conSol.WriteLine ("OOPS! No queries could be extracted from the list of mixed spectrum files...");  else {  	mixedResult.ExportPSMs (1' dbOptions.OutputFolder + "Identifications" + System.IO.Path.DirectorySeparatorChar + "MixedSamplesPSMs.csv");  	conSol.WriteLine ("Computing gradient descents...");  	//Compute all usable spiked peptides  	characterizedPeptides = CharacterizedPrecursor.GetSpikedPrecursors (SpikedSamples' SpikedResult' dbOptions' nbMinFragments' nbMaxFragments);  	ExportSpikedSampleResult (characterizedPeptides' dbOptions);  	vsCSVWriter writerCumul = new vsCSVWriter (OutputFolder + "Results.csv");  	string titleCombined = "Mixed Sample'Precursor";  	string curveStr = "Polynomial Curve'";  	string spikedIntensityStr = "Area under the curve'";  	foreach (double precursor in characterizedPeptides.Keys)  		foreach (CharacterizedPrecursor charPrec in characterizedPeptides [precursor].Values) {  			titleCombined += "'" + charPrec.Peptide.Sequence + " Charge " + charPrec.Charge;  			if (charPrec.eCurveIntensityCount.Coefficients != null && charPrec.eCurveIntensityCount.Coefficients.Length == 3)  				curveStr += "'" + charPrec.eCurveIntensityCount.Coefficients [0] + "x^2 + " + charPrec.eCurveIntensityCount.Coefficients [1] + "x" + charPrec.eCurveIntensityCount.Coefficients [2];  			else  				curveStr += "'NA";  			spikedIntensityStr += "'" + charPrec.eCurveIntensityCount.Area;  		}  	writerCumul.AddLine (titleCombined);  	writerCumul.AddLine (curveStr);  	writerCumul.AddLine (spikedIntensityStr);  	mixedPrecursors = new Dictionary<Sample' List<MixedPrecursor>> ();  	foreach (Sample mixedSample in MixedSamples)  		mixedPrecursors.Add (mixedSample' MixedPrecursor.GetMixedPrecursors (mixedSample' mixedResult' dbOptions' characterizedPeptides));  	//Get the list of precursors to characterize  	foreach (Sample mixedSample in MixedSamples) {  		foreach (double keyMz in characterizedPeptides.Keys) {  			List<Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve>> listOfRatios = new List<Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve>> ();  			foreach (MixedPrecursor mPrec in mixedPrecursors [mixedSample])  				if (mPrec.MZ == keyMz) {  					// Compute Max Flow for this precursor  					Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ratios = GetRatios (characterizedPeptides' mPrec' dbOptions' nbMinFragments' nbMaxFragments);  					listOfRatios.Add (ratios);  					ExportMixedSampleResult (ratios' mixedSample' mPrec' keyMz' dbOptions);  				}  			bool isEmpty = true;  			string resultStr = vsCSV.GetFileName (mixedSample.sSDF) + "'" + keyMz;  			foreach (double precursor in characterizedPeptides.Keys) {  				foreach (CharacterizedPrecursor charPrec in characterizedPeptides [precursor].Values) {  					double cumulArea = 0.0;  					foreach (Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ratios in listOfRatios)  						if (ratios.ContainsKey (charPrec))  							cumulArea += ratios [charPrec].eCurvePerMs.Area;  					resultStr += "'" + cumulArea;  					if (cumulArea > 0)  						isEmpty = false;  				}  			}  			if (!isEmpty)  				writerCumul.AddLine (resultStr);  		}  	}  	writerCumul.WriteToFile ();  	//List Modifications  	Dictionary<Modification' double> dicOfIntensityPerMod = new Dictionary<Modification' double> ();  	foreach (Sample sample in mixedPrecursors.Keys)  		foreach (MixedPrecursor mP in mixedPrecursors [sample])  			foreach (CharacterizedPrecursor cP in mP.PeptideRatios.Keys)  				if (cP.Peptide.VariableModifications != null)  					foreach (Modification mod in cP.Peptide.VariableModifications.Values)  						if (!dicOfIntensityPerMod.ContainsKey (mod))  							dicOfIntensityPerMod.Add (mod' 0.0);  	//Compute site occupancy for identical sequences (real positionnal isomers)  	vsCSVWriter writerSitesOccupancy = new vsCSVWriter (OutputFolder + "Results_SiteOccupancy.csv");  	List<Protein> AllProteins = Ace.ReadProteomeFromFasta (fastaFile' false' dbOptions);  	foreach (Protein protein in AllProteins) {  		string newTitleProtein = protein.Description.Replace ('''' ' ') + "'" + protein.Sequence;  		for (int i = 0; i < protein.Sequence.Length; i++)  			newTitleProtein += "'" + protein [i].ToString ();  		writerSitesOccupancy.AddLine (newTitleProtein);  		foreach (Sample mixedSample in mixedPrecursors.Keys) {  			string coverage = "Coverage'" + mixedSample.Name;  			for (int i = 0; i < protein.Sequence.Length; i++) {  				double cumulSite = 0.0;  				newTitleProtein += "'" + protein [i].ToString ();  				foreach (MixedPrecursor mP in mixedPrecursors [mixedSample]) {  					foreach (CharacterizedPrecursor cP in mP.PeptideRatios.Keys) {  						if (i + 1 >= cP.Peptide.StartResidueNumber && i + 1 <= cP.Peptide.EndResidueNumber)  							cumulSite += mP.PeptideRatios [cP].eCurvePerMs.Area;  					}  				}  				coverage += "'" + cumulSite;  			}  			writerSitesOccupancy.AddLine (coverage);  		}  		foreach (Modification mod in dicOfIntensityPerMod.Keys) {  			Dictionary<Sample' string> dicOfLines = new Dictionary<Sample' string> ();  			for (int i = 0; i < protein.Sequence.Length; i++) {  				foreach (Sample mixedSample in mixedPrecursors.Keys) {  					double cumulModArea = 0.0;  					foreach (MixedPrecursor mP in mixedPrecursors [mixedSample]) {  						foreach (CharacterizedPrecursor cP in mP.PeptideRatios.Keys) {  							if (i + 1 >= cP.Peptide.StartResidueNumber && i + 1 <= cP.Peptide.EndResidueNumber && cP.Peptide.VariableModifications != null) {  								foreach (int pos in cP.Peptide.VariableModifications.Keys)  									if (cP.Peptide.StartResidueNumber + pos - 2 == i + 1 && cP.Peptide.VariableModifications [pos] == mod)  										cumulModArea += mP.PeptideRatios [cP].eCurvePerMs.Area;  							}  						}  					}  					if (!dicOfLines.ContainsKey (mixedSample))  						dicOfLines.Add (mixedSample' mod.Description + "'" + mixedSample.Name + "'" + cumulModArea);  					else  						dicOfLines [mixedSample] += "'" + cumulModArea;  				}  			}  			foreach (string line in dicOfLines.Values)  				writerSitesOccupancy.AddLine (line);  		}  	}  	writerSitesOccupancy.WriteToFile ();  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The following statement contains a magic number: foreach (double precursor in characterizedPeptides.Keys)  	foreach (CharacterizedPrecursor charPrec in characterizedPeptides [precursor].Values) {  		titleCombined += "'" + charPrec.Peptide.Sequence + " Charge " + charPrec.Charge;  		if (charPrec.eCurveIntensityCount.Coefficients != null && charPrec.eCurveIntensityCount.Coefficients.Length == 3)  			curveStr += "'" + charPrec.eCurveIntensityCount.Coefficients [0] + "x^2 + " + charPrec.eCurveIntensityCount.Coefficients [1] + "x" + charPrec.eCurveIntensityCount.Coefficients [2];  		else  			curveStr += "'NA";  		spikedIntensityStr += "'" + charPrec.eCurveIntensityCount.Area;  	}  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The following statement contains a magic number: foreach (double precursor in characterizedPeptides.Keys)  	foreach (CharacterizedPrecursor charPrec in characterizedPeptides [precursor].Values) {  		titleCombined += "'" + charPrec.Peptide.Sequence + " Charge " + charPrec.Charge;  		if (charPrec.eCurveIntensityCount.Coefficients != null && charPrec.eCurveIntensityCount.Coefficients.Length == 3)  			curveStr += "'" + charPrec.eCurveIntensityCount.Coefficients [0] + "x^2 + " + charPrec.eCurveIntensityCount.Coefficients [1] + "x" + charPrec.eCurveIntensityCount.Coefficients [2];  		else  			curveStr += "'NA";  		spikedIntensityStr += "'" + charPrec.eCurveIntensityCount.Area;  	}  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The following statement contains a magic number: foreach (CharacterizedPrecursor charPrec in characterizedPeptides [precursor].Values) {  	titleCombined += "'" + charPrec.Peptide.Sequence + " Charge " + charPrec.Charge;  	if (charPrec.eCurveIntensityCount.Coefficients != null && charPrec.eCurveIntensityCount.Coefficients.Length == 3)  		curveStr += "'" + charPrec.eCurveIntensityCount.Coefficients [0] + "x^2 + " + charPrec.eCurveIntensityCount.Coefficients [1] + "x" + charPrec.eCurveIntensityCount.Coefficients [2];  	else  		curveStr += "'NA";  	spikedIntensityStr += "'" + charPrec.eCurveIntensityCount.Area;  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The following statement contains a magic number: foreach (CharacterizedPrecursor charPrec in characterizedPeptides [precursor].Values) {  	titleCombined += "'" + charPrec.Peptide.Sequence + " Charge " + charPrec.Charge;  	if (charPrec.eCurveIntensityCount.Coefficients != null && charPrec.eCurveIntensityCount.Coefficients.Length == 3)  		curveStr += "'" + charPrec.eCurveIntensityCount.Coefficients [0] + "x^2 + " + charPrec.eCurveIntensityCount.Coefficients [1] + "x" + charPrec.eCurveIntensityCount.Coefficients [2];  	else  		curveStr += "'NA";  	spikedIntensityStr += "'" + charPrec.eCurveIntensityCount.Area;  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The following statement contains a magic number: if (charPrec.eCurveIntensityCount.Coefficients != null && charPrec.eCurveIntensityCount.Coefficients.Length == 3)  	curveStr += "'" + charPrec.eCurveIntensityCount.Coefficients [0] + "x^2 + " + charPrec.eCurveIntensityCount.Coefficients [1] + "x" + charPrec.eCurveIntensityCount.Coefficients [2];  else  	curveStr += "'NA";  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The following statement contains a magic number: if (charPrec.eCurveIntensityCount.Coefficients != null && charPrec.eCurveIntensityCount.Coefficients.Length == 3)  	curveStr += "'" + charPrec.eCurveIntensityCount.Coefficients [0] + "x^2 + " + charPrec.eCurveIntensityCount.Coefficients [1] + "x" + charPrec.eCurveIntensityCount.Coefficients [2];  else  	curveStr += "'NA";  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The following statement contains a magic number: curveStr += "'" + charPrec.eCurveIntensityCount.Coefficients [0] + "x^2 + " + charPrec.eCurveIntensityCount.Coefficients [1] + "x" + charPrec.eCurveIntensityCount.Coefficients [2];  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The following statement contains a magic number: foreach (Protein protein in AllProteins) {  	string newTitleProtein = protein.Description.Replace ('''' ' ') + "'" + protein.Sequence;  	for (int i = 0; i < protein.Sequence.Length; i++)  		newTitleProtein += "'" + protein [i].ToString ();  	writerSitesOccupancy.AddLine (newTitleProtein);  	foreach (Sample mixedSample in mixedPrecursors.Keys) {  		string coverage = "Coverage'" + mixedSample.Name;  		for (int i = 0; i < protein.Sequence.Length; i++) {  			double cumulSite = 0.0;  			newTitleProtein += "'" + protein [i].ToString ();  			foreach (MixedPrecursor mP in mixedPrecursors [mixedSample]) {  				foreach (CharacterizedPrecursor cP in mP.PeptideRatios.Keys) {  					if (i + 1 >= cP.Peptide.StartResidueNumber && i + 1 <= cP.Peptide.EndResidueNumber)  						cumulSite += mP.PeptideRatios [cP].eCurvePerMs.Area;  				}  			}  			coverage += "'" + cumulSite;  		}  		writerSitesOccupancy.AddLine (coverage);  	}  	foreach (Modification mod in dicOfIntensityPerMod.Keys) {  		Dictionary<Sample' string> dicOfLines = new Dictionary<Sample' string> ();  		for (int i = 0; i < protein.Sequence.Length; i++) {  			foreach (Sample mixedSample in mixedPrecursors.Keys) {  				double cumulModArea = 0.0;  				foreach (MixedPrecursor mP in mixedPrecursors [mixedSample]) {  					foreach (CharacterizedPrecursor cP in mP.PeptideRatios.Keys) {  						if (i + 1 >= cP.Peptide.StartResidueNumber && i + 1 <= cP.Peptide.EndResidueNumber && cP.Peptide.VariableModifications != null) {  							foreach (int pos in cP.Peptide.VariableModifications.Keys)  								if (cP.Peptide.StartResidueNumber + pos - 2 == i + 1 && cP.Peptide.VariableModifications [pos] == mod)  									cumulModArea += mP.PeptideRatios [cP].eCurvePerMs.Area;  						}  					}  				}  				if (!dicOfLines.ContainsKey (mixedSample))  					dicOfLines.Add (mixedSample' mod.Description + "'" + mixedSample.Name + "'" + cumulModArea);  				else  					dicOfLines [mixedSample] += "'" + cumulModArea;  			}  		}  		foreach (string line in dicOfLines.Values)  			writerSitesOccupancy.AddLine (line);  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The following statement contains a magic number: foreach (Modification mod in dicOfIntensityPerMod.Keys) {  	Dictionary<Sample' string> dicOfLines = new Dictionary<Sample' string> ();  	for (int i = 0; i < protein.Sequence.Length; i++) {  		foreach (Sample mixedSample in mixedPrecursors.Keys) {  			double cumulModArea = 0.0;  			foreach (MixedPrecursor mP in mixedPrecursors [mixedSample]) {  				foreach (CharacterizedPrecursor cP in mP.PeptideRatios.Keys) {  					if (i + 1 >= cP.Peptide.StartResidueNumber && i + 1 <= cP.Peptide.EndResidueNumber && cP.Peptide.VariableModifications != null) {  						foreach (int pos in cP.Peptide.VariableModifications.Keys)  							if (cP.Peptide.StartResidueNumber + pos - 2 == i + 1 && cP.Peptide.VariableModifications [pos] == mod)  								cumulModArea += mP.PeptideRatios [cP].eCurvePerMs.Area;  					}  				}  			}  			if (!dicOfLines.ContainsKey (mixedSample))  				dicOfLines.Add (mixedSample' mod.Description + "'" + mixedSample.Name + "'" + cumulModArea);  			else  				dicOfLines [mixedSample] += "'" + cumulModArea;  		}  	}  	foreach (string line in dicOfLines.Values)  		writerSitesOccupancy.AddLine (line);  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The following statement contains a magic number: for (int i = 0; i < protein.Sequence.Length; i++) {  	foreach (Sample mixedSample in mixedPrecursors.Keys) {  		double cumulModArea = 0.0;  		foreach (MixedPrecursor mP in mixedPrecursors [mixedSample]) {  			foreach (CharacterizedPrecursor cP in mP.PeptideRatios.Keys) {  				if (i + 1 >= cP.Peptide.StartResidueNumber && i + 1 <= cP.Peptide.EndResidueNumber && cP.Peptide.VariableModifications != null) {  					foreach (int pos in cP.Peptide.VariableModifications.Keys)  						if (cP.Peptide.StartResidueNumber + pos - 2 == i + 1 && cP.Peptide.VariableModifications [pos] == mod)  							cumulModArea += mP.PeptideRatios [cP].eCurvePerMs.Area;  				}  			}  		}  		if (!dicOfLines.ContainsKey (mixedSample))  			dicOfLines.Add (mixedSample' mod.Description + "'" + mixedSample.Name + "'" + cumulModArea);  		else  			dicOfLines [mixedSample] += "'" + cumulModArea;  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The following statement contains a magic number: foreach (Sample mixedSample in mixedPrecursors.Keys) {  	double cumulModArea = 0.0;  	foreach (MixedPrecursor mP in mixedPrecursors [mixedSample]) {  		foreach (CharacterizedPrecursor cP in mP.PeptideRatios.Keys) {  			if (i + 1 >= cP.Peptide.StartResidueNumber && i + 1 <= cP.Peptide.EndResidueNumber && cP.Peptide.VariableModifications != null) {  				foreach (int pos in cP.Peptide.VariableModifications.Keys)  					if (cP.Peptide.StartResidueNumber + pos - 2 == i + 1 && cP.Peptide.VariableModifications [pos] == mod)  						cumulModArea += mP.PeptideRatios [cP].eCurvePerMs.Area;  			}  		}  	}  	if (!dicOfLines.ContainsKey (mixedSample))  		dicOfLines.Add (mixedSample' mod.Description + "'" + mixedSample.Name + "'" + cumulModArea);  	else  		dicOfLines [mixedSample] += "'" + cumulModArea;  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The following statement contains a magic number: foreach (MixedPrecursor mP in mixedPrecursors [mixedSample]) {  	foreach (CharacterizedPrecursor cP in mP.PeptideRatios.Keys) {  		if (i + 1 >= cP.Peptide.StartResidueNumber && i + 1 <= cP.Peptide.EndResidueNumber && cP.Peptide.VariableModifications != null) {  			foreach (int pos in cP.Peptide.VariableModifications.Keys)  				if (cP.Peptide.StartResidueNumber + pos - 2 == i + 1 && cP.Peptide.VariableModifications [pos] == mod)  					cumulModArea += mP.PeptideRatios [cP].eCurvePerMs.Area;  		}  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The following statement contains a magic number: foreach (CharacterizedPrecursor cP in mP.PeptideRatios.Keys) {  	if (i + 1 >= cP.Peptide.StartResidueNumber && i + 1 <= cP.Peptide.EndResidueNumber && cP.Peptide.VariableModifications != null) {  		foreach (int pos in cP.Peptide.VariableModifications.Keys)  			if (cP.Peptide.StartResidueNumber + pos - 2 == i + 1 && cP.Peptide.VariableModifications [pos] == mod)  				cumulModArea += mP.PeptideRatios [cP].eCurvePerMs.Area;  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The following statement contains a magic number: if (i + 1 >= cP.Peptide.StartResidueNumber && i + 1 <= cP.Peptide.EndResidueNumber && cP.Peptide.VariableModifications != null) {  	foreach (int pos in cP.Peptide.VariableModifications.Keys)  		if (cP.Peptide.StartResidueNumber + pos - 2 == i + 1 && cP.Peptide.VariableModifications [pos] == mod)  			cumulModArea += mP.PeptideRatios [cP].eCurvePerMs.Area;  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The following statement contains a magic number: foreach (int pos in cP.Peptide.VariableModifications.Keys)  	if (cP.Peptide.StartResidueNumber + pos - 2 == i + 1 && cP.Peptide.VariableModifications [pos] == mod)  		cumulModArea += mP.PeptideRatios [cP].eCurvePerMs.Area;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,Solve,The following statement contains a magic number: if (cP.Peptide.StartResidueNumber + pos - 2 == i + 1 && cP.Peptide.VariableModifications [pos] == mod)  	cumulModArea += mP.PeptideRatios [cP].eCurvePerMs.Area;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,ExportMixedSampleResult,The following statement contains a magic number: for (int i = 0; i < mixedPrecursor.eCurveIntensityCount.intensityCount.Count; i++) {  	line = mixedPrecursor.eCurveIntensityCount.time [i] / (1000.0 * 60.0) + "'" + mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (mixedPrecursor.eCurveIntensityCount.time [i]) + "'";  	foreach (CharacterizedPrecursor charPep in ratios.Keys)  		line += "'" + ratios [charPep].eCurvePerMs.InterpolateIntensity (mixedPrecursor.eCurveIntensityCount.time [i]);  	line += "'";  	foreach (CharacterizedPrecursor charPep in ratios.Keys)  		line += "'" + ratios [charPep].eCurveCount.InterpolateIntensity (mixedPrecursor.eCurveIntensityCount.time [i]);  	writerRatio.AddLine (line);  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,ExportMixedSampleResult,The following statement contains a magic number: for (int i = 0; i < mixedPrecursor.eCurveIntensityCount.intensityCount.Count; i++) {  	line = mixedPrecursor.eCurveIntensityCount.time [i] / (1000.0 * 60.0) + "'" + mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (mixedPrecursor.eCurveIntensityCount.time [i]) + "'";  	foreach (CharacterizedPrecursor charPep in ratios.Keys)  		line += "'" + ratios [charPep].eCurvePerMs.InterpolateIntensity (mixedPrecursor.eCurveIntensityCount.time [i]);  	line += "'";  	foreach (CharacterizedPrecursor charPep in ratios.Keys)  		line += "'" + ratios [charPep].eCurveCount.InterpolateIntensity (mixedPrecursor.eCurveIntensityCount.time [i]);  	writerRatio.AddLine (line);  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,ExportMixedSampleResult,The following statement contains a magic number: line = mixedPrecursor.eCurveIntensityCount.time [i] / (1000.0 * 60.0) + "'" + mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (mixedPrecursor.eCurveIntensityCount.time [i]) + "'";  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,ExportMixedSampleResult,The following statement contains a magic number: line = mixedPrecursor.eCurveIntensityCount.time [i] / (1000.0 * 60.0) + "'" + mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (mixedPrecursor.eCurveIntensityCount.time [i]) + "'";  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The following statement contains a magic number: for (int nbProductsToKeep = nbMinFragments; nbProductsToKeep <= nbMaxFragments; nbProductsToKeep++) {  	bool validProducts = true;  	int nbIgnoredSpectrum = 0;  	List<CharacterizedPrecursor> Isomers = new List<CharacterizedPrecursor> ();  	foreach (double mz in spikes.Keys)  		if (Math.Abs (Utilities.Numerics.CalculateMassError (mz' mixedPrecursor.MZ' dbOptions.precursorMassTolerance.Units)) <= dbOptions.precursorMassTolerance.Value)  			foreach (Sample sample in spikes [mz].Keys)  				if (spikes [mz] [sample].IsValid (nbProductsToKeep))  					Isomers.Add (spikes [mz] [sample]);  				else  					validProducts = false;  	if (validProducts) {  		double cumulError = 0;  		Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curves = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  		foreach (Query query in mixedPrecursor.Queries) {  			double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  			//                      double overFlow = 0;  			double underFlow = 0;  			double percentError = 0;  			Dictionary<CharacterizedPrecursor' SolvedResult> finalRatios = SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' //query.spectrum.PrecursorIntensityPerMilliSecond * query.spectrum.InjectionTime'   			query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole' dbOptions.OutputFolder + "Fragments" + System.IO.Path.DirectorySeparatorChar + "Fragments_" + vsCSV.GetFileName_NoExtension (mixedPrecursor.Sample.sSDF) + "_" + mixedPrecursor.MZ + "_" + query.spectrum.ScanNumber + "_" + nbProductsToKeep + ".csv");  			cumulError += underFlow;  			// percentError;  			if (percentError < 0.5) {  				foreach (CharacterizedPrecursor cPep in finalRatios.Keys) {  					if (!curves.ContainsKey (cPep))  						curves.Add (cPep' new MaxFlowElutionCurve (nbProductsToKeep));  					//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);                                  					//curves[cPep].eCurvePerMs.AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity(timeInMilliSeconds));  					curves [cPep].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].NbFitTimes / query.spectrum.InjectionTime);  					curves [cPep].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  				}  			}  			else  				nbIgnoredSpectrum++;  			if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  				break;  		}  		//End of foreach query  		if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  			if (nbIgnoredSpectrum > 0)  				Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  			foreach (CharacterizedPrecursor cPep in curves.Keys)  				curves [cPep].Compute ();  			Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curvesToKeep = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  			foreach (CharacterizedPrecursor cPep in curves.Keys)  				if (curves [cPep].eCurvePerMs.Area > 0)  					curvesToKeep.Add (cPep' curves [cPep]);  			if (curvesToKeep.Count > 0)  				DicOfCurveErrors.Add (curvesToKeep' cumulError);  		}  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The following statement contains a magic number: for (int nbProductsToKeep = nbMinFragments; nbProductsToKeep <= nbMaxFragments; nbProductsToKeep++) {  	bool validProducts = true;  	int nbIgnoredSpectrum = 0;  	List<CharacterizedPrecursor> Isomers = new List<CharacterizedPrecursor> ();  	foreach (double mz in spikes.Keys)  		if (Math.Abs (Utilities.Numerics.CalculateMassError (mz' mixedPrecursor.MZ' dbOptions.precursorMassTolerance.Units)) <= dbOptions.precursorMassTolerance.Value)  			foreach (Sample sample in spikes [mz].Keys)  				if (spikes [mz] [sample].IsValid (nbProductsToKeep))  					Isomers.Add (spikes [mz] [sample]);  				else  					validProducts = false;  	if (validProducts) {  		double cumulError = 0;  		Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curves = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  		foreach (Query query in mixedPrecursor.Queries) {  			double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  			//                      double overFlow = 0;  			double underFlow = 0;  			double percentError = 0;  			Dictionary<CharacterizedPrecursor' SolvedResult> finalRatios = SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' //query.spectrum.PrecursorIntensityPerMilliSecond * query.spectrum.InjectionTime'   			query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole' dbOptions.OutputFolder + "Fragments" + System.IO.Path.DirectorySeparatorChar + "Fragments_" + vsCSV.GetFileName_NoExtension (mixedPrecursor.Sample.sSDF) + "_" + mixedPrecursor.MZ + "_" + query.spectrum.ScanNumber + "_" + nbProductsToKeep + ".csv");  			cumulError += underFlow;  			// percentError;  			if (percentError < 0.5) {  				foreach (CharacterizedPrecursor cPep in finalRatios.Keys) {  					if (!curves.ContainsKey (cPep))  						curves.Add (cPep' new MaxFlowElutionCurve (nbProductsToKeep));  					//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);                                  					//curves[cPep].eCurvePerMs.AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity(timeInMilliSeconds));  					curves [cPep].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].NbFitTimes / query.spectrum.InjectionTime);  					curves [cPep].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  				}  			}  			else  				nbIgnoredSpectrum++;  			if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  				break;  		}  		//End of foreach query  		if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  			if (nbIgnoredSpectrum > 0)  				Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  			foreach (CharacterizedPrecursor cPep in curves.Keys)  				curves [cPep].Compute ();  			Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curvesToKeep = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  			foreach (CharacterizedPrecursor cPep in curves.Keys)  				if (curves [cPep].eCurvePerMs.Area > 0)  					curvesToKeep.Add (cPep' curves [cPep]);  			if (curvesToKeep.Count > 0)  				DicOfCurveErrors.Add (curvesToKeep' cumulError);  		}  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The following statement contains a magic number: for (int nbProductsToKeep = nbMinFragments; nbProductsToKeep <= nbMaxFragments; nbProductsToKeep++) {  	bool validProducts = true;  	int nbIgnoredSpectrum = 0;  	List<CharacterizedPrecursor> Isomers = new List<CharacterizedPrecursor> ();  	foreach (double mz in spikes.Keys)  		if (Math.Abs (Utilities.Numerics.CalculateMassError (mz' mixedPrecursor.MZ' dbOptions.precursorMassTolerance.Units)) <= dbOptions.precursorMassTolerance.Value)  			foreach (Sample sample in spikes [mz].Keys)  				if (spikes [mz] [sample].IsValid (nbProductsToKeep))  					Isomers.Add (spikes [mz] [sample]);  				else  					validProducts = false;  	if (validProducts) {  		double cumulError = 0;  		Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curves = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  		foreach (Query query in mixedPrecursor.Queries) {  			double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  			//                      double overFlow = 0;  			double underFlow = 0;  			double percentError = 0;  			Dictionary<CharacterizedPrecursor' SolvedResult> finalRatios = SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' //query.spectrum.PrecursorIntensityPerMilliSecond * query.spectrum.InjectionTime'   			query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole' dbOptions.OutputFolder + "Fragments" + System.IO.Path.DirectorySeparatorChar + "Fragments_" + vsCSV.GetFileName_NoExtension (mixedPrecursor.Sample.sSDF) + "_" + mixedPrecursor.MZ + "_" + query.spectrum.ScanNumber + "_" + nbProductsToKeep + ".csv");  			cumulError += underFlow;  			// percentError;  			if (percentError < 0.5) {  				foreach (CharacterizedPrecursor cPep in finalRatios.Keys) {  					if (!curves.ContainsKey (cPep))  						curves.Add (cPep' new MaxFlowElutionCurve (nbProductsToKeep));  					//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);                                  					//curves[cPep].eCurvePerMs.AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity(timeInMilliSeconds));  					curves [cPep].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].NbFitTimes / query.spectrum.InjectionTime);  					curves [cPep].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  				}  			}  			else  				nbIgnoredSpectrum++;  			if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  				break;  		}  		//End of foreach query  		if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  			if (nbIgnoredSpectrum > 0)  				Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  			foreach (CharacterizedPrecursor cPep in curves.Keys)  				curves [cPep].Compute ();  			Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curvesToKeep = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  			foreach (CharacterizedPrecursor cPep in curves.Keys)  				if (curves [cPep].eCurvePerMs.Area > 0)  					curvesToKeep.Add (cPep' curves [cPep]);  			if (curvesToKeep.Count > 0)  				DicOfCurveErrors.Add (curvesToKeep' cumulError);  		}  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The following statement contains a magic number: for (int nbProductsToKeep = nbMinFragments; nbProductsToKeep <= nbMaxFragments; nbProductsToKeep++) {  	bool validProducts = true;  	int nbIgnoredSpectrum = 0;  	List<CharacterizedPrecursor> Isomers = new List<CharacterizedPrecursor> ();  	foreach (double mz in spikes.Keys)  		if (Math.Abs (Utilities.Numerics.CalculateMassError (mz' mixedPrecursor.MZ' dbOptions.precursorMassTolerance.Units)) <= dbOptions.precursorMassTolerance.Value)  			foreach (Sample sample in spikes [mz].Keys)  				if (spikes [mz] [sample].IsValid (nbProductsToKeep))  					Isomers.Add (spikes [mz] [sample]);  				else  					validProducts = false;  	if (validProducts) {  		double cumulError = 0;  		Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curves = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  		foreach (Query query in mixedPrecursor.Queries) {  			double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  			//                      double overFlow = 0;  			double underFlow = 0;  			double percentError = 0;  			Dictionary<CharacterizedPrecursor' SolvedResult> finalRatios = SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' //query.spectrum.PrecursorIntensityPerMilliSecond * query.spectrum.InjectionTime'   			query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole' dbOptions.OutputFolder + "Fragments" + System.IO.Path.DirectorySeparatorChar + "Fragments_" + vsCSV.GetFileName_NoExtension (mixedPrecursor.Sample.sSDF) + "_" + mixedPrecursor.MZ + "_" + query.spectrum.ScanNumber + "_" + nbProductsToKeep + ".csv");  			cumulError += underFlow;  			// percentError;  			if (percentError < 0.5) {  				foreach (CharacterizedPrecursor cPep in finalRatios.Keys) {  					if (!curves.ContainsKey (cPep))  						curves.Add (cPep' new MaxFlowElutionCurve (nbProductsToKeep));  					//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);                                  					//curves[cPep].eCurvePerMs.AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity(timeInMilliSeconds));  					curves [cPep].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].NbFitTimes / query.spectrum.InjectionTime);  					curves [cPep].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  				}  			}  			else  				nbIgnoredSpectrum++;  			if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  				break;  		}  		//End of foreach query  		if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  			if (nbIgnoredSpectrum > 0)  				Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  			foreach (CharacterizedPrecursor cPep in curves.Keys)  				curves [cPep].Compute ();  			Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curvesToKeep = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  			foreach (CharacterizedPrecursor cPep in curves.Keys)  				if (curves [cPep].eCurvePerMs.Area > 0)  					curvesToKeep.Add (cPep' curves [cPep]);  			if (curvesToKeep.Count > 0)  				DicOfCurveErrors.Add (curvesToKeep' cumulError);  		}  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The following statement contains a magic number: for (int nbProductsToKeep = nbMinFragments; nbProductsToKeep <= nbMaxFragments; nbProductsToKeep++) {  	bool validProducts = true;  	int nbIgnoredSpectrum = 0;  	List<CharacterizedPrecursor> Isomers = new List<CharacterizedPrecursor> ();  	foreach (double mz in spikes.Keys)  		if (Math.Abs (Utilities.Numerics.CalculateMassError (mz' mixedPrecursor.MZ' dbOptions.precursorMassTolerance.Units)) <= dbOptions.precursorMassTolerance.Value)  			foreach (Sample sample in spikes [mz].Keys)  				if (spikes [mz] [sample].IsValid (nbProductsToKeep))  					Isomers.Add (spikes [mz] [sample]);  				else  					validProducts = false;  	if (validProducts) {  		double cumulError = 0;  		Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curves = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  		foreach (Query query in mixedPrecursor.Queries) {  			double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  			//                      double overFlow = 0;  			double underFlow = 0;  			double percentError = 0;  			Dictionary<CharacterizedPrecursor' SolvedResult> finalRatios = SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' //query.spectrum.PrecursorIntensityPerMilliSecond * query.spectrum.InjectionTime'   			query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole' dbOptions.OutputFolder + "Fragments" + System.IO.Path.DirectorySeparatorChar + "Fragments_" + vsCSV.GetFileName_NoExtension (mixedPrecursor.Sample.sSDF) + "_" + mixedPrecursor.MZ + "_" + query.spectrum.ScanNumber + "_" + nbProductsToKeep + ".csv");  			cumulError += underFlow;  			// percentError;  			if (percentError < 0.5) {  				foreach (CharacterizedPrecursor cPep in finalRatios.Keys) {  					if (!curves.ContainsKey (cPep))  						curves.Add (cPep' new MaxFlowElutionCurve (nbProductsToKeep));  					//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);                                  					//curves[cPep].eCurvePerMs.AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity(timeInMilliSeconds));  					curves [cPep].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].NbFitTimes / query.spectrum.InjectionTime);  					curves [cPep].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  				}  			}  			else  				nbIgnoredSpectrum++;  			if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  				break;  		}  		//End of foreach query  		if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  			if (nbIgnoredSpectrum > 0)  				Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  			foreach (CharacterizedPrecursor cPep in curves.Keys)  				curves [cPep].Compute ();  			Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curvesToKeep = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  			foreach (CharacterizedPrecursor cPep in curves.Keys)  				if (curves [cPep].eCurvePerMs.Area > 0)  					curvesToKeep.Add (cPep' curves [cPep]);  			if (curvesToKeep.Count > 0)  				DicOfCurveErrors.Add (curvesToKeep' cumulError);  		}  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The following statement contains a magic number: if (validProducts) {  	double cumulError = 0;  	Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curves = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  	foreach (Query query in mixedPrecursor.Queries) {  		double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  		//                      double overFlow = 0;  		double underFlow = 0;  		double percentError = 0;  		Dictionary<CharacterizedPrecursor' SolvedResult> finalRatios = SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' //query.spectrum.PrecursorIntensityPerMilliSecond * query.spectrum.InjectionTime'   		query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole' dbOptions.OutputFolder + "Fragments" + System.IO.Path.DirectorySeparatorChar + "Fragments_" + vsCSV.GetFileName_NoExtension (mixedPrecursor.Sample.sSDF) + "_" + mixedPrecursor.MZ + "_" + query.spectrum.ScanNumber + "_" + nbProductsToKeep + ".csv");  		cumulError += underFlow;  		// percentError;  		if (percentError < 0.5) {  			foreach (CharacterizedPrecursor cPep in finalRatios.Keys) {  				if (!curves.ContainsKey (cPep))  					curves.Add (cPep' new MaxFlowElutionCurve (nbProductsToKeep));  				//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);                                  				//curves[cPep].eCurvePerMs.AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity(timeInMilliSeconds));  				curves [cPep].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].NbFitTimes / query.spectrum.InjectionTime);  				curves [cPep].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  			}  		}  		else  			nbIgnoredSpectrum++;  		if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  			break;  	}  	//End of foreach query  	if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  		if (nbIgnoredSpectrum > 0)  			Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  		foreach (CharacterizedPrecursor cPep in curves.Keys)  			curves [cPep].Compute ();  		Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curvesToKeep = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  		foreach (CharacterizedPrecursor cPep in curves.Keys)  			if (curves [cPep].eCurvePerMs.Area > 0)  				curvesToKeep.Add (cPep' curves [cPep]);  		if (curvesToKeep.Count > 0)  			DicOfCurveErrors.Add (curvesToKeep' cumulError);  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The following statement contains a magic number: if (validProducts) {  	double cumulError = 0;  	Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curves = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  	foreach (Query query in mixedPrecursor.Queries) {  		double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  		//                      double overFlow = 0;  		double underFlow = 0;  		double percentError = 0;  		Dictionary<CharacterizedPrecursor' SolvedResult> finalRatios = SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' //query.spectrum.PrecursorIntensityPerMilliSecond * query.spectrum.InjectionTime'   		query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole' dbOptions.OutputFolder + "Fragments" + System.IO.Path.DirectorySeparatorChar + "Fragments_" + vsCSV.GetFileName_NoExtension (mixedPrecursor.Sample.sSDF) + "_" + mixedPrecursor.MZ + "_" + query.spectrum.ScanNumber + "_" + nbProductsToKeep + ".csv");  		cumulError += underFlow;  		// percentError;  		if (percentError < 0.5) {  			foreach (CharacterizedPrecursor cPep in finalRatios.Keys) {  				if (!curves.ContainsKey (cPep))  					curves.Add (cPep' new MaxFlowElutionCurve (nbProductsToKeep));  				//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);                                  				//curves[cPep].eCurvePerMs.AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity(timeInMilliSeconds));  				curves [cPep].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].NbFitTimes / query.spectrum.InjectionTime);  				curves [cPep].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  			}  		}  		else  			nbIgnoredSpectrum++;  		if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  			break;  	}  	//End of foreach query  	if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  		if (nbIgnoredSpectrum > 0)  			Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  		foreach (CharacterizedPrecursor cPep in curves.Keys)  			curves [cPep].Compute ();  		Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curvesToKeep = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  		foreach (CharacterizedPrecursor cPep in curves.Keys)  			if (curves [cPep].eCurvePerMs.Area > 0)  				curvesToKeep.Add (cPep' curves [cPep]);  		if (curvesToKeep.Count > 0)  			DicOfCurveErrors.Add (curvesToKeep' cumulError);  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The following statement contains a magic number: if (validProducts) {  	double cumulError = 0;  	Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curves = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  	foreach (Query query in mixedPrecursor.Queries) {  		double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  		//                      double overFlow = 0;  		double underFlow = 0;  		double percentError = 0;  		Dictionary<CharacterizedPrecursor' SolvedResult> finalRatios = SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' //query.spectrum.PrecursorIntensityPerMilliSecond * query.spectrum.InjectionTime'   		query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole' dbOptions.OutputFolder + "Fragments" + System.IO.Path.DirectorySeparatorChar + "Fragments_" + vsCSV.GetFileName_NoExtension (mixedPrecursor.Sample.sSDF) + "_" + mixedPrecursor.MZ + "_" + query.spectrum.ScanNumber + "_" + nbProductsToKeep + ".csv");  		cumulError += underFlow;  		// percentError;  		if (percentError < 0.5) {  			foreach (CharacterizedPrecursor cPep in finalRatios.Keys) {  				if (!curves.ContainsKey (cPep))  					curves.Add (cPep' new MaxFlowElutionCurve (nbProductsToKeep));  				//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);                                  				//curves[cPep].eCurvePerMs.AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity(timeInMilliSeconds));  				curves [cPep].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].NbFitTimes / query.spectrum.InjectionTime);  				curves [cPep].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  			}  		}  		else  			nbIgnoredSpectrum++;  		if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  			break;  	}  	//End of foreach query  	if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  		if (nbIgnoredSpectrum > 0)  			Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  		foreach (CharacterizedPrecursor cPep in curves.Keys)  			curves [cPep].Compute ();  		Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curvesToKeep = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  		foreach (CharacterizedPrecursor cPep in curves.Keys)  			if (curves [cPep].eCurvePerMs.Area > 0)  				curvesToKeep.Add (cPep' curves [cPep]);  		if (curvesToKeep.Count > 0)  			DicOfCurveErrors.Add (curvesToKeep' cumulError);  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The following statement contains a magic number: if (validProducts) {  	double cumulError = 0;  	Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curves = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  	foreach (Query query in mixedPrecursor.Queries) {  		double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  		//                      double overFlow = 0;  		double underFlow = 0;  		double percentError = 0;  		Dictionary<CharacterizedPrecursor' SolvedResult> finalRatios = SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' //query.spectrum.PrecursorIntensityPerMilliSecond * query.spectrum.InjectionTime'   		query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole' dbOptions.OutputFolder + "Fragments" + System.IO.Path.DirectorySeparatorChar + "Fragments_" + vsCSV.GetFileName_NoExtension (mixedPrecursor.Sample.sSDF) + "_" + mixedPrecursor.MZ + "_" + query.spectrum.ScanNumber + "_" + nbProductsToKeep + ".csv");  		cumulError += underFlow;  		// percentError;  		if (percentError < 0.5) {  			foreach (CharacterizedPrecursor cPep in finalRatios.Keys) {  				if (!curves.ContainsKey (cPep))  					curves.Add (cPep' new MaxFlowElutionCurve (nbProductsToKeep));  				//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);                                  				//curves[cPep].eCurvePerMs.AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity(timeInMilliSeconds));  				curves [cPep].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].NbFitTimes / query.spectrum.InjectionTime);  				curves [cPep].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  			}  		}  		else  			nbIgnoredSpectrum++;  		if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  			break;  	}  	//End of foreach query  	if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  		if (nbIgnoredSpectrum > 0)  			Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  		foreach (CharacterizedPrecursor cPep in curves.Keys)  			curves [cPep].Compute ();  		Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curvesToKeep = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  		foreach (CharacterizedPrecursor cPep in curves.Keys)  			if (curves [cPep].eCurvePerMs.Area > 0)  				curvesToKeep.Add (cPep' curves [cPep]);  		if (curvesToKeep.Count > 0)  			DicOfCurveErrors.Add (curvesToKeep' cumulError);  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The following statement contains a magic number: if (validProducts) {  	double cumulError = 0;  	Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curves = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  	foreach (Query query in mixedPrecursor.Queries) {  		double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  		//                      double overFlow = 0;  		double underFlow = 0;  		double percentError = 0;  		Dictionary<CharacterizedPrecursor' SolvedResult> finalRatios = SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' //query.spectrum.PrecursorIntensityPerMilliSecond * query.spectrum.InjectionTime'   		query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole' dbOptions.OutputFolder + "Fragments" + System.IO.Path.DirectorySeparatorChar + "Fragments_" + vsCSV.GetFileName_NoExtension (mixedPrecursor.Sample.sSDF) + "_" + mixedPrecursor.MZ + "_" + query.spectrum.ScanNumber + "_" + nbProductsToKeep + ".csv");  		cumulError += underFlow;  		// percentError;  		if (percentError < 0.5) {  			foreach (CharacterizedPrecursor cPep in finalRatios.Keys) {  				if (!curves.ContainsKey (cPep))  					curves.Add (cPep' new MaxFlowElutionCurve (nbProductsToKeep));  				//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);                                  				//curves[cPep].eCurvePerMs.AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity(timeInMilliSeconds));  				curves [cPep].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].NbFitTimes / query.spectrum.InjectionTime);  				curves [cPep].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  			}  		}  		else  			nbIgnoredSpectrum++;  		if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  			break;  	}  	//End of foreach query  	if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  		if (nbIgnoredSpectrum > 0)  			Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  		foreach (CharacterizedPrecursor cPep in curves.Keys)  			curves [cPep].Compute ();  		Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curvesToKeep = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  		foreach (CharacterizedPrecursor cPep in curves.Keys)  			if (curves [cPep].eCurvePerMs.Area > 0)  				curvesToKeep.Add (cPep' curves [cPep]);  		if (curvesToKeep.Count > 0)  			DicOfCurveErrors.Add (curvesToKeep' cumulError);  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The following statement contains a magic number: foreach (Query query in mixedPrecursor.Queries) {  	double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  	//                      double overFlow = 0;  	double underFlow = 0;  	double percentError = 0;  	Dictionary<CharacterizedPrecursor' SolvedResult> finalRatios = SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' //query.spectrum.PrecursorIntensityPerMilliSecond * query.spectrum.InjectionTime'   	query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole' dbOptions.OutputFolder + "Fragments" + System.IO.Path.DirectorySeparatorChar + "Fragments_" + vsCSV.GetFileName_NoExtension (mixedPrecursor.Sample.sSDF) + "_" + mixedPrecursor.MZ + "_" + query.spectrum.ScanNumber + "_" + nbProductsToKeep + ".csv");  	cumulError += underFlow;  	// percentError;  	if (percentError < 0.5) {  		foreach (CharacterizedPrecursor cPep in finalRatios.Keys) {  			if (!curves.ContainsKey (cPep))  				curves.Add (cPep' new MaxFlowElutionCurve (nbProductsToKeep));  			//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);                                  			//curves[cPep].eCurvePerMs.AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity(timeInMilliSeconds));  			curves [cPep].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].NbFitTimes / query.spectrum.InjectionTime);  			curves [cPep].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  		}  	}  	else  		nbIgnoredSpectrum++;  	if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  		break;  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The following statement contains a magic number: foreach (Query query in mixedPrecursor.Queries) {  	double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  	//                      double overFlow = 0;  	double underFlow = 0;  	double percentError = 0;  	Dictionary<CharacterizedPrecursor' SolvedResult> finalRatios = SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' //query.spectrum.PrecursorIntensityPerMilliSecond * query.spectrum.InjectionTime'   	query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole' dbOptions.OutputFolder + "Fragments" + System.IO.Path.DirectorySeparatorChar + "Fragments_" + vsCSV.GetFileName_NoExtension (mixedPrecursor.Sample.sSDF) + "_" + mixedPrecursor.MZ + "_" + query.spectrum.ScanNumber + "_" + nbProductsToKeep + ".csv");  	cumulError += underFlow;  	// percentError;  	if (percentError < 0.5) {  		foreach (CharacterizedPrecursor cPep in finalRatios.Keys) {  			if (!curves.ContainsKey (cPep))  				curves.Add (cPep' new MaxFlowElutionCurve (nbProductsToKeep));  			//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);                                  			//curves[cPep].eCurvePerMs.AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity(timeInMilliSeconds));  			curves [cPep].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].NbFitTimes / query.spectrum.InjectionTime);  			curves [cPep].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  		}  	}  	else  		nbIgnoredSpectrum++;  	if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  		break;  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The following statement contains a magic number: foreach (Query query in mixedPrecursor.Queries) {  	double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  	//                      double overFlow = 0;  	double underFlow = 0;  	double percentError = 0;  	Dictionary<CharacterizedPrecursor' SolvedResult> finalRatios = SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' //query.spectrum.PrecursorIntensityPerMilliSecond * query.spectrum.InjectionTime'   	query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole' dbOptions.OutputFolder + "Fragments" + System.IO.Path.DirectorySeparatorChar + "Fragments_" + vsCSV.GetFileName_NoExtension (mixedPrecursor.Sample.sSDF) + "_" + mixedPrecursor.MZ + "_" + query.spectrum.ScanNumber + "_" + nbProductsToKeep + ".csv");  	cumulError += underFlow;  	// percentError;  	if (percentError < 0.5) {  		foreach (CharacterizedPrecursor cPep in finalRatios.Keys) {  			if (!curves.ContainsKey (cPep))  				curves.Add (cPep' new MaxFlowElutionCurve (nbProductsToKeep));  			//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);                                  			//curves[cPep].eCurvePerMs.AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity(timeInMilliSeconds));  			curves [cPep].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].NbFitTimes / query.spectrum.InjectionTime);  			curves [cPep].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  		}  	}  	else  		nbIgnoredSpectrum++;  	if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  		break;  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The following statement contains a magic number: foreach (Query query in mixedPrecursor.Queries) {  	double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  	//                      double overFlow = 0;  	double underFlow = 0;  	double percentError = 0;  	Dictionary<CharacterizedPrecursor' SolvedResult> finalRatios = SolveFromSpectrum (Isomers' nbProductsToKeep' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' //query.spectrum.PrecursorIntensityPerMilliSecond * query.spectrum.InjectionTime'   	query.spectrum.PrecursorIntensity' out underFlow' out percentError' dbOptions.ConSole' dbOptions.OutputFolder + "Fragments" + System.IO.Path.DirectorySeparatorChar + "Fragments_" + vsCSV.GetFileName_NoExtension (mixedPrecursor.Sample.sSDF) + "_" + mixedPrecursor.MZ + "_" + query.spectrum.ScanNumber + "_" + nbProductsToKeep + ".csv");  	cumulError += underFlow;  	// percentError;  	if (percentError < 0.5) {  		foreach (CharacterizedPrecursor cPep in finalRatios.Keys) {  			if (!curves.ContainsKey (cPep))  				curves.Add (cPep' new MaxFlowElutionCurve (nbProductsToKeep));  			//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);                                  			//curves[cPep].eCurvePerMs.AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity(timeInMilliSeconds));  			curves [cPep].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].NbFitTimes / query.spectrum.InjectionTime);  			curves [cPep].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  		}  	}  	else  		nbIgnoredSpectrum++;  	if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  		break;  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The following statement contains a magic number: if (percentError < 0.5) {  	foreach (CharacterizedPrecursor cPep in finalRatios.Keys) {  		if (!curves.ContainsKey (cPep))  			curves.Add (cPep' new MaxFlowElutionCurve (nbProductsToKeep));  		//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);                                  		//curves[cPep].eCurvePerMs.AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity(timeInMilliSeconds));  		curves [cPep].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].NbFitTimes / query.spectrum.InjectionTime);  		curves [cPep].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  	}  }  else  	nbIgnoredSpectrum++;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The following statement contains a magic number: if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  	break;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,GetRatios,The following statement contains a magic number: if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  	if (nbIgnoredSpectrum > 0)  		Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  	foreach (CharacterizedPrecursor cPep in curves.Keys)  		curves [cPep].Compute ();  	Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> curvesToKeep = new Dictionary<CharacterizedPrecursor' MaxFlowElutionCurve> ();  	foreach (CharacterizedPrecursor cPep in curves.Keys)  		if (curves [cPep].eCurvePerMs.Area > 0)  			curvesToKeep.Add (cPep' curves [cPep]);  	if (curvesToKeep.Count > 0)  		DicOfCurveErrors.Add (curvesToKeep' cumulError);  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolver,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolver.cs,SolveFromSpectrum,The following statement contains a magic number: if (keepGoing) {  	List<double> solution = new List<double> ();  	double stepSize = PrecursorIntensityInCTrap / 1000.0;  	if (stepSize < 1)  		stepSize = 1;  	double tmpUnderflow = 0;  	Utilities.Methods.GradientDescent.SolveMaxFlowStyle (unitSpectrum' mixedSpectrum' out solution' out tmpUnderflow' ConSole' stepSize);  	//Utilities.Methods.GradientDescent.SolveFromGradientDescent(unitSpectrum' mixedSpectrum' PrecursorIntensityInCTrap' out solution' out tmpUnderflow' ConSole);  	double sumOfIntensities = 0;  	foreach (double val in mixedSpectrum.Values)  		sumOfIntensities += val;  	underFlow = tmpUnderflow;  	List<SolvedResult> result = GetResultList (solution' underFlow' sumOfIntensities);  	Dictionary<CharacterizedPrecursor' SolvedResult> resultPerSample = new Dictionary<CharacterizedPrecursor' SolvedResult> ();  	int i = 0;  	foreach (CharacterizedPrecursor key in ratiosToFit) {  		resultPerSample.Add (key' result [i]);  		i++;  	}  	if (writerFrag != null) {  		foreach (CharacterizedPrecursor cPrec in ratiosToFit) {  			string line = cPrec.Peptide.Sequence;  			foreach (double key in mixedSpectrum.Keys)  				line += "'" + cPrec.NormalizedFragments [nbProductsToKeep] [key] * resultPerSample [cPrec].NbFitTimes;  			writerFrag.AddLine (line);  		}  		writerFrag.WriteToFile ();  	}  	percentError = (underFlow / sumOfIntensities);  	return resultPerSample;  }  else {  	percentError = 1.0;  	underFlow = 0;  	return new Dictionary<CharacterizedPrecursor' SolvedResult> ();  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,CreateOptions,The following statement contains a magic number: dbOptions.MaximumPeptideMass = 200000;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,CreateOptions,The following statement contains a magic number: dbOptions.MaximumNumberOfFragmentsPerSpectrum = 400;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,CreateOptions,The following statement contains a magic number: dbOptions.ToleratedMissedCleavages = 200;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,CreateOptions,The following statement contains a magic number: dbOptions.MinimumPeptideLength = 5;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,CreateOptions,The following statement contains a magic number: dbOptions.MaximumPeptideLength = 300;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,CreateOptions,The following statement contains a magic number: dbOptions.maximumVariableModificationIsoforms = 1024;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,CreateOptions,The following statement contains a magic number: dbOptions.NbPSMToKeep = 100;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,Solve,The following statement contains a magic number: foreach (double precursor in characterizedPeptides.Keys)  	foreach (CharacterizedPrecursor charPrec in characterizedPeptides [precursor].Values) {  		titleCombined += "'" + charPrec.Peptide.Sequence + " Charge " + charPrec.Charge;  		if (charPrec.eCurveIntensityCount.Coefficients != null && charPrec.eCurveIntensityCount.Coefficients.Length == 3)  			curveStr += "'" + charPrec.eCurveIntensityCount.Coefficients [0] + "x^2 + " + charPrec.eCurveIntensityCount.Coefficients [1] + "x" + charPrec.eCurveIntensityCount.Coefficients [2];  		else  			curveStr += "'NA";  		spikedIntensityStr += "'" + charPrec.eCurveIntensityCount.Area;  	}  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,Solve,The following statement contains a magic number: foreach (double precursor in characterizedPeptides.Keys)  	foreach (CharacterizedPrecursor charPrec in characterizedPeptides [precursor].Values) {  		titleCombined += "'" + charPrec.Peptide.Sequence + " Charge " + charPrec.Charge;  		if (charPrec.eCurveIntensityCount.Coefficients != null && charPrec.eCurveIntensityCount.Coefficients.Length == 3)  			curveStr += "'" + charPrec.eCurveIntensityCount.Coefficients [0] + "x^2 + " + charPrec.eCurveIntensityCount.Coefficients [1] + "x" + charPrec.eCurveIntensityCount.Coefficients [2];  		else  			curveStr += "'NA";  		spikedIntensityStr += "'" + charPrec.eCurveIntensityCount.Area;  	}  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,Solve,The following statement contains a magic number: foreach (CharacterizedPrecursor charPrec in characterizedPeptides [precursor].Values) {  	titleCombined += "'" + charPrec.Peptide.Sequence + " Charge " + charPrec.Charge;  	if (charPrec.eCurveIntensityCount.Coefficients != null && charPrec.eCurveIntensityCount.Coefficients.Length == 3)  		curveStr += "'" + charPrec.eCurveIntensityCount.Coefficients [0] + "x^2 + " + charPrec.eCurveIntensityCount.Coefficients [1] + "x" + charPrec.eCurveIntensityCount.Coefficients [2];  	else  		curveStr += "'NA";  	spikedIntensityStr += "'" + charPrec.eCurveIntensityCount.Area;  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,Solve,The following statement contains a magic number: foreach (CharacterizedPrecursor charPrec in characterizedPeptides [precursor].Values) {  	titleCombined += "'" + charPrec.Peptide.Sequence + " Charge " + charPrec.Charge;  	if (charPrec.eCurveIntensityCount.Coefficients != null && charPrec.eCurveIntensityCount.Coefficients.Length == 3)  		curveStr += "'" + charPrec.eCurveIntensityCount.Coefficients [0] + "x^2 + " + charPrec.eCurveIntensityCount.Coefficients [1] + "x" + charPrec.eCurveIntensityCount.Coefficients [2];  	else  		curveStr += "'NA";  	spikedIntensityStr += "'" + charPrec.eCurveIntensityCount.Area;  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,Solve,The following statement contains a magic number: if (charPrec.eCurveIntensityCount.Coefficients != null && charPrec.eCurveIntensityCount.Coefficients.Length == 3)  	curveStr += "'" + charPrec.eCurveIntensityCount.Coefficients [0] + "x^2 + " + charPrec.eCurveIntensityCount.Coefficients [1] + "x" + charPrec.eCurveIntensityCount.Coefficients [2];  else  	curveStr += "'NA";  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,Solve,The following statement contains a magic number: if (charPrec.eCurveIntensityCount.Coefficients != null && charPrec.eCurveIntensityCount.Coefficients.Length == 3)  	curveStr += "'" + charPrec.eCurveIntensityCount.Coefficients [0] + "x^2 + " + charPrec.eCurveIntensityCount.Coefficients [1] + "x" + charPrec.eCurveIntensityCount.Coefficients [2];  else  	curveStr += "'NA";  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,Solve,The following statement contains a magic number: curveStr += "'" + charPrec.eCurveIntensityCount.Coefficients [0] + "x^2 + " + charPrec.eCurveIntensityCount.Coefficients [1] + "x" + charPrec.eCurveIntensityCount.Coefficients [2];  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ExportMixedSampleResult,The following statement contains a magic number: for (int i = 0; i < mixedPrecursor.eCurveIntensityCount.intensityCount.Count; i++) {  	line = mixedPrecursor.eCurveIntensityCount.time [i] / (1000.0 * 60.0) + "'" + mixedPrecursor.eCurveIntensityCount.intensityCount [i];  	foreach (Peptide charPep in ratios.Keys)  		line += "'" + ratios [charPep].eCurvePerMs.InterpolateIntensity (mixedPrecursor.eCurveIntensityCount.time [i]);  	writerRatio.AddLine (line);  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ExportMixedSampleResult,The following statement contains a magic number: for (int i = 0; i < mixedPrecursor.eCurveIntensityCount.intensityCount.Count; i++) {  	line = mixedPrecursor.eCurveIntensityCount.time [i] / (1000.0 * 60.0) + "'" + mixedPrecursor.eCurveIntensityCount.intensityCount [i];  	foreach (Peptide charPep in ratios.Keys)  		line += "'" + ratios [charPep].eCurvePerMs.InterpolateIntensity (mixedPrecursor.eCurveIntensityCount.time [i]);  	writerRatio.AddLine (line);  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ExportMixedSampleResult,The following statement contains a magic number: line = mixedPrecursor.eCurveIntensityCount.time [i] / (1000.0 * 60.0) + "'" + mixedPrecursor.eCurveIntensityCount.intensityCount [i];  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ExportMixedSampleResult,The following statement contains a magic number: line = mixedPrecursor.eCurveIntensityCount.time [i] / (1000.0 * 60.0) + "'" + mixedPrecursor.eCurveIntensityCount.intensityCount [i];  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The following statement contains a magic number: for (int nbProductsToKeep = nbMinFragments; nbProductsToKeep <= nbMaxFragments; nbProductsToKeep++) {  	bool validProducts = true;  	int nbIgnoredSpectrum = 0;  	if (validProducts) {  		double cumulError = 0;  		Dictionary<Peptide' MaxFlowElutionCurve> curves = new Dictionary<Peptide' MaxFlowElutionCurve> ();  		foreach (Query query in mixedPrecursor.Queries) {  			double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  			//                      double overFlow = 0;  			double underFlow = 0;  			double percentError = 0;  			Dictionary<PeptideSpectrumMatch' SolvedResult> finalRatios = SolveFromFragmentScore (nbProductsToKeep' precision' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' query' out underFlow' out percentError' dbOptions.ConSole);  			cumulError += underFlow;  			// percentError;  			if (percentError < 0.5) {  				foreach (PeptideSpectrumMatch cPep in finalRatios.Keys) {  					if (!curves.ContainsKey (cPep.Peptide))  						curves.Add (cPep.Peptide' new MaxFlowElutionCurve (nbProductsToKeep));  					//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);  					curves [cPep.Peptide].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  					curves [cPep.Peptide].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (timeInMilliSeconds));  				}  			}  			else  				nbIgnoredSpectrum++;  			if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  				break;  		}  		//End of foreach query  		if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  			if (nbIgnoredSpectrum > 0)  				Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  			foreach (Peptide cPep in curves.Keys)  				curves [cPep].Compute ();  			Dictionary<Peptide' MaxFlowElutionCurve> curvesToKeep = new Dictionary<Peptide' MaxFlowElutionCurve> ();  			foreach (Peptide cPep in curves.Keys)  				if (curves [cPep].eCurvePerMs.Area > 0)  					curvesToKeep.Add (cPep' curves [cPep]);  			if (curvesToKeep.Count > 0)  				DicOfCurveErrors.Add (curvesToKeep' cumulError);  		}  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The following statement contains a magic number: for (int nbProductsToKeep = nbMinFragments; nbProductsToKeep <= nbMaxFragments; nbProductsToKeep++) {  	bool validProducts = true;  	int nbIgnoredSpectrum = 0;  	if (validProducts) {  		double cumulError = 0;  		Dictionary<Peptide' MaxFlowElutionCurve> curves = new Dictionary<Peptide' MaxFlowElutionCurve> ();  		foreach (Query query in mixedPrecursor.Queries) {  			double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  			//                      double overFlow = 0;  			double underFlow = 0;  			double percentError = 0;  			Dictionary<PeptideSpectrumMatch' SolvedResult> finalRatios = SolveFromFragmentScore (nbProductsToKeep' precision' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' query' out underFlow' out percentError' dbOptions.ConSole);  			cumulError += underFlow;  			// percentError;  			if (percentError < 0.5) {  				foreach (PeptideSpectrumMatch cPep in finalRatios.Keys) {  					if (!curves.ContainsKey (cPep.Peptide))  						curves.Add (cPep.Peptide' new MaxFlowElutionCurve (nbProductsToKeep));  					//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);  					curves [cPep.Peptide].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  					curves [cPep.Peptide].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (timeInMilliSeconds));  				}  			}  			else  				nbIgnoredSpectrum++;  			if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  				break;  		}  		//End of foreach query  		if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  			if (nbIgnoredSpectrum > 0)  				Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  			foreach (Peptide cPep in curves.Keys)  				curves [cPep].Compute ();  			Dictionary<Peptide' MaxFlowElutionCurve> curvesToKeep = new Dictionary<Peptide' MaxFlowElutionCurve> ();  			foreach (Peptide cPep in curves.Keys)  				if (curves [cPep].eCurvePerMs.Area > 0)  					curvesToKeep.Add (cPep' curves [cPep]);  			if (curvesToKeep.Count > 0)  				DicOfCurveErrors.Add (curvesToKeep' cumulError);  		}  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The following statement contains a magic number: for (int nbProductsToKeep = nbMinFragments; nbProductsToKeep <= nbMaxFragments; nbProductsToKeep++) {  	bool validProducts = true;  	int nbIgnoredSpectrum = 0;  	if (validProducts) {  		double cumulError = 0;  		Dictionary<Peptide' MaxFlowElutionCurve> curves = new Dictionary<Peptide' MaxFlowElutionCurve> ();  		foreach (Query query in mixedPrecursor.Queries) {  			double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  			//                      double overFlow = 0;  			double underFlow = 0;  			double percentError = 0;  			Dictionary<PeptideSpectrumMatch' SolvedResult> finalRatios = SolveFromFragmentScore (nbProductsToKeep' precision' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' query' out underFlow' out percentError' dbOptions.ConSole);  			cumulError += underFlow;  			// percentError;  			if (percentError < 0.5) {  				foreach (PeptideSpectrumMatch cPep in finalRatios.Keys) {  					if (!curves.ContainsKey (cPep.Peptide))  						curves.Add (cPep.Peptide' new MaxFlowElutionCurve (nbProductsToKeep));  					//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);  					curves [cPep.Peptide].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  					curves [cPep.Peptide].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (timeInMilliSeconds));  				}  			}  			else  				nbIgnoredSpectrum++;  			if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  				break;  		}  		//End of foreach query  		if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  			if (nbIgnoredSpectrum > 0)  				Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  			foreach (Peptide cPep in curves.Keys)  				curves [cPep].Compute ();  			Dictionary<Peptide' MaxFlowElutionCurve> curvesToKeep = new Dictionary<Peptide' MaxFlowElutionCurve> ();  			foreach (Peptide cPep in curves.Keys)  				if (curves [cPep].eCurvePerMs.Area > 0)  					curvesToKeep.Add (cPep' curves [cPep]);  			if (curvesToKeep.Count > 0)  				DicOfCurveErrors.Add (curvesToKeep' cumulError);  		}  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The following statement contains a magic number: for (int nbProductsToKeep = nbMinFragments; nbProductsToKeep <= nbMaxFragments; nbProductsToKeep++) {  	bool validProducts = true;  	int nbIgnoredSpectrum = 0;  	if (validProducts) {  		double cumulError = 0;  		Dictionary<Peptide' MaxFlowElutionCurve> curves = new Dictionary<Peptide' MaxFlowElutionCurve> ();  		foreach (Query query in mixedPrecursor.Queries) {  			double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  			//                      double overFlow = 0;  			double underFlow = 0;  			double percentError = 0;  			Dictionary<PeptideSpectrumMatch' SolvedResult> finalRatios = SolveFromFragmentScore (nbProductsToKeep' precision' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' query' out underFlow' out percentError' dbOptions.ConSole);  			cumulError += underFlow;  			// percentError;  			if (percentError < 0.5) {  				foreach (PeptideSpectrumMatch cPep in finalRatios.Keys) {  					if (!curves.ContainsKey (cPep.Peptide))  						curves.Add (cPep.Peptide' new MaxFlowElutionCurve (nbProductsToKeep));  					//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);  					curves [cPep.Peptide].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  					curves [cPep.Peptide].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (timeInMilliSeconds));  				}  			}  			else  				nbIgnoredSpectrum++;  			if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  				break;  		}  		//End of foreach query  		if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  			if (nbIgnoredSpectrum > 0)  				Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  			foreach (Peptide cPep in curves.Keys)  				curves [cPep].Compute ();  			Dictionary<Peptide' MaxFlowElutionCurve> curvesToKeep = new Dictionary<Peptide' MaxFlowElutionCurve> ();  			foreach (Peptide cPep in curves.Keys)  				if (curves [cPep].eCurvePerMs.Area > 0)  					curvesToKeep.Add (cPep' curves [cPep]);  			if (curvesToKeep.Count > 0)  				DicOfCurveErrors.Add (curvesToKeep' cumulError);  		}  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The following statement contains a magic number: for (int nbProductsToKeep = nbMinFragments; nbProductsToKeep <= nbMaxFragments; nbProductsToKeep++) {  	bool validProducts = true;  	int nbIgnoredSpectrum = 0;  	if (validProducts) {  		double cumulError = 0;  		Dictionary<Peptide' MaxFlowElutionCurve> curves = new Dictionary<Peptide' MaxFlowElutionCurve> ();  		foreach (Query query in mixedPrecursor.Queries) {  			double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  			//                      double overFlow = 0;  			double underFlow = 0;  			double percentError = 0;  			Dictionary<PeptideSpectrumMatch' SolvedResult> finalRatios = SolveFromFragmentScore (nbProductsToKeep' precision' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' query' out underFlow' out percentError' dbOptions.ConSole);  			cumulError += underFlow;  			// percentError;  			if (percentError < 0.5) {  				foreach (PeptideSpectrumMatch cPep in finalRatios.Keys) {  					if (!curves.ContainsKey (cPep.Peptide))  						curves.Add (cPep.Peptide' new MaxFlowElutionCurve (nbProductsToKeep));  					//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);  					curves [cPep.Peptide].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  					curves [cPep.Peptide].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (timeInMilliSeconds));  				}  			}  			else  				nbIgnoredSpectrum++;  			if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  				break;  		}  		//End of foreach query  		if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  			if (nbIgnoredSpectrum > 0)  				Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  			foreach (Peptide cPep in curves.Keys)  				curves [cPep].Compute ();  			Dictionary<Peptide' MaxFlowElutionCurve> curvesToKeep = new Dictionary<Peptide' MaxFlowElutionCurve> ();  			foreach (Peptide cPep in curves.Keys)  				if (curves [cPep].eCurvePerMs.Area > 0)  					curvesToKeep.Add (cPep' curves [cPep]);  			if (curvesToKeep.Count > 0)  				DicOfCurveErrors.Add (curvesToKeep' cumulError);  		}  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The following statement contains a magic number: if (validProducts) {  	double cumulError = 0;  	Dictionary<Peptide' MaxFlowElutionCurve> curves = new Dictionary<Peptide' MaxFlowElutionCurve> ();  	foreach (Query query in mixedPrecursor.Queries) {  		double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  		//                      double overFlow = 0;  		double underFlow = 0;  		double percentError = 0;  		Dictionary<PeptideSpectrumMatch' SolvedResult> finalRatios = SolveFromFragmentScore (nbProductsToKeep' precision' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' query' out underFlow' out percentError' dbOptions.ConSole);  		cumulError += underFlow;  		// percentError;  		if (percentError < 0.5) {  			foreach (PeptideSpectrumMatch cPep in finalRatios.Keys) {  				if (!curves.ContainsKey (cPep.Peptide))  					curves.Add (cPep.Peptide' new MaxFlowElutionCurve (nbProductsToKeep));  				//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);  				curves [cPep.Peptide].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  				curves [cPep.Peptide].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (timeInMilliSeconds));  			}  		}  		else  			nbIgnoredSpectrum++;  		if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  			break;  	}  	//End of foreach query  	if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  		if (nbIgnoredSpectrum > 0)  			Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  		foreach (Peptide cPep in curves.Keys)  			curves [cPep].Compute ();  		Dictionary<Peptide' MaxFlowElutionCurve> curvesToKeep = new Dictionary<Peptide' MaxFlowElutionCurve> ();  		foreach (Peptide cPep in curves.Keys)  			if (curves [cPep].eCurvePerMs.Area > 0)  				curvesToKeep.Add (cPep' curves [cPep]);  		if (curvesToKeep.Count > 0)  			DicOfCurveErrors.Add (curvesToKeep' cumulError);  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The following statement contains a magic number: if (validProducts) {  	double cumulError = 0;  	Dictionary<Peptide' MaxFlowElutionCurve> curves = new Dictionary<Peptide' MaxFlowElutionCurve> ();  	foreach (Query query in mixedPrecursor.Queries) {  		double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  		//                      double overFlow = 0;  		double underFlow = 0;  		double percentError = 0;  		Dictionary<PeptideSpectrumMatch' SolvedResult> finalRatios = SolveFromFragmentScore (nbProductsToKeep' precision' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' query' out underFlow' out percentError' dbOptions.ConSole);  		cumulError += underFlow;  		// percentError;  		if (percentError < 0.5) {  			foreach (PeptideSpectrumMatch cPep in finalRatios.Keys) {  				if (!curves.ContainsKey (cPep.Peptide))  					curves.Add (cPep.Peptide' new MaxFlowElutionCurve (nbProductsToKeep));  				//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);  				curves [cPep.Peptide].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  				curves [cPep.Peptide].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (timeInMilliSeconds));  			}  		}  		else  			nbIgnoredSpectrum++;  		if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  			break;  	}  	//End of foreach query  	if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  		if (nbIgnoredSpectrum > 0)  			Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  		foreach (Peptide cPep in curves.Keys)  			curves [cPep].Compute ();  		Dictionary<Peptide' MaxFlowElutionCurve> curvesToKeep = new Dictionary<Peptide' MaxFlowElutionCurve> ();  		foreach (Peptide cPep in curves.Keys)  			if (curves [cPep].eCurvePerMs.Area > 0)  				curvesToKeep.Add (cPep' curves [cPep]);  		if (curvesToKeep.Count > 0)  			DicOfCurveErrors.Add (curvesToKeep' cumulError);  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The following statement contains a magic number: if (validProducts) {  	double cumulError = 0;  	Dictionary<Peptide' MaxFlowElutionCurve> curves = new Dictionary<Peptide' MaxFlowElutionCurve> ();  	foreach (Query query in mixedPrecursor.Queries) {  		double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  		//                      double overFlow = 0;  		double underFlow = 0;  		double percentError = 0;  		Dictionary<PeptideSpectrumMatch' SolvedResult> finalRatios = SolveFromFragmentScore (nbProductsToKeep' precision' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' query' out underFlow' out percentError' dbOptions.ConSole);  		cumulError += underFlow;  		// percentError;  		if (percentError < 0.5) {  			foreach (PeptideSpectrumMatch cPep in finalRatios.Keys) {  				if (!curves.ContainsKey (cPep.Peptide))  					curves.Add (cPep.Peptide' new MaxFlowElutionCurve (nbProductsToKeep));  				//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);  				curves [cPep.Peptide].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  				curves [cPep.Peptide].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (timeInMilliSeconds));  			}  		}  		else  			nbIgnoredSpectrum++;  		if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  			break;  	}  	//End of foreach query  	if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  		if (nbIgnoredSpectrum > 0)  			Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  		foreach (Peptide cPep in curves.Keys)  			curves [cPep].Compute ();  		Dictionary<Peptide' MaxFlowElutionCurve> curvesToKeep = new Dictionary<Peptide' MaxFlowElutionCurve> ();  		foreach (Peptide cPep in curves.Keys)  			if (curves [cPep].eCurvePerMs.Area > 0)  				curvesToKeep.Add (cPep' curves [cPep]);  		if (curvesToKeep.Count > 0)  			DicOfCurveErrors.Add (curvesToKeep' cumulError);  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The following statement contains a magic number: if (validProducts) {  	double cumulError = 0;  	Dictionary<Peptide' MaxFlowElutionCurve> curves = new Dictionary<Peptide' MaxFlowElutionCurve> ();  	foreach (Query query in mixedPrecursor.Queries) {  		double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  		//                      double overFlow = 0;  		double underFlow = 0;  		double percentError = 0;  		Dictionary<PeptideSpectrumMatch' SolvedResult> finalRatios = SolveFromFragmentScore (nbProductsToKeep' precision' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' query' out underFlow' out percentError' dbOptions.ConSole);  		cumulError += underFlow;  		// percentError;  		if (percentError < 0.5) {  			foreach (PeptideSpectrumMatch cPep in finalRatios.Keys) {  				if (!curves.ContainsKey (cPep.Peptide))  					curves.Add (cPep.Peptide' new MaxFlowElutionCurve (nbProductsToKeep));  				//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);  				curves [cPep.Peptide].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  				curves [cPep.Peptide].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (timeInMilliSeconds));  			}  		}  		else  			nbIgnoredSpectrum++;  		if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  			break;  	}  	//End of foreach query  	if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  		if (nbIgnoredSpectrum > 0)  			Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  		foreach (Peptide cPep in curves.Keys)  			curves [cPep].Compute ();  		Dictionary<Peptide' MaxFlowElutionCurve> curvesToKeep = new Dictionary<Peptide' MaxFlowElutionCurve> ();  		foreach (Peptide cPep in curves.Keys)  			if (curves [cPep].eCurvePerMs.Area > 0)  				curvesToKeep.Add (cPep' curves [cPep]);  		if (curvesToKeep.Count > 0)  			DicOfCurveErrors.Add (curvesToKeep' cumulError);  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The following statement contains a magic number: if (validProducts) {  	double cumulError = 0;  	Dictionary<Peptide' MaxFlowElutionCurve> curves = new Dictionary<Peptide' MaxFlowElutionCurve> ();  	foreach (Query query in mixedPrecursor.Queries) {  		double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  		//                      double overFlow = 0;  		double underFlow = 0;  		double percentError = 0;  		Dictionary<PeptideSpectrumMatch' SolvedResult> finalRatios = SolveFromFragmentScore (nbProductsToKeep' precision' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' query' out underFlow' out percentError' dbOptions.ConSole);  		cumulError += underFlow;  		// percentError;  		if (percentError < 0.5) {  			foreach (PeptideSpectrumMatch cPep in finalRatios.Keys) {  				if (!curves.ContainsKey (cPep.Peptide))  					curves.Add (cPep.Peptide' new MaxFlowElutionCurve (nbProductsToKeep));  				//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);  				curves [cPep.Peptide].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  				curves [cPep.Peptide].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (timeInMilliSeconds));  			}  		}  		else  			nbIgnoredSpectrum++;  		if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  			break;  	}  	//End of foreach query  	if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  		if (nbIgnoredSpectrum > 0)  			Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  		foreach (Peptide cPep in curves.Keys)  			curves [cPep].Compute ();  		Dictionary<Peptide' MaxFlowElutionCurve> curvesToKeep = new Dictionary<Peptide' MaxFlowElutionCurve> ();  		foreach (Peptide cPep in curves.Keys)  			if (curves [cPep].eCurvePerMs.Area > 0)  				curvesToKeep.Add (cPep' curves [cPep]);  		if (curvesToKeep.Count > 0)  			DicOfCurveErrors.Add (curvesToKeep' cumulError);  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The following statement contains a magic number: foreach (Query query in mixedPrecursor.Queries) {  	double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  	//                      double overFlow = 0;  	double underFlow = 0;  	double percentError = 0;  	Dictionary<PeptideSpectrumMatch' SolvedResult> finalRatios = SolveFromFragmentScore (nbProductsToKeep' precision' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' query' out underFlow' out percentError' dbOptions.ConSole);  	cumulError += underFlow;  	// percentError;  	if (percentError < 0.5) {  		foreach (PeptideSpectrumMatch cPep in finalRatios.Keys) {  			if (!curves.ContainsKey (cPep.Peptide))  				curves.Add (cPep.Peptide' new MaxFlowElutionCurve (nbProductsToKeep));  			//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);  			curves [cPep.Peptide].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  			curves [cPep.Peptide].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (timeInMilliSeconds));  		}  	}  	else  		nbIgnoredSpectrum++;  	if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  		break;  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The following statement contains a magic number: foreach (Query query in mixedPrecursor.Queries) {  	double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  	//                      double overFlow = 0;  	double underFlow = 0;  	double percentError = 0;  	Dictionary<PeptideSpectrumMatch' SolvedResult> finalRatios = SolveFromFragmentScore (nbProductsToKeep' precision' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' query' out underFlow' out percentError' dbOptions.ConSole);  	cumulError += underFlow;  	// percentError;  	if (percentError < 0.5) {  		foreach (PeptideSpectrumMatch cPep in finalRatios.Keys) {  			if (!curves.ContainsKey (cPep.Peptide))  				curves.Add (cPep.Peptide' new MaxFlowElutionCurve (nbProductsToKeep));  			//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);  			curves [cPep.Peptide].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  			curves [cPep.Peptide].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (timeInMilliSeconds));  		}  	}  	else  		nbIgnoredSpectrum++;  	if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  		break;  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The following statement contains a magic number: foreach (Query query in mixedPrecursor.Queries) {  	double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  	//                      double overFlow = 0;  	double underFlow = 0;  	double percentError = 0;  	Dictionary<PeptideSpectrumMatch' SolvedResult> finalRatios = SolveFromFragmentScore (nbProductsToKeep' precision' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' query' out underFlow' out percentError' dbOptions.ConSole);  	cumulError += underFlow;  	// percentError;  	if (percentError < 0.5) {  		foreach (PeptideSpectrumMatch cPep in finalRatios.Keys) {  			if (!curves.ContainsKey (cPep.Peptide))  				curves.Add (cPep.Peptide' new MaxFlowElutionCurve (nbProductsToKeep));  			//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);  			curves [cPep.Peptide].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  			curves [cPep.Peptide].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (timeInMilliSeconds));  		}  	}  	else  		nbIgnoredSpectrum++;  	if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  		break;  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The following statement contains a magic number: foreach (Query query in mixedPrecursor.Queries) {  	double timeInMilliSeconds = query.spectrum.RetentionTimeInMin * 60.0 * 1000.0;  	//                      double overFlow = 0;  	double underFlow = 0;  	double percentError = 0;  	Dictionary<PeptideSpectrumMatch' SolvedResult> finalRatios = SolveFromFragmentScore (nbProductsToKeep' precision' query.spectrum.Peaks' dbOptions.productMassTolerance' mixedPrecursor.eCurveIntensityPerMS.GetLocalArea (timeInMilliSeconds' timeInMilliSeconds + query.spectrum.InjectionTime)' query' out underFlow' out percentError' dbOptions.ConSole);  	cumulError += underFlow;  	// percentError;  	if (percentError < 0.5) {  		foreach (PeptideSpectrumMatch cPep in finalRatios.Keys) {  			if (!curves.ContainsKey (cPep.Peptide))  				curves.Add (cPep.Peptide' new MaxFlowElutionCurve (nbProductsToKeep));  			//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);  			curves [cPep.Peptide].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  			curves [cPep.Peptide].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (timeInMilliSeconds));  		}  	}  	else  		nbIgnoredSpectrum++;  	if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  		break;  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The following statement contains a magic number: if (percentError < 0.5) {  	foreach (PeptideSpectrumMatch cPep in finalRatios.Keys) {  		if (!curves.ContainsKey (cPep.Peptide))  			curves.Add (cPep.Peptide' new MaxFlowElutionCurve (nbProductsToKeep));  		//curves[cPep].AddPoint(timeInMilliSeconds' finalRatios[cPep].Ratio * query.spectrum.PrecursorIntensityPerMilliSecond);  		curves [cPep.Peptide].eCurveCount.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityCount.InterpolateIntensity (timeInMilliSeconds));  		curves [cPep.Peptide].eCurvePerMs.AddPoint (timeInMilliSeconds' finalRatios [cPep].Ratio * mixedPrecursor.eCurveIntensityPerMS.InterpolateIntensity (timeInMilliSeconds));  	}  }  else  	nbIgnoredSpectrum++;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The following statement contains a magic number: if (nbIgnoredSpectrum * 2 > mixedPrecursor.Queries.Count)  	break;  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,GetRatiosNoSpikes,The following statement contains a magic number: if (nbIgnoredSpectrum * 2 < mixedPrecursor.Queries.Count) {  	if (nbIgnoredSpectrum > 0)  		Console.WriteLine ("Ignored Spectrum : " + nbIgnoredSpectrum + " / " + mixedPrecursor.Queries.Count);  	foreach (Peptide cPep in curves.Keys)  		curves [cPep].Compute ();  	Dictionary<Peptide' MaxFlowElutionCurve> curvesToKeep = new Dictionary<Peptide' MaxFlowElutionCurve> ();  	foreach (Peptide cPep in curves.Keys)  		if (curves [cPep].eCurvePerMs.Area > 0)  			curvesToKeep.Add (cPep' curves [cPep]);  	if (curvesToKeep.Count > 0)  		DicOfCurveErrors.Add (curvesToKeep' cumulError);  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ComputePeptideRatios,The following statement contains a magic number: while (nbRun > 0) {  	nbRun--;  	dicOfCurves = lastDicOfCurves;  	//Normalize already computed correlation factors for the remaning curves (sum must equal 1)  	double sumOfCorr = 0.0;  	foreach (Dictionary<Peptide' MaxFlowElutionCurve> dicOfCurve in dicOfCurves.Keys)  		sumOfCorr += dicOfCorrelations [dicOfCurve];  	foreach (Dictionary<Peptide' MaxFlowElutionCurve> dicOfCurve in dicOfCurves.Keys)  		dicOfCorrelations [dicOfCurve] /= sumOfCorr;  	//Compute average from weighted curves  	Dictionary<Peptide' double> average = new Dictionary<Peptide' double> ();  	foreach (Dictionary<Peptide' MaxFlowElutionCurve> dicOfCurve in dicOfCurves.Keys) {  		Dictionary<Peptide' double> areas = MixedPrecursor.GetAreas (dicOfCurve);  		foreach (Peptide cPep in areas.Keys) {  			if (!average.ContainsKey (cPep))  				average.Add (cPep' 0);  			average [cPep] += areas [cPep] * dicOfCorrelations [dicOfCurve];  		}  	}  	//Compute correlation between average and curves  	List<double> corrs = new List<double> ();  	foreach (Dictionary<Peptide' MaxFlowElutionCurve> dicOfCurve in dicOfCurves.Keys) {  		Dictionary<Peptide' double> elution = new Dictionary<Peptide' double> ();  		foreach (Peptide cPep in average.Keys)  			if (dicOfCurve.ContainsKey (cPep))  				elution.Add (cPep' dicOfCurve [cPep].eCurvePerMs.Area);  			else  				elution.Add (cPep' 0);  		double tmp = 1.0;  		if (elution.Count > 1)  			tmp = Math.Abs (MathNet.Numerics.Statistics.Correlation.Pearson (average.Values' elution.Values));  		dicOfCorrelations [dicOfCurve] = tmp;  		corrs.Add (tmp);  	}  	//Remove worst curves                  	if (corrs.Count > 1) {  		Dictionary<Dictionary<Peptide' MaxFlowElutionCurve>' double> dicOfCurves2 = new Dictionary<Dictionary<Peptide' MaxFlowElutionCurve>' double> ();  		double medianCorr = MathNet.Numerics.Statistics.Statistics.Median (corrs);  		double maxCorr = medianCorr + 0.5 * MathNet.Numerics.Statistics.Statistics.Variance (corrs);  		foreach (Dictionary<Peptide' MaxFlowElutionCurve> dic in dicOfCurves.Keys)  			if (dicOfCorrelations [dic] <= maxCorr)  				dicOfCurves2.Add (dic' dicOfCurves [dic]);  		lastDicOfCurves = dicOfCurves2;  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ComputePeptideRatios,The following statement contains a magic number: if (corrs.Count > 1) {  	Dictionary<Dictionary<Peptide' MaxFlowElutionCurve>' double> dicOfCurves2 = new Dictionary<Dictionary<Peptide' MaxFlowElutionCurve>' double> ();  	double medianCorr = MathNet.Numerics.Statistics.Statistics.Median (corrs);  	double maxCorr = medianCorr + 0.5 * MathNet.Numerics.Statistics.Statistics.Variance (corrs);  	foreach (Dictionary<Peptide' MaxFlowElutionCurve> dic in dicOfCurves.Keys)  		if (dicOfCorrelations [dic] <= maxCorr)  			dicOfCurves2.Add (dic' dicOfCurves [dic]);  	lastDicOfCurves = dicOfCurves2;  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,SolveFromSpectrumBKP,The following statement contains a magic number: switch (returnType) {  case 0:  	result = GetResultList (solutions [0]' precision' underFlow' sumOfIntensities);  	break;  case 1:  	result = GetResultList (solutions [1]' precision' underFlow' sumOfIntensities);  	break;  case 2:  	List<double> tmpAverage = new List<double> ();  	foreach (double val in average)  		tmpAverage.Add (val);  	result = GetResultList (tmpAverage' precision' underFlow' sumOfIntensities);  	break;  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,ComputeMaxFlow,The following statement contains a magic number: while (overError >= 1 && iterSize < 10000)//anything less than 1 is an acceptable solution   {  	for (int index = 0; index < bestIndexes.Length; index++)  		bestIndexes [index] = -1;  	for (int i = 0; i < spikedMatches.Count; i++) {  		if (localFlows [i] > 0) {  			localFlows [i] -= iterSize;  			virtualSpectrum = BuildVirtualSpectrum (spikedMatches' localFlows' mixedFragDic);  			double tmpErrorMinus = MaxFlowHelper.ComputeUnderflow (virtualSpectrum' mixedFragDic);  			double tmpErrorPlus = MaxFlowHelper.ComputeOverflow (virtualSpectrum' mixedFragDic);  			double tmpFlowRate = Math.Abs (overError - tmpErrorPlus);  			double underDiff = Math.Abs (underError - tmpErrorMinus);  			if (underDiff >= 1)  				tmpFlowRate /= underDiff;  			bestIndexes [i] = tmpFlowRate;  			localFlows [i] += iterSize;  		}  	}  	//Pick pseudo randomly best index  	double worstFlowRate = 0.0;  	for (int index = 0; index < bestIndexes.Length; index++)  		if (bestIndexes [index] > worstFlowRate) {  			worstFlowRate = bestIndexes [index];  		}  	if (worstFlowRate > 0) {  		int nbMatching = 0;  		for (int index = 0; index < bestIndexes.Length; index++)  			if (bestIndexes [index] >= worstFlowRate)  				nbMatching++;  		int iterChoice = rnd.Next (0' nbMatching - 1);  		int iterNb = 0;  		for (int index = 0; index < bestIndexes.Length; index++)  			if (bestIndexes [index] >= worstFlowRate) {  				if (iterChoice == iterNb)  					localFlows [index] -= iterSize;  				iterNb++;  			}  		iterSize = 1;  	}  	else  		iterSize++;  	virtualSpectrum = BuildVirtualSpectrum (spikedMatches' localFlows' mixedFragDic);  	overError = MaxFlowHelper.ComputeOverflow (virtualSpectrum' mixedFragDic);  	underError = MaxFlowHelper.ComputeUnderflow (virtualSpectrum' mixedFragDic);  	if (overError + underError < bestOverallError) {  		bestLocalFlows = new List<long> (localFlows);  		bestOverallError = overError + underError;  	}  }  
Magic Number,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,FindLocalMaximumFlow,The following statement contains a magic number: maxCumul *= 10000000;  
Missing Default,PeptidAce.Iso.Methods,PositionnalIsomerSolverNoSpike,C:\repos\olivierlizotte_Iso-PeptidAce\Methods\PositionnalIsomerSolverNoSpike.cs,SolveFromSpectrumBKP,The following switch statement is missing a default case: switch (returnType) {  case 0:  	result = GetResultList (solutions [0]' precision' underFlow' sumOfIntensities);  	break;  case 1:  	result = GetResultList (solutions [1]' precision' underFlow' sumOfIntensities);  	break;  case 2:  	List<double> tmpAverage = new List<double> ();  	foreach (double val in average)  		tmpAverage.Add (val);  	result = GetResultList (tmpAverage' precision' underFlow' sumOfIntensities);  	break;  }  
