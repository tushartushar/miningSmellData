Implementation smell,Namespace,Class,File,Method,Description
Long Method,StackExchange.Exceptional,AspNetExtensions,C:\research\architectureSmells\repos\NickCraver_StackExchange.Exceptional\src\StackExchange.Exceptional\AspNetExtensions.cs,SetProperties,The method has 125 lines of code.
Complex Method,StackExchange.Exceptional,AspNetExtensions,C:\research\architectureSmells\repos\NickCraver_StackExchange.Exceptional\src\StackExchange.Exceptional\AspNetExtensions.cs,SetProperties,Cyclomatic complexity of the method is 15
Complex Method,StackExchange.Exceptional,EmailSettingsConfig,C:\research\architectureSmells\repos\NickCraver_StackExchange.Exceptional\src\StackExchange.Exceptional\ConfigSettings.cs,Populate,Cyclomatic complexity of the method is 11
Complex Method,StackExchange.Exceptional,ExceptionalAsyncHandler,C:\research\architectureSmells\repos\NickCraver_StackExchange.Exceptional\src\StackExchange.Exceptional\ExceptionalAsyncHandler.cs,ProcessRequestAsync,Cyclomatic complexity of the method is 14
Long Parameter List,StackExchange.Exceptional,AspNetExtensions,C:\research\architectureSmells\repos\NickCraver_StackExchange.Exceptional\src\StackExchange.Exceptional\AspNetExtensions.cs,Log,The method has 6 parameters. Parameters: ex' context' category' rollupPerServer' customData' applicationName
Long Parameter List,StackExchange.Exceptional,AspNetExtensions,C:\research\architectureSmells\repos\NickCraver_StackExchange.Exceptional\src\StackExchange.Exceptional\AspNetExtensions.cs,LogAsync,The method has 6 parameters. Parameters: ex' context' category' rollupPerServer' customData' applicationName
Long Statement,StackExchange.Exceptional,AspNetExtensions,C:\research\architectureSmells\repos\NickCraver_StackExchange.Exceptional\src\StackExchange.Exceptional\AspNetExtensions.cs,SetProperties,The length of the statement  "            NameValueCollection TryGetCollection(Func<HttpRequest' NameValueCollection> getter' Func<string' bool> shouldRecord = null) " is 123.
Long Statement,StackExchange.Exceptional,AspNetExtensions,C:\research\architectureSmells\repos\NickCraver_StackExchange.Exceptional\src\StackExchange.Exceptional\AspNetExtensions.cs,SetProperties,The length of the statement  "            error.UrlPath = request.ServerVariables?["URL"]; // Legacy compatibility' this may be the same as request.Url.AbsolutePath; " is 123.
Long Statement,StackExchange.Exceptional,ErrorStoreSettings,C:\research\architectureSmells\repos\NickCraver_StackExchange.Exceptional\src\StackExchange.Exceptional\ConfigSettings.cs,Populate,The length of the statement  "                        ?? throw new ConfigurationErrorsException("A connection string was not found for the connection string name provided: " + ConnectionStringName); " is 144.
Long Statement,StackExchange.Exceptional,ExceptionalAsyncHandler,C:\research\architectureSmells\repos\NickCraver_StackExchange.Exceptional\src\StackExchange.Exceptional\ExceptionalAsyncHandler.cs,ProcessRequestAsync,The length of the statement  "            string TrimEnd(string s' string value) => s.EndsWith(value) ? s.Remove(s.LastIndexOf(value' StringComparison.Ordinal)) : s; " is 123.
Long Statement,StackExchange.Exceptional,ExceptionalAsyncHandler,C:\research\architectureSmells\repos\NickCraver_StackExchange.Exceptional\src\StackExchange.Exceptional\ExceptionalAsyncHandler.cs,ProcessRequestAsync,The length of the statement  "                            string actualUrl = Uri.TryCreate(Url' UriKind.RelativeOrAbsolute' out var urlResult) && urlResult.IsAbsoluteUri ? urlResult.AbsolutePath : Url; " is 143.
Long Statement,StackExchange.Exceptional,ExceptionalModule,C:\research\architectureSmells\repos\NickCraver_StackExchange.Exceptional\src\StackExchange.Exceptional\ExceptionalModule.cs,HandleRequestAsync,The length of the statement  "            var page = new HandlerFactory().GetHandler(context' context.Request.RequestType' context.Request.Url.ToString()' context.Request.PathInfo); " is 139.
Empty Catch Block,StackExchange.Exceptional,ExceptionalAsyncHandler,C:\research\architectureSmells\repos\NickCraver_StackExchange.Exceptional\src\StackExchange.Exceptional\ExceptionalAsyncHandler.cs,ProcessRequestAsync,The method has an empty catch block.
Magic Number,StackExchange.Exceptional,ExceptionalAsyncHandler,C:\research\architectureSmells\repos\NickCraver_StackExchange.Exceptional\src\StackExchange.Exceptional\ExceptionalAsyncHandler.cs,ProcessRequestAsync,The following statement contains a magic number: switch (context.Request.HttpMethod)              {                  case "POST":                      errorGuid = context.Request.Form["guid"] ?? string.Empty;                      switch (resource)                      {                          case KnownRoutes.Delete:                              JsonResult(await store.DeleteAsync(errorGuid.ToGuid()).ConfigureAwait(false));                              return;                          case KnownRoutes.DeleteAll:                              JsonResult(await store.DeleteAllAsync().ConfigureAwait(false));                              return;                          case KnownRoutes.DeleteList:                              JsonResult(await store.DeleteAsync(GetFormGuids()).ConfigureAwait(false));                              return;                          case KnownRoutes.Protect:                              JsonResult(await store.ProtectAsync(errorGuid.ToGuid()).ConfigureAwait(false));                              return;                          case KnownRoutes.ProtectList:                              JsonResult(await store.ProtectAsync(GetFormGuids()).ConfigureAwait(false));                              return;                          default:                              Content("Invalid POST Request");                              return;                      }                  case "GET":                      errorGuid = context.Request.QueryString["guid"] ?? string.Empty;                      switch (resource)                      {                          case KnownRoutes.Info:                              var guid = errorGuid.ToGuid();                              var error = errorGuid.HasValue() ? await store.GetAsync(guid).ConfigureAwait(false) : null;                              Page(new ErrorDetailPage(error' settings' store' TrimEnd(context.Request.Path' "/info")' guid));                              return;                          case KnownRoutes.Json:                              context.Response.ContentType = "application/json";                              DateTime? since = long.TryParse(context.Request["since"]' out long sinceLong)                                       ? new DateTime(1970' 1' 1' 0' 0' 0).AddSeconds(sinceLong)                                       : (DateTime?)null;                                var errors = await store.GetAllAsync().ConfigureAwait(false);                              if (since.HasValue)                              {                                  errors = errors.Where(e => e.CreationDate >= since).ToList();                              }                              serializer.Serialize(context.Response.Output' errors);                              return;                          case KnownRoutes.Css:                              Resource(Resources.BundleCss);                              return;                          case KnownRoutes.Js:                              Resource(Resources.BundleJs);                              return;                          case KnownRoutes.Test:                              throw new Exception("This is a test. Please disregard. If this were a real emergency' it'd have a different message.");                          default:                              context.Response.Cache.SetCacheability(HttpCacheability.NoCache);                              context.Response.Cache.SetNoStore();                              string actualUrl = Uri.TryCreate(Url' UriKind.RelativeOrAbsolute' out var urlResult) && urlResult.IsAbsoluteUri ? urlResult.AbsolutePath : Url;                              Page(new ErrorListPage(store' settings' actualUrl' await store.GetAllAsync().ConfigureAwait(false)));                              return;                      }                  default:                      Content("Unsupported request method: " + context.Request.HttpMethod);                      return;              }
