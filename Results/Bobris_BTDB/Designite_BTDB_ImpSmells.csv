Implementation smell,Namespace,Class,File,Method,Description
Long Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The method has 456 lines of code.
Long Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,SeekIndex,The method has 123 lines of code.
Long Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Find,The method has 125 lines of code.
Long Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Upsert,The method has 278 lines of code.
Long Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The method has 456 lines of code.
Long Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,SeekIndex,The method has 123 lines of code.
Long Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Find,The method has 122 lines of code.
Long Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Upsert,The method has 264 lines of code.
Long Method,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,EraseFromBranch,The method has 134 lines of code.
Long Method,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,Upsert,The method has 265 lines of code.
Long Method,BTDB.BTreeLib,SplitInserter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,Run,The method has 257 lines of code.
Long Method,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The method has 139 lines of code.
Long Method,BTDB.EventStore2Layer,EventSerializer,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,Create,The method has 132 lines of code.
Long Method,BTDB.EventStoreLayer,DictionaryTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateSave,The method has 101 lines of code.
Long Method,BTDB.EventStoreLayer,ReadOnlyEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The method has 152 lines of code.
Long Method,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadInfoAboutFiles,The method has 136 lines of code.
Long Method,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The method has 149 lines of code.
Long Method,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadTransactionLog,The method has 214 lines of code.
Long Method,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The method has 110 lines of code.
Long Method,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadInfoAboutFiles,The method has 108 lines of code.
Long Method,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadTransactionLog,The method has 183 lines of code.
Long Method,BTDB.KVDBLayer.BTreeMem,BTreeBranch,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,CreateOrUpdate,The method has 114 lines of code.
Long Method,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,The method has 131 lines of code.
Long Method,BTDB.KVDBLayer.BTree,BTreeBranch,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,CreateOrUpdate,The method has 114 lines of code.
Long Method,BTDB.KVDBLayer.BTree,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,CreateOrUpdate,The method has 153 lines of code.
Long Method,BTDB.ODBLayer,ODBIterator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,IterateHandler,The method has 155 lines of code.
Long Method,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The method has 142 lines of code.
Long Method,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The method has 274 lines of code.
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,AllocateNode,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRange,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetStartPosAndByte,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetStartPosAndByteSkipLeaf,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetEndPosAndByte,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,Cyclomatic complexity of the method is 63
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CalcIndex,Cyclomatic complexity of the method is 15
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,SeekIndex,Cyclomatic complexity of the method is 17
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,MoveNext,Cyclomatic complexity of the method is 10
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,MovePrevious,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,Cyclomatic complexity of the method is 13
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ReferenceAllChildren,Cyclomatic complexity of the method is 14
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Dereference,Cyclomatic complexity of the method is 16
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,FindExact,Cyclomatic complexity of the method is 12
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Find,Cyclomatic complexity of the method is 18
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,FindNearPosAndByte,Cyclomatic complexity of the method is 14
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,FindFirst,Cyclomatic complexity of the method is 10
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,FindLast,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushLeftMost,Cyclomatic complexity of the method is 11
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushRightMost,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Upsert,Cyclomatic complexity of the method is 22
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,StructureCheck,Cyclomatic complexity of the method is 10
Complex Method,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,IterateNodeInfo,Cyclomatic complexity of the method is 10
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRange,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetStartPosAndByte,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetStartPosAndByteSkipLeaf,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetEndPosAndByte,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,Cyclomatic complexity of the method is 63
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,CalcIndex,Cyclomatic complexity of the method is 15
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,SeekIndex,Cyclomatic complexity of the method is 17
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,MoveNext,Cyclomatic complexity of the method is 10
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,MovePrevious,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ExpandNode,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ReferenceAllChildren,Cyclomatic complexity of the method is 14
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Dereference,Cyclomatic complexity of the method is 16
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,FindExact,Cyclomatic complexity of the method is 10
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Find,Cyclomatic complexity of the method is 18
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,FindNearPosAndByte,Cyclomatic complexity of the method is 14
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,FindFirst,Cyclomatic complexity of the method is 10
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,FindLast,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushLeftMost,Cyclomatic complexity of the method is 11
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushRightMost,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Upsert,Cyclomatic complexity of the method is 18
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,StructureCheck,Cyclomatic complexity of the method is 10
Complex Method,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,IterateNodeInfo,Cyclomatic complexity of the method is 11
Complex Method,BTDB.ARTLib,Cursor12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\Cursor12.cs,KeyHasPrefix,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ARTLib,CursorV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\CursorV.cs,KeyHasPrefix,Cyclomatic complexity of the method is 8
Complex Method,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,ValueReplacer,Cyclomatic complexity of the method is 12
Complex Method,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,EraseFromBranch,Cyclomatic complexity of the method is 23
Complex Method,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,EraseFromLeaf,Cyclomatic complexity of the method is 8
Complex Method,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,FindExact,Cyclomatic complexity of the method is 13
Complex Method,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,Find,Cyclomatic complexity of the method is 12
Complex Method,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,FindFirst,Cyclomatic complexity of the method is 9
Complex Method,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,FindLastWithPrefix,Cyclomatic complexity of the method is 13
Complex Method,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,Upsert,Cyclomatic complexity of the method is 29
Complex Method,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,CalcCommonPrefix,Cyclomatic complexity of the method is 9
Complex Method,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,CalcCommonPrefix,Cyclomatic complexity of the method is 10
Complex Method,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,CalcCommonPrefix,Cyclomatic complexity of the method is 8
Complex Method,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,CalcCommonPrefixExcept,Cyclomatic complexity of the method is 11
Complex Method,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,KeyValueIterate,Cyclomatic complexity of the method is 8
Complex Method,BTDB.BTreeLib,SplitInserter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,Run,Cyclomatic complexity of the method is 25
Complex Method,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,IncrementInt64LE,Cyclomatic complexity of the method is 8
Complex Method,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,Cyclomatic complexity of the method is 9
Complex Method,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,Cyclomatic complexity of the method is 8
Complex Method,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,Cyclomatic complexity of the method is 9
Complex Method,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,Cyclomatic complexity of the method is 9
Complex Method,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,Cyclomatic complexity of the method is 8
Complex Method,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,Cyclomatic complexity of the method is 8
Complex Method,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,Cyclomatic complexity of the method is 15
Complex Method,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,Cyclomatic complexity of the method is 15
Complex Method,BTDB.ChunkCache,DiskChunkCache,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,LoadContent,Cyclomatic complexity of the method is 10
Complex Method,BTDB.ChunkCache,DiskChunkCache,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,CompactionCore,Cyclomatic complexity of the method is 11
Complex Method,BTDB.ChunkCache,DiskChunkCache,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,PreserveJustMostOftenUsed,Cyclomatic complexity of the method is 9
Complex Method,BTDB.EventStore2Layer,EventDeserializer,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventDeserializer.cs,ProcessMetadataLog,Cyclomatic complexity of the method is 17
Complex Method,BTDB.EventStore2Layer,EventSerializer,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,ProcessMetadataLog,Cyclomatic complexity of the method is 17
Complex Method,BTDB.EventStore2Layer,EventSerializer,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,Create,Cyclomatic complexity of the method is 28
Complex Method,BTDB.EventStore2Layer,EventSerializer,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,StoreNewDescriptors,Cyclomatic complexity of the method is 10
Complex Method,BTDB.EventStore2Layer,EventSerializer,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,MergeTypesByShapeAndStoreNew,Cyclomatic complexity of the method is 11
Complex Method,BTDB.EventStore2Layer,EventSerializer,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,StoreObject,Cyclomatic complexity of the method is 8
Complex Method,BTDB.EventStoreLayer,AppendingEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,SerializeIntoBuffer,Cyclomatic complexity of the method is 12
Complex Method,BTDB.EventStoreLayer,EnumTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,EnumTypeDescriptor,Cyclomatic complexity of the method is 8
Complex Method,BTDB.EventStoreLayer,EnumTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,UlongValueToStringFlags,Cyclomatic complexity of the method is 8
Complex Method,BTDB.EventStoreLayer,FullNameTypeMapper,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\FullNameTypeMapper.cs,ToType,Cyclomatic complexity of the method is 10
Complex Method,BTDB.EventStoreLayer,ObjectTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,CheckObjectTypeIsGoodDTO,Cyclomatic complexity of the method is 9
Complex Method,BTDB.EventStoreLayer,ObjectTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,BTDB.EventStoreLayer,ReadOnlyEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,Cyclomatic complexity of the method is 29
Complex Method,BTDB.EventStoreLayer,ReadOnlyEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,Process,Cyclomatic complexity of the method is 9
Complex Method,BTDB.EventStoreLayer,BuildFromTypeCtx,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,Create,Cyclomatic complexity of the method is 14
Complex Method,BTDB.EventStoreLayer,TypeSerializersMapping,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializersMapping.cs,LoadTypeDescriptors,Cyclomatic complexity of the method is 14
Complex Method,BTDB.EventStoreLayer,TypeSerializersMapping,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializersMapping.cs,StoreNewDescriptors,Cyclomatic complexity of the method is 11
Complex Method,BTDB.EventStoreLayer,DescriptorSerializerContext,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializersMapping.cs,StoreNewDescriptors,Cyclomatic complexity of the method is 10
Complex Method,BTDB.FieldHandler,DefaultFieldHandlerFactory,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\DefaultFieldHandlerFactory.cs,CreateFromName,Cyclomatic complexity of the method is 9
Complex Method,BTDB.FieldHandler,EnumFieldHandler,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\EnumFieldHandler.cs,SpecializeLoadForType,Cyclomatic complexity of the method is 8
Complex Method,BTDB.FieldHandler,EnumConfiguration,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\EnumFieldHandler.cs,EnumConfiguration,Cyclomatic complexity of the method is 10
Complex Method,BTDB.IL,EmitHelpers,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,ToSimpleName,Cyclomatic complexity of the method is 22
Complex Method,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,Cyclomatic complexity of the method is 12
Complex Method,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldelem,Cyclomatic complexity of the method is 11
Complex Method,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Stelem,Cyclomatic complexity of the method is 8
Complex Method,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ld,Cyclomatic complexity of the method is 10
Complex Method,BTDB.IOC,AsTraitImpl,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IOC\AsTraitImpl.cs,GetAsTypesFor,Cyclomatic complexity of the method is 8
Complex Method,BTDB.IOC,BuildContext,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IOC\BuildContext.cs,ResolveNeedBy,Cyclomatic complexity of the method is 16
Complex Method,BTDB.IOC,GenerationContext,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IOC\GenerationContext.cs,PushToILStack,Cyclomatic complexity of the method is 9
Complex Method,BTDB.IOC,GenerationContext,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IOC\GenerationContext.cs,GatherNeeds,Cyclomatic complexity of the method is 11
Complex Method,BTDB.IOC,MultiRegistration,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IOC\MultiRegistration.cs,Register,Cyclomatic complexity of the method is 9
Complex Method,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,Cyclomatic complexity of the method is 8
Complex Method,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,Cyclomatic complexity of the method is 20
Complex Method,BTDB.KVDBLayer,PtrLenList,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryExclude,Cyclomatic complexity of the method is 15
Complex Method,BTDB.KVDBLayer,PtrLenList,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryInclude,Cyclomatic complexity of the method is 14
Complex Method,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadInfoAboutFiles,Cyclomatic complexity of the method is 21
Complex Method,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadUsedFilesFromKeyIndex,Cyclomatic complexity of the method is 9
Complex Method,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadTransactionLog,Cyclomatic complexity of the method is 36
Complex Method,BTDB.KVDBLayer,Compactor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,Run,Cyclomatic complexity of the method is 9
Complex Method,BTDB.KVDBLayer,CompactorScheduler,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\CompactorScheduler.cs,RemoveCompactAction,Cyclomatic complexity of the method is 8
Complex Method,BTDB.KVDBLayer,FileCollectionWithFileInfos,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\FileCollectionWithFileInfos.cs,LoadInfoAboutFiles,Cyclomatic complexity of the method is 15
Complex Method,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadInfoAboutFiles,Cyclomatic complexity of the method is 21
Complex Method,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadUsedFilesFromKeyIndex,Cyclomatic complexity of the method is 9
Complex Method,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadTransactionLog,Cyclomatic complexity of the method is 31
Complex Method,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,Cyclomatic complexity of the method is 9
Complex Method,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,WriteCreateOrUpdateCommand,Cyclomatic complexity of the method is 8
Complex Method,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,Cyclomatic complexity of the method is 13
Complex Method,BTDB.KVDBLayer.BTreeMem,BTreeBranch,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,CreateOrUpdate,Cyclomatic complexity of the method is 13
Complex Method,BTDB.KVDBLayer.BTreeMem,BTreeBranch,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,EraseRange,Cyclomatic complexity of the method is 16
Complex Method,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,Cyclomatic complexity of the method is 8
Complex Method,BTDB.KVDBLayer.BTree,BTreeBranch,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,CreateOrUpdate,Cyclomatic complexity of the method is 13
Complex Method,BTDB.KVDBLayer.BTree,BTreeBranch,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,EraseRange,Cyclomatic complexity of the method is 16
Complex Method,BTDB.KVDBLayer.BTree,BTreeBranch,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,ReplaceValues,Cyclomatic complexity of the method is 9
Complex Method,BTDB.KVDBLayer.BTree,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,CreateOrUpdate,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ODBLayer,ObjectDBTransaction,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,Enumerate,Cyclomatic complexity of the method is 17
Complex Method,BTDB.ODBLayer,ObjectDBTransaction,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,Store,Cyclomatic complexity of the method is 11
Complex Method,BTDB.ODBLayer,ObjectDBTransaction,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,StoreAndFlush,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ODBLayer,ObjectDBTransaction,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,StoreIfNotInlined,Cyclomatic complexity of the method is 11
Complex Method,BTDB.ODBLayer,ObjectDBTransaction,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,Delete,Cyclomatic complexity of the method is 11
Complex Method,BTDB.ODBLayer,ObjectDBTransaction,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,Delete,Cyclomatic complexity of the method is 12
Complex Method,BTDB.ODBLayer,ODBDictionary<TKey;TValue>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,FreeContent,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ODBLayer,ODBDictionary<TKey;TValue>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,GetEnumerator,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ODBLayer,ODBDictionary<TKey;TValue>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,GetReverseEnumerator,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ODBLayer,ODBDictionary<TKey;TValue>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,GetIncreasingEnumerator,Cyclomatic complexity of the method is 11
Complex Method,BTDB.ODBLayer,ODBDictionary<TKey;TValue>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,GetDecreasingEnumerator,Cyclomatic complexity of the method is 11
Complex Method,BTDB.ODBLayer,ODBDictionary<TKey;TValue>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,RemoveRange,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ODBLayer,ODBDictionary<TKey;TValue>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,QuerySizeEnumerator,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ODBLayer,KeysCollection,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,GetEnumerator,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ODBLayer,ValuesCollection,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,GetEnumerator,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ODBLayer,AdvancedEnumerator<TKey;TValue>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,AdvancedEnumerator,Cyclomatic complexity of the method is 13
Complex Method,BTDB.ODBLayer,ODBIterator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,IterateRelation,Cyclomatic complexity of the method is 11
Complex Method,BTDB.ODBLayer,ODBIterator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,IterateDict,Cyclomatic complexity of the method is 12
Complex Method,BTDB.ODBLayer,ODBIterator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,IterateHandler,Cyclomatic complexity of the method is 34
Complex Method,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,Cyclomatic complexity of the method is 15
Complex Method,BTDB.ODBLayer,RelationDBManipulator<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,CompareAndRelease,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ODBLayer,RelationDBManipulator<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,CountWithProposition,Cyclomatic complexity of the method is 14
Complex Method,BTDB.ODBLayer,RelationAdvancedEnumerator<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,RelationAdvancedEnumerator,Cyclomatic complexity of the method is 14
Complex Method,BTDB.ODBLayer,RelationAdvancedOrderedEnumerator<TKey;TValue>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,RelationAdvancedOrderedEnumerator,Cyclomatic complexity of the method is 16
Complex Method,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateBytesToSKSaver,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateVersionInfoByReflection,Cyclomatic complexity of the method is 11
Complex Method,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateLoader,Cyclomatic complexity of the method is 13
Complex Method,BTDB.ODBLayer,RelationVersionInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationVersionInfo.cs,CreateSecondaryKeyInfo,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ODBLayer,RelationVersionInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationVersionInfo.cs,Equal,Cyclomatic complexity of the method is 11
Complex Method,BTDB.ODBLayer,TableFieldInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableFieldInfo.cs,Equal,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ODBLayer,TableInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateInitializer,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ODBLayer,TableInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,Cyclomatic complexity of the method is 13
Complex Method,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,OnReceive,Cyclomatic complexity of the method is 9
Complex Method,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,Cyclomatic complexity of the method is 14
Complex Method,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,Cyclomatic complexity of the method is 22
Complex Method,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibility,Cyclomatic complexity of the method is 12
Complex Method,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibilityIgnoringName,Cyclomatic complexity of the method is 20
Complex Method,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,WriteObjectForServer,Cyclomatic complexity of the method is 8
Complex Method,BTDB.Service,Client,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\TcpipServer.cs,ReceiveBody,Cyclomatic complexity of the method is 8
Complex Method,BTDB.Service,TypeInf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\TypeInf.cs,TypeInf,Cyclomatic complexity of the method is 15
Complex Method,BTDB.Service,TypeInf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\TypeInf.cs,IsMethodSupported,Cyclomatic complexity of the method is 8
Complex Method,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,Cyclomatic complexity of the method is 10
Complex Method,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,Cyclomatic complexity of the method is 15
Complex Method,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,Cyclomatic complexity of the method is 11
Complex Method,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,Cyclomatic complexity of the method is 19
Complex Method,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadString,Cyclomatic complexity of the method is 9
Long Parameter List,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The method has 8 parameters. Parameters: canBeInplace' node' leftPos' leftByte' leftNode' rightPos' rightByte' rightNode
Long Parameter List,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The method has 8 parameters. Parameters: canBeInplace' node' leftPos' leftByte' leftNode' rightPos' rightByte' rightNode
Long Parameter List,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,EraseFromBranch,The method has 5 parameters. Parameters: node' leftPos' leftChild' rightPos' rightChild
Long Parameter List,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,CalcCommonPrefix,The method has 5 parameters. Parameters: nodePtr' startIdx' endIdx' keyPrefix' keySuffix
Long Parameter List,BTDB.Buffer,BitArrayManipulation,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,CompareByteArray,The method has 6 parameters. Parameters: a1' o1' l1' a2' o2' l2
Long Parameter List,BTDB.EventStore2Layer,PlaceHolderDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStore2Layer\PlaceHolderDescriptor.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushCtx' pushDescriptor' targetType
Long Parameter List,BTDB.EventStore2Layer,PlaceHolderDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStore2Layer\PlaceHolderDescriptor.cs,GenerateSave,The method has 5 parameters. Parameters: ilGenerator' pushWriter' pushCtx' pushValue' valueType
Long Parameter List,BTDB.EventStoreLayer,AppendingEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,SerializeIntoBuffer,The method has 7 parameters. Parameters: metadata' events' startOffset' serializerContext' blockType' lenWithoutEndPadding' block
Long Parameter List,BTDB.EventStoreLayer,ByteArrayTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ByteArrayTypeDescriptor.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushCtx' pushDescriptor' targetType
Long Parameter List,BTDB.EventStoreLayer,ByteArrayTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ByteArrayTypeDescriptor.cs,GenerateSave,The method has 5 parameters. Parameters: ilGenerator' pushWriter' pushCtx' pushValue' valueType
Long Parameter List,BTDB.EventStoreLayer,DictionaryTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushCtx' pushDescriptor' targetType
Long Parameter List,BTDB.EventStoreLayer,DictionaryTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateSave,The method has 5 parameters. Parameters: ilGenerator' pushWriter' pushCtx' pushValue' saveType
Long Parameter List,BTDB.EventStoreLayer,EnumTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,EnumTypeDescriptor,The method has 6 parameters. Parameters: typeSerializers' type' name' signed' flags' pairs
Long Parameter List,BTDB.EventStoreLayer,EnumTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushCtx' pushDescriptor' targetType
Long Parameter List,BTDB.EventStoreLayer,EnumTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,GenerateSave,The method has 5 parameters. Parameters: ilGenerator' pushWriter' pushCtx' pushValue' valueType
Long Parameter List,BTDB.EventStoreLayer,ITypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ITypeDescriptor.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushCtx' pushDescriptor' targetType
Long Parameter List,BTDB.EventStoreLayer,ITypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ITypeDescriptor.cs,GenerateSave,The method has 5 parameters. Parameters: ilGenerator' pushWriter' pushCtx' pushValue' valueType
Long Parameter List,BTDB.EventStoreLayer,ListTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushCtx' pushDescriptor' targetType
Long Parameter List,BTDB.EventStoreLayer,ListTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateSave,The method has 5 parameters. Parameters: ilGenerator' pushWriter' pushCtx' pushValue' valueType
Long Parameter List,BTDB.EventStoreLayer,NullableTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\NullableTypeDescriptor.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushCtx' pushDescriptor' targetType
Long Parameter List,BTDB.EventStoreLayer,NullableTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\NullableTypeDescriptor.cs,GenerateSave,The method has 5 parameters. Parameters: ilGenerator' pushWriter' pushCtx' pushValue' valueType
Long Parameter List,BTDB.EventStoreLayer,ObjectTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushCtx' pushDescriptor' targetType
Long Parameter List,BTDB.EventStoreLayer,ObjectTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,GenerateSave,The method has 5 parameters. Parameters: ilGenerator' pushWriter' pushCtx' pushValue' valueType
Long Parameter List,BTDB.EventStoreLayer,SimpleTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\SimpleTypeDescriptor.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushCtx' pushDescriptor' targetType
Long Parameter List,BTDB.EventStoreLayer,SimpleTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\SimpleTypeDescriptor.cs,GenerateSave,The method has 5 parameters. Parameters: ilGenerator' pushWriter' pushCtx' pushValue' valueType
Long Parameter List,BTDB.EventStoreLayer,TypeDescriptorExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeDescriptorExtensions.cs,GenerateSaveEx,The method has 6 parameters. Parameters: descriptor' ilGenerator' pushWriter' pushCtx' pushSubValue' subValueType
Long Parameter List,BTDB.EventStoreLayer,TypeDescriptorExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeDescriptorExtensions.cs,GenerateLoadEx,The method has 7 parameters. Parameters: descriptor' ilGenerator' pushReader' pushCtx' pushDescriptor' asType' convertorGenerator
Long Parameter List,BTDB.EventStoreLayer,TypeSerializersMapping,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializersMapping.cs,StoreObjectCore,The method has 5 parameters. Parameters: typeSerializers' writer' obj' infoForType' mapping
Long Parameter List,BTDB.EventStoreLayer,PlaceHolderDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializersMapping.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushCtx' pushDescriptor' targetType
Long Parameter List,BTDB.EventStoreLayer,PlaceHolderDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializersMapping.cs,GenerateSave,The method has 5 parameters. Parameters: ilGenerator' pushWriter' pushCtx' pushValue' valueType
Long Parameter List,BTDB.FieldHandler,BasicSerializersFactory,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\BasicSerializersFactory.cs,AddJustOrderable,The method has 5 parameters. Parameters: fh' name' readMethodInfo' skipMethodInfo' writeMethodInfo
Long Parameter List,BTDB.FieldHandler,BasicSerializersFactory,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\BasicSerializersFactory.cs,AddDescriptor,The method has 5 parameters. Parameters: des' name' readMethodInfo' skipMethodInfo' writeMethodInfo
Long Parameter List,BTDB.FieldHandler,BasicSerializersFactory,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\BasicSerializersFactory.cs,Add,The method has 6 parameters. Parameters: fh' des' name' readMethodInfo' skipMethodInfo' writeMethodInfo
Long Parameter List,BTDB.FieldHandler,DictionaryFieldHandler,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,DictionaryFieldHandler,The method has 5 parameters. Parameters: fieldHandlerFactory' typeConvertorGenerator' type' keySpecialized' valueSpecialized
Long Parameter List,BTDB.FieldHandler,Extensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\Extensions.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' fieldHandler' typeWanted' pushReaderOrCtx' typeConvertorGenerator
Long Parameter List,BTDB.IL.Caching,Method,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\Caching\CachingILDynamicType.cs,Method,The method has 5 parameters. Parameters: id' name' returns' parameters' methodAttributes
Long Parameter List,BTDB.IL,EmitHelpers,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateJumpIfEqual,The method has 5 parameters. Parameters: ilGenerator' type' jumpTo' loadLeft' loadRight
Long Parameter List,BTDB.IOC.CRegs,EnumerableImpl,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IOC\CRegs\EnumerableImpl.cs,EnumerableImpl,The method has 5 parameters. Parameters: key' type' resultType' firstBuildCtx' firstReg
Long Parameter List,BTDB.KVDBLayer,FileKeyIndex,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\FileKeyIndex.cs,FileKeyIndex,The method has 5 parameters. Parameters: reader' guid' withCommitUlong' modern' withUlongs
Long Parameter List,BTDB.KVDBLayer,FileKeyIndex,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\FileKeyIndex.cs,FileKeyIndex,The method has 8 parameters. Parameters: generation' guid' trLogFileId' trLogOffset' keyCount' commitUlong' compression' ulongs
Long Parameter List,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,WriteCreateOrUpdateCommand,The method has 6 parameters. Parameters: prefix' key' value' valueFileId' valueOfs' valueSize
Long Parameter List,BTDB.ODBLayer,ConcurrentDictionaryExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ConcurrentDictionaryExtensions.cs,GetOrAdd,The method has 5 parameters. Parameters: dictionary' key' valueFactory' arg1' arg2
Long Parameter List,BTDB.ODBLayer,ConcurrentDictionaryExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ConcurrentDictionaryExtensions.cs,GetOrAdd,The method has 6 parameters. Parameters: dictionary' key' valueFactory' arg1' arg2' arg3
Long Parameter List,BTDB.ODBLayer,AdvancedEnumeratorParam<TKey>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\IOrderedDictionary.cs,AdvancedEnumeratorParam,The method has 5 parameters. Parameters: order' start' startProposition' end' endProposition
Long Parameter List,BTDB.ODBLayer,ODBDictionaryFieldHandler,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ODBDictionaryFieldHandler.cs,ODBDictionaryFieldHandler,The method has 5 parameters. Parameters: odb' configuration' configurationId' specializedKeyHandler' specializedValueHandler
Long Parameter List,BTDB.ODBLayer,ODBIterator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,IterateInlineDict,The method has 5 parameters. Parameters: reader' keyHandler' valueHandler' skipping' knownInlineRefs
Long Parameter List,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,WritePrimaryKeyPrefixFinishedByAdvancedEnumerator,The method has 8 parameters. Parameters: method' parameters' reqMethod' prefixParamCount' advEnumParamOrder' advEnumParam' field' emptyBufferLoc
Long Parameter List,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,WritePrimaryKeyPrefixFinishedByAdvancedEnumeratorWithoutOrder,The method has 7 parameters. Parameters: method' parameters' reqMethod' advEnumParamOrder' advEnumParam' field' emptyBufferLoc
Long Parameter List,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodFindById,The method has 7 parameters. Parameters: ilGenerator' methodName' methodParameters' methodReturnType' apartFields' pushWriter' writerLoc
Long Parameter List,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodFindBy,The method has 7 parameters. Parameters: ilGenerator' methodName' methodParameters' methodReturnType' apartFields' pushWriter' writerLoc
Long Parameter List,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,SaveMethodParameters,The method has 6 parameters. Parameters: ilGenerator' methodName' methodParameters' apartFields' fields' writerLoc
Long Parameter List,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,FillBufferWhenNotIgnoredKeyPropositionIl,The method has 5 parameters. Parameters: advEnumParamOrder' field' emptyBufferLoc' instField' ilGenerator
Long Parameter List,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,SaveListPrefixBytes,The method has 5 parameters. Parameters: secondaryKeyIndex' ilGenerator' methodName' methodParameters' apartFields
Long Parameter List,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,SaveKeyFieldFromArgument,The method has 5 parameters. Parameters: ilGenerator' field' parameterId' parameterType' writerLoc
Long Parameter List,BTDB.ODBLayer,RelationDBManipulator<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,AnyWithProposition,The method has 5 parameters. Parameters: prefixBytes' startKeyProposition' startKeyBytes' endKeyProposition' endKeyBytes
Long Parameter List,BTDB.ODBLayer,RelationDBManipulator<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,CountWithProposition,The method has 5 parameters. Parameters: prefixBytes' startKeyProposition' startKeyBytes' endKeyProposition' endKeyBytes
Long Parameter List,BTDB.ODBLayer,RelationDBManipulator<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,RemoveByIdAdvancedParam,The method has 8 parameters. Parameters: manipulator' prefixBytes' prefixFieldCount' order' startKeyProposition' startKeyBytes' endKeyProposition' endKeyBytes
Long Parameter List,BTDB.ODBLayer,RelationSecondaryKeyEnumerator<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,RelationSecondaryKeyEnumerator,The method has 6 parameters. Parameters: tr' relationInfo' keyBytes' secondaryKeyIndex' fieldCountInKey' manipulator
Long Parameter List,BTDB.ODBLayer,RelationAdvancedEnumerator<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,RelationAdvancedEnumerator,The method has 8 parameters. Parameters: manipulator' prefixBytes' prefixFieldCount' order' startKeyProposition' startKeyBytes' endKeyProposition' endKeyBytes
Long Parameter List,BTDB.ODBLayer,RelationAdvancedSecondaryKeyEnumerator<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,RelationAdvancedSecondaryKeyEnumerator,The method has 9 parameters. Parameters: manipulator' prefixBytes' prefixFieldCount' order' startKeyProposition' startKeyBytes' endKeyProposition' endKeyBytes' secondaryKeyIndex
Long Parameter List,BTDB.ODBLayer,RelationAdvancedOrderedEnumerator<TKey;TValue>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,RelationAdvancedOrderedEnumerator,The method has 9 parameters. Parameters: manipulator' prefixBytes' prefixFieldCount' order' startKeyProposition' startKeyBytes' endKeyProposition' endKeyBytes' initKeyReader
Long Parameter List,BTDB.ODBLayer,RelationAdvancedOrderedSecondaryKeyEnumerator<TKey;TValue>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,RelationAdvancedOrderedSecondaryKeyEnumerator,The method has 9 parameters. Parameters: manipulator' prefixBytes' prefixFieldCount' order' startKeyProposition' startKeyBytes' endKeyProposition' endKeyBytes' secondaryKeyIndex
Long Parameter List,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,RelationInfo,The method has 5 parameters. Parameters: id' name' relationInfoResolver' interfaceType' tr
Long Parameter List,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateSaverIl,The method has 6 parameters. Parameters: ilGen' fields' pushInstance' pushRelationIface' pushWriter' pushTransaction
Long Parameter List,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CopyToOutput,The method has 6 parameters. Parameters: ilGenerator' valueHandler' writerCtxLocal' pushWriter' skHandler' buffer
Long Parameter List,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,StoreIntoLocal,The method has 6 parameters. Parameters: ilGenerator' valueHandler' bufferInfo' outOfOrderSkParts' skFieldIdx' skFieldHandler
Long Parameter List,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,InitializeBuffer,The method has 5 parameters. Parameters: bufferArgIdx' bufferInfo' ilGenerator' fields' skipAllRelationsPKPrefix
Long Parameter List,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CopyFromBuffer,The method has 10 parameters. Parameters: ilGenerator' bufferIdx' skFieldIdx' bi' outOfOrderPKParts' pks' skFields' positionLoc' memoPositionLoc' pushWriter
Long Parameter List,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,FindPosition,The method has 5 parameters. Parameters: pkIdx' skFields' paramFieldCountInFirstBuffer' bufferIdx' skFieldIdx
Long Parameter List,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,SkipWithMemorizing,The method has 5 parameters. Parameters: activeBuffer' ilGenerator' pushReader' handler' tempPosition
Long Parameter List,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CopyFromMemorizedPosition,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushWriter' memo' memoPositionLoc
Long Parameter List,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,GenerateCopyFieldFromByteBufferToWriterIl,The method has 6 parameters. Parameters: ilGenerator' handler' pushReader' pushWriter' positionLoc' memoPositionLoc
Long Parameter List,BTDB.ODBLayer,RelationVersionInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationVersionInfo.cs,RelationVersionInfo,The method has 5 parameters. Parameters: primaryKeyFields' secondaryKeys' secondaryKeyFields' fields' prevVersion
Long Parameter List,BTDB.ODBLayer,RelationVersionInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationVersionInfo.cs,RelationVersionInfo,The method has 5 parameters. Parameters: primaryKeyFields' secondaryKeys' secondaryKeysNames' secondaryKeyFields' fields
Long Parameter List,BTDB.ODBLayer,UnresolvedTableFieldInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableFieldInfo.cs,UnresolvedTableFieldInfo,The method has 5 parameters. Parameters: name' handlerName' configuration' tableName' handlerOptions
Long Parameter List,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,GenerateOneFieldHandlerSave,The method has 5 parameters. Parameters: loadInput' fieldHandler' inputType' ilGenerator' pushWriterOrCtx
Long Parameter List,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The method has 6 parameters. Parameters: dst' d' dL' src' s' sL
Long Parameter List,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The method has 5 parameters. Parameters: dst' d' dL' offset' length
Long Parameter List,BTDB.StreamLayer,WindowsPlatformMethods,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\WindowsPlatformMethods.cs,ReadFile,The method has 5 parameters. Parameters: handle' bytes' numBytesToRead' numBytesRead_mustBeZero' overlapped
Long Parameter List,BTDB.StreamLayer,WindowsPlatformMethods,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\WindowsPlatformMethods.cs,WriteFile,The method has 5 parameters. Parameters: handle' bytes' numBytesToWrite' numBytesWritten_mustBeZero' lpOverlapped
Long Parameter List,BTDB.StreamLayer,WindowsPlatformMethods,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\WindowsPlatformMethods.cs,CreateFile,The method has 7 parameters. Parameters: lpFileName' dwDesiredAccess' dwShareMode' SecurityAttributes' dwCreationDisposition' dwFlagsAndAttributes' hTemplateFile
Long Identifier,BTDB.EventStoreLayer,DictionaryTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateLoad,The length of the parameter dictionaryTypeGenericDefinition is 31.
Long Identifier,BTDB.EventStoreLayer,TypeSerializers,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,,The length of the parameter _newDescriptorSaverFactoryAction is 32.
Long Identifier,BTDB.IL,EmitHelpers,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateAddRemoveEvent,The length of the parameter typePropertyChangedEventHandler is 31.
Long Identifier,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CalculatePreserveKeyIndexKeyFromKeyIndexInfos,The length of the parameter preserveHistoryUpToCommitUlong is 30.
Long Identifier,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,RevertWritingTransaction,The length of the parameter nothingWrittenToTransactionLog is 30.
Long Identifier,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,,The length of the parameter _usedNodesInReadonlyTransactions is 32.
Long Identifier,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,,The length of the parameter _preserveHistoryUpToCommitUlong is 31.
Long Identifier,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,,The length of the parameter _fileIdWithPreviousTransactionLog is 33.
Long Identifier,BTDB.KVDBLayer,Compactor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,Run,The length of the parameter dontTouchGenerationDueToPreserve is 32.
Long Identifier,BTDB.KVDBLayer,FileTransactionLog,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\FileTransactionLog.cs,FileTransactionLog,The length of the parameter fileIdWithPreviousTransactionLog is 32.
Long Identifier,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,CalculatePreserveKeyIndexKeyFromKeyIndexInfos,The length of the parameter preserveHistoryUpToCommitUlong is 30.
Long Identifier,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,RevertWritingTransaction,The length of the parameter nothingWrittenToTransactionLog is 30.
Long Identifier,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,,The length of the parameter _preserveHistoryUpToCommitUlong is 31.
Long Identifier,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,,The length of the parameter _fileIdWithPreviousTransactionLog is 33.
Long Identifier,BTDB.KVDBLayer,KeyValueDBOptions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDBOptions.cs,,The length of the parameter PreserveHistoryUpToCommitUlong is 30.
Long Identifier,BTDB.KVDBLayer,KeyValueDBOptions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDBOptions.cs,,The length of the parameter CompactorReadBytesPerSecondLimit is 32.
Long Identifier,BTDB.KVDBLayer,KeyValueDBOptions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDBOptions.cs,,The length of the parameter CompactorWriteBytesPerSecondLimit is 33.
Long Identifier,BTDB.ODBLayer,TableInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,,The length of the parameter _freeContentNeedDetectionInProgress is 35.
Long Identifier,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,RegisterLocalTypeInternalUnlocked,The length of the parameter iFieldHandlerWithNestedFieldHandlers is 36.
Long Identifier,BTDB.StreamLayer,WindowsPlatformMethods,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\WindowsPlatformMethods.cs,,The length of the parameter CREATION_DISPOSITION_OPEN_EXISTING is 34.
Long Statement,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The length of the statement  "            var (_' _' keyPrefixSize' keyPrefixPtr' suffixSize' totalSuffixPtr' valueSize' valuePtr) = NodeUtils12.GetAllSizeAndPtr(nodePtr);" is 129.
Long Statement,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The length of the statement  "                            if (suffixSize > 0) NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 256' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' pos' 48));" is 127.
Long Statement,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CloneNodeWithSetSuffix,The length of the statement  "            var (baseSize' maxChildren' keyPrefixSize' keyPrefixPtr' suffixSize' totalSuffixPtr' valueSize' valuePtr) = NodeUtils12.GetAllSizeAndPtr(nodePtr);" is 146.
Long Statement,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CloneNodeWithKeyPrefixCut,The length of the statement  "            var (baseSize' maxChildren' keyPrefixSize' keyPrefixPtr' suffixSize' totalSuffixPtr' valueSize' valuePtr) = NodeUtils12.GetAllSizeAndPtr(nodePtr);" is 146.
Long Statement,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CloneNodeWithKeyPrefixCut,The length of the statement  "            var (newKeyPrefixSize' newKeyPrefixPtr' newTotalSuffixPtr' _' newValuePtr) = NodeUtils12.GetAllSizeAndPtr(newNode' suffixSize);" is 127.
Long Statement,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CloneNodeWithValueResize,The length of the statement  "            var (baseSize' maxChildren' keyPrefixSize' keyPrefixPtr' suffixSize' totalSuffixPtr' valueSize' valuePtr) = NodeUtils12.GetAllSizeAndPtr(nodePtr);" is 146.
Long Statement,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,IterateNodeInfo,The length of the statement  "            var (baseSize' maxChildren' prefixSize' prefixPtr' totalSuffixSize' _' valueSize' _) = NodeUtils12.GetAllSizeAndPtr(nodePtr);" is 125.
Long Statement,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,SetSuffix,The length of the statement  "            if (suffixOfs3 > suffixOfs2) TreeNodeUtils.MoveMemory(ptr + suffixOfs2' ptr + (int)(suffixOfs2 + src.Size)' suffixOfs3 - suffixOfs2);" is 133.
Long Statement,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,SetSuffix,The length of the statement  "            if (suffixOfs3 > suffixOfs2) TreeNodeUtils.MoveMemory(ptr + suffixOfs2' ptr + (suffixOfs2 + src.Length)' suffixOfs3 - suffixOfs2);" is 130.
Long Statement,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The length of the statement  "            result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)" is 126.
Long Statement,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "                    result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];" is 127.
Long Statement,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "                    result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];" is 157.
Long Statement,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "                    result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];" is 156.
Long Statement,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "                result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)" is 122.
Long Statement,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "                result = ((long)(first - 0x08) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];" is 127.
Long Statement,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "                result = ((long)(first - 0x04) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];" is 157.
Long Statement,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "                result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];" is 170.
Long Statement,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "            result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)" is 122.
Long Statement,BTDB.DtoChannel,Receiver,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\DtoChannel\DtoChannel.cs,OnNext,The length of the statement  "                    _dtoChannel._onReceive.OnError(new InvalidDataException("Data received from other side must Start with byte 99 or 100"));" is 121.
Long Statement,BTDB.EventStore2Layer,EventDeserializer,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventDeserializer.cs,LoaderFactory,The length of the statement  "            var methodBuilder = ILBuilder.Instance.NewMethod<Func<AbstractBufferedReader' ITypeBinaryDeserializerContext' ITypeDescriptor' object>>("DeserializerFor" + descriptor.Name);" is 173.
Long Statement,BTDB.EventStoreLayer,AppendingEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,Store,The length of the statement  "            SerializeIntoBuffer(metadata' events' out startOffset' out serializerContext' out blockType' out lenWithoutEndPadding' out block);" is 130.
Long Statement,BTDB.EventStoreLayer,AppendingEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,Store,The length of the statement  "                SerializeIntoBuffer(metadata' events' out startOffset' out serializerContext' out blockType' out lenWithoutEndPadding' out block);" is 130.
Long Statement,BTDB.EventStoreLayer,AppendingEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,KnownAppendablePosition,The length of the statement  "            if (!IsKnownAsAppendable()) throw new InvalidOperationException("IsKnownAsAppendable needs to return true before calling this method. Use ReadToEnd(new SkippingEventObserver()).Wait() to initialize.");" is 201.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateLoad,The length of the statement  "            var dictionaryTypeGenericDefinition = targetType.InheritsOrImplements(typeof(IOrderedDictionary<'>)) ? typeof(OrderedDictionaryWithDescriptor<'>) : typeof(DictionaryWithDescriptor<'>);" is 184.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateLoad,The length of the statement  "            _keyDescriptor.GenerateLoadEx(ilGenerator' pushReader' pushCtx' il => il.Do(pushDescriptor).LdcI4(0).Callvirt(() => default(ITypeDescriptor).NestedType(0))' keyType' _convertorGenerator);" is 187.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateLoad,The length of the statement  "            _valueDescriptor.GenerateLoadEx(ilGenerator' pushReader' pushCtx' il => il.Do(pushDescriptor).LdcI4(1).Callvirt(() => default(ITypeDescriptor).NestedType(0))' valueType' _convertorGenerator);" is 191.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateSave,The length of the statement  "                _keyDescriptor.GenerateSaveEx(ilGenerator' pushWriter' pushCtx' il => il.Ldloca(localPair).Call(typeKeyValuePair.GetProperty("Key").GetGetMethod())' keyType);" is 158.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateSave,The length of the statement  "                _valueDescriptor.GenerateSaveEx(ilGenerator' pushWriter' pushCtx' il => il.Ldloca(localPair).Call(typeKeyValuePair.GetProperty("Value").GetGetMethod())' valueType);" is 164.
Long Statement,BTDB.EventStoreLayer,TypeNewDescriptorGenerator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateTypeIterator,The length of the statement  "                var itemType = _listTypeDescriptor._typeSerializers.LoadAsType(_listTypeDescriptor._itemDescriptor' targetTypeArguments[0]);" is 124.
Long Statement,BTDB.EventStoreLayer,ListTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateLoad,The length of the statement  "                _itemDescriptor.GenerateLoadEx(ilGenerator' pushReader' pushCtx' il => il.Do(pushDescriptor).LdcI4(0).Callvirt(() => default(ITypeDescriptor).NestedType(0))' itemType' _convertorGenerator);" is 189.
Long Statement,BTDB.EventStoreLayer,ListTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateLoad,The length of the statement  "                    throw new NotSupportedException($"List type {listType.ToSimpleName()} is not assignable to {targetType.ToSimpleName()}.");" is 122.
Long Statement,BTDB.EventStoreLayer,ListTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateLoad,The length of the statement  "                _itemDescriptor.GenerateLoadEx(ilGenerator' pushReader' pushCtx' il => il.Do(pushDescriptor).LdcI4(0).Callvirt(() => default(ITypeDescriptor).NestedType(0))' itemType' _convertorGenerator);" is 189.
Long Statement,BTDB.EventStoreLayer,NullableTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\NullableTypeDescriptor.cs,GenerateLoad,The length of the statement  "            _itemDescriptor.GenerateLoadEx(ilGenerator' pushReader' pushCtx' il => il.Do(pushDescriptor).LdcI4(0).Callvirt(() => default(ITypeDescriptor).NestedType(0))' itemType' _convertorGenerator);" is 189.
Long Statement,BTDB.EventStoreLayer,TypeDescriptorExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeDescriptorExtensions.cs,Describe,The length of the statement  "            descriptor.BuildHumanReadableFullName(sb' new HashSet<ITypeDescriptor>(ReferenceEqualityComparer<ITypeDescriptor>.Instance)' 0);" is 128.
Long Statement,BTDB.EventStoreLayer,TypeDescriptorExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeDescriptorExtensions.cs,AppendJsonLike,The length of the statement  "                return sb.Append('"').Append(objString.Replace("\\"' "\\\\").Replace("\""' "\\\"").Replace("\r"' "\\r").Replace("\n"' "\\n")).Append('"');" is 138.
Long Statement,BTDB.EventStoreLayer,TypeSerializers,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,ForgotAllTypesAndSerializers,The length of the statement  "            _type2DescriptorMap = new ConcurrentDictionary<Type' ITypeDescriptor>(EnumDefaultTypes()' ReferenceEqualityComparer<Type>.Instance);" is 132.
Long Statement,BTDB.EventStoreLayer,TypeSerializers,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,LoaderFactory,The length of the statement  "            var methodBuilder = ILBuilder.Instance.NewMethod<Func<AbstractBufferedReader' ITypeBinaryDeserializerContext' ITypeSerializersId2LoaderMapping' ITypeDescriptor' object>>("DeserializerFor" + descriptor.Name);" is 207.
Long Statement,BTDB.EventStoreLayer,TypeSerializers,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,LoaderFactory,The length of the statement  "                    descriptor.GenerateLoad(il' ilGen => ilGen.Ldarg(0)' ilGen => ilGen.Ldloc(localCtx)' ilGen => ilGen.Ldarg(3)' loadAsType);" is 122.
Long Statement,BTDB.EventStoreLayer,TypeSerializers,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,NewComplexSaver,The length of the statement  "            var method = ILBuilder.Instance.NewMethod<Action<AbstractBufferedWriter' ITypeBinarySerializerContext' object>>(descriptor.Name + "ComplexSaver");" is 146.
Long Statement,BTDB.EventStoreLayer,TypeSerializers,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,NewDescriptorSaverFactory,The length of the statement  "            var method = ILBuilder.Instance.NewMethod<Action<object' IDescriptorSerializerLiteContext>>("GatherAllObjectsForTypeExtraction_" + descriptor.Name);" is 148.
Long Statement,BTDB.EventStoreLayer,DescriptorSerializerContext,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializersMapping.cs,GetInfoFromObject,The length of the statement  "                    if (!_typeOrDescriptor2InfoMap.TryGetValue(objType' out infoForType) && !_typeSerializersMapping._typeOrDescriptor2Info.TryGetValue(objType' out infoForType))" is 158.
Long Statement,BTDB.FieldHandler,DefaultFieldHandlerFactory,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\DefaultFieldHandlerFactory.cs,CreateFromType,The length of the statement  "            if (ListFieldHandler.IsCompatibleWith(type)) return new ListFieldHandler(_provider.FieldHandlerFactory' _provider.TypeConvertorGenerator' type);" is 144.
Long Statement,BTDB.FieldHandler,DefaultFieldHandlerFactory,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\DefaultFieldHandlerFactory.cs,CreateFromType,The length of the statement  "            if (DictionaryFieldHandler.IsCompatibleWith(type)) return new DictionaryFieldHandler(_provider.FieldHandlerFactory' _provider.TypeConvertorGenerator' type);" is 156.
Long Statement,BTDB.FieldHandler,DefaultFieldHandlerFactory,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\DefaultFieldHandlerFactory.cs,CreateFromType,The length of the statement  "            if (NullableFieldHandler.IsCompatibleWith(type)) return new NullableFieldHandler(_provider.FieldHandlerFactory' _provider.TypeConvertorGenerator' type);" is 152.
Long Statement,BTDB.FieldHandler,DefaultFieldHandlerFactory,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\DefaultFieldHandlerFactory.cs,CreateFromName,The length of the statement  "            if (handlerName == ListFieldHandler.HandlerName) return new ListFieldHandler(_provider.FieldHandlerFactory' _provider.TypeConvertorGenerator' configuration);" is 157.
Long Statement,BTDB.FieldHandler,DefaultFieldHandlerFactory,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\DefaultFieldHandlerFactory.cs,CreateFromName,The length of the statement  "            if (handlerName == DictionaryFieldHandler.HandlerName) return new DictionaryFieldHandler(_provider.FieldHandlerFactory' _provider.TypeConvertorGenerator' configuration);" is 169.
Long Statement,BTDB.FieldHandler,DefaultFieldHandlerFactory,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\DefaultFieldHandlerFactory.cs,CreateFromName,The length of the statement  "            if (handlerName == NullableFieldHandler.HandlerName) return new NullableFieldHandler(_provider.FieldHandlerFactory' _provider.TypeConvertorGenerator' configuration);" is 165.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,IsCompatibleWith,The length of the statement  "            return type.GetGenericTypeDefinition() == typeof(IDictionary<'>) || type.GetGenericTypeDefinition() == typeof(Dictionary<'>);" is 125.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,HandledType,The length of the statement  "            return _type ?? (_type = typeof(IDictionary<'>).MakeGenericType(_keysHandler.HandledType()' _valuesHandler.HandledType()));" is 123.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,Save,The length of the statement  "            _valuesHandler.Save(ilGenerator' Extensions.PushWriterOrCtxAsNeeded(pushWriterOrCtx' _valuesHandler.NeedsCtx())' il => il" is 121.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,SpecializeLoadForType,The length of the statement  "            return new DictionaryFieldHandler(_fieldHandlerFactory' _typeConvertorGenerator' type' keySpecialized' valueSpecialized);" is 121.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,SpecializeSaveForType,The length of the statement  "            return new DictionaryFieldHandler(_fieldHandlerFactory' _typeConvertorGenerator' type' keySpecialized' valueSpecialized);" is 121.
Long Statement,BTDB.FieldHandler,EnumFieldHandler,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\EnumFieldHandler.cs,IsCompatibleWith,The length of the statement  "            return SignedFieldHandler.IsCompatibleWith(enumUnderlyingType) || UnsignedFieldHandler.IsCompatibleWith(enumUnderlyingType);" is 124.
Long Statement,BTDB.FieldHandler,EnumFieldHandler,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\EnumFieldHandler.cs,SpecializeLoadForType,The length of the statement  "                    if (new EnumConfiguration(Configuration).IsBinaryRepresentationSubsetOf(new EnumConfiguration(enumTypeHandler.Configuration)))" is 126.
Long Statement,BTDB.FieldHandler,ConvertingHandler,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\SimpleFieldHandlerBase.cs,Save,The length of the statement  "                _fieldHandler.Save(ilGenerator' pushWriterOrCtx' il => il.Do(pushValue).Do(DefaultTypeConvertorGenerator.Instance.GenerateConversion(_type' _fieldHandler.HandledType())));" is 171.
Long Statement,BTDB.IL,EmitHelpers,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateINotifyPropertyChangedImpl,The length of the statement  "            var fieldBuilder = typeBuilder.DefineField("_propertyChanged"' typeof(PropertyChangedEventHandler)' FieldAttributes.Private);" is 125.
Long Statement,BTDB.IL,EmitHelpers,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateINotifyPropertyChangedImpl,The length of the statement  "            var eventBuilder = typeBuilder.DefineEvent("PropertyChanged"' EventAttributes.None' typeof(PropertyChangedEventHandler));" is 121.
Long Statement,BTDB.IL,EmitHelpers,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateINotifyPropertyChangedImpl,The length of the statement  "            var methodBuilder = typeBuilder.DefineMethod("RaisePropertyChanged"' null' new[] { typeof(string) }' MethodAttributes.Family);" is 126.
Long Statement,BTDB.IL,EmitHelpers,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateAddRemoveEvent,The length of the statement  "            typeBuilder.DefineMethodOverride(methodBuilder' add ? eventPropertyChanged.GetAddMethod() : eventPropertyChanged.GetRemoveMethod());" is 132.
Long Statement,BTDB.IL,ILDynamicTypeImpl,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILDynamicTypeImpl.cs,DefineConstructor,The length of the statement  "            return new ILConstructorImpl(_typeBuilder.DefineConstructor(MethodAttributes.Public' CallingConventions.Standard' parameters)' _forbidenInstructions);" is 150.
Long Statement,BTDB.IL,Call,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenForbidenInstructionsCheating.cs,GenerateStaticParts,The length of the statement  "                    _staticMethod = typeBuilder.DefineMethod(_name' MethodAttributes.Private | MethodAttributes.Static' _methodInfo.ReturnType' paramTypesWithoutResult);" is 149.
Long Statement,BTDB.IL,Call,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenForbidenInstructionsCheating.cs,GenerateStaticParts,The length of the statement  "                    _staticMethod = typeBuilder.DefineMethod(_name' MethodAttributes.Private | MethodAttributes.Static' accesibleConstructorType' paramTypesWithoutResult);" is 151.
Long Statement,BTDB.IOC,ClosureOfObjBuilder,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IOC\ClosureOfObjBuilder.cs,Build,The length of the statement  "                                            typeof(ClosureOfObj<'>).MakeGenericType(methodInfo.ReturnType' parameters[0].ParameterType).GetConstructors()[0].Invoke(new[] { toReturn })'" is 140.
Long Statement,BTDB.IOC,ConstructorTraitImpl,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IOC\ConstructorTraitImpl.cs,ChooseConstructor,The length of the statement  "                return candidates.FirstOrDefault(ci => ci.GetParameters().Select(pi => pi.ParameterType).SequenceEqual(_parameterTypes));" is 121.
Long Statement,BTDB.IOC,ConstructorTraitImpl,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IOC\ConstructorTraitImpl.cs,UsingConstructor,The length of the statement  "            if (_parameterTypes != null) throw new InvalidOperationException("UsingConstructor specification could be used only once");" is 123.
Long Statement,BTDB.IOC,GenerationContext,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IOC\GenerationContext.cs,PushToCycleDetector,The length of the statement  "                throw new InvalidOperationException("Cycle detected in registrations: " + string.Join("' "' _cycleDetectionStack.Select(t => t.Item2)) + ". Consider using Lazy<> to break cycle.");" is 180.
Long Statement,BTDB.IOC,SingleRegistration,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IOC\SingleRegistration.cs,Register,The length of the statement  "                    reg = new SingletonImpl(_implementationType' new AlwaysNewImpl(_implementationType' bestConstructor)' context.SingletonCount);" is 126.
Long Statement,BTDB.IOC.CRegs,DelegateImpl,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IOC\CRegs\DelegateImpl.cs,GetNeeds,The length of the statement  "                var genCtx = new GenerationContext(context.Container' _nestedRegistration' buildContext' _type.GetMethod("Invoke").GetParameters());" is 132.
Long Statement,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The length of the statement  "            if (tempbuf[0] != 'B' || tempbuf[1] != 'T' || tempbuf[2] != 'D' || tempbuf[3] != 'B' || tempbuf[4] != 'E' || tempbuf[5] != 'X' || tempbuf[6] != 'P' || tempbuf[7] != '2')" is 169.
Long Statement,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The length of the statement  "                transaction.CreateOrUpdateKeyValue(ByteBuffer.NewSync(tempbuf' 0' keySize)' ByteBuffer.NewSync(tempbuf2' 0' valueSize));" is 120.
Long Statement,BTDB.KVDBLayer,PtrLenList,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryInclude,The length of the statement  "                    _list[m] = new KeyValuePair<ulong' ulong>(cur.Key' Math.Max(lastOk.Key + lastOk.Value' includePos + includeLen) - cur.Key);" is 123.
Long Statement,BTDB.KVDBLayer,PtrLenList,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryInclude,The length of the statement  "            _list[l] = new KeyValuePair<ulong' ulong>(includePos' Math.Max(cur.Key + cur.Value' includePos + includeLen) - includePos);" is 123.
Long Statement,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CalcStats,The length of the statement  "                    $"KeyValueCount:{lastCommitted.GetCount()}\nFileCount:{FileCollection.GetCount()}\nFileGeneration:{FileCollection.LastFileGeneration}\n");" is 138.
Long Statement,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CalcStats,The length of the statement  "                sb.Append($"LastTrId:{lastCommitted.TransactionId}'TRL:{lastCommitted.TrLogFileId}'ComUlong:{lastCommitted.CommitUlong}\n");" is 124.
Long Statement,BTDB.KVDBLayer,BTreeKeyValueDBTransaction,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDBTransaction.cs,GetValue,The length of the statement  "                    throw new BTDBException($"GetValue failed in TrId:{BTreeRoot.TransactionId}'TRL:{BTreeRoot.TrLogFileId}'Ofs:{BTreeRoot.TrLogOffset}'ComUlong:{BTreeRoot.CommitUlong} and LastTrId:{lastCommitted.TransactionId}'ComUlong:{lastCommitted.CommitUlong} OldestTrId:{oldestRoot.TransactionId}'TRL:{oldestRoot.TrLogFileId}'ComUlong:{oldestRoot.CommitUlong} innerMessage:{ex.Message}"' ex);" is 378.
Long Statement,BTDB.KVDBLayer,BTreeKeyValueDBTransaction,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDBTransaction.cs,GetValueAsReadOnlySpan,The length of the statement  "                    throw new BTDBException($"GetValue failed in TrId:{BTreeRoot.TransactionId}'TRL:{BTreeRoot.TrLogFileId}'Ofs:{BTreeRoot.TrLogOffset}'ComUlong:{BTreeRoot.CommitUlong} and LastTrId:{lastCommitted.TransactionId}'ComUlong:{lastCommitted.CommitUlong} OldestTrId:{oldestRoot.TransactionId}'TRL:{oldestRoot.TrLogFileId}'ComUlong:{oldestRoot.CommitUlong} innerMessage:{ex.Message}"' ex);" is 378.
Long Statement,BTDB.KVDBLayer,BTreeKeyValueDBTransaction,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDBTransaction.cs,SetValue,The length of the statement  "            _keyValueDB.WriteCreateOrUpdateCommand(GetCurrentKeyFromStack().AsSyncReadOnlySpan()' value.AsSyncReadOnlySpan()' trueValue);" is 125.
Long Statement,BTDB.KVDBLayer,BTreeKeyValueDBTransaction,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDBTransaction.cs,GetStorageSizeOfCurrentKey,The length of the statement  "                _keyValueDB.CalcValueSize(MemoryMarshal.Read<uint>(trueValue)' MemoryMarshal.Read<uint>(trueValue.Slice(4))' MemoryMarshal.Read<int>(trueValue.Slice(8))));" is 155.
Long Statement,BTDB.KVDBLayer,FileKeyIndex,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\FileKeyIndex.cs,SkipHeader,The length of the statement  "            var withCommitUlong = type == KVFileType.KeyIndexWithCommitUlong || type == KVFileType.ModernKeyIndex || type == KVFileType.ModernKeyIndexWithUlongs;" is 149.
Long Statement,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadInfoAboutFiles,The length of the statement  "            if (openUpToCommitUlong.HasValue || lastestTrLogFileId != firstTrLogId && firstTrLogId != 0 || !hasKeyIndex && _fileCollection.FileInfos.Any(p => p.Value.SubDBId == 0))" is 168.
Long Statement,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadUsedFilesFromKeyIndex,The length of the statement  "                info.UsedFilesInOlderGenerations = usedFileIds.Select(GetGenerationIgnoreMissing).Where(gen => gen > 0 && gen < trlGeneration).OrderBy(a => a).ToArray();" is 153.
Long Statement,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadKeyIndex,The length of the statement  "                info.UsedFilesInOlderGenerations = usedFileIds.Select(fi => GetGenerationIgnoreMissing(fi)).Where(gen => gen > 0 && gen < trlGeneration).OrderBy(a => a).ToArray();" is 163.
Long Statement,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,CalcStats,The length of the statement  "                    $"KeyValueCount:{lastCommitted.CalcKeyCount()}\nFileCount:{FileCollection.GetCount()}\nFileGeneration:{FileCollection.LastFileGeneration}\n");" is 142.
Long Statement,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,CalcStats,The length of the statement  "                sb.Append($"LastTrId:{lastCommitted.TransactionId}'TRL:{lastCommitted.TrLogFileId}'ComUlong:{lastCommitted.CommitUlong}\n");" is 124.
Long Statement,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,UpdateTransactionLogInBTreeRoot,The length of the statement  "            if (btreeRoot.TrLogFileId != _fileIdWithTransactionLog && btreeRoot.TrLogFileId != 0 && !PreserveHistoryUpToCommitUlong.HasValue)" is 129.
Long Statement,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,CreateKeyIndexFile,The length of the statement  "            Logger?.KeyValueIndexCreated(file.Index' keyIndex.KeyValueCount' file.GetSize()' TimeSpan.FromMilliseconds(bytesPerSecondLimiter.TotalTimeInMs));" is 145.
Long Statement,BTDB.KVDBLayer,KeyValueDBTransaction,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDBTransaction.cs,CalcPrefixKeyStart,The length of the statement  "            if (BtreeRoot.FindKey(new List<NodeIdxPair>()' out _prefixKeyStart' _prefix' ByteBuffer.NewEmpty()) == FindResult.NotFound)" is 123.
Long Statement,BTDB.KVDBLayer,KeyValueDBTransaction,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDBTransaction.cs,GetValue,The length of the statement  "                throw new BTDBException($"GetValue failed in TrId:{BtreeRoot.TransactionId}'TRL:{BtreeRoot.TrLogFileId}'Ofs:{BtreeRoot.TrLogOffset}'ComUlong:{BtreeRoot.CommitUlong} and LastTrId:{lastCommited.TransactionId}'ComUlong:{lastCommited.CommitUlong} OldestTrId:{oldestRoot.TransactionId}'TRL:{oldestRoot.TrLogFileId}'ComUlong:{oldestRoot.CommitUlong} innerMessage:{ex.Message}"' ex);" is 376.
Long Statement,BTDB.KVDBLayer,KeyValueDBTransaction,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDBTransaction.cs,SetValue,The length of the statement  "            _keyValueDB.WriteCreateOrUpdateCommand(Array.Empty<byte>()' memberKey' value' out memberValue.ValueFileId' out memberValue.ValueOfs' out memberValue.ValueSize);" is 160.
Long Statement,BTDB.KVDBLayer,InMemoryKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\MemoryImplementation\InMemoryKeyValueDB.cs,Dispose,The length of the statement  "                if (_writingTransaction != null) throw new BTDBException("Cannot dispose KeyValueDB when writing transaction still running");" is 125.
Long Statement,BTDB.KVDBLayer,InMemoryKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\MemoryImplementation\InMemoryKeyValueDB.cs,MakeWritableTransaction,The length of the statement  "                if (_writingTransaction != null) throw new BTDBTransactionRetryException("Another writing transaction already running");" is 120.
Long Statement,BTDB.KVDBLayer,InMemoryKeyValueDBTransaction,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\MemoryImplementation\InMemoryKeyValueDBTransaction.cs,CalcPrefixKeyStart,The length of the statement  "            if (BtreeRoot.FindKey(new List<NodeIdxPair>()' out _prefixKeyStart' _prefix' ByteBuffer.NewEmpty()) == FindResult.NotFound)" is 123.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,CreateOrUpdate,The length of the statement  "                Array.Copy(_keyvalues' index' rightNode._keyvalues' index - keyCountLeft + 1' keyCountLeft + keyCountRight - 1 - index);" is 120.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,EraseRange,The length of the statement  "            Array.Copy(_keyvalues' (int)lastKeyIndex + 1' newKeyValues' (int)firstKeyIndex' newKeyValues.Length - (int)firstKeyIndex);" is 122.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,The length of the statement  "                Array.Copy(_keyBytes' ofs + leftKeyBytesLen' newKeyBytes' ofs + newKey.Length' _keyBytes.Length - ofs - leftKeyBytesLen);" is 121.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,The length of the statement  "                Array.Copy(_keyvalues' index' rightNode._keyvalues' index - keyCountLeft + 1' keyCountLeft + keyCountRight - 1 - index);" is 120.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,EraseRange,The length of the statement  "            var newKeyBytes = new byte[_keyBytes.Length + _keyvalues[firstKeyIndex].KeyOffset - _keyvalues[lastKeyIndex].KeyOffset - _keyvalues[lastKeyIndex].KeyLength];" is 157.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,EraseRange,The length of the statement  "            Array.Copy(_keyvalues' (int)lastKeyIndex + 1' newKeyValues' (int)firstKeyIndex' newKeyValues.Length - (int)firstKeyIndex);" is 122.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,EraseRange,The length of the statement  "            Array.Copy(_keyBytes' _keyvalues[lastKeyIndex].KeyOffset + _keyvalues[lastKeyIndex].KeyLength' newKeyBytes' _keyvalues[firstKeyIndex].KeyOffset' newKeyBytes.Length - _keyvalues[firstKeyIndex].KeyOffset);" is 203.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeRoot,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeRoot.cs,NewTransactionRoot,The length of the statement  "            return new BTreeRoot(_transactionId + 1) { _keyValueCount = _keyValueCount' _rootNode = _rootNode' CommitUlong = CommitUlong' _ulongs = newulongs };" is 148.
Long Statement,BTDB.KVDBLayer.BTree,BTreeBranch,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,ReplaceValues,The length of the statement  "                    var compRes = BitArrayManipulation.CompareByteArray(_keys[i]' 0' _keys[i].Length' ctx._restartKey' 0' ctx._restartKey.Length);" is 126.
Long Statement,BTDB.ODBLayer,DefaultODBFieldHandlerFactory,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\DefaultODBFieldHandlerFactory.cs,CreateFromType,The length of the statement  "            if (ODBDictionaryFieldHandler.IsCompatibleWithStatic(type' options)) return new ODBDictionaryFieldHandler(_odb' type' false' this);" is 131.
Long Statement,BTDB.ODBLayer,ObjectDBTransaction,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,WriteInlineObject,The length of the statement  "                throw new BTDBException($"Object of type {@object.GetType().ToSimpleName()} is not known how to store as inline object.");" is 122.
Long Statement,BTDB.ODBLayer,ODBDictionaryFieldHandler,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ODBDictionaryFieldHandler.cs,SpecializeLoadForType,The length of the statement  "            if (wantedKeyHandler == specializedKeyHandler && (wantedValueHandler == specializedValueHandler || wantedValueHandler.HandledType() == specializedValueHandler.HandledType()))" is 174.
Long Statement,BTDB.ODBLayer,ODBDictionaryFieldHandler,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ODBDictionaryFieldHandler.cs,SpecializeLoadForType,The length of the statement  "            var res = new ODBDictionaryFieldHandler(_odb' _configuration' _configurationId' specializedKeyHandler' specializedValueHandler);" is 128.
Long Statement,BTDB.ODBLayer,ODBIterator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,IterateOid,The length of the statement  "            if (_visitor != null && !_visitor.StartObject(oid' tableId' _tableId2Name.TryGetValue(tableId' out tableName) ? tableName : null'" is 129.
Long Statement,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,ValidateAdvancedEnumParameter,The length of the statement  "                    $"Parameter type mismatch in {methodName} (expected '{field.Handler.HandledType().ToSimpleName()}' but '{advEnumParamType.ToSimpleName()}' found).");" is 149.
Long Statement,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodFindBy,The length of the statement  "            //call public T FindBySecondaryKeyOrDefault(uint secondaryKeyIndex' uint prefixParametersCount' ByteBuffer secKeyBytes' bool throwWhenNotFound)" is 143.
Long Statement,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,SaveMethodParameters,The length of the statement  "                        $"Parameter type mismatch in {methodName} (expected '{field.Handler.HandledType().ToSimpleName()}' but '{par.ParameterType.ToSimpleName()}' found).");" is 150.
Long Statement,BTDB.ODBLayer,RelationDBManipulator<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,KeyBytes,The length of the statement  "            _relationInfo.PrimaryKeysSaver(_transaction' keyWriter' obj' this);  //this for relation interface which is same with manipulator" is 129.
Long Statement,BTDB.ODBLayer,RelationDBManipulator<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,RemoveByPrimaryKeyPrefix,The length of the statement  "            var enumerator = new RelationPrimaryKeyEnumerator<T>(_transaction' _relationInfo' keyBytesPrefix' _modificationCounter);" is 120.
Long Statement,BTDB.ODBLayer,RelationDBManipulator<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,RemoveByPrimaryKeyPrefixPartial,The length of the statement  "            var enumerator = new RelationPrimaryKeyEnumerator<T>(_transaction' _relationInfo' keyBytesPrefix' _modificationCounter);" is 120.
Long Statement,BTDB.ODBLayer,RelationDBManipulator<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,CountWithProposition,The length of the statement  "                endKeyBytes = RelationAdvancedEnumerator<T>.FindLastKeyWithPrefix(prefixBytes' endKeyBytes' _kvtr' keyValueTrProtector);" is 120.
Long Statement,BTDB.ODBLayer,RelationDBManipulator<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,GetEnumerator,The length of the statement  "            return new RelationEnumerator<T>(_transaction' _relationInfo' ByteBuffer.NewSync(_relationInfo.Prefix)' _modificationCounter);" is 126.
Long Statement,BTDB.ODBLayer,RelationDBManipulator<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,WriteSecondaryKeyKey,The length of the statement  "            keySaver(_transaction' keyWriter' new ByteBufferReader(keyBytes)' new ByteBufferReader(valueBytes)' _relationInfo.DefaultClientObject);" is 135.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CheckThatPrimaryKeyHasNotChanged,The length of the statement  "                throw new BTDBException($"Change of primary key in relation '{name}' is not allowed. Field count {pkFields.Count} != {prevPkFields.Count}.");" is 141.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CheckThatPrimaryKeyHasNotChanged,The length of the statement  "                    throw new BTDBException($"Change of primary key in relation '{name}' is not allowed. Field '{en.Current.Name}' is not compatible.");" is 132.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CalculateSecondaryKey,The length of the statement  "            var enumerator = (IEnumerator)Activator.CreateInstance(enumeratorType' tr' this' keyWriter.GetDataAndRewind().ToAsyncSafe()' new SimpleModificationCounter());" is 158.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateCreatorLoadersAndSavers,The length of the statement  "            _primaryKeysSaver = CreateSaverWithApartFields(ClientRelationVersionInfo.GetPrimaryKeyFields()' $"RelationKeySaver_{Name}");" is 124.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateCreatorLoadersAndSavers,The length of the statement  "            _primaryKeysLoader = CreateLoader(ClientTypeVersion' ClientRelationVersionInfo.GetPrimaryKeyFields()' $"RelationKeyLoader_{Name}");" is 131.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateCreatorLoadersAndSavers,The length of the statement  "                _secondaryKeysSavers = new Action<IInternalObjectDBTransaction' AbstractBufferedWriter' object' object>[ClientRelationVersionInfo.SecondaryKeys.Keys.Max()+1];" is 158.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateBytesToSKSaver,The length of the statement  "            var method = ILBuilder.Instance.NewMethod<Action<IInternalObjectDBTransaction' AbstractBufferedWriter' AbstractBufferedReader' AbstractBufferedReader' object>>(saverName);" is 171.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateBytesToSKSaver,The length of the statement  "                        StoreIntoLocal(ilGenerator' pks[pkIdx].Handler' firstBuffer' outOfOrderSkParts' skFieldIdxForPk' skFields[skFieldIdxForPk].Handler);" is 132.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateBytesToSKSaver,The length of the statement  "                    CopyToOutput(ilGenerator' pks[(int)skf.Index].Handler' writerCtxLocal' pushWriter' skFields[skFieldIdx].Handler' firstBuffer);" is 126.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateBytesToSKSaver,The length of the statement  "                                StoreIntoLocal(ilGenerator' valueField.Handler' secondBuffer' outOfOrderSkParts' storeForSkIndex' skFields[storeForSkIndex].Handler);" is 133.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateBytesToSKSaver,The length of the statement  "                        CopyToOutput(ilGenerator' valueFields[valueFieldIdx].Handler' writerCtxLocal' pushWriter' skFields[skFieldIdx].Handler' secondBuffer);" is 134.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateBytesToSKSaver,The length of the statement  "                    { //older version of value does not contain sk field - store field from default value (can be initialized in constructor)" is 121.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateVersionInfoByReflection,The length of the statement  "            var secondaryKeys = new List<Tuple<int' IList<SecondaryKeyAttribute>>>(); //positive: sec key field idx' negative: pk order' attrs" is 130.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateVersionInfoByReflection,The length of the statement  "                            secondaryKeyFields.Add(TableFieldInfo.Build(Name' pi' _relationInfoResolver.FieldHandlerFactory' FieldHandlerOptions.Orderable));" is 129.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateVersionInfoByReflection,The length of the statement  "            return new RelationVersionInfo(primaryKeys' secondaryKeys' secondaryKeyFields.ToArray()' fields.ToArray()' prevVersion);" is 120.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,FindApartFields,The length of the statement  "                    throw new BTDBException($"Property {name} has incompatible return type with the member of primary key with the same name.");" is 124.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,GetPKValToSKMerger,The length of the statement  "                    $"Relation_{relationInfo.Name}_PkVal_to_SK_{relationInfo.ClientRelationVersionInfo.SecondaryKeys[secKeyIndex].Name}_v{ver}")'" is 125.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,GetSKKeyValuetoPKMerger,The length of the statement  "                (_' secKeyIndex' relationInfo' paramFieldCount) => relationInfo.CreatePrimaryKeyFromSKDataMerger(secKeyIndex' paramFieldCount'" is 126.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreatePrimaryKeyFromSKDataMerger,The length of the statement  "            var method = ILBuilder.Instance.NewMethod<Action<AbstractBufferedReader' AbstractBufferedReader' AbstractBufferedWriter>>(mergerName);" is 134.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreatePrimaryKeyFromSKDataMerger,The length of the statement  "            var outOfOrderPKParts = new Dictionary<int' MemorizedPositionWithLength>(); //index -> bufferIdx' IMemorizedPosition' length" is 124.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateSimpleLoader,The length of the statement  "            var delegateType = typeof(Func<''>).MakeGenericType(typeof(AbstractBufferedReader)' typeof(IReaderCtx)' loaderType.RealType);" is 125.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateLoader,The length of the statement  "            var method = ILBuilder.Instance.NewMethod<Action<IInternalObjectDBTransaction' AbstractBufferedReader' object>>(loaderName);" is 124.
Long Statement,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateLoader,The length of the statement  "                    var converterGenerator = _relationInfoResolver.TypeConvertorGenerator.GenerateConversion(willLoad' setterMethod.GetParameters()[0].ParameterType);" is 146.
Long Statement,BTDB.ODBLayer,TableFieldInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableFieldInfo.cs,Build,The length of the statement  "            if (fieldHandler == null) throw new BTDBException(string.Format("FieldHandlerFactory did not build property {0} of type {2} in {1}"' pi.Name' tableName' pi.PropertyType.FullName));" is 180.
Long Statement,BTDB.ODBLayer,TableInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateInitializer,The length of the statement  "                    var converterGenerator = _tableInfoResolver.TypeConvertorGenerator.GenerateConversion(willLoad' setterMethod.GetParameters()[0].ParameterType);" is 143.
Long Statement,BTDB.ODBLayer,TableInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateSaver,The length of the statement  "            var method = ILBuilder.Instance.NewMethod<Action<IInternalObjectDBTransaction' DBObjectMetadata' AbstractBufferedWriter' object>>(" is 130.
Long Statement,BTDB.ODBLayer,TableInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,EnsureClientTypeVersion,The length of the statement  "                var last = _tableVersions.GetOrAdd(LastPersistedVersion' (ver' tableInfo) => tableInfo._tableInfoResolver.LoadTableVersionInfo(tableInfo._id' ver' tableInfo.Name)' this);" is 170.
Long Statement,BTDB.ODBLayer,TableInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,The length of the statement  "            var method = ILBuilder.Instance.NewMethod<Action<IInternalObjectDBTransaction' DBObjectMetadata' AbstractBufferedReader' object>>(" is 130.
Long Statement,BTDB.ODBLayer,TableInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,The length of the statement  "            var tableVersionInfo = _tableVersions.GetOrAdd(version' (ver' tableInfo) => tableInfo._tableInfoResolver.LoadTableVersionInfo(tableInfo._id' ver' tableInfo.Name)' this);" is 169.
Long Statement,BTDB.ODBLayer,TableInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,The length of the statement  "                    var converterGenerator = _tableInfoResolver.TypeConvertorGenerator.GenerateConversion(willLoad' setterMethod.GetParameters()[0].ParameterType);" is 143.
Long Statement,BTDB.ODBLayer,TableInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateFreeContent,The length of the statement  "            var tableVersionInfo = _tableVersions.GetOrAdd(version' (ver' tableInfo) => tableInfo._tableInfoResolver.LoadTableVersionInfo(tableInfo._id' ver' tableInfo.Name)' this);" is 169.
Long Statement,BTDB.Reactive,FastBehaviourSubject<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,OnCompleted,The length of the statement  "            } while (Interlocked.CompareExchange(ref _current' FastSubjectHelpers<T>.CompletedSubjectMarker' original) != original);" is 120.
Long Statement,BTDB.Reactive,FastBehaviourSubject<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,OnError,The length of the statement  "            } while (Interlocked.CompareExchange(ref _current' new FastSubjectHelpers<T>.ExceptionedSubject(error)' original) != original);" is 127.
Long Statement,BTDB.Reactive,FastBehaviourSubject<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,OnNext,The length of the statement  "                else if (original is FastSubjectHelpers<T>.EmptySubjectWithValue || original == FastSubjectHelpers<T>.EmptySubjectMarker)" is 121.
Long Statement,BTDB.Reactive,FastSubject<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Reactive\FastSubject.cs,OnCompleted,The length of the statement  "            } while (Interlocked.CompareExchange(ref _current' FastSubjectHelpers<T>.CompletedSubjectMarker' original) != original);" is 120.
Long Statement,BTDB.Reactive,FastSubject<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Reactive\FastSubject.cs,OnError,The length of the statement  "            } while (Interlocked.CompareExchange(ref _current' new FastSubjectHelpers<T>.ExceptionedSubject(error)' original) != original);" is 127.
Long Statement,BTDB.Service,DefaultServiceFieldHandlerFactory,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\DefaultServiceFieldHandlerFactory.cs,CreateFromName,The length of the statement  "            if (handlerName == ServiceObjectFieldHandler.HandlerName) return new ServiceObjectFieldHandler(_service' configuration);" is 120.
Long Statement,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The length of the statement  "                    resultFieldHandler.Save(ilGenerator' il => il.Ldloc(resultFieldHandler.NeedsCtx() ? localWriterCtx : localWriter)' il => il.Ldloc(localResult));" is 144.
Long Statement,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,CreateTaskContinuationWithResultMarshaling,The length of the statement  "                resultFieldHandler.Save(ilGenerator' il => il.Ldloc(resultFieldHandler.NeedsCtx() ? localWriterCtx : localWriter)' il =>" is 120.
Long Statement,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The length of the statement  "                var methodBuilder = tb.DefineMethod(methodInfo.Name' methodInfo.ReturnType' parameterTypes' MethodAttributes.Public | MethodAttributes.Virtual);" is 144.
Long Statement,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The length of the statement  "                                                new[] { typeof(object)' typeof(AbstractBufferedReader)' typeof(IServiceInternalClient) }' MethodAttributes.Public | MethodAttributes.Static);" is 141.
Long Statement,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The length of the statement  "                    finalType.GetMethod("HandleResult_" + resultType).CreateDelegate<Action<object' AbstractBufferedReader' IServiceInternalClient>>();" is 131.
Long Statement,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibilityIgnoringName,The length of the statement  "                result = EvaluateCompatibility(to.ResultFieldHandler' from.ResultFieldHandler); // from to is exchanged because return value going back" is 135.
Long Statement,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibility,The length of the statement  "            if (from.Name == to.Name && (from.Configuration == to.Configuration || from.Configuration.SequenceEqual(to.Configuration))) return 10;" is 134.
Long Statement,BTDB.Service,TcpipServer,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\TcpipServer.cs,StartListening,The length of the statement  "            _acceptClientsTask = Task.Factory.StartNew(AcceptNewClients' CancellationToken.None' TaskCreationOptions.LongRunning' TaskScheduler.Default);" is 141.
Long Statement,BTDB.StreamLayer,WindowsPlatformMethods,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\WindowsPlatformMethods.cs,PRead,The length of the statement  "                throw Marshal.GetExceptionForHR(lastError & ushort.MaxValue | -2147024896) ?? new IOException(); //GetHRForLastWin32Error" is 121.
Long Statement,BTDB.StreamLayer,WindowsPlatformMethods,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\WindowsPlatformMethods.cs,RealPath,The length of the statement  "            using (var directoryHandle = CreateFile(opath' 0' 2' IntPtr.Zero' CREATION_DISPOSITION_OPEN_EXISTING' FILE_FLAG_BACKUP_SEMANTICS' IntPtr.Zero))" is 143.
Complex Conditional,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,EraseFromBranch,The conditional expression  "leftPos == 0 && rightPos > 0 && leftChild == IntPtr.Zero && rightChild == IntPtr.Zero"  is complex.
Complex Conditional,BTDB.EventStoreLayer,TypeDescriptorExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeDescriptorExtensions.cs,AppendJsonLike,The conditional expression  "obj.GetType().IsEnum || obj is EnumTypeDescriptor.DynamicEnum || obj is bool ||                 obj is DateTime || obj is Guid"  is complex.
Complex Conditional,BTDB.IL,EmitHelpers,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateJumpIfEqual,The conditional expression  "type == typeof(sbyte) || type == typeof(byte) || type == typeof(short) || type == typeof(ushort)                 || type == typeof(int) || type == typeof(uint) || type == typeof(long) || type == typeof(ulong)                 || type == typeof(float) || type == typeof(double) || type == typeof(bool) || type.IsEnum"  is complex.
Complex Conditional,BTDB.IOC,OptionalImpl,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IOC\GenerationContext.cs,GenMain,The conditional expression  "type.IsValueType && value != null && !type.IsPrimitive && !type.IsEnum"  is complex.
Complex Conditional,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The conditional expression  "tempbuf[0] != 'B' || tempbuf[1] != 'T' || tempbuf[2] != 'D' || tempbuf[3] != 'B' || tempbuf[4] != 'E' || tempbuf[5] != 'X' || tempbuf[6] != 'P' || tempbuf[7] != '2'"  is complex.
Complex Conditional,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadInfoAboutFiles,The conditional expression  "openUpToCommitUlong.HasValue || latestTrLogFileId != firstTrLogId && firstTrLogId != 0 ||                     !hasKeyIndex && _fileCollection.FileInfos.Any(p => p.Value.SubDBId == 0)"  is complex.
Complex Conditional,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadInfoAboutFiles,The conditional expression  "openUpToCommitUlong.HasValue || lastestTrLogFileId != firstTrLogId && firstTrLogId != 0 || !hasKeyIndex && _fileCollection.FileInfos.Any(p => p.Value.SubDBId == 0)"  is complex.
Complex Conditional,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,BuildRemoveByIdPartialMethod,The conditional expression  "!isPrefixBased || methodParameters.Length == 0 ||                 methodParameters[^1].ParameterType != typeof(int) ||                 methodParameters[^1].Name                     .IndexOf("max"' StringComparison.InvariantCultureIgnoreCase) == -1"  is complex.
Complex Conditional,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,FindClientType,The conditional expression  "method.Name != "Insert" && method.Name != "Update" && method.Name != "Upsert"                     && method.Name != "ShallowUpdate" && method.Name != "ShallowUpsert""  is complex.
Complex Conditional,BTDB.StreamLayer,WindowsPlatformMethods,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\WindowsPlatformMethods.cs,RealPath,The conditional expression  "result[0] == '\\' && result[1] == '\\' && result[2] == '?' && result[3] == '\\'"  is complex.
Empty Catch Block,BTDB.ChunkCache,DiskChunkCache,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,QuickFinishCompaction,The method has an empty catch block.
Empty Catch Block,BTDB.ChunkCache,DiskChunkCache,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,Get,The method has an empty catch block.
Empty Catch Block,BTDB.EventStoreLayer,TypeSerializers,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,LoaderFactory,The method has an empty catch block.
Empty Catch Block,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,SendDataIgnoringExceptions,The method has an empty catch block.
Empty Catch Block,BTDB.Service,Client,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\TcpipServer.cs,Dispose,The method has an empty catch block.
Empty Catch Block,BTDB.Service,Client,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\TcpipServer.cs,Dispose,The method has an empty catch block.
Magic Number,BTDB.Allocators,LeakDetectorWrapperAllocator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Allocators\LeakDetectorWrapperAllocator.cs,Allocate,The following statement contains a magic number: var res = _wrapped.Allocate(size + 32);
Magic Number,BTDB.Allocators,LeakDetectorWrapperAllocator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Allocators\LeakDetectorWrapperAllocator.cs,Allocate,The following statement contains a magic number: new Span<byte>(res.ToPointer()' 16).Fill(0xBB);
Magic Number,BTDB.Allocators,LeakDetectorWrapperAllocator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Allocators\LeakDetectorWrapperAllocator.cs,Allocate,The following statement contains a magic number: new Span<byte>((res + 16).ToPointer()' size.ToInt32()).Fill(255);
Magic Number,BTDB.Allocators,LeakDetectorWrapperAllocator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Allocators\LeakDetectorWrapperAllocator.cs,Allocate,The following statement contains a magic number: new Span<byte>((res + 16).ToPointer()' size.ToInt32()).Fill(255);
Magic Number,BTDB.Allocators,LeakDetectorWrapperAllocator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Allocators\LeakDetectorWrapperAllocator.cs,Allocate,The following statement contains a magic number: new Span<byte>((res + size.ToInt32() + 16).ToPointer()' 16).Fill(0xEE);
Magic Number,BTDB.Allocators,LeakDetectorWrapperAllocator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Allocators\LeakDetectorWrapperAllocator.cs,Allocate,The following statement contains a magic number: new Span<byte>((res + size.ToInt32() + 16).ToPointer()' 16).Fill(0xEE);
Magic Number,BTDB.Allocators,LeakDetectorWrapperAllocator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Allocators\LeakDetectorWrapperAllocator.cs,Allocate,The following statement contains a magic number: res += 16;
Magic Number,BTDB.Allocators,LeakDetectorWrapperAllocator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Allocators\LeakDetectorWrapperAllocator.cs,Deallocate,The following statement contains a magic number: ptr -= 16;
Magic Number,BTDB.Allocators,LeakDetectorWrapperAllocator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Allocators\LeakDetectorWrapperAllocator.cs,Deallocate,The following statement contains a magic number: var span = new Span<byte>(ptr.ToPointer()' 16);
Magic Number,BTDB.Allocators,LeakDetectorWrapperAllocator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Allocators\LeakDetectorWrapperAllocator.cs,Deallocate,The following statement contains a magic number: i < 16
Magic Number,BTDB.Allocators,LeakDetectorWrapperAllocator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Allocators\LeakDetectorWrapperAllocator.cs,Deallocate,The following statement contains a magic number: span = new Span<byte>((ptr + size.ToInt32() + 16).ToPointer()' 16);
Magic Number,BTDB.Allocators,LeakDetectorWrapperAllocator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Allocators\LeakDetectorWrapperAllocator.cs,Deallocate,The following statement contains a magic number: span = new Span<byte>((ptr + size.ToInt32() + 16).ToPointer()' 16);
Magic Number,BTDB.Allocators,LeakDetectorWrapperAllocator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Allocators\LeakDetectorWrapperAllocator.cs,Deallocate,The following statement contains a magic number: i < 16
Magic Number,BTDB.Allocators,LeakDetectorWrapperAllocator,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Allocators\LeakDetectorWrapperAllocator.cs,Deallocate,The following statement contains a magic number: new Span<byte>(ptr.ToPointer()' (int)size + 32).Fill(0xDD);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,AllocateNode,The following statement contains a magic number: totalSuffixSpace = (uint)maxChildren * 2 + 2 + suffixLength;
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,AllocateNode,The following statement contains a magic number: totalSuffixSpace = (uint)maxChildren * 2 + 2 + suffixLength;
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,AllocateNode,The following statement contains a magic number: var size = baseSize + TreeNodeUtils.AlignUIntUpInt32(totalSuffixSpace + keyPrefixLength) +                         (nodeType.HasFlag(NodeType12.IsLeaf) ? 12 : 0);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,AllocateNode,The following statement contains a magic number: size += 4;
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,AllocateNode,The following statement contains a magic number: new Span<byte>(node.ToPointer()' baseSize).Slice(16).Clear();
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,AllocateNode,The following statement contains a magic number: baseSize += 4;
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,AllocateNode,The following statement contains a magic number: Unsafe.InitBlockUnaligned((node + baseSize).ToPointer()' 0' (uint)maxChildren * 2 + 2);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,AllocateNode,The following statement contains a magic number: Unsafe.InitBlockUnaligned((node + baseSize).ToPointer()' 0' (uint)maxChildren * 2 + 2);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,AllocateNode,The following statement contains a magic number: Unsafe.InitBlock((node + 16).ToPointer()' 255' 256);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,AllocateNode,The following statement contains a magic number: Unsafe.InitBlock((node + 16).ToPointer()' 255' 256);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,AllocateNode,The following statement contains a magic number: Unsafe.InitBlock((node + 16).ToPointer()' 255' 256);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,AllocateNode,The following statement contains a magic number: var p = (uint*)(node + 16).ToPointer();
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,AllocateNode,The following statement contains a magic number: p += 3;
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,AllocateNode,The following statement contains a magic number: i < 256
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetStartPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeType12.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeType12.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetStartPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeType12.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeType12.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetStartPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeType12.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeType12.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetStartPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeType12.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeType12.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetStartPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeType12.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeType12.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetStartPosAndByteSkipLeaf,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeType12.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeType12.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetStartPosAndByteSkipLeaf,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeType12.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeType12.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetStartPosAndByteSkipLeaf,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeType12.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeType12.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetStartPosAndByteSkipLeaf,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeType12.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeType12.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetStartPosAndByteSkipLeaf,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeType12.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeType12.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetEndPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     return (-1' 0);                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         var pos = header._childCount - 1;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeType12.Node48:                     for (var i = 255; i >= 0; i--)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeType12.Node256:                     for (var i = 255; i >= 0; i--)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetEndPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     return (-1' 0);                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         var pos = header._childCount - 1;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeType12.Node48:                     for (var i = 255; i >= 0; i--)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeType12.Node256:                     for (var i = 255; i >= 0; i--)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetEndPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     return (-1' 0);                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         var pos = header._childCount - 1;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeType12.Node48:                     for (var i = 255; i >= 0; i--)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeType12.Node256:                     for (var i = 255; i >= 0; i--)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetEndPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     return (-1' 0);                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         var pos = header._childCount - 1;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeType12.Node48:                     for (var i = 255; i >= 0; i--)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeType12.Node256:                     for (var i = 255; i >= 0; i--)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetEndPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     return (-1' 0);                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         var pos = header._childCount - 1;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeType12.Node48:                     for (var i = 255; i >= 0; i--)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeType12.Node256:                     for (var i = 255; i >= 0; i--)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     for (var i = leftPos; i <= rightPos; i++)                     {                         willBeChildCount--;                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             children += (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                         }                         else                         {                             children++;                         }                     }                      break;                 case NodeType12.Node48:                     unsafe                     {                         var span = new Span<byte>((node + 16).ToPointer()' 256);                         for (int i = leftByte; i <= rightByte; i++)                         {                             if (span[i] == 255)                                 continue;                             willBeChildCount--;                             if (IsPtr(NodeUtils12.PtrInNode(node' span[i])' out var ptr))                             {                                 children += (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                             }                             else                             {                                 children++;                             }                         }                     }                      break;                 case NodeType12.Node256:                     for (int j = leftByte; j <= rightByte; j++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' j)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                             children += (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                         }                         else                         {                             children++;                         }                          willBeChildCount--;                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     for (var i = leftPos; i <= rightPos; i++)                     {                         willBeChildCount--;                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             children += (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                         }                         else                         {                             children++;                         }                     }                      break;                 case NodeType12.Node48:                     unsafe                     {                         var span = new Span<byte>((node + 16).ToPointer()' 256);                         for (int i = leftByte; i <= rightByte; i++)                         {                             if (span[i] == 255)                                 continue;                             willBeChildCount--;                             if (IsPtr(NodeUtils12.PtrInNode(node' span[i])' out var ptr))                             {                                 children += (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                             }                             else                             {                                 children++;                             }                         }                     }                      break;                 case NodeType12.Node256:                     for (int j = leftByte; j <= rightByte; j++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' j)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                             children += (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                         }                         else                         {                             children++;                         }                          willBeChildCount--;                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     for (var i = leftPos; i <= rightPos; i++)                     {                         willBeChildCount--;                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             children += (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                         }                         else                         {                             children++;                         }                     }                      break;                 case NodeType12.Node48:                     unsafe                     {                         var span = new Span<byte>((node + 16).ToPointer()' 256);                         for (int i = leftByte; i <= rightByte; i++)                         {                             if (span[i] == 255)                                 continue;                             willBeChildCount--;                             if (IsPtr(NodeUtils12.PtrInNode(node' span[i])' out var ptr))                             {                                 children += (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                             }                             else                             {                                 children++;                             }                         }                     }                      break;                 case NodeType12.Node256:                     for (int j = leftByte; j <= rightByte; j++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' j)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                             children += (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                         }                         else                         {                             children++;                         }                          willBeChildCount--;                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The following statement contains a magic number: willBeChildCount > 48
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  TreeNodeUtils.MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 TreeNodeUtils.MoveMemory(NodeUtils12.PtrInNode(node' rightPos + 1)' NodeUtils12.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeType12.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtils12.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeType12.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  TreeNodeUtils.MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 TreeNodeUtils.MoveMemory(NodeUtils12.PtrInNode(node' rightPos + 1)' NodeUtils12.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeType12.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtils12.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeType12.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  TreeNodeUtils.MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 TreeNodeUtils.MoveMemory(NodeUtils12.PtrInNode(node' rightPos + 1)' NodeUtils12.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeType12.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtils12.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeType12.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  TreeNodeUtils.MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 TreeNodeUtils.MoveMemory(NodeUtils12.PtrInNode(node' rightPos + 1)' NodeUtils12.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeType12.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtils12.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeType12.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  TreeNodeUtils.MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 TreeNodeUtils.MoveMemory(NodeUtils12.PtrInNode(node' rightPos + 1)' NodeUtils12.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeType12.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtils12.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeType12.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  TreeNodeUtils.MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 TreeNodeUtils.MoveMemory(NodeUtils12.PtrInNode(node' rightPos + 1)' NodeUtils12.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeType12.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtils12.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeType12.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  TreeNodeUtils.MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 TreeNodeUtils.MoveMemory(NodeUtils12.PtrInNode(node' rightPos + 1)' NodeUtils12.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeType12.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtils12.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeType12.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  TreeNodeUtils.MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 TreeNodeUtils.MoveMemory(NodeUtils12.PtrInNode(node' rightPos + 1)' NodeUtils12.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeType12.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtils12.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeType12.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  TreeNodeUtils.MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 TreeNodeUtils.MoveMemory(NodeUtils12.PtrInNode(node' rightPos + 1)' NodeUtils12.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeType12.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtils12.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeType12.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  TreeNodeUtils.MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 TreeNodeUtils.MoveMemory(NodeUtils12.PtrInNode(node' rightPos + 1)' NodeUtils12.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeType12.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtils12.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeType12.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  TreeNodeUtils.MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 TreeNodeUtils.MoveMemory(NodeUtils12.PtrInNode(node' rightPos + 1)' NodeUtils12.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeType12.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtils12.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeType12.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     var child = NodeUtils12.Read12Ptr(ptrInNode);                                     if (child != IntPtr.Zero)                                         res += (long)NodeUtils12.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     var child = NodeUtils12.Read12Ptr(ptrInNode);                                     if (child != IntPtr.Zero)                                         res += (long)NodeUtils12.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     var child = NodeUtils12.Read12Ptr(ptrInNode);                                     if (child != IntPtr.Zero)                                         res += (long)NodeUtils12.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     var child = NodeUtils12.Read12Ptr(ptrInNode);                                     if (child != IntPtr.Zero)                                         res += (long)NodeUtils12.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     var child = NodeUtils12.Read12Ptr(ptrInNode);                                     if (child != IntPtr.Zero)                                         res += (long)NodeUtils12.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     var child = NodeUtils12.Read12Ptr(ptrInNode);                                     if (child != IntPtr.Zero)                                         res += (long)NodeUtils12.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     var child = NodeUtils12.Read12Ptr(ptrInNode);                                     if (child != IntPtr.Zero)                                         res += (long)NodeUtils12.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     var child = NodeUtils12.Read12Ptr(ptrInNode);                                     if (child != IntPtr.Zero)                                         res += (long)NodeUtils12.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     var child = NodeUtils12.Read12Ptr(ptrInNode);                                     if (child != IntPtr.Zero)                                         res += (long)NodeUtils12.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     var child = NodeUtils12.Read12Ptr(ptrInNode);                                     if (child != IntPtr.Zero)                                         res += (long)NodeUtils12.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     var child = NodeUtils12.Read12Ptr(ptrInNode);                                     if (child != IntPtr.Zero)                                         res += (long)NodeUtils12.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     var child = NodeUtils12.Read12Ptr(ptrInNode);                                     if (child != IntPtr.Zero)                                         res += (long)NodeUtils12.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     var child = NodeUtils12.Read12Ptr(ptrInNode);                                     if (child != IntPtr.Zero)                                         res += (long)NodeUtils12.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     var child = NodeUtils12.Read12Ptr(ptrInNode);                                     if (child != IntPtr.Zero)                                         res += (long)NodeUtils12.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     var child = NodeUtils12.Read12Ptr(ptrInNode);                                     if (child != IntPtr.Zero)                                         res += (long)NodeUtils12.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     var child = NodeUtils12.Read12Ptr(ptrInNode);                                     if (child != IntPtr.Zero)                                         res += (long)NodeUtils12.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,SeekIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         for (int j = 0; j < header._childCount; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     return true;                                 }                                  index--;                             }                         }                          break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 if (IsPtr(NodeUtils12.PtrInNode(top' span[j])' out var ptr))                                 {                                     var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                     if (index < rcc)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         top = ptr;                                         break;                                     }                                      index -= rcc;                                 }                                 else                                 {                                     if (index == 0)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         return true;                                     }                                      index--;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         for (int j = 0; j < 256; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                     continue;                                 var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     return true;                                 }                                  index--;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,SeekIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         for (int j = 0; j < header._childCount; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     return true;                                 }                                  index--;                             }                         }                          break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 if (IsPtr(NodeUtils12.PtrInNode(top' span[j])' out var ptr))                                 {                                     var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                     if (index < rcc)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         top = ptr;                                         break;                                     }                                      index -= rcc;                                 }                                 else                                 {                                     if (index == 0)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         return true;                                     }                                      index--;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         for (int j = 0; j < 256; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                     continue;                                 var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     return true;                                 }                                  index--;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,SeekIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         for (int j = 0; j < header._childCount; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     return true;                                 }                                  index--;                             }                         }                          break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 if (IsPtr(NodeUtils12.PtrInNode(top' span[j])' out var ptr))                                 {                                     var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                     if (index < rcc)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         top = ptr;                                         break;                                     }                                      index -= rcc;                                 }                                 else                                 {                                     if (index == 0)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         return true;                                     }                                      index--;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         for (int j = 0; j < 256; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                     continue;                                 var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     return true;                                 }                                  index--;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,SeekIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         for (int j = 0; j < header._childCount; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     return true;                                 }                                  index--;                             }                         }                          break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 if (IsPtr(NodeUtils12.PtrInNode(top' span[j])' out var ptr))                                 {                                     var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                     if (index < rcc)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         top = ptr;                                         break;                                     }                                      index -= rcc;                                 }                                 else                                 {                                     if (index == 0)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         return true;                                     }                                      index--;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         for (int j = 0; j < 256; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                     continue;                                 var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     return true;                                 }                                  index--;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,SeekIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         for (int j = 0; j < header._childCount; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     return true;                                 }                                  index--;                             }                         }                          break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 if (IsPtr(NodeUtils12.PtrInNode(top' span[j])' out var ptr))                                 {                                     var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                     if (index < rcc)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         top = ptr;                                         break;                                     }                                      index -= rcc;                                 }                                 else                                 {                                     if (index == 0)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         return true;                                     }                                      index--;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         for (int j = 0; j < 256; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                     continue;                                 var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     return true;                                 }                                  index--;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,SeekIndex,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         for (int j = 0; j < header._childCount; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     return true;                                 }                                  index--;                             }                         }                          break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 if (IsPtr(NodeUtils12.PtrInNode(top' span[j])' out var ptr))                                 {                                     var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                     if (index < rcc)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         top = ptr;                                         break;                                     }                                      index -= rcc;                                 }                                 else                                 {                                     if (index == 0)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         return true;                                     }                                      index--;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         for (int j = 0; j < 256; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                     continue;                                 var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     return true;                                 }                                  index--;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,MoveNext,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.NodeLeaf:                         goto up;                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (stackItem._posInNode == header._childCount - 1)                             {                                 goto up;                             }                              stackItem._posInNode++;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeType12.Node256:                         for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                                  stackItem._posInNode = (short)j;                                 stackItem._byte = (byte)j;                                 PushLeftMost(ptr2' (int)stackItem._keyOffset' ref stack);                                 return true;                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             return true;                         }                          goto up;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,MoveNext,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.NodeLeaf:                         goto up;                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (stackItem._posInNode == header._childCount - 1)                             {                                 goto up;                             }                              stackItem._posInNode++;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeType12.Node256:                         for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                                  stackItem._posInNode = (short)j;                                 stackItem._byte = (byte)j;                                 PushLeftMost(ptr2' (int)stackItem._keyOffset' ref stack);                                 return true;                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             return true;                         }                          goto up;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,MoveNext,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.NodeLeaf:                         goto up;                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (stackItem._posInNode == header._childCount - 1)                             {                                 goto up;                             }                              stackItem._posInNode++;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeType12.Node256:                         for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                                  stackItem._posInNode = (short)j;                                 stackItem._byte = (byte)j;                                 PushLeftMost(ptr2' (int)stackItem._keyOffset' ref stack);                                 return true;                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             return true;                         }                          goto up;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,MoveNext,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.NodeLeaf:                         goto up;                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (stackItem._posInNode == header._childCount - 1)                             {                                 goto up;                             }                              stackItem._posInNode++;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeType12.Node256:                         for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                                  stackItem._posInNode = (short)j;                                 stackItem._byte = (byte)j;                                 PushLeftMost(ptr2' (int)stackItem._keyOffset' ref stack);                                 return true;                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             return true;                         }                          goto up;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,MoveNext,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.NodeLeaf:                         goto up;                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (stackItem._posInNode == header._childCount - 1)                             {                                 goto up;                             }                              stackItem._posInNode++;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeType12.Node256:                         for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                                  stackItem._posInNode = (short)j;                                 stackItem._byte = (byte)j;                                 PushLeftMost(ptr2' (int)stackItem._keyOffset' ref stack);                                 return true;                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             return true;                         }                          goto up;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,MoveNext,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.NodeLeaf:                         goto up;                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (stackItem._posInNode == header._childCount - 1)                             {                                 goto up;                             }                              stackItem._posInNode++;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeType12.Node256:                         for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                                  stackItem._posInNode = (short)j;                                 stackItem._byte = (byte)j;                                 PushLeftMost(ptr2' (int)stackItem._keyOffset' ref stack);                                 return true;                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             return true;                         }                          goto up;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,MovePrevious,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (stackItem._posInNode == 0)                             {                                 goto up;                             }                              stackItem._posInNode--;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = stackItem._byte - 1; j >= 0; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeType12.Node256:                         for (int j = stackItem._byte - 1; j >= 0; j--)                         {                             if (IsPtr(NodeUtils12.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             goto down;                         }                          goto up;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,MovePrevious,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (stackItem._posInNode == 0)                             {                                 goto up;                             }                              stackItem._posInNode--;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = stackItem._byte - 1; j >= 0; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeType12.Node256:                         for (int j = stackItem._byte - 1; j >= 0; j--)                         {                             if (IsPtr(NodeUtils12.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             goto down;                         }                          goto up;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,MovePrevious,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (stackItem._posInNode == 0)                             {                                 goto up;                             }                              stackItem._posInNode--;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = stackItem._byte - 1; j >= 0; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeType12.Node256:                         for (int j = stackItem._byte - 1; j >= 0; j--)                         {                             if (IsPtr(NodeUtils12.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             goto down;                         }                          goto up;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,MovePrevious,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (stackItem._posInNode == 0)                             {                                 goto up;                             }                              stackItem._posInNode--;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = stackItem._byte - 1; j >= 0; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeType12.Node256:                         for (int j = stackItem._byte - 1; j >= 0; j--)                         {                             if (IsPtr(NodeUtils12.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             goto down;                         }                          goto up;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CloneNode,The following statement contains a magic number: ptr += 2 * maxChildren;
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CloneNode,The following statement contains a magic number: ptr += 2 + totalSuffixSize;
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CloneNode,The following statement contains a magic number: ptr += 12;
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node16:                     {                         TreeNodeUtils.CopyMemory(nodePtr + 16' newNode + 16' 4);                         TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 4 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 4; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 16' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 4));                             }                         break;                     }                 case NodeType12.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 16 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 16; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 48' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 16));                             }                         break;                     }                 case NodeType12.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' pos)' NodeUtils12.PtrInNode(newNode' i)' PtrSize);                             if (suffixSize > 0) NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 256' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' pos' 48));                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node16:                     {                         TreeNodeUtils.CopyMemory(nodePtr + 16' newNode + 16' 4);                         TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 4 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 4; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 16' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 4));                             }                         break;                     }                 case NodeType12.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 16 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 16; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 48' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 16));                             }                         break;                     }                 case NodeType12.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' pos)' NodeUtils12.PtrInNode(newNode' i)' PtrSize);                             if (suffixSize > 0) NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 256' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' pos' 48));                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node16:                     {                         TreeNodeUtils.CopyMemory(nodePtr + 16' newNode + 16' 4);                         TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 4 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 4; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 16' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 4));                             }                         break;                     }                 case NodeType12.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 16 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 16; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 48' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 16));                             }                         break;                     }                 case NodeType12.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' pos)' NodeUtils12.PtrInNode(newNode' i)' PtrSize);                             if (suffixSize > 0) NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 256' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' pos' 48));                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node16:                     {                         TreeNodeUtils.CopyMemory(nodePtr + 16' newNode + 16' 4);                         TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 4 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 4; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 16' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 4));                             }                         break;                     }                 case NodeType12.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 16 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 16; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 48' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 16));                             }                         break;                     }                 case NodeType12.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' pos)' NodeUtils12.PtrInNode(newNode' i)' PtrSize);                             if (suffixSize > 0) NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 256' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' pos' 48));                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node16:                     {                         TreeNodeUtils.CopyMemory(nodePtr + 16' newNode + 16' 4);                         TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 4 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 4; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 16' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 4));                             }                         break;                     }                 case NodeType12.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 16 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 16; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 48' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 16));                             }                         break;                     }                 case NodeType12.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' pos)' NodeUtils12.PtrInNode(newNode' i)' PtrSize);                             if (suffixSize > 0) NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 256' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' pos' 48));                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node16:                     {                         TreeNodeUtils.CopyMemory(nodePtr + 16' newNode + 16' 4);                         TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 4 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 4; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 16' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 4));                             }                         break;                     }                 case NodeType12.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 16 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 16; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 48' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 16));                             }                         break;                     }                 case NodeType12.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' pos)' NodeUtils12.PtrInNode(newNode' i)' PtrSize);                             if (suffixSize > 0) NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 256' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' pos' 48));                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node16:                     {                         TreeNodeUtils.CopyMemory(nodePtr + 16' newNode + 16' 4);                         TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 4 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 4; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 16' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 4));                             }                         break;                     }                 case NodeType12.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 16 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 16; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 48' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 16));                             }                         break;                     }                 case NodeType12.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' pos)' NodeUtils12.PtrInNode(newNode' i)' PtrSize);                             if (suffixSize > 0) NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 256' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' pos' 48));                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node16:                     {                         TreeNodeUtils.CopyMemory(nodePtr + 16' newNode + 16' 4);                         TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 4 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 4; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 16' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 4));                             }                         break;                     }                 case NodeType12.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 16 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 16; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 48' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 16));                             }                         break;                     }                 case NodeType12.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' pos)' NodeUtils12.PtrInNode(newNode' i)' PtrSize);                             if (suffixSize > 0) NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 256' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' pos' 48));                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node16:                     {                         TreeNodeUtils.CopyMemory(nodePtr + 16' newNode + 16' 4);                         TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 4 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 4; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 16' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 4));                             }                         break;                     }                 case NodeType12.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 16 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 16; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 48' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 16));                             }                         break;                     }                 case NodeType12.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' pos)' NodeUtils12.PtrInNode(newNode' i)' PtrSize);                             if (suffixSize > 0) NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 256' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' pos' 48));                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node16:                     {                         TreeNodeUtils.CopyMemory(nodePtr + 16' newNode + 16' 4);                         TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 4 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 4; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 16' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 4));                             }                         break;                     }                 case NodeType12.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 16 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 16; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 48' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 16));                             }                         break;                     }                 case NodeType12.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' pos)' NodeUtils12.PtrInNode(newNode' i)' PtrSize);                             if (suffixSize > 0) NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 256' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' pos' 48));                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node16:                     {                         TreeNodeUtils.CopyMemory(nodePtr + 16' newNode + 16' 4);                         TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 4 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 4; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 16' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 4));                             }                         break;                     }                 case NodeType12.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 16 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 16; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 48' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 16));                             }                         break;                     }                 case NodeType12.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' pos)' NodeUtils12.PtrInNode(newNode' i)' PtrSize);                             if (suffixSize > 0) NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 256' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' pos' 48));                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node16:                     {                         TreeNodeUtils.CopyMemory(nodePtr + 16' newNode + 16' 4);                         TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 4 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 4; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 16' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 4));                             }                         break;                     }                 case NodeType12.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 16 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 16; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 48' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 16));                             }                         break;                     }                 case NodeType12.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' pos)' NodeUtils12.PtrInNode(newNode' i)' PtrSize);                             if (suffixSize > 0) NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 256' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' pos' 48));                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node16:                     {                         TreeNodeUtils.CopyMemory(nodePtr + 16' newNode + 16' 4);                         TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 4 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 4; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 16' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 4));                             }                         break;                     }                 case NodeType12.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 16 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 16; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 48' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 16));                             }                         break;                     }                 case NodeType12.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' pos)' NodeUtils12.PtrInNode(newNode' i)' PtrSize);                             if (suffixSize > 0) NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 256' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' pos' 48));                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node16:                     {                         TreeNodeUtils.CopyMemory(nodePtr + 16' newNode + 16' 4);                         TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 4 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 4; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 16' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 4));                             }                         break;                     }                 case NodeType12.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 16 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 16; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 48' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 16));                             }                         break;                     }                 case NodeType12.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' pos)' NodeUtils12.PtrInNode(newNode' i)' PtrSize);                             if (suffixSize > 0) NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 256' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' pos' 48));                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node16:                     {                         TreeNodeUtils.CopyMemory(nodePtr + 16' newNode + 16' 4);                         TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 4 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 4; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 16' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 4));                             }                         break;                     }                 case NodeType12.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 16 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 16; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 48' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 16));                             }                         break;                     }                 case NodeType12.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' pos)' NodeUtils12.PtrInNode(newNode' i)' PtrSize);                             if (suffixSize > 0) NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 256' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' pos' 48));                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node16:                     {                         TreeNodeUtils.CopyMemory(nodePtr + 16' newNode + 16' 4);                         TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 4 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 4; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 16' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 4));                             }                         break;                     }                 case NodeType12.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 16 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 16; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 48' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 16));                             }                         break;                     }                 case NodeType12.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' pos)' NodeUtils12.PtrInNode(newNode' i)' PtrSize);                             if (suffixSize > 0) NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 256' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' pos' 48));                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node16:                     {                         TreeNodeUtils.CopyMemory(nodePtr + 16' newNode + 16' 4);                         TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 4 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 4; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 16' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 4));                             }                         break;                     }                 case NodeType12.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 16 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 16; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 48' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 16));                             }                         break;                     }                 case NodeType12.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' pos)' NodeUtils12.PtrInNode(newNode' i)' PtrSize);                             if (suffixSize > 0) NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 256' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' pos' 48));                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node16:                     {                         TreeNodeUtils.CopyMemory(nodePtr + 16' newNode + 16' 4);                         TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 4 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 4; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 16' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 4));                             }                         break;                     }                 case NodeType12.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 16 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 16; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 48' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 16));                             }                         break;                     }                 case NodeType12.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' pos)' NodeUtils12.PtrInNode(newNode' i)' PtrSize);                             if (suffixSize > 0) NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 256' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' pos' 48));                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node16:                     {                         TreeNodeUtils.CopyMemory(nodePtr + 16' newNode + 16' 4);                         TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 4 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 4; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 16' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 4));                             }                         break;                     }                 case NodeType12.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' 0)' NodeUtils12.PtrInNode(newNode' 0)' 16 * PtrSize);                         if (suffixSize > 0) for (var i = 0; i < 16; i++)                             {                                 NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 48' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' i' 16));                             }                         break;                     }                 case NodeType12.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             TreeNodeUtils.CopyMemory(NodeUtils12.PtrInNode(nodePtr' pos)' NodeUtils12.PtrInNode(newNode' i)' PtrSize);                             if (suffixSize > 0) NodeUtils12.SetSuffix(newTotalSuffixPtr' i' 256' NodeUtils12.GetSuffixSizeAndPtr(totalSuffixPtr' pos' 48));                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 12;                         for (; p != limit; p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeType12.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 case NodeType12.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 12)                         {                             if (NodeUtils12.IsPtr12Ptr(p))                             {                                 Dereference(NodeUtils12.Read12Ptr(p));                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CheckContent12,The following statement contains a magic number: content.Length != 12
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,WriteValue,The following statement contains a magic number: content.CopyTo(new Span<byte>(ptr.ToPointer()' 12));
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,WritePtrAndByteInNode,The following statement contains a magic number: TreeNodeUtils.WriteByte(stackItem._node' 16 + stackItem._posInNode' stackItem._byte);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,WritePtrInNode,The following statement contains a magic number: TreeNodeUtils.WriteIntPtrUnaligned(ptrInNode + 4' newNode);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,WriteContentAndByteInNode,The following statement contains a magic number: TreeNodeUtils.WriteByte(stackItem._node' 16 + stackItem._posInNode' stackItem._byte);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,WriteContentInNode,The following statement contains a magic number: content.CopyTo(new Span<byte>(ptr.ToPointer()' 12));
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,InitializeZeroPtrValue,The following statement contains a magic number: var v = new Span<uint>(ptr.ToPointer()' 3);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,InitializeZeroPtrValue,The following statement contains a magic number: v[2] = 0;
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,FindNearPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         pos = ~pos;                         if (pos >= header._childCount) pos--;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeType12.Node48:                     {                         var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                         pos = @byte + 1;                         while (pos < 256)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos++;                         }                          pos = @byte - 1;                         while (true)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos--;                         }                     }                 case NodeType12.Node256:                     {                         pos = @byte + 1;                         while (pos < 256)                         {                             if (IsPtr(NodeUtils12.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos++;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          pos = @byte - 1;                         while (pos >= 0)                         {                             if (IsPtr(NodeUtils12.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos--;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          break;                     }             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,FindNearPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         pos = ~pos;                         if (pos >= header._childCount) pos--;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeType12.Node48:                     {                         var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                         pos = @byte + 1;                         while (pos < 256)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos++;                         }                          pos = @byte - 1;                         while (true)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos--;                         }                     }                 case NodeType12.Node256:                     {                         pos = @byte + 1;                         while (pos < 256)                         {                             if (IsPtr(NodeUtils12.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos++;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          pos = @byte - 1;                         while (pos >= 0)                         {                             if (IsPtr(NodeUtils12.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos--;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          break;                     }             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,FindNearPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         pos = ~pos;                         if (pos >= header._childCount) pos--;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeType12.Node48:                     {                         var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                         pos = @byte + 1;                         while (pos < 256)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos++;                         }                          pos = @byte - 1;                         while (true)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos--;                         }                     }                 case NodeType12.Node256:                     {                         pos = @byte + 1;                         while (pos < 256)                         {                             if (IsPtr(NodeUtils12.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos++;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          pos = @byte - 1;                         while (pos >= 0)                         {                             if (IsPtr(NodeUtils12.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos--;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          break;                     }             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,FindNearPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         pos = ~pos;                         if (pos >= header._childCount) pos--;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeType12.Node48:                     {                         var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                         pos = @byte + 1;                         while (pos < 256)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos++;                         }                          pos = @byte - 1;                         while (true)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos--;                         }                     }                 case NodeType12.Node256:                     {                         pos = @byte + 1;                         while (pos < 256)                         {                             if (IsPtr(NodeUtils12.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos++;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          pos = @byte - 1;                         while (pos >= 0)                         {                             if (IsPtr(NodeUtils12.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos--;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          break;                     }             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,FindNearPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         pos = ~pos;                         if (pos >= header._childCount) pos--;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeType12.Node48:                     {                         var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                         pos = @byte + 1;                         while (pos < 256)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos++;                         }                          pos = @byte - 1;                         while (true)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos--;                         }                     }                 case NodeType12.Node256:                     {                         pos = @byte + 1;                         while (pos < 256)                         {                             if (IsPtr(NodeUtils12.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos++;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          pos = @byte - 1;                         while (pos >= 0)                         {                             if (IsPtr(NodeUtils12.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos--;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          break;                     }             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,FindNearPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         pos = ~pos;                         if (pos >= header._childCount) pos--;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeType12.Node48:                     {                         var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                         pos = @byte + 1;                         while (pos < 256)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos++;                         }                          pos = @byte - 1;                         while (true)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos--;                         }                     }                 case NodeType12.Node256:                     {                         pos = @byte + 1;                         while (pos < 256)                         {                             if (IsPtr(NodeUtils12.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos++;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          pos = @byte - 1;                         while (pos >= 0)                         {                             if (IsPtr(NodeUtils12.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos--;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          break;                     }             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,FindNearPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         pos = ~pos;                         if (pos >= header._childCount) pos--;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeType12.Node48:                     {                         var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                         pos = @byte + 1;                         while (pos < 256)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos++;                         }                          pos = @byte - 1;                         while (true)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos--;                         }                     }                 case NodeType12.Node256:                     {                         pos = @byte + 1;                         while (pos < 256)                         {                             if (IsPtr(NodeUtils12.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos++;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          pos = @byte - 1;                         while (pos >= 0)                         {                             if (IsPtr(NodeUtils12.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos--;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          break;                     }             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 4;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 16;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var ptr = top + 16 + 256 + pos * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptr))                                 {                                     top = NodeUtils12.Read12Ptr(ptr);                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(p))                                 {                                     var child = NodeUtils12.Read12Ptr(p);                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 4;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 16;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var ptr = top + 16 + 256 + pos * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptr))                                 {                                     top = NodeUtils12.Read12Ptr(ptr);                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(p))                                 {                                     var child = NodeUtils12.Read12Ptr(p);                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 4;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 16;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var ptr = top + 16 + 256 + pos * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptr))                                 {                                     top = NodeUtils12.Read12Ptr(ptr);                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(p))                                 {                                     var child = NodeUtils12.Read12Ptr(p);                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 4;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 16;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var ptr = top + 16 + 256 + pos * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptr))                                 {                                     top = NodeUtils12.Read12Ptr(ptr);                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(p))                                 {                                     var child = NodeUtils12.Read12Ptr(p);                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 4;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 16;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var ptr = top + 16 + 256 + pos * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptr))                                 {                                     top = NodeUtils12.Read12Ptr(ptr);                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(p))                                 {                                     var child = NodeUtils12.Read12Ptr(p);                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 4;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 16;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var ptr = top + 16 + 256 + pos * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptr))                                 {                                     top = NodeUtils12.Read12Ptr(ptr);                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(p))                                 {                                     var child = NodeUtils12.Read12Ptr(p);                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 4;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 16;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var ptr = top + 16 + 256 + pos * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptr))                                 {                                     top = NodeUtils12.Read12Ptr(ptr);                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(p))                                 {                                     var child = NodeUtils12.Read12Ptr(p);                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 4;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 16;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var ptr = top + 16 + 256 + pos * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptr))                                 {                                     top = NodeUtils12.Read12Ptr(ptr);                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(p))                                 {                                     var child = NodeUtils12.Read12Ptr(p);                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 4;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 16;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var ptr = top + 16 + 256 + pos * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptr))                                 {                                     top = NodeUtils12.Read12Ptr(ptr);                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(p))                                 {                                     var child = NodeUtils12.Read12Ptr(p);                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 4;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 16;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var ptr = top + 16 + 256 + pos * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptr))                                 {                                     top = NodeUtils12.Read12Ptr(ptr);                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(p))                                 {                                     var child = NodeUtils12.Read12Ptr(p);                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 4;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 16;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var ptr = top + 16 + 256 + pos * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptr))                                 {                                     top = NodeUtils12.Read12Ptr(ptr);                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(p))                                 {                                     var child = NodeUtils12.Read12Ptr(p);                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 4;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 16;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var ptr = top + 16 + 256 + pos * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptr))                                 {                                     top = NodeUtils12.Read12Ptr(ptr);                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(p))                                 {                                     var child = NodeUtils12.Read12Ptr(p);                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 4;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 16;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var ptr = top + 16 + 256 + pos * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptr))                                 {                                     top = NodeUtils12.Read12Ptr(ptr);                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(p))                                 {                                     var child = NodeUtils12.Read12Ptr(p);                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 4;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 16;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var ptr = top + 16 + 256 + pos * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptr))                                 {                                     top = NodeUtils12.Read12Ptr(ptr);                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(p))                                 {                                     var child = NodeUtils12.Read12Ptr(p);                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushRightMost,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             var pos = header._childCount - 1;                             stack.AddRef().Set(top' (uint)keyOffset' (short)pos' TreeNodeUtils.ReadByte(top + 16 + pos));                             if (IsPtr(NodeUtils12.PtrInNode(top' pos)' out var ptr))                             {                                 top = ptr;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 255; true; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' span[j]' (byte)j);                                 if (IsPtr(NodeUtils12.PtrInNode(top' span[j])' out var ptr))                                 {                                     top = ptr;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         for (int j = 255; true; j--)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr != IntPtr.Zero)                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  continue;                             }                             else                             {                                 stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                 return;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushRightMost,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             var pos = header._childCount - 1;                             stack.AddRef().Set(top' (uint)keyOffset' (short)pos' TreeNodeUtils.ReadByte(top + 16 + pos));                             if (IsPtr(NodeUtils12.PtrInNode(top' pos)' out var ptr))                             {                                 top = ptr;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 255; true; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' span[j]' (byte)j);                                 if (IsPtr(NodeUtils12.PtrInNode(top' span[j])' out var ptr))                                 {                                     top = ptr;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         for (int j = 255; true; j--)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr != IntPtr.Zero)                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  continue;                             }                             else                             {                                 stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                 return;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushRightMost,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             var pos = header._childCount - 1;                             stack.AddRef().Set(top' (uint)keyOffset' (short)pos' TreeNodeUtils.ReadByte(top + 16 + pos));                             if (IsPtr(NodeUtils12.PtrInNode(top' pos)' out var ptr))                             {                                 top = ptr;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 255; true; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' span[j]' (byte)j);                                 if (IsPtr(NodeUtils12.PtrInNode(top' span[j])' out var ptr))                                 {                                     top = ptr;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         for (int j = 255; true; j--)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr != IntPtr.Zero)                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  continue;                             }                             else                             {                                 stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                 return;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushRightMost,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             var pos = header._childCount - 1;                             stack.AddRef().Set(top' (uint)keyOffset' (short)pos' TreeNodeUtils.ReadByte(top + 16 + pos));                             if (IsPtr(NodeUtils12.PtrInNode(top' pos)' out var ptr))                             {                                 top = ptr;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 255; true; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' span[j]' (byte)j);                                 if (IsPtr(NodeUtils12.PtrInNode(top' span[j])' out var ptr))                                 {                                     top = ptr;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         for (int j = 255; true; j--)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr != IntPtr.Zero)                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  continue;                             }                             else                             {                                 stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                 return;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushRightMost,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             var pos = header._childCount - 1;                             stack.AddRef().Set(top' (uint)keyOffset' (short)pos' TreeNodeUtils.ReadByte(top + 16 + pos));                             if (IsPtr(NodeUtils12.PtrInNode(top' pos)' out var ptr))                             {                                 top = ptr;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 255; true; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' span[j]' (byte)j);                                 if (IsPtr(NodeUtils12.PtrInNode(top' span[j])' out var ptr))                                 {                                     top = ptr;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         for (int j = 255; true; j--)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr != IntPtr.Zero)                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  continue;                             }                             else                             {                                 stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                 return;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushRightMost,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             var pos = header._childCount - 1;                             stack.AddRef().Set(top' (uint)keyOffset' (short)pos' TreeNodeUtils.ReadByte(top + 16 + pos));                             if (IsPtr(NodeUtils12.PtrInNode(top' pos)' out var ptr))                             {                                 top = ptr;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 255; true; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' span[j]' (byte)j);                                 if (IsPtr(NodeUtils12.PtrInNode(top' span[j])' out var ptr))                                 {                                     top = ptr;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         for (int j = 255; true; j--)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr != IntPtr.Zero)                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  continue;                             }                             else                             {                                 stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                 return;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Upsert,The following statement contains a magic number: keyRest < 256 && stack.Count > 0
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Upsert,The following statement contains a magic number: NodeUtils12.SetSuffix(newSuffixPtr' 0' 4' ((uint)existingSuffix' keyPrefixPtr + newKeyPrefixSize + 1));
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Upsert,The following statement contains a magic number: content.CopyTo(new Span<byte>(newValuePtr.ToPointer()' 12));
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Upsert,The following statement contains a magic number: TreeNodeUtils.WriteByte(newNode' 16' b);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Upsert,The following statement contains a magic number: NodeUtils12.SetSuffix(newNode + 16 + 4 + 4 * 12' 0' 4' key.Slice(keyOffset));
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Upsert,The following statement contains a magic number: NodeUtils12.SetSuffix(newNode + 16 + 4 + 4 * 12' 0' 4' key.Slice(keyOffset));
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Upsert,The following statement contains a magic number: NodeUtils12.SetSuffix(newNode + 16 + 4 + 4 * 12' 0' 4' key.Slice(keyOffset));
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Upsert,The following statement contains a magic number: NodeUtils12.SetSuffix(newNode + 16 + 4 + 4 * 12' 0' 4' key.Slice(keyOffset));
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Upsert,The following statement contains a magic number: NodeUtils12.SetSuffix(newNode + 16 + 4 + 4 * 12' 0' 4' key.Slice(keyOffset));
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Upsert,The following statement contains a magic number: TreeNodeUtils.WriteByte(newNode' 16' b);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Upsert,The following statement contains a magic number: content.CopyTo(new Span<byte>((newNode + 16 + 4).ToPointer()' 12));
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Upsert,The following statement contains a magic number: content.CopyTo(new Span<byte>((newNode + 16 + 4).ToPointer()' 12));
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Upsert,The following statement contains a magic number: content.CopyTo(new Span<byte>((newNode + 16 + 4).ToPointer()' 12));
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Upsert,The following statement contains a magic number: keyRest < 256
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetValueSizeAndPtrFromPtrInNode,The following statement contains a magic number: return (12' ptr);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Find,The following statement contains a magic number: var pos = TreeNodeUtils.ReadByte(nodePtr + 16 + b);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Find,The following statement contains a magic number: pos == 255
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,InsertChildIntoNode4,The following statement contains a magic number: var childernBytes = new ReadOnlySpan<byte>((nodePtr + 16).ToPointer()' header._childCount);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,InsertChildIntoNode4,The following statement contains a magic number: childernBytes.Slice(pos)                     .CopyTo(new Span<byte>((nodePtr + 16).ToPointer()' header._childCount + 1).Slice(pos + 1));
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,InsertChildIntoNode4,The following statement contains a magic number: TreeNodeUtils.MoveMemory(totalSuffixPtr + pos * 2' totalSuffixPtr + pos * 2 + 2' (header._childCount - pos) * 2);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,InsertChildIntoNode4,The following statement contains a magic number: TreeNodeUtils.MoveMemory(totalSuffixPtr + pos * 2' totalSuffixPtr + pos * 2 + 2' (header._childCount - pos) * 2);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,InsertChildIntoNode4,The following statement contains a magic number: TreeNodeUtils.MoveMemory(totalSuffixPtr + pos * 2' totalSuffixPtr + pos * 2 + 2' (header._childCount - pos) * 2);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,InsertChildIntoNode4,The following statement contains a magic number: TreeNodeUtils.MoveMemory(totalSuffixPtr + pos * 2' totalSuffixPtr + pos * 2 + 2' (header._childCount - pos) * 2);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,InsertChildIntoNode4,The following statement contains a magic number: TreeNodeUtils.WriteByte(nodePtr' 16 + pos' b);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,InsertChildRaw,The following statement contains a magic number: TreeNodeUtils.WriteByte(nodePtr' 16 + b' (byte)pos);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,StructureCheck,The following statement contains a magic number: Debug.Assert(header._referenceCount > 0 && header._referenceCount < 2000);
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,StructureCheck,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)              {                 case NodeType12.NodeLeaf:                     childrenCount = 1;                     break;                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' pos)' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeType12.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         StructureCheck48(span' header.ChildCount);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' span[j])' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeType12.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(nodePtr' j)' out var ptr))                         {                             childrenCount += StructureCheck(ptr);                         }                         else                         {                             childrenCount++;                         }                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,StructureCheck,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)              {                 case NodeType12.NodeLeaf:                     childrenCount = 1;                     break;                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' pos)' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeType12.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         StructureCheck48(span' header.ChildCount);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' span[j])' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeType12.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(nodePtr' j)' out var ptr))                         {                             childrenCount += StructureCheck(ptr);                         }                         else                         {                             childrenCount++;                         }                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,StructureCheck,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)              {                 case NodeType12.NodeLeaf:                     childrenCount = 1;                     break;                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' pos)' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeType12.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         StructureCheck48(span' header.ChildCount);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' span[j])' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeType12.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(nodePtr' j)' out var ptr))                         {                             childrenCount += StructureCheck(ptr);                         }                         else                         {                             childrenCount++;                         }                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,StructureCheck,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)              {                 case NodeType12.NodeLeaf:                     childrenCount = 1;                     break;                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' pos)' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeType12.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         StructureCheck48(span' header.ChildCount);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' span[j])' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeType12.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(nodePtr' j)' out var ptr))                         {                             childrenCount += StructureCheck(ptr);                         }                         else                         {                             childrenCount++;                         }                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,StructureCheck,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)              {                 case NodeType12.NodeLeaf:                     childrenCount = 1;                     break;                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' pos)' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeType12.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         StructureCheck48(span' header.ChildCount);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' span[j])' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeType12.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(nodePtr' j)' out var ptr))                         {                             childrenCount += StructureCheck(ptr);                         }                         else                         {                             childrenCount++;                         }                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,StructureCheck,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)              {                 case NodeType12.NodeLeaf:                     childrenCount = 1;                     break;                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' pos)' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeType12.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         StructureCheck48(span' header.ChildCount);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' span[j])' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeType12.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(nodePtr' j)' out var ptr))                         {                             childrenCount += StructureCheck(ptr);                         }                         else                         {                             childrenCount++;                         }                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,StructureCheck48,The following statement contains a magic number: Span<byte> cnts = stackalloc byte[48];
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,StructureCheck48,The following statement contains a magic number: p == 255
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,StructureCheck48,The following statement contains a magic number: i < 256
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,StructureCheck48,The following statement contains a magic number: i < 48
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,IterateNodeInfo,The following statement contains a magic number: ptr += 12;
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,IterateNodeInfo,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     break;                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' pos)' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeType12.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' span[j])' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeType12.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(nodePtr' j)' out ptr))                         {                             IterateNodeInfo(ptr' deepness + 1' iterator);                         }                     }                     break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,IterateNodeInfo,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     break;                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' pos)' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeType12.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' span[j])' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeType12.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(nodePtr' j)' out ptr))                         {                             IterateNodeInfo(ptr' deepness + 1' iterator);                         }                     }                     break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,IterateNodeInfo,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     break;                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' pos)' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeType12.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' span[j])' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeType12.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(nodePtr' j)' out ptr))                         {                             IterateNodeInfo(ptr' deepness + 1' iterator);                         }                     }                     break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,IterateNodeInfo,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     break;                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' pos)' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeType12.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' span[j])' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeType12.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(nodePtr' j)' out ptr))                         {                             IterateNodeInfo(ptr' deepness + 1' iterator);                         }                     }                     break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,IterateNodeInfo,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     break;                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' pos)' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeType12.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' span[j])' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeType12.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(nodePtr' j)' out ptr))                         {                             IterateNodeInfo(ptr' deepness + 1' iterator);                         }                     }                     break;             }
Magic Number,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,IterateNodeInfo,The following statement contains a magic number: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     break;                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' pos)' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeType12.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' span[j])' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeType12.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(nodePtr' j)' out ptr))                         {                             IterateNodeInfo(ptr' deepness + 1' iterator);                         }                     }                     break;             }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeType12.Node16:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeType12.Node48:                         {                             _type = 3;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeType12.Node256:                         {                             _type = 5;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeType12.Node16:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeType12.Node48:                         {                             _type = 3;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeType12.Node256:                         {                             _type = 5;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeType12.Node16:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeType12.Node48:                         {                             _type = 3;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeType12.Node256:                         {                             _type = 5;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeType12.Node16:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeType12.Node48:                         {                             _type = 3;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeType12.Node256:                         {                             _type = 5;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeType12.Node16:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeType12.Node48:                         {                             _type = 3;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeType12.Node256:                         {                             _type = 5;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeType12.Node16:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeType12.Node48:                         {                             _type = 3;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeType12.Node256:                         {                             _type = 5;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeType12.Node16:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeType12.Node48:                         {                             _type = 3;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeType12.Node256:                         {                             _type = 5;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeType12.Node16:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeType12.Node48:                         {                             _type = 3;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeType12.Node256:                         {                             _type = 5;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeType12.Node16:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeType12.Node48:                         {                             _type = 3;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeType12.Node256:                         {                             _type = 5;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeType12.Node16:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeType12.Node48:                         {                             _type = 3;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeType12.Node256:                         {                             _type = 5;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeType12.Node16:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeType12.Node48:                         {                             _type = 3;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeType12.Node256:                         {                             _type = 5;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeType12.Node16:                         {                             _type = 1;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeType12.Node48:                         {                             _type = 3;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeType12.Node256:                         {                             _type = 5;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushPtr,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4' ptr);                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4' ptr);                             _dst += 12;                             break;                         }                     case 5:                         {                             TreeNodeUtils.WriteInt32Aligned(_dst + 12 * @byte' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4 + 12 * @byte' ptr);                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushPtr,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4' ptr);                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4' ptr);                             _dst += 12;                             break;                         }                     case 5:                         {                             TreeNodeUtils.WriteInt32Aligned(_dst + 12 * @byte' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4 + 12 * @byte' ptr);                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushPtr,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4' ptr);                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4' ptr);                             _dst += 12;                             break;                         }                     case 5:                         {                             TreeNodeUtils.WriteInt32Aligned(_dst + 12 * @byte' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4 + 12 * @byte' ptr);                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushPtr,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4' ptr);                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4' ptr);                             _dst += 12;                             break;                         }                     case 5:                         {                             TreeNodeUtils.WriteInt32Aligned(_dst + 12 * @byte' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4 + 12 * @byte' ptr);                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushPtr,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4' ptr);                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4' ptr);                             _dst += 12;                             break;                         }                     case 5:                         {                             TreeNodeUtils.WriteInt32Aligned(_dst + 12 * @byte' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4 + 12 * @byte' ptr);                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushPtr,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4' ptr);                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4' ptr);                             _dst += 12;                             break;                         }                     case 5:                         {                             TreeNodeUtils.WriteInt32Aligned(_dst + 12 * @byte' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4 + 12 * @byte' ptr);                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushPtr,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4' ptr);                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4' ptr);                             _dst += 12;                             break;                         }                     case 5:                         {                             TreeNodeUtils.WriteInt32Aligned(_dst + 12 * @byte' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4 + 12 * @byte' ptr);                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushPtr,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4' ptr);                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4' ptr);                             _dst += 12;                             break;                         }                     case 5:                         {                             TreeNodeUtils.WriteInt32Aligned(_dst + 12 * @byte' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4 + 12 * @byte' ptr);                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushPtr,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4' ptr);                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4' ptr);                             _dst += 12;                             break;                         }                     case 5:                         {                             TreeNodeUtils.WriteInt32Aligned(_dst + 12 * @byte' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4 + 12 * @byte' ptr);                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 5:                         {                             var ofs = 12 * @byte;                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 5:                         {                             var ofs = 12 * @byte;                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 5:                         {                             var ofs = 12 * @byte;                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 5:                         {                             var ofs = 12 * @byte;                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 5:                         {                             var ofs = 12 * @byte;                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 5:                         {                             var ofs = 12 * @byte;                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 5:                         {                             var ofs = 12 * @byte;                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 5:                         {                             var ofs = 12 * @byte;                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 5:                         {                             var ofs = 12 * @byte;                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 5:                         {                             var ofs = 12 * @byte;                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 5:                         {                             var ofs = 12 * @byte;                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 5:                         {                             var ofs = 12 * @byte;                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 5:                         {                             var ofs = 12 * @byte;                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 5:                         {                             var ofs = 12 * @byte;                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 5:                         {                             var ofs = 12 * @byte;                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 5:                         {                             var ofs = 12 * @byte;                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 5:                         {                             var ofs = 12 * @byte;                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeTypeV.Node16:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeTypeV.Node48:                         {                             _type = 2;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeTypeV.Node256:                         {                             _type = 4;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeTypeV.Node16:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeTypeV.Node48:                         {                             _type = 2;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeTypeV.Node256:                         {                             _type = 4;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeTypeV.Node16:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeTypeV.Node48:                         {                             _type = 2;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeTypeV.Node256:                         {                             _type = 4;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeTypeV.Node16:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeTypeV.Node48:                         {                             _type = 2;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeTypeV.Node256:                         {                             _type = 4;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeTypeV.Node16:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeTypeV.Node48:                         {                             _type = 2;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeTypeV.Node256:                         {                             _type = 4;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeTypeV.Node16:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeTypeV.Node48:                         {                             _type = 2;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeTypeV.Node256:                         {                             _type = 4;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeTypeV.Node16:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeTypeV.Node48:                         {                             _type = 2;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeTypeV.Node256:                         {                             _type = 4;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeTypeV.Node16:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeTypeV.Node48:                         {                             _type = 2;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeTypeV.Node256:                         {                             _type = 4;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeTypeV.Node16:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeTypeV.Node48:                         {                             _type = 2;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeTypeV.Node256:                         {                             _type = 4;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeTypeV.Node16:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeTypeV.Node48:                         {                             _type = 2;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeTypeV.Node256:                         {                             _type = 4;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeTypeV.Node16:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeTypeV.Node48:                         {                             _type = 2;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeTypeV.Node256:                         {                             _type = 4;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Pusher,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 4;                             break;                         }                     case NodeTypeV.Node16:                         {                             _type = 0;                             _byteDst = node + 16;                             _dst = node + 16 + 16;                             break;                         }                     case NodeTypeV.Node48:                         {                             _type = 2;                             _byteDst = node + 16;                             _dst = node + 16 + 256;                             break;                         }                     case NodeTypeV.Node256:                         {                             _type = 4;                             _byteDst = node;                             _dst = node + 16;                             break;                         }                     default:                         throw new InvalidOperationException();                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushPtr,The following statement contains a magic number: switch (_type)                 {                     case 0:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' ptr);                             _dst += 8;                             break;                         }                     case 2:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' ptr);                             _dst += 8;                             break;                         }                     case 4:                         {                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 8 * @byte' ptr);                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushPtr,The following statement contains a magic number: switch (_type)                 {                     case 0:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' ptr);                             _dst += 8;                             break;                         }                     case 2:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' ptr);                             _dst += 8;                             break;                         }                     case 4:                         {                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 8 * @byte' ptr);                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushPtr,The following statement contains a magic number: switch (_type)                 {                     case 0:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' ptr);                             _dst += 8;                             break;                         }                     case 2:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' ptr);                             _dst += 8;                             break;                         }                     case 4:                         {                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 8 * @byte' ptr);                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushPtr,The following statement contains a magic number: switch (_type)                 {                     case 0:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' ptr);                             _dst += 8;                             break;                         }                     case 2:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' ptr);                             _dst += 8;                             break;                         }                     case 4:                         {                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 8 * @byte' ptr);                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushPtr,The following statement contains a magic number: switch (_type)                 {                     case 0:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' ptr);                             _dst += 8;                             break;                         }                     case 2:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' ptr);                             _dst += 8;                             break;                         }                     case 4:                         {                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 8 * @byte' ptr);                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 0:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             var p = TreeNodeUtils.ReadIntPtrUnaligned(source);                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' p);                             if (NodeUtilsV.IsPtrPtr(p))                                 NodeUtilsV.Reference(p);                             _dst += 8;                             break;                         }                     case 2:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             var p = TreeNodeUtils.ReadIntPtrUnaligned(source);                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' p);                             if (NodeUtilsV.IsPtrPtr(p))                                 NodeUtilsV.Reference(p);                             _dst += 8;                             break;                         }                     case 4:                         {                             var p = TreeNodeUtils.ReadIntPtrUnaligned(source);                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 8 * @byte' p);                             if (NodeUtilsV.IsPtrPtr(p))                                 NodeUtilsV.Reference(p);                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 0:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             var p = TreeNodeUtils.ReadIntPtrUnaligned(source);                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' p);                             if (NodeUtilsV.IsPtrPtr(p))                                 NodeUtilsV.Reference(p);                             _dst += 8;                             break;                         }                     case 2:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             var p = TreeNodeUtils.ReadIntPtrUnaligned(source);                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' p);                             if (NodeUtilsV.IsPtrPtr(p))                                 NodeUtilsV.Reference(p);                             _dst += 8;                             break;                         }                     case 4:                         {                             var p = TreeNodeUtils.ReadIntPtrUnaligned(source);                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 8 * @byte' p);                             if (NodeUtilsV.IsPtrPtr(p))                                 NodeUtilsV.Reference(p);                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 0:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             var p = TreeNodeUtils.ReadIntPtrUnaligned(source);                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' p);                             if (NodeUtilsV.IsPtrPtr(p))                                 NodeUtilsV.Reference(p);                             _dst += 8;                             break;                         }                     case 2:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             var p = TreeNodeUtils.ReadIntPtrUnaligned(source);                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' p);                             if (NodeUtilsV.IsPtrPtr(p))                                 NodeUtilsV.Reference(p);                             _dst += 8;                             break;                         }                     case 4:                         {                             var p = TreeNodeUtils.ReadIntPtrUnaligned(source);                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 8 * @byte' p);                             if (NodeUtilsV.IsPtrPtr(p))                                 NodeUtilsV.Reference(p);                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 0:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             var p = TreeNodeUtils.ReadIntPtrUnaligned(source);                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' p);                             if (NodeUtilsV.IsPtrPtr(p))                                 NodeUtilsV.Reference(p);                             _dst += 8;                             break;                         }                     case 2:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             var p = TreeNodeUtils.ReadIntPtrUnaligned(source);                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' p);                             if (NodeUtilsV.IsPtrPtr(p))                                 NodeUtilsV.Reference(p);                             _dst += 8;                             break;                         }                     case 4:                         {                             var p = TreeNodeUtils.ReadIntPtrUnaligned(source);                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 8 * @byte' p);                             if (NodeUtilsV.IsPtrPtr(p))                                 NodeUtilsV.Reference(p);                             break;                         }                 }
Magic Number,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following statement contains a magic number: switch (_type)                 {                     case 0:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             var p = TreeNodeUtils.ReadIntPtrUnaligned(source);                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' p);                             if (NodeUtilsV.IsPtrPtr(p))                                 NodeUtilsV.Reference(p);                             _dst += 8;                             break;                         }                     case 2:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             var p = TreeNodeUtils.ReadIntPtrUnaligned(source);                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' p);                             if (NodeUtilsV.IsPtrPtr(p))                                 NodeUtilsV.Reference(p);                             _dst += 8;                             break;                         }                     case 4:                         {                             var p = TreeNodeUtils.ReadIntPtrUnaligned(source);                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 8 * @byte' p);                             if (NodeUtilsV.IsPtrPtr(p))                                 NodeUtilsV.Reference(p);                             break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,AllocateNode,The following statement contains a magic number: size += 4;
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,AllocateNode,The following statement contains a magic number: size += 4;
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,AllocateNode,The following statement contains a magic number: new Span<byte>(node.ToPointer()' baseSize).Slice(16).Clear();
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,AllocateNode,The following statement contains a magic number: baseSize += 4;
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,AllocateNode,The following statement contains a magic number: Unsafe.InitBlock((node + 16).ToPointer()' 255' 256);
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,AllocateNode,The following statement contains a magic number: Unsafe.InitBlock((node + 16).ToPointer()' 255' 256);
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,AllocateNode,The following statement contains a magic number: Unsafe.InitBlock((node + 16).ToPointer()' 255' 256);
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetStartPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeTypeV.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeTypeV.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetStartPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeTypeV.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeTypeV.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetStartPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeTypeV.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeTypeV.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetStartPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeTypeV.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeTypeV.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetStartPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeTypeV.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeTypeV.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetStartPosAndByteSkipLeaf,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeTypeV.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeTypeV.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetStartPosAndByteSkipLeaf,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeTypeV.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeTypeV.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetStartPosAndByteSkipLeaf,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeTypeV.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeTypeV.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetStartPosAndByteSkipLeaf,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeTypeV.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeTypeV.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetStartPosAndByteSkipLeaf,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeTypeV.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeTypeV.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetEndPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     return (-1' 0);                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         var pos = header._childCount - 1;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeTypeV.Node48:                     for (var i = 255; i >= 0; i--)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeTypeV.Node256:                     for (var i = 255; i >= 0; i--)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetEndPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     return (-1' 0);                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         var pos = header._childCount - 1;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeTypeV.Node48:                     for (var i = 255; i >= 0; i--)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeTypeV.Node256:                     for (var i = 255; i >= 0; i--)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetEndPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     return (-1' 0);                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         var pos = header._childCount - 1;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeTypeV.Node48:                     for (var i = 255; i >= 0; i--)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeTypeV.Node256:                     for (var i = 255; i >= 0; i--)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetEndPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     return (-1' 0);                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         var pos = header._childCount - 1;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeTypeV.Node48:                     for (var i = 255; i >= 0; i--)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeTypeV.Node256:                     for (var i = 255; i >= 0; i--)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetEndPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     return (-1' 0);                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         var pos = header._childCount - 1;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeTypeV.Node48:                     for (var i = 255; i >= 0; i--)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeTypeV.Node256:                     for (var i = 255; i >= 0; i--)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     for (var i = leftPos; i <= rightPos; i++)                     {                         willBeChildCount--;                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             children += (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                         }                         else                         {                             children++;                         }                     }                      break;                 case NodeTypeV.Node48:                     unsafe                     {                         var span = new Span<byte>((node + 16).ToPointer()' 256);                         for (int i = leftByte; i <= rightByte; i++)                         {                             if (span[i] == 255)                                 continue;                             willBeChildCount--;                             if (IsPtr(NodeUtilsV.PtrInNode(node' span[i])' out var ptr))                             {                                 children += (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                             }                             else                             {                                 children++;                             }                         }                     }                      break;                 case NodeTypeV.Node256:                     for (int j = leftByte; j <= rightByte; j++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' j)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                             children += (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                         }                         else                         {                             children++;                         }                          willBeChildCount--;                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     for (var i = leftPos; i <= rightPos; i++)                     {                         willBeChildCount--;                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             children += (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                         }                         else                         {                             children++;                         }                     }                      break;                 case NodeTypeV.Node48:                     unsafe                     {                         var span = new Span<byte>((node + 16).ToPointer()' 256);                         for (int i = leftByte; i <= rightByte; i++)                         {                             if (span[i] == 255)                                 continue;                             willBeChildCount--;                             if (IsPtr(NodeUtilsV.PtrInNode(node' span[i])' out var ptr))                             {                                 children += (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                             }                             else                             {                                 children++;                             }                         }                     }                      break;                 case NodeTypeV.Node256:                     for (int j = leftByte; j <= rightByte; j++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' j)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                             children += (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                         }                         else                         {                             children++;                         }                          willBeChildCount--;                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     for (var i = leftPos; i <= rightPos; i++)                     {                         willBeChildCount--;                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             children += (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                         }                         else                         {                             children++;                         }                     }                      break;                 case NodeTypeV.Node48:                     unsafe                     {                         var span = new Span<byte>((node + 16).ToPointer()' 256);                         for (int i = leftByte; i <= rightByte; i++)                         {                             if (span[i] == 255)                                 continue;                             willBeChildCount--;                             if (IsPtr(NodeUtilsV.PtrInNode(node' span[i])' out var ptr))                             {                                 children += (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                             }                             else                             {                                 children++;                             }                         }                     }                      break;                 case NodeTypeV.Node256:                     for (int j = leftByte; j <= rightByte; j++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' j)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                             children += (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                         }                         else                         {                             children++;                         }                          willBeChildCount--;                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The following statement contains a magic number: willBeChildCount > 48
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 MoveMemory(NodeUtilsV.PtrInNode(node' rightPos + 1)' NodeUtilsV.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeTypeV.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtilsV.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 MoveMemory(NodeUtilsV.PtrInNode(node' rightPos + 1)' NodeUtilsV.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeTypeV.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtilsV.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 MoveMemory(NodeUtilsV.PtrInNode(node' rightPos + 1)' NodeUtilsV.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeTypeV.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtilsV.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 MoveMemory(NodeUtilsV.PtrInNode(node' rightPos + 1)' NodeUtilsV.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeTypeV.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtilsV.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 MoveMemory(NodeUtilsV.PtrInNode(node' rightPos + 1)' NodeUtilsV.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeTypeV.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtilsV.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 MoveMemory(NodeUtilsV.PtrInNode(node' rightPos + 1)' NodeUtilsV.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeTypeV.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtilsV.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 MoveMemory(NodeUtilsV.PtrInNode(node' rightPos + 1)' NodeUtilsV.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeTypeV.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtilsV.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 MoveMemory(NodeUtilsV.PtrInNode(node' rightPos + 1)' NodeUtilsV.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeTypeV.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtilsV.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 MoveMemory(NodeUtilsV.PtrInNode(node' rightPos + 1)' NodeUtilsV.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeTypeV.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtilsV.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 MoveMemory(NodeUtilsV.PtrInNode(node' rightPos + 1)' NodeUtilsV.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeTypeV.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtilsV.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 MoveMemory(NodeUtilsV.PtrInNode(node' rightPos + 1)' NodeUtilsV.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeTypeV.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtilsV.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 8;                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (child == IntPtr.Zero)                                     continue;                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 8;                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (child == IntPtr.Zero)                                     continue;                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 8;                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (child == IntPtr.Zero)                                     continue;                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 8;                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (child == IntPtr.Zero)                                     continue;                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 8;                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (child == IntPtr.Zero)                                     continue;                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 8;                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (child == IntPtr.Zero)                                     continue;                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 8;                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (child == IntPtr.Zero)                                     continue;                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 8;                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (child == IntPtr.Zero)                                     continue;                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 8;                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (child == IntPtr.Zero)                                     continue;                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 8;                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (child == IntPtr.Zero)                                     continue;                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 8;                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (child == IntPtr.Zero)                                     continue;                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 8;                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (child == IntPtr.Zero)                                     continue;                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 8;                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (child == IntPtr.Zero)                                     continue;                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 8;                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (child == IntPtr.Zero)                                     continue;                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 8;                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (child == IntPtr.Zero)                                     continue;                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,CalcIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 8;                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (child == IntPtr.Zero)                                     continue;                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,SeekIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         for (int j = 0; j < header._childCount; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     return true;                                 }                                  index--;                             }                         }                          break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 if (IsPtr(NodeUtilsV.PtrInNode(top' span[j])' out var ptr))                                 {                                     var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                     if (index < rcc)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         top = ptr;                                         break;                                     }                                      index -= rcc;                                 }                                 else                                 {                                     if (index == 0)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         return true;                                     }                                      index--;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         for (int j = 0; j < 256; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                     continue;                                 var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     return true;                                 }                                  index--;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,SeekIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         for (int j = 0; j < header._childCount; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     return true;                                 }                                  index--;                             }                         }                          break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 if (IsPtr(NodeUtilsV.PtrInNode(top' span[j])' out var ptr))                                 {                                     var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                     if (index < rcc)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         top = ptr;                                         break;                                     }                                      index -= rcc;                                 }                                 else                                 {                                     if (index == 0)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         return true;                                     }                                      index--;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         for (int j = 0; j < 256; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                     continue;                                 var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     return true;                                 }                                  index--;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,SeekIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         for (int j = 0; j < header._childCount; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     return true;                                 }                                  index--;                             }                         }                          break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 if (IsPtr(NodeUtilsV.PtrInNode(top' span[j])' out var ptr))                                 {                                     var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                     if (index < rcc)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         top = ptr;                                         break;                                     }                                      index -= rcc;                                 }                                 else                                 {                                     if (index == 0)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         return true;                                     }                                      index--;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         for (int j = 0; j < 256; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                     continue;                                 var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     return true;                                 }                                  index--;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,SeekIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         for (int j = 0; j < header._childCount; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     return true;                                 }                                  index--;                             }                         }                          break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 if (IsPtr(NodeUtilsV.PtrInNode(top' span[j])' out var ptr))                                 {                                     var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                     if (index < rcc)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         top = ptr;                                         break;                                     }                                      index -= rcc;                                 }                                 else                                 {                                     if (index == 0)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         return true;                                     }                                      index--;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         for (int j = 0; j < 256; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                     continue;                                 var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     return true;                                 }                                  index--;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,SeekIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         for (int j = 0; j < header._childCount; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     return true;                                 }                                  index--;                             }                         }                          break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 if (IsPtr(NodeUtilsV.PtrInNode(top' span[j])' out var ptr))                                 {                                     var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                     if (index < rcc)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         top = ptr;                                         break;                                     }                                      index -= rcc;                                 }                                 else                                 {                                     if (index == 0)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         return true;                                     }                                      index--;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         for (int j = 0; j < 256; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                     continue;                                 var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     return true;                                 }                                  index--;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,SeekIndex,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         for (int j = 0; j < header._childCount; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     return true;                                 }                                  index--;                             }                         }                          break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 if (IsPtr(NodeUtilsV.PtrInNode(top' span[j])' out var ptr))                                 {                                     var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                     if (index < rcc)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         top = ptr;                                         break;                                     }                                      index -= rcc;                                 }                                 else                                 {                                     if (index == 0)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         return true;                                     }                                      index--;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         for (int j = 0; j < 256; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                     continue;                                 var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     return true;                                 }                                  index--;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,MoveNext,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.NodeLeaf:                         goto up;                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (stackItem._posInNode == header._childCount - 1)                             {                                 goto up;                             }                              stackItem._posInNode++;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeTypeV.Node256:                         for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                                  stackItem._posInNode = (short)j;                                 stackItem._byte = (byte)j;                                 PushLeftMost(ptr2' (int)stackItem._keyOffset' ref stack);                                 return true;                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             return true;                         }                          goto up;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,MoveNext,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.NodeLeaf:                         goto up;                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (stackItem._posInNode == header._childCount - 1)                             {                                 goto up;                             }                              stackItem._posInNode++;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeTypeV.Node256:                         for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                                  stackItem._posInNode = (short)j;                                 stackItem._byte = (byte)j;                                 PushLeftMost(ptr2' (int)stackItem._keyOffset' ref stack);                                 return true;                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             return true;                         }                          goto up;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,MoveNext,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.NodeLeaf:                         goto up;                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (stackItem._posInNode == header._childCount - 1)                             {                                 goto up;                             }                              stackItem._posInNode++;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeTypeV.Node256:                         for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                                  stackItem._posInNode = (short)j;                                 stackItem._byte = (byte)j;                                 PushLeftMost(ptr2' (int)stackItem._keyOffset' ref stack);                                 return true;                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             return true;                         }                          goto up;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,MoveNext,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.NodeLeaf:                         goto up;                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (stackItem._posInNode == header._childCount - 1)                             {                                 goto up;                             }                              stackItem._posInNode++;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeTypeV.Node256:                         for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                                  stackItem._posInNode = (short)j;                                 stackItem._byte = (byte)j;                                 PushLeftMost(ptr2' (int)stackItem._keyOffset' ref stack);                                 return true;                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             return true;                         }                          goto up;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,MoveNext,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.NodeLeaf:                         goto up;                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (stackItem._posInNode == header._childCount - 1)                             {                                 goto up;                             }                              stackItem._posInNode++;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeTypeV.Node256:                         for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                                  stackItem._posInNode = (short)j;                                 stackItem._byte = (byte)j;                                 PushLeftMost(ptr2' (int)stackItem._keyOffset' ref stack);                                 return true;                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             return true;                         }                          goto up;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,MoveNext,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.NodeLeaf:                         goto up;                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (stackItem._posInNode == header._childCount - 1)                             {                                 goto up;                             }                              stackItem._posInNode++;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeTypeV.Node256:                         for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                                  stackItem._posInNode = (short)j;                                 stackItem._byte = (byte)j;                                 PushLeftMost(ptr2' (int)stackItem._keyOffset' ref stack);                                 return true;                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             return true;                         }                          goto up;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,MovePrevious,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (stackItem._posInNode == 0)                             {                                 goto up;                             }                              stackItem._posInNode--;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = stackItem._byte - 1; j >= 0; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeTypeV.Node256:                         for (int j = stackItem._byte - 1; j >= 0; j--)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             goto down;                         }                          goto up;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,MovePrevious,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (stackItem._posInNode == 0)                             {                                 goto up;                             }                              stackItem._posInNode--;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = stackItem._byte - 1; j >= 0; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeTypeV.Node256:                         for (int j = stackItem._byte - 1; j >= 0; j--)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             goto down;                         }                          goto up;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,MovePrevious,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (stackItem._posInNode == 0)                             {                                 goto up;                             }                              stackItem._posInNode--;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = stackItem._byte - 1; j >= 0; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeTypeV.Node256:                         for (int j = stackItem._byte - 1; j >= 0; j--)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             goto down;                         }                          goto up;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,MovePrevious,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (stackItem._posInNode == 0)                             {                                 goto up;                             }                              stackItem._posInNode--;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = stackItem._byte - 1; j >= 0; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeTypeV.Node256:                         for (int j = stackItem._byte - 1; j >= 0; j--)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             goto down;                         }                          goto up;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,CloneNode,The following statement contains a magic number: ptr += 12;
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node16:                     {                         CopyMemory(nodePtr + 16' newNode + 16' 4);                         CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 4 * PtrSize);                         break;                     }                 case NodeTypeV.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 16 * PtrSize);                         break;                     }                 case NodeTypeV.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             CopyMemory(NodeUtilsV.PtrInNode(nodePtr' pos)' NodeUtilsV.PtrInNode(newNode' i)' PtrSize);                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node16:                     {                         CopyMemory(nodePtr + 16' newNode + 16' 4);                         CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 4 * PtrSize);                         break;                     }                 case NodeTypeV.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 16 * PtrSize);                         break;                     }                 case NodeTypeV.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             CopyMemory(NodeUtilsV.PtrInNode(nodePtr' pos)' NodeUtilsV.PtrInNode(newNode' i)' PtrSize);                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node16:                     {                         CopyMemory(nodePtr + 16' newNode + 16' 4);                         CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 4 * PtrSize);                         break;                     }                 case NodeTypeV.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 16 * PtrSize);                         break;                     }                 case NodeTypeV.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             CopyMemory(NodeUtilsV.PtrInNode(nodePtr' pos)' NodeUtilsV.PtrInNode(newNode' i)' PtrSize);                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node16:                     {                         CopyMemory(nodePtr + 16' newNode + 16' 4);                         CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 4 * PtrSize);                         break;                     }                 case NodeTypeV.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 16 * PtrSize);                         break;                     }                 case NodeTypeV.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             CopyMemory(NodeUtilsV.PtrInNode(nodePtr' pos)' NodeUtilsV.PtrInNode(newNode' i)' PtrSize);                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node16:                     {                         CopyMemory(nodePtr + 16' newNode + 16' 4);                         CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 4 * PtrSize);                         break;                     }                 case NodeTypeV.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 16 * PtrSize);                         break;                     }                 case NodeTypeV.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             CopyMemory(NodeUtilsV.PtrInNode(nodePtr' pos)' NodeUtilsV.PtrInNode(newNode' i)' PtrSize);                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node16:                     {                         CopyMemory(nodePtr + 16' newNode + 16' 4);                         CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 4 * PtrSize);                         break;                     }                 case NodeTypeV.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 16 * PtrSize);                         break;                     }                 case NodeTypeV.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             CopyMemory(NodeUtilsV.PtrInNode(nodePtr' pos)' NodeUtilsV.PtrInNode(newNode' i)' PtrSize);                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node16:                     {                         CopyMemory(nodePtr + 16' newNode + 16' 4);                         CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 4 * PtrSize);                         break;                     }                 case NodeTypeV.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 16 * PtrSize);                         break;                     }                 case NodeTypeV.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             CopyMemory(NodeUtilsV.PtrInNode(nodePtr' pos)' NodeUtilsV.PtrInNode(newNode' i)' PtrSize);                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node16:                     {                         CopyMemory(nodePtr + 16' newNode + 16' 4);                         CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 4 * PtrSize);                         break;                     }                 case NodeTypeV.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 16 * PtrSize);                         break;                     }                 case NodeTypeV.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             CopyMemory(NodeUtilsV.PtrInNode(nodePtr' pos)' NodeUtilsV.PtrInNode(newNode' i)' PtrSize);                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node16:                     {                         CopyMemory(nodePtr + 16' newNode + 16' 4);                         CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 4 * PtrSize);                         break;                     }                 case NodeTypeV.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 16 * PtrSize);                         break;                     }                 case NodeTypeV.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             CopyMemory(NodeUtilsV.PtrInNode(nodePtr' pos)' NodeUtilsV.PtrInNode(newNode' i)' PtrSize);                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node16:                     {                         CopyMemory(nodePtr + 16' newNode + 16' 4);                         CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 4 * PtrSize);                         break;                     }                 case NodeTypeV.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 16 * PtrSize);                         break;                     }                 case NodeTypeV.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             CopyMemory(NodeUtilsV.PtrInNode(nodePtr' pos)' NodeUtilsV.PtrInNode(newNode' i)' PtrSize);                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ExpandNode,The following statement contains a magic number: switch (newNodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node16:                     {                         CopyMemory(nodePtr + 16' newNode + 16' 4);                         CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 4 * PtrSize);                         break;                     }                 case NodeTypeV.Node48:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         var dstBytesPtr = (byte*)(newNode + 16).ToPointer();                         for (var i = 0; i < 16; i++)                         {                             dstBytesPtr[srcBytesPtr[i]] = (byte)i;                         }                          CopyMemory(NodeUtilsV.PtrInNode(nodePtr' 0)' NodeUtilsV.PtrInNode(newNode' 0)' 16 * PtrSize);                         break;                     }                 case NodeTypeV.Node256:                     {                         var srcBytesPtr = (byte*)(nodePtr + 16).ToPointer();                         for (var i = 0; i < 256; i++)                         {                             var pos = srcBytesPtr[i];                             if (pos == 255) continue;                             CopyMemory(NodeUtilsV.PtrInNode(nodePtr' pos)' NodeUtilsV.PtrInNode(newNode' i)' PtrSize);                         }                          break;                     }                 default:                     throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,ReferenceAllChildren,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         var limit = p + nodeHeader._childCount * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         var limit = p + 256 * 8;                         for (; p != limit; p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 NodeUtilsV.Reference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Dereference,The following statement contains a magic number: switch (nodeHeader._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     // does not contain any pointers                     break;                 case NodeTypeV.Node4:                     {                         var p = node + 16 + 4;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node16:                     {                         var p = node + 16 + 16;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node48:                     {                         var p = node + 16 + 256;                         for (var i = 0; i < nodeHeader._childCount; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 case NodeTypeV.Node256:                     {                         var p = node + 16;                         for (var i = 0; i < 256; i++' p += 8)                         {                             var child = NodeUtilsV.ReadPtr(p);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 Dereference(child);                             }                         }                     }                     break;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,WritePtrAndByteInNode,The following statement contains a magic number: TreeNodeUtils.WriteByte(stackItem._node' 16 + stackItem._posInNode' stackItem._byte);
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,WriteContentAndByteInNode,The following statement contains a magic number: TreeNodeUtils.WriteByte(stackItem._node' 16 + stackItem._posInNode' stackItem._byte);
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,WriteContentInNode,The following statement contains a magic number: content.CopyTo(new Span<byte>(NodeUtilsV.SkipLenFromPtr(ptr).ToPointer()' 7));
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,FindNearPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         pos = ~pos;                         if (pos >= header._childCount) pos--;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeTypeV.Node48:                     {                         var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                         pos = @byte + 1;                         while (pos < 256)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos++;                         }                          pos = @byte - 1;                         while (true)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos--;                         }                     }                 case NodeTypeV.Node256:                     {                         pos = @byte + 1;                         while (pos < 256)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos++;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          pos = @byte - 1;                         while (pos >= 0)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos--;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          break;                     }             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,FindNearPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         pos = ~pos;                         if (pos >= header._childCount) pos--;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeTypeV.Node48:                     {                         var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                         pos = @byte + 1;                         while (pos < 256)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos++;                         }                          pos = @byte - 1;                         while (true)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos--;                         }                     }                 case NodeTypeV.Node256:                     {                         pos = @byte + 1;                         while (pos < 256)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos++;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          pos = @byte - 1;                         while (pos >= 0)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos--;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          break;                     }             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,FindNearPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         pos = ~pos;                         if (pos >= header._childCount) pos--;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeTypeV.Node48:                     {                         var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                         pos = @byte + 1;                         while (pos < 256)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos++;                         }                          pos = @byte - 1;                         while (true)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos--;                         }                     }                 case NodeTypeV.Node256:                     {                         pos = @byte + 1;                         while (pos < 256)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos++;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          pos = @byte - 1;                         while (pos >= 0)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos--;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          break;                     }             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,FindNearPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         pos = ~pos;                         if (pos >= header._childCount) pos--;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeTypeV.Node48:                     {                         var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                         pos = @byte + 1;                         while (pos < 256)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos++;                         }                          pos = @byte - 1;                         while (true)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos--;                         }                     }                 case NodeTypeV.Node256:                     {                         pos = @byte + 1;                         while (pos < 256)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos++;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          pos = @byte - 1;                         while (pos >= 0)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos--;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          break;                     }             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,FindNearPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         pos = ~pos;                         if (pos >= header._childCount) pos--;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeTypeV.Node48:                     {                         var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                         pos = @byte + 1;                         while (pos < 256)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos++;                         }                          pos = @byte - 1;                         while (true)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos--;                         }                     }                 case NodeTypeV.Node256:                     {                         pos = @byte + 1;                         while (pos < 256)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos++;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          pos = @byte - 1;                         while (pos >= 0)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos--;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          break;                     }             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,FindNearPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         pos = ~pos;                         if (pos >= header._childCount) pos--;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeTypeV.Node48:                     {                         var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                         pos = @byte + 1;                         while (pos < 256)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos++;                         }                          pos = @byte - 1;                         while (true)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos--;                         }                     }                 case NodeTypeV.Node256:                     {                         pos = @byte + 1;                         while (pos < 256)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos++;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          pos = @byte - 1;                         while (pos >= 0)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos--;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          break;                     }             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,FindNearPosAndByte,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         pos = ~pos;                         if (pos >= header._childCount) pos--;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeTypeV.Node48:                     {                         var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                         pos = @byte + 1;                         while (pos < 256)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos++;                         }                          pos = @byte - 1;                         while (true)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos--;                         }                     }                 case NodeTypeV.Node256:                     {                         pos = @byte + 1;                         while (pos < 256)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos++;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          pos = @byte - 1;                         while (pos >= 0)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos--;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          break;                     }             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 4);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 16);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var child = NodeUtilsV.ReadPtr(top + 16 + 256 + pos * 8);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     top = child;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 8)                             {                                 var child = NodeUtilsV.ReadPtr(p);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 4);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 16);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var child = NodeUtilsV.ReadPtr(top + 16 + 256 + pos * 8);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     top = child;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 8)                             {                                 var child = NodeUtilsV.ReadPtr(p);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 4);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 16);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var child = NodeUtilsV.ReadPtr(top + 16 + 256 + pos * 8);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     top = child;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 8)                             {                                 var child = NodeUtilsV.ReadPtr(p);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 4);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 16);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var child = NodeUtilsV.ReadPtr(top + 16 + 256 + pos * 8);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     top = child;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 8)                             {                                 var child = NodeUtilsV.ReadPtr(p);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 4);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 16);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var child = NodeUtilsV.ReadPtr(top + 16 + 256 + pos * 8);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     top = child;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 8)                             {                                 var child = NodeUtilsV.ReadPtr(p);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 4);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 16);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var child = NodeUtilsV.ReadPtr(top + 16 + 256 + pos * 8);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     top = child;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 8)                             {                                 var child = NodeUtilsV.ReadPtr(p);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 4);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 16);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var child = NodeUtilsV.ReadPtr(top + 16 + 256 + pos * 8);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     top = child;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 8)                             {                                 var child = NodeUtilsV.ReadPtr(p);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 4);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 16);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var child = NodeUtilsV.ReadPtr(top + 16 + 256 + pos * 8);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     top = child;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 8)                             {                                 var child = NodeUtilsV.ReadPtr(p);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 4);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 16);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var child = NodeUtilsV.ReadPtr(top + 16 + 256 + pos * 8);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     top = child;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 8)                             {                                 var child = NodeUtilsV.ReadPtr(p);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 4);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 16);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var child = NodeUtilsV.ReadPtr(top + 16 + 256 + pos * 8);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     top = child;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 8)                             {                                 var child = NodeUtilsV.ReadPtr(p);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 4);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 16);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var child = NodeUtilsV.ReadPtr(top + 16 + 256 + pos * 8);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     top = child;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 8)                             {                                 var child = NodeUtilsV.ReadPtr(p);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 4);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 16);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var child = NodeUtilsV.ReadPtr(top + 16 + 256 + pos * 8);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     top = child;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 8)                             {                                 var child = NodeUtilsV.ReadPtr(p);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 4);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 16);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var child = NodeUtilsV.ReadPtr(top + 16 + 256 + pos * 8);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     top = child;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 8)                             {                                 var child = NodeUtilsV.ReadPtr(p);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushLeftMost,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 4);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 16);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var child = NodeUtilsV.ReadPtr(top + 16 + 256 + pos * 8);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     top = child;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 8)                             {                                 var child = NodeUtilsV.ReadPtr(p);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushRightMost,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             var pos = header._childCount - 1;                             stack.AddRef().Set(top' (uint)keyOffset' (short)pos' TreeNodeUtils.ReadByte(top + 16 + pos));                             if (IsPtr(NodeUtilsV.PtrInNode(top' pos)' out var ptr))                             {                                 top = ptr;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 255; true; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' span[j]' (byte)j);                                 if (IsPtr(NodeUtilsV.PtrInNode(top' span[j])' out var ptr))                                 {                                     top = ptr;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         for (int j = 255; true; j--)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr != IntPtr.Zero)                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  continue;                             }                             else                             {                                 stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                 return;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushRightMost,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             var pos = header._childCount - 1;                             stack.AddRef().Set(top' (uint)keyOffset' (short)pos' TreeNodeUtils.ReadByte(top + 16 + pos));                             if (IsPtr(NodeUtilsV.PtrInNode(top' pos)' out var ptr))                             {                                 top = ptr;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 255; true; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' span[j]' (byte)j);                                 if (IsPtr(NodeUtilsV.PtrInNode(top' span[j])' out var ptr))                                 {                                     top = ptr;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         for (int j = 255; true; j--)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr != IntPtr.Zero)                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  continue;                             }                             else                             {                                 stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                 return;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushRightMost,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             var pos = header._childCount - 1;                             stack.AddRef().Set(top' (uint)keyOffset' (short)pos' TreeNodeUtils.ReadByte(top + 16 + pos));                             if (IsPtr(NodeUtilsV.PtrInNode(top' pos)' out var ptr))                             {                                 top = ptr;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 255; true; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' span[j]' (byte)j);                                 if (IsPtr(NodeUtilsV.PtrInNode(top' span[j])' out var ptr))                                 {                                     top = ptr;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         for (int j = 255; true; j--)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr != IntPtr.Zero)                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  continue;                             }                             else                             {                                 stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                 return;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushRightMost,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             var pos = header._childCount - 1;                             stack.AddRef().Set(top' (uint)keyOffset' (short)pos' TreeNodeUtils.ReadByte(top + 16 + pos));                             if (IsPtr(NodeUtilsV.PtrInNode(top' pos)' out var ptr))                             {                                 top = ptr;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 255; true; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' span[j]' (byte)j);                                 if (IsPtr(NodeUtilsV.PtrInNode(top' span[j])' out var ptr))                                 {                                     top = ptr;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         for (int j = 255; true; j--)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr != IntPtr.Zero)                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  continue;                             }                             else                             {                                 stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                 return;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushRightMost,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             var pos = header._childCount - 1;                             stack.AddRef().Set(top' (uint)keyOffset' (short)pos' TreeNodeUtils.ReadByte(top + 16 + pos));                             if (IsPtr(NodeUtilsV.PtrInNode(top' pos)' out var ptr))                             {                                 top = ptr;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 255; true; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' span[j]' (byte)j);                                 if (IsPtr(NodeUtilsV.PtrInNode(top' span[j])' out var ptr))                                 {                                     top = ptr;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         for (int j = 255; true; j--)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr != IntPtr.Zero)                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  continue;                             }                             else                             {                                 stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                 return;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushRightMost,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             var pos = header._childCount - 1;                             stack.AddRef().Set(top' (uint)keyOffset' (short)pos' TreeNodeUtils.ReadByte(top + 16 + pos));                             if (IsPtr(NodeUtilsV.PtrInNode(top' pos)' out var ptr))                             {                                 top = ptr;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 255; true; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' span[j]' (byte)j);                                 if (IsPtr(NodeUtilsV.PtrInNode(top' span[j])' out var ptr))                                 {                                     top = ptr;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         for (int j = 255; true; j--)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr != IntPtr.Zero)                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  continue;                             }                             else                             {                                 stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                 return;                             }                         }                          break;                 }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Upsert,The following statement contains a magic number: keyRest == 0 && (content.Length < 8) && stack.Count > 0
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Upsert,The following statement contains a magic number: TreeNodeUtils.WriteByte(newNode' 16' b);
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,IsValueInlineable,The following statement contains a magic number: content.Length < 8
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Find,The following statement contains a magic number: var pos = TreeNodeUtils.ReadByte(nodePtr + 16 + b);
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,Find,The following statement contains a magic number: pos == 255
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,InsertChildIntoNode4,The following statement contains a magic number: var childernBytes = new ReadOnlySpan<byte>((nodePtr + 16).ToPointer()' header._childCount);
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,InsertChildIntoNode4,The following statement contains a magic number: childernBytes.Slice(pos)                     .CopyTo(new Span<byte>((nodePtr + 16).ToPointer()' header._childCount + 1).Slice(pos + 1));
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,InsertChildIntoNode4,The following statement contains a magic number: TreeNodeUtils.WriteByte(nodePtr' 16 + pos' b);
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,InsertChildRaw,The following statement contains a magic number: TreeNodeUtils.WriteByte(nodePtr' 16 + b' (byte)pos);
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,StructureCheck,The following statement contains a magic number: Debug.Assert(header._referenceCount > 0 && header._referenceCount < 2000);
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,StructureCheck,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     childrenCount = 1;                     break;                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' pos)' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeTypeV.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         StructureCheck48(span' header.ChildCount);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' span[j])' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeTypeV.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' j)' out var ptr))                         {                             childrenCount += StructureCheck(ptr);                         }                         else                         {                             childrenCount++;                         }                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,StructureCheck,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     childrenCount = 1;                     break;                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' pos)' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeTypeV.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         StructureCheck48(span' header.ChildCount);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' span[j])' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeTypeV.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' j)' out var ptr))                         {                             childrenCount += StructureCheck(ptr);                         }                         else                         {                             childrenCount++;                         }                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,StructureCheck,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     childrenCount = 1;                     break;                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' pos)' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeTypeV.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         StructureCheck48(span' header.ChildCount);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' span[j])' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeTypeV.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' j)' out var ptr))                         {                             childrenCount += StructureCheck(ptr);                         }                         else                         {                             childrenCount++;                         }                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,StructureCheck,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     childrenCount = 1;                     break;                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' pos)' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeTypeV.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         StructureCheck48(span' header.ChildCount);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' span[j])' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeTypeV.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' j)' out var ptr))                         {                             childrenCount += StructureCheck(ptr);                         }                         else                         {                             childrenCount++;                         }                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,StructureCheck,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     childrenCount = 1;                     break;                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' pos)' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeTypeV.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         StructureCheck48(span' header.ChildCount);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' span[j])' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeTypeV.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' j)' out var ptr))                         {                             childrenCount += StructureCheck(ptr);                         }                         else                         {                             childrenCount++;                         }                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,StructureCheck,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     childrenCount = 1;                     break;                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' pos)' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeTypeV.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         StructureCheck48(span' header.ChildCount);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' span[j])' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeTypeV.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' j)' out var ptr))                         {                             childrenCount += StructureCheck(ptr);                         }                         else                         {                             childrenCount++;                         }                     }                      break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,StructureCheck48,The following statement contains a magic number: Span<byte> cnts = stackalloc byte[48];
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,StructureCheck48,The following statement contains a magic number: p == 255
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,StructureCheck48,The following statement contains a magic number: i < 256
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,StructureCheck48,The following statement contains a magic number: i < 48
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,IterateNodeInfo,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     break;                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' pos)' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeTypeV.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' span[j])' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeTypeV.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' j)' out ptr))                         {                             IterateNodeInfo(ptr' deepness + 1' iterator);                         }                     }                     break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,IterateNodeInfo,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     break;                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' pos)' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeTypeV.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' span[j])' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeTypeV.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' j)' out ptr))                         {                             IterateNodeInfo(ptr' deepness + 1' iterator);                         }                     }                     break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,IterateNodeInfo,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     break;                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' pos)' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeTypeV.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' span[j])' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeTypeV.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' j)' out ptr))                         {                             IterateNodeInfo(ptr' deepness + 1' iterator);                         }                     }                     break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,IterateNodeInfo,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     break;                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' pos)' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeTypeV.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' span[j])' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeTypeV.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' j)' out ptr))                         {                             IterateNodeInfo(ptr' deepness + 1' iterator);                         }                     }                     break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,IterateNodeInfo,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     break;                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' pos)' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeTypeV.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' span[j])' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeTypeV.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' j)' out ptr))                         {                             IterateNodeInfo(ptr' deepness + 1' iterator);                         }                     }                     break;             }
Magic Number,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,IterateNodeInfo,The following statement contains a magic number: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     break;                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' pos)' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeTypeV.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' span[j])' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeTypeV.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' j)' out ptr))                         {                             IterateNodeInfo(ptr' deepness + 1' iterator);                         }                     }                     break;             }
Magic Number,BTDB.ARTLib,Cursor12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\Cursor12.cs,GetValueLength,The following statement contains a magic number: return 12;
Magic Number,BTDB.ARTLib,Cursor12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\Cursor12.cs,GetValue,The following statement contains a magic number: return new Span<byte>(ptr2.ToPointer()' 12);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return (16' 0);                 case NodeType12.Node4: return (16 + 4 + 4 * 12' 4);                 case NodeType12.Node16: return (16 + 16 + 16 * 12' 16);                 case NodeType12.Node48: return (16 + 256 + 48 * 12' 48);                 case NodeType12.Node256: return (16 + 256 * 12' 256);                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return (16' 0);                 case NodeType12.Node4: return (16 + 4 + 4 * 12' 4);                 case NodeType12.Node16: return (16 + 16 + 16 * 12' 16);                 case NodeType12.Node48: return (16 + 256 + 48 * 12' 48);                 case NodeType12.Node256: return (16 + 256 * 12' 256);                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return (16' 0);                 case NodeType12.Node4: return (16 + 4 + 4 * 12' 4);                 case NodeType12.Node16: return (16 + 16 + 16 * 12' 16);                 case NodeType12.Node48: return (16 + 256 + 48 * 12' 48);                 case NodeType12.Node256: return (16 + 256 * 12' 256);                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return (16' 0);                 case NodeType12.Node4: return (16 + 4 + 4 * 12' 4);                 case NodeType12.Node16: return (16 + 16 + 16 * 12' 16);                 case NodeType12.Node48: return (16 + 256 + 48 * 12' 48);                 case NodeType12.Node256: return (16 + 256 * 12' 256);                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return (16' 0);                 case NodeType12.Node4: return (16 + 4 + 4 * 12' 4);                 case NodeType12.Node16: return (16 + 16 + 16 * 12' 16);                 case NodeType12.Node48: return (16 + 256 + 48 * 12' 48);                 case NodeType12.Node256: return (16 + 256 * 12' 256);                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return (16' 0);                 case NodeType12.Node4: return (16 + 4 + 4 * 12' 4);                 case NodeType12.Node16: return (16 + 16 + 16 * 12' 16);                 case NodeType12.Node48: return (16 + 256 + 48 * 12' 48);                 case NodeType12.Node256: return (16 + 256 * 12' 256);                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return (16' 0);                 case NodeType12.Node4: return (16 + 4 + 4 * 12' 4);                 case NodeType12.Node16: return (16 + 16 + 16 * 12' 16);                 case NodeType12.Node48: return (16 + 256 + 48 * 12' 48);                 case NodeType12.Node256: return (16 + 256 * 12' 256);                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return (16' 0);                 case NodeType12.Node4: return (16 + 4 + 4 * 12' 4);                 case NodeType12.Node16: return (16 + 16 + 16 * 12' 16);                 case NodeType12.Node48: return (16 + 256 + 48 * 12' 48);                 case NodeType12.Node256: return (16 + 256 * 12' 256);                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return (16' 0);                 case NodeType12.Node4: return (16 + 4 + 4 * 12' 4);                 case NodeType12.Node16: return (16 + 16 + 16 * 12' 16);                 case NodeType12.Node48: return (16 + 256 + 48 * 12' 48);                 case NodeType12.Node256: return (16 + 256 * 12' 256);                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return (16' 0);                 case NodeType12.Node4: return (16 + 4 + 4 * 12' 4);                 case NodeType12.Node16: return (16 + 16 + 16 * 12' 16);                 case NodeType12.Node48: return (16 + 256 + 48 * 12' 48);                 case NodeType12.Node256: return (16 + 256 * 12' 256);                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return (16' 0);                 case NodeType12.Node4: return (16 + 4 + 4 * 12' 4);                 case NodeType12.Node16: return (16 + 16 + 16 * 12' 16);                 case NodeType12.Node48: return (16 + 256 + 48 * 12' 48);                 case NodeType12.Node256: return (16 + 256 * 12' 256);                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return (16' 0);                 case NodeType12.Node4: return (16 + 4 + 4 * 12' 4);                 case NodeType12.Node16: return (16 + 16 + 16 * 12' 16);                 case NodeType12.Node48: return (16 + 256 + 48 * 12' 48);                 case NodeType12.Node256: return (16 + 256 * 12' 256);                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return (16' 0);                 case NodeType12.Node4: return (16 + 4 + 4 * 12' 4);                 case NodeType12.Node16: return (16 + 16 + 16 * 12' 16);                 case NodeType12.Node48: return (16 + 256 + 48 * 12' 48);                 case NodeType12.Node256: return (16 + 256 * 12' 256);                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return (16' 0);                 case NodeType12.Node4: return (16 + 4 + 4 * 12' 4);                 case NodeType12.Node16: return (16 + 16 + 16 * 12' 16);                 case NodeType12.Node48: return (16 + 256 + 48 * 12' 48);                 case NodeType12.Node256: return (16 + 256 * 12' 256);                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return (16' 0);                 case NodeType12.Node4: return (16 + 4 + 4 * 12' 4);                 case NodeType12.Node16: return (16 + 16 + 16 * 12' 16);                 case NodeType12.Node48: return (16 + 256 + 48 * 12' 48);                 case NodeType12.Node256: return (16 + 256 * 12' 256);                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return (16' 0);                 case NodeType12.Node4: return (16 + 4 + 4 * 12' 4);                 case NodeType12.Node16: return (16 + 16 + 16 * 12' 16);                 case NodeType12.Node48: return (16 + 256 + 48 * 12' 48);                 case NodeType12.Node256: return (16 + 256 * 12' 256);                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return (16' 0);                 case NodeType12.Node4: return (16 + 4 + 4 * 12' 4);                 case NodeType12.Node16: return (16 + 16 + 16 * 12' 16);                 case NodeType12.Node48: return (16 + 256 + 48 * 12' 48);                 case NodeType12.Node256: return (16 + 256 * 12' 256);                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return (16' 0);                 case NodeType12.Node4: return (16 + 4 + 4 * 12' 4);                 case NodeType12.Node16: return (16 + 16 + 16 * 12' 16);                 case NodeType12.Node48: return (16 + 256 + 48 * 12' 48);                 case NodeType12.Node256: return (16 + 256 * 12' 256);                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return (16' 0);                 case NodeType12.Node4: return (16 + 4 + 4 * 12' 4);                 case NodeType12.Node16: return (16 + 16 + 16 * 12' 16);                 case NodeType12.Node48: return (16 + 256 + 48 * 12' 48);                 case NodeType12.Node256: return (16 + 256 * 12' 256);                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return (16' 0);                 case NodeType12.Node4: return (16 + 4 + 4 * 12' 4);                 case NodeType12.Node16: return (16 + 16 + 16 * 12' 16);                 case NodeType12.Node48: return (16 + 256 + 48 * 12' 48);                 case NodeType12.Node256: return (16 + 256 * 12' 256);                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetPrefixSizeAndPtr,The following statement contains a magic number: ptr += 2 * maxChildren;
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetPrefixSizeAndPtr,The following statement contains a magic number: ptr += 2 + *(ushort*)ptr;
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetSuffixSizeAndPtr,The following statement contains a magic number: var suffixOfs = *(ushort*)(ptr + i * 2);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetSuffixSizeAndPtr,The following statement contains a magic number: var suffixSize = (uint)(*(ushort*)(ptr + i * 2 + 2) - suffixOfs);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetSuffixSizeAndPtr,The following statement contains a magic number: var suffixSize = (uint)(*(ushort*)(ptr + i * 2 + 2) - suffixOfs);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetSuffixSizeAndPtr,The following statement contains a magic number: ptr += 2 * maxChildren + 2 + suffixOfs;
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetSuffixSizeAndPtr,The following statement contains a magic number: ptr += 2 * maxChildren + 2 + suffixOfs;
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,SetSuffix,The following statement contains a magic number: var suffixOfs = *(ushort*)(ptr + i * 2);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,SetSuffix,The following statement contains a magic number: var suffixOfs2 = *(ushort*)(ptr + i * 2 + 2);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,SetSuffix,The following statement contains a magic number: var suffixOfs2 = *(ushort*)(ptr + i * 2 + 2);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,SetSuffix,The following statement contains a magic number: var suffixOfs3 = *(ushort*)(ptr + 2 * maxChildren);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,SetSuffix,The following statement contains a magic number: *(ushort*)(ptr + j * 2) += (ushort)src.Size;
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,SetSuffix,The following statement contains a magic number: ptr += 2 * maxChildren + 2;
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,SetSuffix,The following statement contains a magic number: ptr += 2 * maxChildren + 2;
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,SetSuffix,The following statement contains a magic number: var suffixOfs = *(ushort*)(ptr + i * 2);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,SetSuffix,The following statement contains a magic number: var suffixOfs2 = *(ushort*)(ptr + i * 2 + 2);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,SetSuffix,The following statement contains a magic number: var suffixOfs2 = *(ushort*)(ptr + i * 2 + 2);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,SetSuffix,The following statement contains a magic number: var suffixOfs3 = *(ushort*)(ptr + 2 * maxChildren);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,SetSuffix,The following statement contains a magic number: *(ushort*)(ptr + j * 2) += (ushort)src.Length;
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,SetSuffix,The following statement contains a magic number: ptr += 2 * maxChildren + 2;
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,SetSuffix,The following statement contains a magic number: ptr += 2 * maxChildren + 2;
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetSuffixSize,The following statement contains a magic number: var suffixOfs = *(ushort*)(ptr + i * 2);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetSuffixSize,The following statement contains a magic number: var suffixSize = (uint)(*(ushort*)(ptr + i * 2 + 2) - suffixOfs);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetSuffixSize,The following statement contains a magic number: var suffixSize = (uint)(*(ushort*)(ptr + i * 2 + 2) - suffixOfs);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetSuffixSizeAndPtr,The following statement contains a magic number: var suffixOfs = *(ushort*)(ptr + i * 2);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetSuffixSizeAndPtr,The following statement contains a magic number: var suffixSize = (uint)(*(ushort*)(ptr + i * 2 + 2) - suffixOfs);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetSuffixSizeAndPtr,The following statement contains a magic number: var suffixSize = (uint)(*(ushort*)(ptr + i * 2 + 2) - suffixOfs);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetSuffixSizeAndPtr,The following statement contains a magic number: ptr += 2 * maxChildren + 2 + suffixOfs;
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetSuffixSizeAndPtr,The following statement contains a magic number: ptr += 2 * maxChildren + 2 + suffixOfs;
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetSuffixTotalSizeAndPtr,The following statement contains a magic number: var suffixSize = *(ushort*)(ptr + maxChildren * 2);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetValueSizeAndPtr,The following statement contains a magic number: ptr += 2 * maxChildren;
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetValueSizeAndPtr,The following statement contains a magic number: ptr += 2 + *(ushort*)ptr;
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetValueSizeAndPtr,The following statement contains a magic number: return (12' ptr);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetAllSizeAndPtr,The following statement contains a magic number: ptr += 2 * maxChildren;
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetAllSizeAndPtr,The following statement contains a magic number: ptr += 2 + (int)totalSuffixSize;
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetAllSizeAndPtr,The following statement contains a magic number: return (baseSize' maxChildren' prefixSize' prefixPtr' totalSuffixSize' suffixPtr' 12' ptr);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetAllSizeAndPtr,The following statement contains a magic number: ptr += 2 * maxChildren;
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetAllSizeAndPtr,The following statement contains a magic number: ptr += 2 + (int)totalSuffixSize;
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,GetAllSizeAndPtr,The following statement contains a magic number: return (prefixSize' prefixPtr' suffixPtr' 12' ptr);
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return node + 16;                 case NodeType12.Node4: return node + 16 + 4 + posInNode * 12;                 case NodeType12.Node16: return node + 16 + 16 + posInNode * 12;                 case NodeType12.Node48: return node + 16 + 256 + posInNode * 12;                 case NodeType12.Node256: return node + 16 + posInNode * 12;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return node + 16;                 case NodeType12.Node4: return node + 16 + 4 + posInNode * 12;                 case NodeType12.Node16: return node + 16 + 16 + posInNode * 12;                 case NodeType12.Node48: return node + 16 + 256 + posInNode * 12;                 case NodeType12.Node256: return node + 16 + posInNode * 12;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return node + 16;                 case NodeType12.Node4: return node + 16 + 4 + posInNode * 12;                 case NodeType12.Node16: return node + 16 + 16 + posInNode * 12;                 case NodeType12.Node48: return node + 16 + 256 + posInNode * 12;                 case NodeType12.Node256: return node + 16 + posInNode * 12;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return node + 16;                 case NodeType12.Node4: return node + 16 + 4 + posInNode * 12;                 case NodeType12.Node16: return node + 16 + 16 + posInNode * 12;                 case NodeType12.Node48: return node + 16 + 256 + posInNode * 12;                 case NodeType12.Node256: return node + 16 + posInNode * 12;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return node + 16;                 case NodeType12.Node4: return node + 16 + 4 + posInNode * 12;                 case NodeType12.Node16: return node + 16 + 16 + posInNode * 12;                 case NodeType12.Node48: return node + 16 + 256 + posInNode * 12;                 case NodeType12.Node256: return node + 16 + posInNode * 12;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return node + 16;                 case NodeType12.Node4: return node + 16 + 4 + posInNode * 12;                 case NodeType12.Node16: return node + 16 + 16 + posInNode * 12;                 case NodeType12.Node48: return node + 16 + 256 + posInNode * 12;                 case NodeType12.Node256: return node + 16 + posInNode * 12;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return node + 16;                 case NodeType12.Node4: return node + 16 + 4 + posInNode * 12;                 case NodeType12.Node16: return node + 16 + 16 + posInNode * 12;                 case NodeType12.Node48: return node + 16 + 256 + posInNode * 12;                 case NodeType12.Node256: return node + 16 + posInNode * 12;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return node + 16;                 case NodeType12.Node4: return node + 16 + 4 + posInNode * 12;                 case NodeType12.Node16: return node + 16 + 16 + posInNode * 12;                 case NodeType12.Node48: return node + 16 + 256 + posInNode * 12;                 case NodeType12.Node256: return node + 16 + posInNode * 12;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return node + 16;                 case NodeType12.Node4: return node + 16 + 4 + posInNode * 12;                 case NodeType12.Node16: return node + 16 + 16 + posInNode * 12;                 case NodeType12.Node48: return node + 16 + 256 + posInNode * 12;                 case NodeType12.Node256: return node + 16 + posInNode * 12;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return node + 16;                 case NodeType12.Node4: return node + 16 + 4 + posInNode * 12;                 case NodeType12.Node16: return node + 16 + 16 + posInNode * 12;                 case NodeType12.Node48: return node + 16 + 256 + posInNode * 12;                 case NodeType12.Node256: return node + 16 + posInNode * 12;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return node + 16;                 case NodeType12.Node4: return node + 16 + 4 + posInNode * 12;                 case NodeType12.Node16: return node + 16 + 16 + posInNode * 12;                 case NodeType12.Node48: return node + 16 + 256 + posInNode * 12;                 case NodeType12.Node256: return node + 16 + posInNode * 12;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return node + 16;                 case NodeType12.Node4: return node + 16 + 4 + posInNode * 12;                 case NodeType12.Node16: return node + 16 + 16 + posInNode * 12;                 case NodeType12.Node48: return node + 16 + 256 + posInNode * 12;                 case NodeType12.Node256: return node + 16 + posInNode * 12;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,MaxChildren,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return 0;                 case NodeType12.Node4: return 4;                 case NodeType12.Node16: return 16;                 case NodeType12.Node48: return 48;                 case NodeType12.Node256: return 256;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,MaxChildren,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return 0;                 case NodeType12.Node4: return 4;                 case NodeType12.Node16: return 16;                 case NodeType12.Node48: return 48;                 case NodeType12.Node256: return 256;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,MaxChildren,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return 0;                 case NodeType12.Node4: return 4;                 case NodeType12.Node16: return 16;                 case NodeType12.Node48: return 48;                 case NodeType12.Node256: return 256;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,MaxChildren,The following statement contains a magic number: switch (nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf: return 0;                 case NodeType12.Node4: return 4;                 case NodeType12.Node16: return 16;                 case NodeType12.Node48: return 48;                 case NodeType12.Node256: return 256;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,CalcTotalSuffixSize,The following statement contains a magic number: return (int)suffixSize + maxChildren * 2 + 2;
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,CalcTotalSuffixSize,The following statement contains a magic number: return (int)suffixSize + maxChildren * 2 + 2;
Magic Number,BTDB.ARTLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtils12.cs,ValidateSuffix,The following statement contains a magic number: suffix > 0 && suffix < 256
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return 16;                 case NodeTypeV.Node4: return 16 + 4 + 4 * 8;                 case NodeTypeV.Node16: return 16 + 16 + 16 * 8;                 case NodeTypeV.Node48: return 16 + 256 + 48 * 8;                 case NodeTypeV.Node256: return 16 + 256 * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return 16;                 case NodeTypeV.Node4: return 16 + 4 + 4 * 8;                 case NodeTypeV.Node16: return 16 + 16 + 16 * 8;                 case NodeTypeV.Node48: return 16 + 256 + 48 * 8;                 case NodeTypeV.Node256: return 16 + 256 * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return 16;                 case NodeTypeV.Node4: return 16 + 4 + 4 * 8;                 case NodeTypeV.Node16: return 16 + 16 + 16 * 8;                 case NodeTypeV.Node48: return 16 + 256 + 48 * 8;                 case NodeTypeV.Node256: return 16 + 256 * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return 16;                 case NodeTypeV.Node4: return 16 + 4 + 4 * 8;                 case NodeTypeV.Node16: return 16 + 16 + 16 * 8;                 case NodeTypeV.Node48: return 16 + 256 + 48 * 8;                 case NodeTypeV.Node256: return 16 + 256 * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return 16;                 case NodeTypeV.Node4: return 16 + 4 + 4 * 8;                 case NodeTypeV.Node16: return 16 + 16 + 16 * 8;                 case NodeTypeV.Node48: return 16 + 256 + 48 * 8;                 case NodeTypeV.Node256: return 16 + 256 * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return 16;                 case NodeTypeV.Node4: return 16 + 4 + 4 * 8;                 case NodeTypeV.Node16: return 16 + 16 + 16 * 8;                 case NodeTypeV.Node48: return 16 + 256 + 48 * 8;                 case NodeTypeV.Node256: return 16 + 256 * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return 16;                 case NodeTypeV.Node4: return 16 + 4 + 4 * 8;                 case NodeTypeV.Node16: return 16 + 16 + 16 * 8;                 case NodeTypeV.Node48: return 16 + 256 + 48 * 8;                 case NodeTypeV.Node256: return 16 + 256 * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return 16;                 case NodeTypeV.Node4: return 16 + 4 + 4 * 8;                 case NodeTypeV.Node16: return 16 + 16 + 16 * 8;                 case NodeTypeV.Node48: return 16 + 256 + 48 * 8;                 case NodeTypeV.Node256: return 16 + 256 * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return 16;                 case NodeTypeV.Node4: return 16 + 4 + 4 * 8;                 case NodeTypeV.Node16: return 16 + 16 + 16 * 8;                 case NodeTypeV.Node48: return 16 + 256 + 48 * 8;                 case NodeTypeV.Node256: return 16 + 256 * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return 16;                 case NodeTypeV.Node4: return 16 + 4 + 4 * 8;                 case NodeTypeV.Node16: return 16 + 16 + 16 * 8;                 case NodeTypeV.Node48: return 16 + 256 + 48 * 8;                 case NodeTypeV.Node256: return 16 + 256 * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return 16;                 case NodeTypeV.Node4: return 16 + 4 + 4 * 8;                 case NodeTypeV.Node16: return 16 + 16 + 16 * 8;                 case NodeTypeV.Node48: return 16 + 256 + 48 * 8;                 case NodeTypeV.Node256: return 16 + 256 * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return 16;                 case NodeTypeV.Node4: return 16 + 4 + 4 * 8;                 case NodeTypeV.Node16: return 16 + 16 + 16 * 8;                 case NodeTypeV.Node48: return 16 + 256 + 48 * 8;                 case NodeTypeV.Node256: return 16 + 256 * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return 16;                 case NodeTypeV.Node4: return 16 + 4 + 4 * 8;                 case NodeTypeV.Node16: return 16 + 16 + 16 * 8;                 case NodeTypeV.Node48: return 16 + 256 + 48 * 8;                 case NodeTypeV.Node256: return 16 + 256 * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return 16;                 case NodeTypeV.Node4: return 16 + 4 + 4 * 8;                 case NodeTypeV.Node16: return 16 + 16 + 16 * 8;                 case NodeTypeV.Node48: return 16 + 256 + 48 * 8;                 case NodeTypeV.Node256: return 16 + 256 * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return 16;                 case NodeTypeV.Node4: return 16 + 4 + 4 * 8;                 case NodeTypeV.Node16: return 16 + 16 + 16 * 8;                 case NodeTypeV.Node48: return 16 + 256 + 48 * 8;                 case NodeTypeV.Node256: return 16 + 256 * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,BaseSize,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return 16;                 case NodeTypeV.Node4: return 16 + 4 + 4 * 8;                 case NodeTypeV.Node16: return 16 + 16 + 16 * 8;                 case NodeTypeV.Node48: return 16 + 256 + 48 * 8;                 case NodeTypeV.Node256: return 16 + 256 * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return node + 16;                 case NodeTypeV.Node4: return node + 16 + 4 + posInNode * 8;                 case NodeTypeV.Node16: return node + 16 + 16 + posInNode * 8;                 case NodeTypeV.Node48: return node + 16 + 256 + posInNode * 8;                 case NodeTypeV.Node256: return node + 16 + posInNode * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return node + 16;                 case NodeTypeV.Node4: return node + 16 + 4 + posInNode * 8;                 case NodeTypeV.Node16: return node + 16 + 16 + posInNode * 8;                 case NodeTypeV.Node48: return node + 16 + 256 + posInNode * 8;                 case NodeTypeV.Node256: return node + 16 + posInNode * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return node + 16;                 case NodeTypeV.Node4: return node + 16 + 4 + posInNode * 8;                 case NodeTypeV.Node16: return node + 16 + 16 + posInNode * 8;                 case NodeTypeV.Node48: return node + 16 + 256 + posInNode * 8;                 case NodeTypeV.Node256: return node + 16 + posInNode * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return node + 16;                 case NodeTypeV.Node4: return node + 16 + 4 + posInNode * 8;                 case NodeTypeV.Node16: return node + 16 + 16 + posInNode * 8;                 case NodeTypeV.Node48: return node + 16 + 256 + posInNode * 8;                 case NodeTypeV.Node256: return node + 16 + posInNode * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return node + 16;                 case NodeTypeV.Node4: return node + 16 + 4 + posInNode * 8;                 case NodeTypeV.Node16: return node + 16 + 16 + posInNode * 8;                 case NodeTypeV.Node48: return node + 16 + 256 + posInNode * 8;                 case NodeTypeV.Node256: return node + 16 + posInNode * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return node + 16;                 case NodeTypeV.Node4: return node + 16 + 4 + posInNode * 8;                 case NodeTypeV.Node16: return node + 16 + 16 + posInNode * 8;                 case NodeTypeV.Node48: return node + 16 + 256 + posInNode * 8;                 case NodeTypeV.Node256: return node + 16 + posInNode * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return node + 16;                 case NodeTypeV.Node4: return node + 16 + 4 + posInNode * 8;                 case NodeTypeV.Node16: return node + 16 + 16 + posInNode * 8;                 case NodeTypeV.Node48: return node + 16 + 256 + posInNode * 8;                 case NodeTypeV.Node256: return node + 16 + posInNode * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return node + 16;                 case NodeTypeV.Node4: return node + 16 + 4 + posInNode * 8;                 case NodeTypeV.Node16: return node + 16 + 16 + posInNode * 8;                 case NodeTypeV.Node48: return node + 16 + 256 + posInNode * 8;                 case NodeTypeV.Node256: return node + 16 + posInNode * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return node + 16;                 case NodeTypeV.Node4: return node + 16 + 4 + posInNode * 8;                 case NodeTypeV.Node16: return node + 16 + 16 + posInNode * 8;                 case NodeTypeV.Node48: return node + 16 + 256 + posInNode * 8;                 case NodeTypeV.Node256: return node + 16 + posInNode * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return node + 16;                 case NodeTypeV.Node4: return node + 16 + 4 + posInNode * 8;                 case NodeTypeV.Node16: return node + 16 + 16 + posInNode * 8;                 case NodeTypeV.Node48: return node + 16 + 256 + posInNode * 8;                 case NodeTypeV.Node256: return node + 16 + posInNode * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return node + 16;                 case NodeTypeV.Node4: return node + 16 + 4 + posInNode * 8;                 case NodeTypeV.Node16: return node + 16 + 16 + posInNode * 8;                 case NodeTypeV.Node48: return node + 16 + 256 + posInNode * 8;                 case NodeTypeV.Node256: return node + 16 + posInNode * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,PtrInNode,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return node + 16;                 case NodeTypeV.Node4: return node + 16 + 4 + posInNode * 8;                 case NodeTypeV.Node16: return node + 16 + 16 + posInNode * 8;                 case NodeTypeV.Node48: return node + 16 + 256 + posInNode * 8;                 case NodeTypeV.Node256: return node + 16 + posInNode * 8;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,MaxChildren,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return 0;                 case NodeTypeV.Node4: return 4;                 case NodeTypeV.Node16: return 16;                 case NodeTypeV.Node48: return 48;                 case NodeTypeV.Node256: return 256;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,MaxChildren,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return 0;                 case NodeTypeV.Node4: return 4;                 case NodeTypeV.Node16: return 16;                 case NodeTypeV.Node48: return 48;                 case NodeTypeV.Node256: return 256;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,MaxChildren,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return 0;                 case NodeTypeV.Node4: return 4;                 case NodeTypeV.Node16: return 16;                 case NodeTypeV.Node48: return 48;                 case NodeTypeV.Node256: return 256;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.ARTLib,NodeUtilsV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\NodeUtilsV.cs,MaxChildren,The following statement contains a magic number: switch (nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf: return 0;                 case NodeTypeV.Node4: return 4;                 case NodeTypeV.Node16: return 16;                 case NodeTypeV.Node48: return 48;                 case NodeTypeV.Node256: return 256;                 default: throw new InvalidOperationException();             }
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,AllocateLeaf,The following statement contains a magic number: uint size = 8;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,AllocateLeaf,The following statement contains a magic number: size += 2 * childCount + 2;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,AllocateLeaf,The following statement contains a magic number: size += 2 * childCount + 2;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,AllocateLeaf,The following statement contains a magic number: size += 12 * childCount;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,AllocateLeaf,The following statement contains a magic number: new Span<byte>(node.ToPointer()' (int) size).Slice(8).Clear();
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,AllocateBranch,The following statement contains a magic number: uint size = 16;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,AllocateBranch,The following statement contains a magic number: size += 2 * childCount;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,AllocateBranch,The following statement contains a magic number: size += 8 * childCount;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,AllocateBranch,The following statement contains a magic number: new Span<byte>(node.ToPointer()' (int) size).Slice(8).Clear();
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,ValueReplacer,The following statement contains a magic number: var value = values.Slice(i' 12);
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,ValueReplacer,The following statement contains a magic number: value = values.Slice(i' 12);
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,ValueReplacer,The following statement contains a magic number: var valueFileId = (uint) (targetOfs >> 32);
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,ValueReplacer,The following statement contains a magic number: MemoryMarshal.Write(value.Slice(4)' ref valueFileOfs);
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,ValueReplacer,The following statement contains a magic number: ctx._positionMap.TryGetValue(                         (((ulong) MemoryMarshal.Read<uint>(value)) << 32) + MemoryMarshal.Read<uint>(value.Slice(4))'                         out var targetOfs)
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,ValueReplacer,The following statement contains a magic number: ctx._positionMap.TryGetValue(                         (((ulong) MemoryMarshal.Read<uint>(value)) << 32) + MemoryMarshal.Read<uint>(value.Slice(4))'                         out var targetOfs)
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,BuildTreeNode,The following statement contains a magic number: var values = new byte[MaxChildren * 12];
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,BuildTreeNode,The following statement contains a magic number: return BuildBranchNode(leafs' () =>             {                 order++;                 var reach = keyCount * order / leafs;                 var todo = (int) (reach - done);                 done = reach;                 long totalKeyLen = 0;                 for (int i = 0; i < todo; i++)                 {                     generator(ref keys[i]' values.AsSpan(i * 12' 12));                     totalKeyLen += keys[i].Length;                 }                  var newPrefixSize = TreeNodeUtils.CalcCommonPrefix(keys.AsSpan(0' todo));                 var newSuffixSize = totalKeyLen - todo * newPrefixSize;                 var newNode = AllocateLeaf((uint) todo' (uint) newPrefixSize' (ulong) newSuffixSize' out var keyPusher);                 for (var i = 0; i < todo; i++)                 {                     keyPusher.AddKey(keys[i].AsSyncReadOnlySpan());                 }                  keyPusher.Finish();                 values.AsSpan(0' todo * 12).CopyTo(NodeUtils12.GetLeafValues(newNode));                 return newNode;             });
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,BuildTreeNode,The following statement contains a magic number: return BuildBranchNode(leafs' () =>             {                 order++;                 var reach = keyCount * order / leafs;                 var todo = (int) (reach - done);                 done = reach;                 long totalKeyLen = 0;                 for (int i = 0; i < todo; i++)                 {                     generator(ref keys[i]' values.AsSpan(i * 12' 12));                     totalKeyLen += keys[i].Length;                 }                  var newPrefixSize = TreeNodeUtils.CalcCommonPrefix(keys.AsSpan(0' todo));                 var newSuffixSize = totalKeyLen - todo * newPrefixSize;                 var newNode = AllocateLeaf((uint) todo' (uint) newPrefixSize' (ulong) newSuffixSize' out var keyPusher);                 for (var i = 0; i < todo; i++)                 {                     keyPusher.AddKey(keys[i].AsSyncReadOnlySpan());                 }                  keyPusher.Finish();                 values.AsSpan(0' todo * 12).CopyTo(NodeUtils12.GetLeafValues(newNode));                 return newNode;             });
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,BuildTreeNode,The following statement contains a magic number: return BuildBranchNode(leafs' () =>             {                 order++;                 var reach = keyCount * order / leafs;                 var todo = (int) (reach - done);                 done = reach;                 long totalKeyLen = 0;                 for (int i = 0; i < todo; i++)                 {                     generator(ref keys[i]' values.AsSpan(i * 12' 12));                     totalKeyLen += keys[i].Length;                 }                  var newPrefixSize = TreeNodeUtils.CalcCommonPrefix(keys.AsSpan(0' todo));                 var newSuffixSize = totalKeyLen - todo * newPrefixSize;                 var newNode = AllocateLeaf((uint) todo' (uint) newPrefixSize' (ulong) newSuffixSize' out var keyPusher);                 for (var i = 0; i < todo; i++)                 {                     keyPusher.AddKey(keys[i].AsSyncReadOnlySpan());                 }                  keyPusher.Finish();                 values.AsSpan(0' todo * 12).CopyTo(NodeUtils12.GetLeafValues(newNode));                 return newNode;             });
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,EraseFromLeaf,The following statement contains a magic number: oldValues.Slice(0' 12 * leftPos).CopyTo(newValues);
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,EraseFromLeaf,The following statement contains a magic number: oldValues.Slice((rightPos + 1) * 12).CopyTo(newValues.Slice(12 * leftPos));
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,EraseFromLeaf,The following statement contains a magic number: oldValues.Slice((rightPos + 1) * 12).CopyTo(newValues.Slice(12 * leftPos));
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,CloneKey,The following statement contains a magic number: var res = _allocator.Allocate((IntPtr) size + 4);
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,CloneKey,The following statement contains a magic number: TreeNodeUtils.CopyMemory(ptr' res' size + 4);
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,CheckContent12,The following statement contains a magic number: content.Length != 12
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,WriteValue,The following statement contains a magic number: content.CopyTo(NodeUtils12.GetLeafValues(stackItem._node).Slice(stackItem._posInNode * 12' 12));
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,WriteValue,The following statement contains a magic number: content.CopyTo(NodeUtils12.GetLeafValues(stackItem._node).Slice(stackItem._posInNode * 12' 12));
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,BinarySearchKeys,The following statement contains a magic number: var m = (l + r) / 2;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,BinarySearchKeys,The following statement contains a magic number: return m * 2 + 1;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,BinarySearchKeys,The following statement contains a magic number: return l * 2;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,BinarySearchKeysLast,The following statement contains a magic number: var m = (l + r) / 2;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,BinarySearchKeysLastLeaf,The following statement contains a magic number: var r = offsets.Length - 2;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,BinarySearchKeysLastLeaf,The following statement contains a magic number: var m = (l + r) / 2;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,BinarySearchLongKeys,The following statement contains a magic number: var m = (l + r) / 2;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,BinarySearchLongKeys,The following statement contains a magic number: return m * 2 + 1;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,BinarySearchLongKeys,The following statement contains a magic number: return l * 2;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,BinarySearchLongKeysLast,The following statement contains a magic number: var m = (l + r) / 2;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,BinarySearchLongKeysLastLeaf,The following statement contains a magic number: var m = (l + r) / 2;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,FindFirst,The following statement contains a magic number: stack.AddRef().Set(top' (byte) (idx / 2));
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,FindFirst,The following statement contains a magic number: idx = idx / 2;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,FindFirst,The following statement contains a magic number: idx = idx / 2;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,Upsert,The following statement contains a magic number: idx = (idx + 1) / 2;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,Upsert,The following statement contains a magic number: stack.AddRef().Set(top' (byte) (idx / 2));
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,Upsert,The following statement contains a magic number: idx = idx / 2;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,Upsert,The following statement contains a magic number: oldValues.Slice(0' 12 * idx).CopyTo(newValues);
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,Upsert,The following statement contains a magic number: newValues = newValues.Slice(12 * idx);
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,Upsert,The following statement contains a magic number: newValues = newValues.Slice(12);
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,Upsert,The following statement contains a magic number: oldValues.Slice(12 * idx).CopyTo(newValues);
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,BinarySearch,The following statement contains a magic number: return 2 * header.KeyCount;
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,AllocateLongKey,The following statement contains a magic number: var res = _allocator.Allocate((IntPtr) (4 + data.Length));
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,AllocateLongKey,The following statement contains a magic number: data.CopyTo(new Span<byte>((res + 4).ToPointer()' data.Length));
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,AllocateLongKey,The following statement contains a magic number: var res = _allocator.Allocate((IntPtr) (4 + totalLen));
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,AllocateLongKey,The following statement contains a magic number: var dest = new Span<byte>((res + 4).ToPointer()' totalLen);
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,ValuesIterate,The following statement contains a magic number: var valueOfs = MemoryMarshal.Read<uint>(values.Slice(4));
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,ValuesIterate,The following statement contains a magic number: var valueSize = MemoryMarshal.Read<int>(values.Slice(8));
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,ValuesIterate,The following statement contains a magic number: values = values.Slice(12);
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,ValuesIterate,The following statement contains a magic number: values.Length >= 12
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,KeyValueIterate,The following statement contains a magic number: ctx.CurrentValue = values.Slice(i * 12' 12);
Magic Number,BTDB.BTreeLib,BTreeImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,KeyValueIterate,The following statement contains a magic number: ctx.CurrentValue = values.Slice(i * 12' 12);
Magic Number,BTDB.BTreeLib,SplitInserter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,Run,The following statement contains a magic number: var stackIdx = (int) stack.Count - 2;
Magic Number,BTDB.BTreeLib,SplitInserter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,Run,The following statement contains a magic number: var newRootNode = _owner.AllocateBranch(2' (uint) keyPrefix.Length' (ulong) keySuffix.Length'                         out var keyPusher);
Magic Number,BTDB.BTreeLib,SplitInserter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\BTreeImpl12.cs,Run,The following statement contains a magic number: newValues = newValues.Slice(2);
Magic Number,BTDB.BTreeLib,Cursor12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\Cursor12.cs,FillByKey,The following statement contains a magic number: new Span<byte>((keyPtr + 4).ToPointer()' lenSuffix).CopyTo(res.Slice(header._keyPrefixLength));
Magic Number,BTDB.BTreeLib,Cursor12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\Cursor12.cs,GetValueLength,The following statement contains a magic number: return 12;
Magic Number,BTDB.BTreeLib,Cursor12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\Cursor12.cs,GetValue,The following statement contains a magic number: return vals.Slice(stackItem._posInNode * 12' 12);
Magic Number,BTDB.BTreeLib,Cursor12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\Cursor12.cs,GetValue,The following statement contains a magic number: return vals.Slice(stackItem._posInNode * 12' 12);
Magic Number,BTDB.BTreeLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\NodeUtils12.cs,Ptr2NodeHeader,The following statement contains a magic number: Debug.Assert((uint)(*(NodeHeader12*)pointerInt)._nodeType < 4);
Magic Number,BTDB.BTreeLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\NodeUtils12.cs,GetKeySpans,The following statement contains a magic number: ptr += 2 * offsetsCount;
Magic Number,BTDB.BTreeLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\NodeUtils12.cs,GetKeySpans,The following statement contains a magic number: var keysLen = *(ushort*)(ptr - 2);
Magic Number,BTDB.BTreeLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\NodeUtils12.cs,GetKeySpans,The following statement contains a magic number: ptr += 2 * offsetsCount;
Magic Number,BTDB.BTreeLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\NodeUtils12.cs,GetLeafValues,The following statement contains a magic number: var ptr = nodePtr + 8;
Magic Number,BTDB.BTreeLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\NodeUtils12.cs,GetLeafValues,The following statement contains a magic number: ptr += 8 * header._childCount;
Magic Number,BTDB.BTreeLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\NodeUtils12.cs,GetLeafValues,The following statement contains a magic number: return new Span<byte>(ptr.ToPointer()' 12 * header._childCount);
Magic Number,BTDB.BTreeLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\NodeUtils12.cs,GetBranchValuePtrs,The following statement contains a magic number: var ptr = nodePtr + 16;
Magic Number,BTDB.BTreeLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\NodeUtils12.cs,GetBranchValuePtrs,The following statement contains a magic number: ptr += 8 * (header._childCount - 1);
Magic Number,BTDB.BTreeLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\NodeUtils12.cs,NodeSize,The following statement contains a magic number: ptr += 8 * header._childCount;
Magic Number,BTDB.BTreeLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\NodeUtils12.cs,NodeSize,The following statement contains a magic number: return (int)(ptr.ToInt64() - nodePtr.ToInt64() + 12 * header._childCount);
Magic Number,BTDB.BTreeLib,NodeUtils12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\BTreeLib\NodeUtils12.cs,LongKeyPtrToSpan,The following statement contains a magic number: return new Span<byte>((ptr + 4).ToPointer()' size);
Magic Number,BTDB.Buffer,ByteBuffer,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\ByteBuffer.cs,ResizingAppend,The following statement contains a magic number: var newCapacity = Math.Max(Length + append.Length' Length * 2);
Magic Number,BTDB.Buffer,ByteBuffer,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\ByteBuffer.cs,Expand,The following statement contains a magic number: this = NewAsync(new byte[Math.Min((long) size * 3 / 2' int.MaxValue)]);
Magic Number,BTDB.Buffer,ByteBuffer,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\ByteBuffer.cs,Expand,The following statement contains a magic number: this = NewAsync(new byte[Math.Min((long) size * 3 / 2' int.MaxValue)]);
Magic Number,BTDB.Buffer,Key20,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\ByteStructs.cs,Key20,The following statement contains a magic number: V2 = PackUnpack.UnpackUInt64LE(value.Buffer' value.Offset + 8);
Magic Number,BTDB.Buffer,Key20,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\ByteStructs.cs,Key20,The following statement contains a magic number: V3 = PackUnpack.UnpackUInt32LE(value.Buffer' value.Offset + 16);
Magic Number,BTDB.Buffer,Key20,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\ByteStructs.cs,FillBuffer,The following statement contains a magic number: PackUnpack.PackUInt64LE(buf.Buffer' o + 8' V2);
Magic Number,BTDB.Buffer,Key20,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\ByteStructs.cs,FillBuffer,The following statement contains a magic number: PackUnpack.PackUInt32LE(buf.Buffer' o + 16' V3);
Magic Number,BTDB.Buffer,Key32,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\ByteStructs.cs,Key32,The following statement contains a magic number: V2 = PackUnpack.UnpackUInt64LE(value.Buffer' value.Offset + 8);
Magic Number,BTDB.Buffer,Key32,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\ByteStructs.cs,Key32,The following statement contains a magic number: V3 = PackUnpack.UnpackUInt64LE(value.Buffer' value.Offset + 16);
Magic Number,BTDB.Buffer,Key32,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\ByteStructs.cs,Key32,The following statement contains a magic number: V4 = PackUnpack.UnpackUInt64LE(value.Buffer' value.Offset + 23);
Magic Number,BTDB.Buffer,Key32,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\ByteStructs.cs,FillBuffer,The following statement contains a magic number: PackUnpack.PackUInt64LE(buf.Buffer' o + 8' V2);
Magic Number,BTDB.Buffer,Key32,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\ByteStructs.cs,FillBuffer,The following statement contains a magic number: PackUnpack.PackUInt64LE(buf.Buffer' o + 16' V3);
Magic Number,BTDB.Buffer,Key32,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\ByteStructs.cs,FillBuffer,The following statement contains a magic number: PackUnpack.PackUInt64LE(buf.Buffer' o + 24' V4);
Magic Number,BTDB.Buffer,Checksum,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: uint tlen = length > 360 ? 360 : length;
Magic Number,BTDB.Buffer,Checksum,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: uint tlen = length > 360 ? 360 : length;
Magic Number,BTDB.Buffer,Checksum,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: sum1 += (uint)(data[position] + data[position + 1] * 256);
Magic Number,BTDB.Buffer,Checksum,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: position += 2;
Magic Number,BTDB.Buffer,Checksum,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: sum1 = (sum1 & 0xffff) + (sum1 >> 16);
Magic Number,BTDB.Buffer,Checksum,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: sum2 = (sum2 & 0xffff) + (sum2 >> 16);
Magic Number,BTDB.Buffer,Checksum,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: sum1 = (sum1 & 0xffff) + (sum1 >> 16);
Magic Number,BTDB.Buffer,Checksum,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: sum2 = (sum2 & 0xffff) + (sum2 >> 16);
Magic Number,BTDB.Buffer,Checksum,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: sum1 = (sum1 & 0xffff) + (sum1 >> 16);
Magic Number,BTDB.Buffer,Checksum,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: sum2 = (sum2 & 0xffff) + (sum2 >> 16);
Magic Number,BTDB.Buffer,Checksum,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: return sum2 << 16 | sum1;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt16LE,The following statement contains a magic number: data[offset + 1] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt16LE,The following statement contains a magic number: return (ushort)(data[offset] | (data[offset + 1] << 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt16LE,The following statement contains a magic number: data[offset + 1] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt16LE,The following statement contains a magic number: return (short)(data[offset] | (data[offset + 1] << 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt32LE,The following statement contains a magic number: data[offset + 1] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt32LE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt32LE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt32LE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt32LE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt32LE,The following statement contains a magic number: return (uint)(data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt32LE,The following statement contains a magic number: return (uint)(data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt32LE,The following statement contains a magic number: return (uint)(data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt32LE,The following statement contains a magic number: return (uint)(data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt32LE,The following statement contains a magic number: return (uint)(data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32LE,The following statement contains a magic number: data[offset + 1] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32LE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32LE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32LE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32LE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32BE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32BE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32BE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32BE,The following statement contains a magic number: data[offset + 1] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32BE,The following statement contains a magic number: data[offset] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32LE,The following statement contains a magic number: return data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32LE,The following statement contains a magic number: return data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32LE,The following statement contains a magic number: return data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32LE,The following statement contains a magic number: return data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32LE,The following statement contains a magic number: return data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32BE,The following statement contains a magic number: return data[offset + 3] | (data[offset + 2] << 8) | (data[offset + 1] << 16) | (data[offset] << 24);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32BE,The following statement contains a magic number: return data[offset + 3] | (data[offset + 2] << 8) | (data[offset + 1] << 16) | (data[offset] << 24);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32BE,The following statement contains a magic number: return data[offset + 3] | (data[offset + 2] << 8) | (data[offset + 1] << 16) | (data[offset] << 24);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32BE,The following statement contains a magic number: return data[offset + 3] | (data[offset + 2] << 8) | (data[offset + 1] << 16) | (data[offset] << 24);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32BE,The following statement contains a magic number: return data[offset + 3] | (data[offset + 2] << 8) | (data[offset + 1] << 16) | (data[offset] << 24);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 1] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 4] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 4] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 5] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 5] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 6] = unchecked((byte)(value >> 48));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 6] = unchecked((byte)(value >> 48));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 7] = unchecked((byte)(value >> 56));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 7] = unchecked((byte)(value >> 56));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 1] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 4] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 4] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 5] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 5] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 6] = unchecked((byte)(value >> 48));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 6] = unchecked((byte)(value >> 48));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 7] = unchecked((byte)(value >> 56));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 7] = unchecked((byte)(value >> 56));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 7] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 6] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 6] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 5] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 5] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 4] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 4] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 1] = unchecked((byte)(value >> 48));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset] = unchecked((byte)(value >> 56));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 2;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 3;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 4;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 5;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 2;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 3;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 4;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 5;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 6;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 7;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 8;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 9;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 2;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 3;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 4;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 5;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 6;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 7;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return first == 0xFE ? 8 : 9;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return first == 0xFE ? 8 : 9;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs] = (byte)(0x80 + (value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 2;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs] = (byte)(0xC0 + (value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 1] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 3;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs] = (byte)(0xE0 + (value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 1] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 4;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 1] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 5;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs] = (byte)(0x80 + (value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 2;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs] = (byte)(0xC0 + (value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 1] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 3;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs] = (byte)(0xE0 + (value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 1] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 4;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs] = (byte)(0xF0 + (value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 1] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 5;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs] = (byte)(0xF8 + (value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 1] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 5] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 6;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs] = (byte)(0xFC + (value >> 48));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 1] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 5] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 5] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 6] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 7;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs] = (byte)(0xFE + (value >> 56));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 1] = unchecked((byte)(value >> 48));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 5] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 5] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 6] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 6] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 7] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 8;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 1] = unchecked((byte)(value >> 56));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 48));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 48));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 5] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 5] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 6] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 6] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 7] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 7] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 8] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 9;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((first & 0x3F) << 8) + data[ofs];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((first & 0x1Fu) << 16) + ((uint)data[ofs] << 8) + data[ofs + 1];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((first & 0x1Fu) << 16) + ((uint)data[ofs] << 8) + data[ofs + 1];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: ofs += 2;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((first & 0x0Fu) << 24) + ((uint)data[ofs] << 16) + ((uint)data[ofs + 1] << 8) + data[ofs + 2];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((first & 0x0Fu) << 24) + ((uint)data[ofs] << 16) + ((uint)data[ofs + 1] << 8) + data[ofs + 2];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((first & 0x0Fu) << 24) + ((uint)data[ofs] << 16) + ((uint)data[ofs + 1] << 8) + data[ofs + 2];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((first & 0x0Fu) << 24) + ((uint)data[ofs] << 16) + ((uint)data[ofs + 1] << 8) + data[ofs + 2];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: ofs += 3;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x07u) << 32) + ((uint)data[ofs] << 24) + ((uint)data[ofs + 1] << 16)                     + ((uint)data[ofs + 2] << 8) + data[ofs + 3];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x07u) << 32) + ((uint)data[ofs] << 24) + ((uint)data[ofs + 1] << 16)                     + ((uint)data[ofs + 2] << 8) + data[ofs + 3];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x07u) << 32) + ((uint)data[ofs] << 24) + ((uint)data[ofs + 1] << 16)                     + ((uint)data[ofs + 2] << 8) + data[ofs + 3];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x07u) << 32) + ((uint)data[ofs] << 24) + ((uint)data[ofs + 1] << 16)                     + ((uint)data[ofs + 2] << 8) + data[ofs + 3];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x07u) << 32) + ((uint)data[ofs] << 24) + ((uint)data[ofs + 1] << 16)                     + ((uint)data[ofs + 2] << 8) + data[ofs + 3];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x07u) << 32) + ((uint)data[ofs] << 24) + ((uint)data[ofs + 1] << 16)                     + ((uint)data[ofs + 2] << 8) + data[ofs + 3];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: ofs += 4;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x03u) << 40) + ((ulong)data[ofs] << 32) + ((uint)data[ofs + 1] << 24)                     + ((uint)data[ofs + 2] << 16) + ((uint)data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x03u) << 40) + ((ulong)data[ofs] << 32) + ((uint)data[ofs + 1] << 24)                     + ((uint)data[ofs + 2] << 16) + ((uint)data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x03u) << 40) + ((ulong)data[ofs] << 32) + ((uint)data[ofs + 1] << 24)                     + ((uint)data[ofs + 2] << 16) + ((uint)data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x03u) << 40) + ((ulong)data[ofs] << 32) + ((uint)data[ofs + 1] << 24)                     + ((uint)data[ofs + 2] << 16) + ((uint)data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x03u) << 40) + ((ulong)data[ofs] << 32) + ((uint)data[ofs + 1] << 24)                     + ((uint)data[ofs + 2] << 16) + ((uint)data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x03u) << 40) + ((ulong)data[ofs] << 32) + ((uint)data[ofs + 1] << 24)                     + ((uint)data[ofs + 2] << 16) + ((uint)data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x03u) << 40) + ((ulong)data[ofs] << 32) + ((uint)data[ofs + 1] << 24)                     + ((uint)data[ofs + 2] << 16) + ((uint)data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x03u) << 40) + ((ulong)data[ofs] << 32) + ((uint)data[ofs + 1] << 24)                     + ((uint)data[ofs + 2] << 16) + ((uint)data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: ofs += 5;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: ofs += 6;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: ofs += 7;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: ofs += 8;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 2;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 3;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 4;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 5;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 2;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 3;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 4;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 5;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 6;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 7;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 9;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 2;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 3;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 4;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 5;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 6;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 7;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 9;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs] = (byte)(0xC0 + (value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 2;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs] = (byte)(0xE0 + (value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 1] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 3;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs] = (byte)(0xF0 + (value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 1] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 4;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs] = (byte)(0xF8 + (value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 1] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 5;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs] = (byte)(0xFC + (value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 1] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 5] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 6;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 1] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 5] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 5] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 6] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 7;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 1] = unchecked((byte)(value >> 56));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 48));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 48));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 5] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 5] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 6] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 6] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 7] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 7] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 8] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 9;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((first & 0x1F) << 8) + data[ofs];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 2;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 3;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 4;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 5;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 6;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 8;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((int)(first - 0x40) << 8) + data[ofs];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((int)(first - 0x20) << 16) + (data[ofs] << 8) + data[ofs + 1];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((int)(first - 0x20) << 16) + (data[ofs] << 8) + data[ofs + 1];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 2;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((int)(first - 0x10) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((int)(first - 0x10) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((int)(first - 0x10) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((int)(first - 0x10) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 3;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x08) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x08) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x08) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x08) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x08) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x08) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 4;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x04) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x04) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x04) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x04) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x04) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x04) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x04) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x04) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 5;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 6;
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 8;
Magic Number,BTDB.Buffer,TreeNodeUtils,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\TreeNodeUtils.cs,AlignPtrUpInt32,The following statement contains a magic number: return ptr + (~(int) ptr.ToInt64() + 1 & 3);
Magic Number,BTDB.Buffer,TreeNodeUtils,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\TreeNodeUtils.cs,AlignUIntUpInt32,The following statement contains a magic number: return ptr + (~ptr + 1 & 3);
Magic Number,BTDB.Buffer,TreeNodeUtils,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\TreeNodeUtils.cs,AlignPtrUpInt64,The following statement contains a magic number: return ptr + (~(int) ptr.ToInt64() + 1 & 7);
Magic Number,BTDB.Buffer,TreeNodeUtils,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\TreeNodeUtils.cs,AlignUIntUpInt64,The following statement contains a magic number: return ptr + (~ptr + 1 & 7);
Magic Number,BTDB.ChunkCache,DiskChunkCache,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: keySize != 20
Magic Number,BTDB.ChunkCache,DiskChunkCache,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: cacheCapacity < 1000
Magic Number,BTDB.ChunkCache,DiskChunkCache,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: cacheCapacity = cacheCapacity / 1000 * (980 - keySize);
Magic Number,BTDB.ChunkCache,DiskChunkCache,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: cacheCapacity = cacheCapacity / 1000 * (980 - keySize);
Magic Number,BTDB.ChunkCache,DiskChunkCache,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: cacheCapacity / 8 > int.MaxValue
Magic Number,BTDB.ChunkCache,DiskChunkCache,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,PreserveJustMostOftenUsed,The following statement contains a magic number: var preserveRate = freqencies.OrderByDescending(r => r).Skip(freqencies.Count / 5).FirstOrDefault();
Magic Number,BTDB.Collections,HashHelpers,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Collections\HashHelpers.cs,PowerOf2,The following statement contains a magic number: int i = 2;
Magic Number,BTDB.Collections,RefDictionary<TKey;TValue>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Collections\RefDictionary.cs,RefDictionary,The following statement contains a magic number: capacity = 2;
Magic Number,BTDB.Collections,RefDictionary<TKey;TValue>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Collections\RefDictionary.cs,RefDictionary,The following statement contains a magic number: capacity < 2
Magic Number,BTDB.Collections,RefDictionary<TKey;TValue>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Collections\RefDictionary.cs,Remove,The following statement contains a magic number: entries[entryIndex].next = -3 - _freeList;
Magic Number,BTDB.Collections,RefDictionary<TKey;TValue>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Collections\RefDictionary.cs,AddKey,The following statement contains a magic number: _freeList = -3 - entries[_freeList].next;
Magic Number,BTDB.Collections,RefDictionary<TKey;TValue>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Collections\RefDictionary.cs,Resize,The following statement contains a magic number: var newSize = _entries.Length * 2;
Magic Number,BTDB.Collections,RefDictionary<TKey;TValue>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Collections\RefDictionary.cs,CopyTo,The following statement contains a magic number: entry.next > -2
Magic Number,BTDB.Collections,StructList,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Collections\StructList.cs,Expand,The following statement contains a magic number: Array.Resize(ref _a' (int) Math.Min(int.MaxValue' Math.Max(2u' _count * 2)));
Magic Number,BTDB.Collections,StructList,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Collections\StructList.cs,Expand,The following statement contains a magic number: Array.Resize(ref _a' (int) Math.Min(int.MaxValue' Math.Max(2u' _count * 2)));
Magic Number,BTDB.Collections,StructList,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Collections\StructList.cs,Expand,The following statement contains a magic number: Array.Resize(ref _a' (int) Math.Min(int.MaxValue' Math.Max(count' _count * 2)));
Magic Number,BTDB.DtoChannel,DtoChannel,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\DtoChannel\DtoChannel.cs,Send,The following statement contains a magic number: writer.WriteUInt8(100);
Magic Number,BTDB.DtoChannel,DtoChannel,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\DtoChannel\DtoChannel.cs,Send,The following statement contains a magic number: block[0] = 99;
Magic Number,BTDB.DtoChannel,Receiver,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\DtoChannel\DtoChannel.cs,OnNext,The following statement contains a magic number: c0 == 99
Magic Number,BTDB.EventStore2Layer,EventDeserializer,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventDeserializer.cs,LoaderFactory,The following statement contains a magic number: descriptor.GenerateLoad(il' ilGen => ilGen.Ldarg(0)' ilGen => ilGen.Ldarg(1)' ilGen => ilGen.Ldarg(2)' loadAsType);
Magic Number,BTDB.EventStore2Layer,EventSerializer,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,BuildComplexSaver,The following statement contains a magic number: descriptor.GenerateSave(il' ilgen => ilgen.Ldarg(0)' ilgen => ilgen.Ldarg(1)' ilgen =>             {                 ilgen.Ldarg(2);                 var type = descriptor.GetPreferedType();                 if (type != typeof(object))                 {                     ilgen.UnboxAny(type);                 }             }' descriptor.GetPreferedType());
Magic Number,BTDB.EventStoreLayer,AppendingEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,FinalizeStore,The following statement contains a magic number: WriteOneBlock(ByteBuffer.NewSync(new byte[SectorSize * 2]' startOffset' 0)' BlockType.LastBlock);
Magic Number,BTDB.EventStoreLayer,AppendingEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,WriteOneBlock,The following statement contains a magic number: var o = block.Offset - 4;
Magic Number,BTDB.EventStoreLayer,AppendingEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,WriteOneBlock,The following statement contains a magic number: PackUnpack.PackUInt32LE(block.Buffer' o' (blockLen << 8) + (uint)blockType);
Magic Number,BTDB.EventStoreLayer,AppendingEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,WriteOneBlock,The following statement contains a magic number: var checksum = Checksum.CalcFletcher32(block.Buffer' (uint)o' blockLen + 4);
Magic Number,BTDB.EventStoreLayer,AppendingEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,WriteOneBlock,The following statement contains a magic number: o -= 4;
Magic Number,BTDB.EventStoreLayer,EnumTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,EnumTypeDescriptor,The following statement contains a magic number: _flags = (header & 2) != 0;
Magic Number,BTDB.EventStoreLayer,EnumTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,EnumTypeDescriptor,The following statement contains a magic number: var count = header >> 2;
Magic Number,BTDB.EventStoreLayer,EnumTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,AppendIndent,The following statement contains a magic number: text.Append(' '' (int)(indent * 4));
Magic Number,BTDB.EventStoreLayer,EnumTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,Persist,The following statement contains a magic number: writer.WriteVUInt32((_signed ? 1u : 0) + (_flags ? 2u : 0) + 4u * (uint)_pairs.Count);
Magic Number,BTDB.EventStoreLayer,EnumTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,Persist,The following statement contains a magic number: writer.WriteVUInt32((_signed ? 1u : 0) + (_flags ? 2u : 0) + 4u * (uint)_pairs.Count);
Magic Number,BTDB.EventStoreLayer,ListTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GetHashCode,The following statement contains a magic number: return 33 *_itemDescriptor.GetHashCode();
Magic Number,BTDB.EventStoreLayer,NullableTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\NullableTypeDescriptor.cs,GetHashCode,The following statement contains a magic number: return 17 * _itemDescriptor.GetHashCode();
Magic Number,BTDB.EventStoreLayer,ObjectTypeDescriptor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,AppendIndent,The following statement contains a magic number: text.Append(' '' (int) (indent * 4));
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: bufferReadOffset += 4;
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: bufferReadOffset -= 4;
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: blockLen >>= 8;
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: bufferReadOffset += 4;
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: currentReadAhead = currentReadAhead * 2;
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: currentReadAhead * 4 < MaxBlockSize
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum
Magic Number,BTDB.EventStoreLayer,SnappyCompressionStrategy,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\SnappyCompressionStrategy.cs,ShouldTryToCompress,The following statement contains a magic number: return length > 512;
Magic Number,BTDB.EventStoreLayer,SnappyCompressionStrategy,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\SnappyCompressionStrategy.cs,Compress,The following statement contains a magic number: return SnappyCompress.TryCompress(ref data' 80);
Magic Number,BTDB.EventStoreLayer,StreamEventFileStorage,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\StreamEventFileStorage.cs,StreamEventFileStorage,The following statement contains a magic number: MaxBlockSize = 4*1024*1024;
Magic Number,BTDB.EventStoreLayer,StreamEventFileStorage,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\StreamEventFileStorage.cs,StreamEventFileStorage,The following statement contains a magic number: MaxBlockSize = 4*1024*1024;
Magic Number,BTDB.EventStoreLayer,StreamEventFileStorage,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\StreamEventFileStorage.cs,StreamEventFileStorage,The following statement contains a magic number: MaxBlockSize = 4*1024*1024;
Magic Number,BTDB.EventStoreLayer,TypeSerializers,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,LoaderFactory,The following statement contains a magic number: il                     .Ldarg(1)                     .Dup()                     .Stloc(localCtx)                     .Brtrue(haveCtx)                     .Ldarg(0)                     .Ldarg(2)                     .Newobj(() => new DeserializerCtx(null' null))                     .Castclass(typeof(ITypeBinaryDeserializerContext))                     .Stloc(localCtx)                     .Mark(haveCtx);
Magic Number,BTDB.EventStoreLayer,TypeSerializers,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,NewComplexSaver,The following statement contains a magic number: descriptor.GenerateSave(il' ilgen => ilgen.Ldarg(0)' ilgen => ilgen.Ldarg(1)' ilgen =>             {                 ilgen.Ldarg(2);                 var type = descriptor.GetPreferedType();                 if (type != typeof(object))                 {                     ilgen.UnboxAny(type);                 }             }' descriptor.GetPreferedType());
Magic Number,BTDB.FieldHandler,EnumConfiguration,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\EnumFieldHandler.cs,EnumConfiguration,The following statement contains a magic number: _flags = (header & 2) != 0;
Magic Number,BTDB.FieldHandler,EnumConfiguration,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\EnumFieldHandler.cs,EnumConfiguration,The following statement contains a magic number: var count = header >> 2;
Magic Number,BTDB.FieldHandler,EnumConfiguration,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\EnumFieldHandler.cs,ToConfiguration,The following statement contains a magic number: writer.WriteVUInt32((_signed ? 1u : 0) + (Flags ? 2u : 0) + 4u * (uint)Names.Length);
Magic Number,BTDB.FieldHandler,EnumConfiguration,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\EnumFieldHandler.cs,ToConfiguration,The following statement contains a magic number: writer.WriteVUInt32((_signed ? 1u : 0) + (Flags ? 2u : 0) + 4u * (uint)Names.Length);
Magic Number,BTDB.FieldHandler,EnumConfiguration,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\EnumFieldHandler.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ _names.GetHashCode();
Magic Number,BTDB.FieldHandler,EnumConfiguration,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\FieldHandler\EnumFieldHandler.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ _values.GetHashCode();
Magic Number,BTDB.IL.Caching,EnumKey,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\Caching\CachingILBuilder.cs,GetHashCode,The following statement contains a magic number: return _name.GetHashCode() * 33 + _baseType.GetHashCode();
Magic Number,BTDB.IL.Caching,CacheItem,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\Caching\CachingILDynamicMethod.cs,GetHashCode,The following statement contains a magic number: return _name.GetHashCode() * 33 + _delegate.GetHashCode();
Magic Number,BTDB.IL.Caching,CachingILDynamicType,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\Caching\CachingILDynamicType.cs,GetHashCode,The following statement contains a magic number: return _name.GetHashCode() * 33 + _insts.Count;
Magic Number,BTDB.IL.Caching,Method,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\Caching\CachingILDynamicType.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ _name.GetHashCode();
Magic Number,BTDB.IL.Caching,Method,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\Caching\CachingILDynamicType.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ _returns.GetHashCode();
Magic Number,BTDB.IL.Caching,Field,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\Caching\CachingILDynamicType.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ _name.GetHashCode();
Magic Number,BTDB.IL.Caching,Field,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\Caching\CachingILDynamicType.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ _type.GetHashCode();
Magic Number,BTDB.IL.Caching,Event,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\Caching\CachingILDynamicType.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ _name.GetHashCode();
Magic Number,BTDB.IL.Caching,Event,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\Caching\CachingILDynamicType.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ _type.GetHashCode();
Magic Number,BTDB.IL,EmitHelpers,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateAddRemoveEvent,The following statement contains a magic number: ilGenerator                 .Ldarg(0)                 .Ldfld(fieldBuilder)                 .Stloc(0)                 .Mark(label)                 .Ldloc(0)                 .Stloc(1)                 .Ldloc(1)                 .Ldarg(1)                 .Call(add                           ? GetMethodInfo(() => Delegate.Combine(null' null))                           : GetMethodInfo(() => Delegate.Remove(null' null)))                 .Castclass(typePropertyChangedEventHandler)                 .Stloc(2)                 .Ldarg(0)                 .Ldflda(fieldBuilder)                 .Ldloc(2)                 .Ldloc(1);
Magic Number,BTDB.IL,EmitHelpers,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateAddRemoveEvent,The following statement contains a magic number: ilGenerator                 .Ldarg(0)                 .Ldfld(fieldBuilder)                 .Stloc(0)                 .Mark(label)                 .Ldloc(0)                 .Stloc(1)                 .Ldloc(1)                 .Ldarg(1)                 .Call(add                           ? GetMethodInfo(() => Delegate.Combine(null' null))                           : GetMethodInfo(() => Delegate.Remove(null' null)))                 .Castclass(typePropertyChangedEventHandler)                 .Stloc(2)                 .Ldarg(0)                 .Ldflda(fieldBuilder)                 .Ldloc(2)                 .Ldloc(1);
Magic Number,BTDB.IL,ILConstructorImpl,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILConstructorImpl.cs,ILConstructorImpl,The following statement contains a magic number: _expectedLength = 64;
Magic Number,BTDB.IL,ILDynamicMethodImpl,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILDynamicMethodImpl.cs,ILDynamicMethodImpl,The following statement contains a magic number: _expectedLength = 64;
Magic Number,BTDB.IL,ILDynamicMethodWithThisImpl,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILDynamicMethodWithThisImpl.cs,ILDynamicMethodWithThisImpl,The following statement contains a magic number: _expectedLength = 64;
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value)             {                 case 0:                     il.Emit(OpCodes.Ldc_I4_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldc_I4_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldc_I4_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldc_I4_3);                     break;                 case 4:                     il.Emit(OpCodes.Ldc_I4_4);                     break;                 case 5:                     il.Emit(OpCodes.Ldc_I4_5);                     break;                 case 6:                     il.Emit(OpCodes.Ldc_I4_6);                     break;                 case 7:                     il.Emit(OpCodes.Ldc_I4_7);                     break;                 case 8:                     il.Emit(OpCodes.Ldc_I4_8);                     break;                 case -1:                     il.Emit(OpCodes.Ldc_I4_M1);                     break;                 default:                     if (value >= -128 && value <= 127)                         il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                     else                         il.Emit(OpCodes.Ldc_I4' value);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value)             {                 case 0:                     il.Emit(OpCodes.Ldc_I4_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldc_I4_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldc_I4_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldc_I4_3);                     break;                 case 4:                     il.Emit(OpCodes.Ldc_I4_4);                     break;                 case 5:                     il.Emit(OpCodes.Ldc_I4_5);                     break;                 case 6:                     il.Emit(OpCodes.Ldc_I4_6);                     break;                 case 7:                     il.Emit(OpCodes.Ldc_I4_7);                     break;                 case 8:                     il.Emit(OpCodes.Ldc_I4_8);                     break;                 case -1:                     il.Emit(OpCodes.Ldc_I4_M1);                     break;                 default:                     if (value >= -128 && value <= 127)                         il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                     else                         il.Emit(OpCodes.Ldc_I4' value);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value)             {                 case 0:                     il.Emit(OpCodes.Ldc_I4_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldc_I4_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldc_I4_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldc_I4_3);                     break;                 case 4:                     il.Emit(OpCodes.Ldc_I4_4);                     break;                 case 5:                     il.Emit(OpCodes.Ldc_I4_5);                     break;                 case 6:                     il.Emit(OpCodes.Ldc_I4_6);                     break;                 case 7:                     il.Emit(OpCodes.Ldc_I4_7);                     break;                 case 8:                     il.Emit(OpCodes.Ldc_I4_8);                     break;                 case -1:                     il.Emit(OpCodes.Ldc_I4_M1);                     break;                 default:                     if (value >= -128 && value <= 127)                         il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                     else                         il.Emit(OpCodes.Ldc_I4' value);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value)             {                 case 0:                     il.Emit(OpCodes.Ldc_I4_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldc_I4_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldc_I4_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldc_I4_3);                     break;                 case 4:                     il.Emit(OpCodes.Ldc_I4_4);                     break;                 case 5:                     il.Emit(OpCodes.Ldc_I4_5);                     break;                 case 6:                     il.Emit(OpCodes.Ldc_I4_6);                     break;                 case 7:                     il.Emit(OpCodes.Ldc_I4_7);                     break;                 case 8:                     il.Emit(OpCodes.Ldc_I4_8);                     break;                 case -1:                     il.Emit(OpCodes.Ldc_I4_M1);                     break;                 default:                     if (value >= -128 && value <= 127)                         il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                     else                         il.Emit(OpCodes.Ldc_I4' value);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value)             {                 case 0:                     il.Emit(OpCodes.Ldc_I4_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldc_I4_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldc_I4_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldc_I4_3);                     break;                 case 4:                     il.Emit(OpCodes.Ldc_I4_4);                     break;                 case 5:                     il.Emit(OpCodes.Ldc_I4_5);                     break;                 case 6:                     il.Emit(OpCodes.Ldc_I4_6);                     break;                 case 7:                     il.Emit(OpCodes.Ldc_I4_7);                     break;                 case 8:                     il.Emit(OpCodes.Ldc_I4_8);                     break;                 case -1:                     il.Emit(OpCodes.Ldc_I4_M1);                     break;                 default:                     if (value >= -128 && value <= 127)                         il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                     else                         il.Emit(OpCodes.Ldc_I4' value);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value)             {                 case 0:                     il.Emit(OpCodes.Ldc_I4_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldc_I4_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldc_I4_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldc_I4_3);                     break;                 case 4:                     il.Emit(OpCodes.Ldc_I4_4);                     break;                 case 5:                     il.Emit(OpCodes.Ldc_I4_5);                     break;                 case 6:                     il.Emit(OpCodes.Ldc_I4_6);                     break;                 case 7:                     il.Emit(OpCodes.Ldc_I4_7);                     break;                 case 8:                     il.Emit(OpCodes.Ldc_I4_8);                     break;                 case -1:                     il.Emit(OpCodes.Ldc_I4_M1);                     break;                 default:                     if (value >= -128 && value <= 127)                         il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                     else                         il.Emit(OpCodes.Ldc_I4' value);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value)             {                 case 0:                     il.Emit(OpCodes.Ldc_I4_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldc_I4_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldc_I4_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldc_I4_3);                     break;                 case 4:                     il.Emit(OpCodes.Ldc_I4_4);                     break;                 case 5:                     il.Emit(OpCodes.Ldc_I4_5);                     break;                 case 6:                     il.Emit(OpCodes.Ldc_I4_6);                     break;                 case 7:                     il.Emit(OpCodes.Ldc_I4_7);                     break;                 case 8:                     il.Emit(OpCodes.Ldc_I4_8);                     break;                 case -1:                     il.Emit(OpCodes.Ldc_I4_M1);                     break;                 default:                     if (value >= -128 && value <= 127)                         il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                     else                         il.Emit(OpCodes.Ldc_I4' value);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value)             {                 case 0:                     il.Emit(OpCodes.Ldc_I4_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldc_I4_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldc_I4_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldc_I4_3);                     break;                 case 4:                     il.Emit(OpCodes.Ldc_I4_4);                     break;                 case 5:                     il.Emit(OpCodes.Ldc_I4_5);                     break;                 case 6:                     il.Emit(OpCodes.Ldc_I4_6);                     break;                 case 7:                     il.Emit(OpCodes.Ldc_I4_7);                     break;                 case 8:                     il.Emit(OpCodes.Ldc_I4_8);                     break;                 case -1:                     il.Emit(OpCodes.Ldc_I4_M1);                     break;                 default:                     if (value >= -128 && value <= 127)                         il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                     else                         il.Emit(OpCodes.Ldc_I4' value);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value)             {                 case 0:                     il.Emit(OpCodes.Ldc_I4_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldc_I4_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldc_I4_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldc_I4_3);                     break;                 case 4:                     il.Emit(OpCodes.Ldc_I4_4);                     break;                 case 5:                     il.Emit(OpCodes.Ldc_I4_5);                     break;                 case 6:                     il.Emit(OpCodes.Ldc_I4_6);                     break;                 case 7:                     il.Emit(OpCodes.Ldc_I4_7);                     break;                 case 8:                     il.Emit(OpCodes.Ldc_I4_8);                     break;                 case -1:                     il.Emit(OpCodes.Ldc_I4_M1);                     break;                 default:                     if (value >= -128 && value <= 127)                         il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                     else                         il.Emit(OpCodes.Ldc_I4' value);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldarg,The following statement contains a magic number: switch (parameterIndex)             {                 case 0:                     il.Emit(OpCodes.Ldarg_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldarg_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldarg_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldarg_3);                     break;                 default:                     if (parameterIndex <= 255)                         il.Emit(OpCodes.Ldarg_S' (byte)parameterIndex);                     else                         il.Emit(OpCodes.Ldarg' parameterIndex);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldarg,The following statement contains a magic number: switch (parameterIndex)             {                 case 0:                     il.Emit(OpCodes.Ldarg_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldarg_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldarg_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldarg_3);                     break;                 default:                     if (parameterIndex <= 255)                         il.Emit(OpCodes.Ldarg_S' (byte)parameterIndex);                     else                         il.Emit(OpCodes.Ldarg' parameterIndex);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldarg,The following statement contains a magic number: switch (parameterIndex)             {                 case 0:                     il.Emit(OpCodes.Ldarg_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldarg_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldarg_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldarg_3);                     break;                 default:                     if (parameterIndex <= 255)                         il.Emit(OpCodes.Ldarg_S' (byte)parameterIndex);                     else                         il.Emit(OpCodes.Ldarg' parameterIndex);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Starg,The following statement contains a magic number: parameterIndex <= 255
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Stloc,The following statement contains a magic number: switch (localVariableIndex)             {                 case 0:                     il.Emit(OpCodes.Stloc_0);                     break;                 case 1:                     il.Emit(OpCodes.Stloc_1);                     break;                 case 2:                     il.Emit(OpCodes.Stloc_2);                     break;                 case 3:                     il.Emit(OpCodes.Stloc_3);                     break;                 case 65535:                     throw new ArgumentOutOfRangeException(nameof(localVariableIndex));                 default:                     if (localVariableIndex <= 255)                         il.Emit(OpCodes.Stloc_S' (byte)localVariableIndex);                     else                         il.Emit(OpCodes.Stloc' localVariableIndex);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Stloc,The following statement contains a magic number: switch (localVariableIndex)             {                 case 0:                     il.Emit(OpCodes.Stloc_0);                     break;                 case 1:                     il.Emit(OpCodes.Stloc_1);                     break;                 case 2:                     il.Emit(OpCodes.Stloc_2);                     break;                 case 3:                     il.Emit(OpCodes.Stloc_3);                     break;                 case 65535:                     throw new ArgumentOutOfRangeException(nameof(localVariableIndex));                 default:                     if (localVariableIndex <= 255)                         il.Emit(OpCodes.Stloc_S' (byte)localVariableIndex);                     else                         il.Emit(OpCodes.Stloc' localVariableIndex);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Stloc,The following statement contains a magic number: switch (localVariableIndex)             {                 case 0:                     il.Emit(OpCodes.Stloc_0);                     break;                 case 1:                     il.Emit(OpCodes.Stloc_1);                     break;                 case 2:                     il.Emit(OpCodes.Stloc_2);                     break;                 case 3:                     il.Emit(OpCodes.Stloc_3);                     break;                 case 65535:                     throw new ArgumentOutOfRangeException(nameof(localVariableIndex));                 default:                     if (localVariableIndex <= 255)                         il.Emit(OpCodes.Stloc_S' (byte)localVariableIndex);                     else                         il.Emit(OpCodes.Stloc' localVariableIndex);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Stloc,The following statement contains a magic number: switch (localVariableIndex)             {                 case 0:                     il.Emit(OpCodes.Stloc_0);                     break;                 case 1:                     il.Emit(OpCodes.Stloc_1);                     break;                 case 2:                     il.Emit(OpCodes.Stloc_2);                     break;                 case 3:                     il.Emit(OpCodes.Stloc_3);                     break;                 case 65535:                     throw new ArgumentOutOfRangeException(nameof(localVariableIndex));                 default:                     if (localVariableIndex <= 255)                         il.Emit(OpCodes.Stloc_S' (byte)localVariableIndex);                     else                         il.Emit(OpCodes.Stloc' localVariableIndex);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldloc,The following statement contains a magic number: switch (localVariableIndex)             {                 case 0:                     il.Emit(OpCodes.Ldloc_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldloc_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldloc_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldloc_3);                     break;                 case 65535:                     throw new ArgumentOutOfRangeException(nameof(localVariableIndex));                 default:                     if (localVariableIndex <= 255)                         il.Emit(OpCodes.Ldloc_S' (byte)localVariableIndex);                     else                         il.Emit(OpCodes.Ldloc' localVariableIndex);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldloc,The following statement contains a magic number: switch (localVariableIndex)             {                 case 0:                     il.Emit(OpCodes.Ldloc_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldloc_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldloc_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldloc_3);                     break;                 case 65535:                     throw new ArgumentOutOfRangeException(nameof(localVariableIndex));                 default:                     if (localVariableIndex <= 255)                         il.Emit(OpCodes.Ldloc_S' (byte)localVariableIndex);                     else                         il.Emit(OpCodes.Ldloc' localVariableIndex);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldloc,The following statement contains a magic number: switch (localVariableIndex)             {                 case 0:                     il.Emit(OpCodes.Ldloc_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldloc_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldloc_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldloc_3);                     break;                 case 65535:                     throw new ArgumentOutOfRangeException(nameof(localVariableIndex));                 default:                     if (localVariableIndex <= 255)                         il.Emit(OpCodes.Ldloc_S' (byte)localVariableIndex);                     else                         il.Emit(OpCodes.Ldloc' localVariableIndex);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldloc,The following statement contains a magic number: switch (localVariableIndex)             {                 case 0:                     il.Emit(OpCodes.Ldloc_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldloc_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldloc_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldloc_3);                     break;                 case 65535:                     throw new ArgumentOutOfRangeException(nameof(localVariableIndex));                 default:                     if (localVariableIndex <= 255)                         il.Emit(OpCodes.Ldloc_S' (byte)localVariableIndex);                     else                         il.Emit(OpCodes.Ldloc' localVariableIndex);                     break;             }
Magic Number,BTDB.IL,Call,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenForbidenInstructionsCheating.cs,GetHashCode,The following statement contains a magic number: return _opCode.GetHashCode() * 33 + _methodInfo.GetHashCode() * 2;
Magic Number,BTDB.IL,Call,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenForbidenInstructionsCheating.cs,GetHashCode,The following statement contains a magic number: return _opCode.GetHashCode() * 33 + _methodInfo.GetHashCode() * 2;
Magic Number,BTDB.IL,Call,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenForbidenInstructionsCheating.cs,GetHashCode,The following statement contains a magic number: return _opCode.GetHashCode() * 33 + _constructorInfo.GetHashCode() * 2 + 1;
Magic Number,BTDB.IL,Call,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILGenForbidenInstructionsCheating.cs,GetHashCode,The following statement contains a magic number: return _opCode.GetHashCode() * 33 + _constructorInfo.GetHashCode() * 2 + 1;
Magic Number,BTDB.IL,ILMethodImpl,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IL\ILMethodImpl.cs,ILMethodImpl,The following statement contains a magic number: _expectedLength = 64;
Magic Number,BTDB.IOC,Comparer,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IOC\GenerationContext.cs,GetHashCode,The following statement contains a magic number: return obj.Item1.GetHashCode() * 33 + obj.Item2.ClrType.GetHashCode();
Magic Number,BTDB.IOC,ComparerConst,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IOC\GenerationContext.cs,GetHashCode,The following statement contains a magic number: return obj.Item1.GetHashCode() * 33 + obj.Item2.GetHashCode();
Magic Number,BTDB.IOC,ComparerProcessingContext,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IOC\GenerationContext.cs,GetHashCode,The following statement contains a magic number: return obj.Item1.GetHashCode() * 33 + obj.Item2.GetHashCode();
Magic Number,BTDB.IOC,KeyAndType,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\IOC\KeyAndType.cs,GetHashCode,The following statement contains a magic number: return Key.GetHashCode()*33 + Type.GetHashCode();
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: var tempbuf = new byte[16];
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: tempbuf[2] = (byte)'D';
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: tempbuf[3] = (byte)'B';
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: tempbuf[4] = (byte)'E';
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: tempbuf[5] = (byte)'X';
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: tempbuf[6] = (byte)'P';
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: tempbuf[7] = (byte)'2';
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: PackUnpack.PackInt64LE(tempbuf' 8' keyValueCount);
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: stream.Write(tempbuf' 0' 16);
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: stream.Write(tempbuf' 0' 4);
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: stream.Write(tempbuf' 0' 4);
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: stream.Write(tempbuf' 0' 8);
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: stream.Write(tempbuf' 0' 4);
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: stream.Write(tempbuf' 0' 8);
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: var tempbuf = new byte[4096];
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: var tempbuf2 = new byte[4096];
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: stream.Read(tempbuf' 0' 16) != 16
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: stream.Read(tempbuf' 0' 16) != 16
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: tempbuf[0] != 'B' || tempbuf[1] != 'T' || tempbuf[2] != 'D' || tempbuf[3] != 'B' || tempbuf[4] != 'E' || tempbuf[5] != 'X' || tempbuf[6] != 'P' || tempbuf[7] != '2'
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: tempbuf[0] != 'B' || tempbuf[1] != 'T' || tempbuf[2] != 'D' || tempbuf[3] != 'B' || tempbuf[4] != 'E' || tempbuf[5] != 'X' || tempbuf[6] != 'P' || tempbuf[7] != '2'
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: tempbuf[0] != 'B' || tempbuf[1] != 'T' || tempbuf[2] != 'D' || tempbuf[3] != 'B' || tempbuf[4] != 'E' || tempbuf[5] != 'X' || tempbuf[6] != 'P' || tempbuf[7] != '2'
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: tempbuf[0] != 'B' || tempbuf[1] != 'T' || tempbuf[2] != 'D' || tempbuf[3] != 'B' || tempbuf[4] != 'E' || tempbuf[5] != 'X' || tempbuf[6] != 'P' || tempbuf[7] != '2'
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: tempbuf[0] != 'B' || tempbuf[1] != 'T' || tempbuf[2] != 'D' || tempbuf[3] != 'B' || tempbuf[4] != 'E' || tempbuf[5] != 'X' || tempbuf[6] != 'P' || tempbuf[7] != '2'
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: tempbuf[0] != 'B' || tempbuf[1] != 'T' || tempbuf[2] != 'D' || tempbuf[3] != 'B' || tempbuf[4] != 'E' || tempbuf[5] != 'X' || tempbuf[6] != 'P' || tempbuf[7] != '2'
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: var keyValuePairs = PackUnpack.UnpackInt64LE(tempbuf' 8);
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: stream.Read(tempbuf' 0' 4) != 4
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: stream.Read(tempbuf' 0' 4) != 4
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: stream.Read(tempbuf2' 0' 4) != 4
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: stream.Read(tempbuf2' 0' 4) != 4
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: stream.Read(tempbuf' 0' 8) != 8
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: stream.Read(tempbuf' 0' 8) != 8
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: stream.Read(tempbuf' 0' 4) == 4
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: stream.Read(tempbuf' 0' 4) == 4
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: stream.Read(tempbuf' 0' 8) == 8
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: stream.Read(tempbuf' 0' 8) == 8
Magic Number,BTDB.KVDBLayer,PtrLenList,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,FindFreeSizeAfter,The following statement contains a magic number: uint m = (l + r)/2;
Magic Number,BTDB.KVDBLayer,PtrLenList,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryExclude,The following statement contains a magic number: uint m = (l + r) / 2;
Magic Number,BTDB.KVDBLayer,PtrLenList,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryInclude,The following statement contains a magic number: _list = new KeyValuePair<ulong' ulong>[4];
Magic Number,BTDB.KVDBLayer,PtrLenList,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryInclude,The following statement contains a magic number: uint m = (l + r) / 2;
Magic Number,BTDB.KVDBLayer,PtrLenList,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,Contains,The following statement contains a magic number: uint m = (l + r) / 2;
Magic Number,BTDB.KVDBLayer,PtrLenList,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,GrowIfNeeded,The following statement contains a magic number: Array.Resize(ref _list' (int)_size * 2);
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,BTreeKeyValueDB,The following statement contains a magic number: options.FileSplitSize < 1024 || options.FileSplitSize > int.MaxValue
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The following statement contains a magic number: cursor.BuildTree(keyCount' (ref ByteBuffer key' Span<byte> trueValue) =>                     {                         var keyLength = reader.ReadVInt32();                         key = ByteBuffer.NewAsync(new byte[Math.Abs(keyLength)]);                         reader.ReadBlock(key);                         if (keyLength < 0)                         {                             _compression.DecompressKey(ref key);                         }                          trueValue.Clear();                         var vFileId = reader.ReadVUInt32();                         if (vFileId > 0) usedFileIds.Add(vFileId);                         MemoryMarshal.Write(trueValue' ref vFileId);                         var valueOfs = reader.ReadVUInt32();                         var valueSize = reader.ReadVInt32();                         if (vFileId == 0)                         {                             var len = valueSize >> 24;                             trueValue[4] = (byte) len;                             switch (len)                             {                                 case 7:                                     trueValue[11] = (byte) (valueOfs >> 24);                                     goto case 6;                                 case 6:                                     trueValue[10] = (byte) (valueOfs >> 16);                                     goto case 5;                                 case 5:                                     trueValue[9] = (byte) (valueOfs >> 8);                                     goto case 4;                                 case 4:                                     trueValue[8] = (byte) valueOfs;                                     goto case 3;                                 case 3:                                     trueValue[7] = (byte) valueSize;                                     goto case 2;                                 case 2:                                     trueValue[6] = (byte) (valueSize >> 8);                                     goto case 1;                                 case 1:                                     trueValue[5] = (byte) (valueSize >> 16);                                     break;                                 case 0:                                     break;                                 default:                                     throw new BTDBException("Corrupted DB");                             }                         }                         else                         {                             MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                             MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                         }                     });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadTransactionLog,The following statement contains a magic number: Span<byte> trueValue = stackalloc byte[12];
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadTransactionLog,The following statement contains a magic number: switch (command & KVCommandType.CommandMask)                     {                         case KVCommandType.CreateOrUpdateDeprecated:                         case KVCommandType.CreateOrUpdate:                         {                             if (_nextRoot == null) return false;                             var keyLen = reader.ReadVInt32();                             var valueLen = reader.ReadVInt32();                             var key = new byte[keyLen];                             reader.ReadBlock(key);                             var keyBuf = ByteBuffer.NewAsync(key);                             if ((command & KVCommandType.FirstParamCompressed) != 0)                             {                                 _compression.DecompressKey(ref keyBuf);                             }                              trueValue.Clear();                             var valueOfs = (uint) reader.GetCurrentPosition();                             var valueSize = (command & KVCommandType.SecondParamCompressed) != 0 ? -valueLen : valueLen;                             if (valueLen <= MaxValueSizeInlineInMemory &&                                 (command & KVCommandType.SecondParamCompressed) == 0)                             {                                 var value = 0;                                 MemoryMarshal.Write(trueValue' ref value);                                 trueValue[4] = (byte) valueLen;                                 reader.ReadBlock(trueValue.Slice(5' valueLen));                             }                             else                             {                                 MemoryMarshal.Write(trueValue' ref fileId);                                 MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                                 MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                                 reader.SkipBlock(valueLen);                             }                              cursor.Upsert(keyBuf.AsSyncReadOnlySpan()' trueValue);                         }                             break;                         case KVCommandType.EraseOne:                         {                             if (_nextRoot == null) return false;                             var keyLen = reader.ReadVInt32();                             var key = new byte[keyLen];                             reader.ReadBlock(key);                             var keyBuf = ByteBuffer.NewAsync(key);                             if ((command & KVCommandType.FirstParamCompressed) != 0)                             {                                 _compression.DecompressKey(ref keyBuf);                             }                              if (cursor.FindExact(keyBuf.AsSyncReadOnlySpan()))                                 cursor.Erase();                         }                             break;                         case KVCommandType.EraseRange:                         {                             if (_nextRoot == null) return false;                             var keyLen1 = reader.ReadVInt32();                             var keyLen2 = reader.ReadVInt32();                             var key = new byte[keyLen1];                             reader.ReadBlock(key);                             var keyBuf = ByteBuffer.NewAsync(key);                             if ((command & KVCommandType.FirstParamCompressed) != 0)                             {                                 _compression.DecompressKey(ref keyBuf);                             }                              var findResult = cursor.Find(keyBuf.AsSyncReadOnlySpan());                             if (findResult == FindResult.Previous) cursor.MoveNext();                             key = new byte[keyLen2];                             reader.ReadBlock(key);                             keyBuf = ByteBuffer.NewAsync(key);                             if ((command & KVCommandType.SecondParamCompressed) != 0)                             {                                 _compression.DecompressKey(ref keyBuf);                             }                              findResult = cursor2.Find(keyBuf.AsSyncReadOnlySpan());                             if (findResult == FindResult.Next) cursor2.MovePrevious();                             cursor.EraseTo(cursor2);                         }                             break;                         case KVCommandType.DeltaUlongs:                         {                             if (_nextRoot == null) return false;                             var idx = reader.ReadVUInt32();                             var delta = reader.ReadVUInt64();                             // overflow is expected in case Ulong is decreasing but that should be rare                             _nextRoot.SetUlong(idx' unchecked(_nextRoot.GetUlong(idx) + delta));                         }                             break;                         case KVCommandType.TransactionStart:                             if (!reader.CheckMagic(MagicStartOfTransaction))                                 return false;                             if (_nextRoot != null)                             {                                 _nextRoot.Dispose();                                 _nextRoot = null;                                 return false;                             }                              _nextRoot = _lastCommitted.CreateWritableTransaction();                             cursor.SetNewRoot(_nextRoot);                             cursor2.SetNewRoot(_nextRoot);                             break;                         case KVCommandType.CommitWithDeltaUlong:                             if (_nextRoot == null) return false;                             unchecked // overflow is expected in case commitUlong is decreasing but that should be rare                             {                                 _nextRoot.CommitUlong += reader.ReadVUInt64();                             }                              goto case KVCommandType.Commit;                         case KVCommandType.Commit:                             if (_nextRoot == null) return false;                             _nextRoot.TrLogFileId = fileId;                             _nextRoot.TrLogOffset = (uint) reader.GetCurrentPosition();                             _lastCommitted.Dispose();                             _nextRoot.Commit();                             _lastCommitted = _nextRoot;                             _nextRoot = null;                             if (openUpToCommitUlong.HasValue && _lastCommitted.CommitUlong >= openUpToCommitUlong)                             {                                 finishReading = true;                             }                              break;                         case KVCommandType.Rollback:                             _nextRoot.Dispose();                             _nextRoot = null;                             break;                         case KVCommandType.EndOfFile:                             return false;                         case KVCommandType.TemporaryEndOfFile:                             _lastCommitted.TrLogFileId = fileId;                             _lastCommitted.TrLogOffset = (uint) reader.GetCurrentPosition();                             afterTemporaryEnd = true;                             break;                         default:                             if (_nextRoot != null)                             {                                 _nextRoot.Dispose();                                 _nextRoot = null;                             }                              return false;                     }
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadTransactionLog,The following statement contains a magic number: switch (command & KVCommandType.CommandMask)                     {                         case KVCommandType.CreateOrUpdateDeprecated:                         case KVCommandType.CreateOrUpdate:                         {                             if (_nextRoot == null) return false;                             var keyLen = reader.ReadVInt32();                             var valueLen = reader.ReadVInt32();                             var key = new byte[keyLen];                             reader.ReadBlock(key);                             var keyBuf = ByteBuffer.NewAsync(key);                             if ((command & KVCommandType.FirstParamCompressed) != 0)                             {                                 _compression.DecompressKey(ref keyBuf);                             }                              trueValue.Clear();                             var valueOfs = (uint) reader.GetCurrentPosition();                             var valueSize = (command & KVCommandType.SecondParamCompressed) != 0 ? -valueLen : valueLen;                             if (valueLen <= MaxValueSizeInlineInMemory &&                                 (command & KVCommandType.SecondParamCompressed) == 0)                             {                                 var value = 0;                                 MemoryMarshal.Write(trueValue' ref value);                                 trueValue[4] = (byte) valueLen;                                 reader.ReadBlock(trueValue.Slice(5' valueLen));                             }                             else                             {                                 MemoryMarshal.Write(trueValue' ref fileId);                                 MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                                 MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                                 reader.SkipBlock(valueLen);                             }                              cursor.Upsert(keyBuf.AsSyncReadOnlySpan()' trueValue);                         }                             break;                         case KVCommandType.EraseOne:                         {                             if (_nextRoot == null) return false;                             var keyLen = reader.ReadVInt32();                             var key = new byte[keyLen];                             reader.ReadBlock(key);                             var keyBuf = ByteBuffer.NewAsync(key);                             if ((command & KVCommandType.FirstParamCompressed) != 0)                             {                                 _compression.DecompressKey(ref keyBuf);                             }                              if (cursor.FindExact(keyBuf.AsSyncReadOnlySpan()))                                 cursor.Erase();                         }                             break;                         case KVCommandType.EraseRange:                         {                             if (_nextRoot == null) return false;                             var keyLen1 = reader.ReadVInt32();                             var keyLen2 = reader.ReadVInt32();                             var key = new byte[keyLen1];                             reader.ReadBlock(key);                             var keyBuf = ByteBuffer.NewAsync(key);                             if ((command & KVCommandType.FirstParamCompressed) != 0)                             {                                 _compression.DecompressKey(ref keyBuf);                             }                              var findResult = cursor.Find(keyBuf.AsSyncReadOnlySpan());                             if (findResult == FindResult.Previous) cursor.MoveNext();                             key = new byte[keyLen2];                             reader.ReadBlock(key);                             keyBuf = ByteBuffer.NewAsync(key);                             if ((command & KVCommandType.SecondParamCompressed) != 0)                             {                                 _compression.DecompressKey(ref keyBuf);                             }                              findResult = cursor2.Find(keyBuf.AsSyncReadOnlySpan());                             if (findResult == FindResult.Next) cursor2.MovePrevious();                             cursor.EraseTo(cursor2);                         }                             break;                         case KVCommandType.DeltaUlongs:                         {                             if (_nextRoot == null) return false;                             var idx = reader.ReadVUInt32();                             var delta = reader.ReadVUInt64();                             // overflow is expected in case Ulong is decreasing but that should be rare                             _nextRoot.SetUlong(idx' unchecked(_nextRoot.GetUlong(idx) + delta));                         }                             break;                         case KVCommandType.TransactionStart:                             if (!reader.CheckMagic(MagicStartOfTransaction))                                 return false;                             if (_nextRoot != null)                             {                                 _nextRoot.Dispose();                                 _nextRoot = null;                                 return false;                             }                              _nextRoot = _lastCommitted.CreateWritableTransaction();                             cursor.SetNewRoot(_nextRoot);                             cursor2.SetNewRoot(_nextRoot);                             break;                         case KVCommandType.CommitWithDeltaUlong:                             if (_nextRoot == null) return false;                             unchecked // overflow is expected in case commitUlong is decreasing but that should be rare                             {                                 _nextRoot.CommitUlong += reader.ReadVUInt64();                             }                              goto case KVCommandType.Commit;                         case KVCommandType.Commit:                             if (_nextRoot == null) return false;                             _nextRoot.TrLogFileId = fileId;                             _nextRoot.TrLogOffset = (uint) reader.GetCurrentPosition();                             _lastCommitted.Dispose();                             _nextRoot.Commit();                             _lastCommitted = _nextRoot;                             _nextRoot = null;                             if (openUpToCommitUlong.HasValue && _lastCommitted.CommitUlong >= openUpToCommitUlong)                             {                                 finishReading = true;                             }                              break;                         case KVCommandType.Rollback:                             _nextRoot.Dispose();                             _nextRoot = null;                             break;                         case KVCommandType.EndOfFile:                             return false;                         case KVCommandType.TemporaryEndOfFile:                             _lastCommitted.TrLogFileId = fileId;                             _lastCommitted.TrLogOffset = (uint) reader.GetCurrentPosition();                             afterTemporaryEnd = true;                             break;                         default:                             if (_nextRoot != null)                             {                                 _nextRoot.Dispose();                                 _nextRoot = null;                             }                              return false;                     }
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadTransactionLog,The following statement contains a magic number: switch (command & KVCommandType.CommandMask)                     {                         case KVCommandType.CreateOrUpdateDeprecated:                         case KVCommandType.CreateOrUpdate:                         {                             if (_nextRoot == null) return false;                             var keyLen = reader.ReadVInt32();                             var valueLen = reader.ReadVInt32();                             var key = new byte[keyLen];                             reader.ReadBlock(key);                             var keyBuf = ByteBuffer.NewAsync(key);                             if ((command & KVCommandType.FirstParamCompressed) != 0)                             {                                 _compression.DecompressKey(ref keyBuf);                             }                              trueValue.Clear();                             var valueOfs = (uint) reader.GetCurrentPosition();                             var valueSize = (command & KVCommandType.SecondParamCompressed) != 0 ? -valueLen : valueLen;                             if (valueLen <= MaxValueSizeInlineInMemory &&                                 (command & KVCommandType.SecondParamCompressed) == 0)                             {                                 var value = 0;                                 MemoryMarshal.Write(trueValue' ref value);                                 trueValue[4] = (byte) valueLen;                                 reader.ReadBlock(trueValue.Slice(5' valueLen));                             }                             else                             {                                 MemoryMarshal.Write(trueValue' ref fileId);                                 MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                                 MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                                 reader.SkipBlock(valueLen);                             }                              cursor.Upsert(keyBuf.AsSyncReadOnlySpan()' trueValue);                         }                             break;                         case KVCommandType.EraseOne:                         {                             if (_nextRoot == null) return false;                             var keyLen = reader.ReadVInt32();                             var key = new byte[keyLen];                             reader.ReadBlock(key);                             var keyBuf = ByteBuffer.NewAsync(key);                             if ((command & KVCommandType.FirstParamCompressed) != 0)                             {                                 _compression.DecompressKey(ref keyBuf);                             }                              if (cursor.FindExact(keyBuf.AsSyncReadOnlySpan()))                                 cursor.Erase();                         }                             break;                         case KVCommandType.EraseRange:                         {                             if (_nextRoot == null) return false;                             var keyLen1 = reader.ReadVInt32();                             var keyLen2 = reader.ReadVInt32();                             var key = new byte[keyLen1];                             reader.ReadBlock(key);                             var keyBuf = ByteBuffer.NewAsync(key);                             if ((command & KVCommandType.FirstParamCompressed) != 0)                             {                                 _compression.DecompressKey(ref keyBuf);                             }                              var findResult = cursor.Find(keyBuf.AsSyncReadOnlySpan());                             if (findResult == FindResult.Previous) cursor.MoveNext();                             key = new byte[keyLen2];                             reader.ReadBlock(key);                             keyBuf = ByteBuffer.NewAsync(key);                             if ((command & KVCommandType.SecondParamCompressed) != 0)                             {                                 _compression.DecompressKey(ref keyBuf);                             }                              findResult = cursor2.Find(keyBuf.AsSyncReadOnlySpan());                             if (findResult == FindResult.Next) cursor2.MovePrevious();                             cursor.EraseTo(cursor2);                         }                             break;                         case KVCommandType.DeltaUlongs:                         {                             if (_nextRoot == null) return false;                             var idx = reader.ReadVUInt32();                             var delta = reader.ReadVUInt64();                             // overflow is expected in case Ulong is decreasing but that should be rare                             _nextRoot.SetUlong(idx' unchecked(_nextRoot.GetUlong(idx) + delta));                         }                             break;                         case KVCommandType.TransactionStart:                             if (!reader.CheckMagic(MagicStartOfTransaction))                                 return false;                             if (_nextRoot != null)                             {                                 _nextRoot.Dispose();                                 _nextRoot = null;                                 return false;                             }                              _nextRoot = _lastCommitted.CreateWritableTransaction();                             cursor.SetNewRoot(_nextRoot);                             cursor2.SetNewRoot(_nextRoot);                             break;                         case KVCommandType.CommitWithDeltaUlong:                             if (_nextRoot == null) return false;                             unchecked // overflow is expected in case commitUlong is decreasing but that should be rare                             {                                 _nextRoot.CommitUlong += reader.ReadVUInt64();                             }                              goto case KVCommandType.Commit;                         case KVCommandType.Commit:                             if (_nextRoot == null) return false;                             _nextRoot.TrLogFileId = fileId;                             _nextRoot.TrLogOffset = (uint) reader.GetCurrentPosition();                             _lastCommitted.Dispose();                             _nextRoot.Commit();                             _lastCommitted = _nextRoot;                             _nextRoot = null;                             if (openUpToCommitUlong.HasValue && _lastCommitted.CommitUlong >= openUpToCommitUlong)                             {                                 finishReading = true;                             }                              break;                         case KVCommandType.Rollback:                             _nextRoot.Dispose();                             _nextRoot = null;                             break;                         case KVCommandType.EndOfFile:                             return false;                         case KVCommandType.TemporaryEndOfFile:                             _lastCommitted.TrLogFileId = fileId;                             _lastCommitted.TrLogOffset = (uint) reader.GetCurrentPosition();                             afterTemporaryEnd = true;                             break;                         default:                             if (_nextRoot != null)                             {                                 _nextRoot.Dispose();                                 _nextRoot = null;                             }                              return false;                     }
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadTransactionLog,The following statement contains a magic number: switch (command & KVCommandType.CommandMask)                     {                         case KVCommandType.CreateOrUpdateDeprecated:                         case KVCommandType.CreateOrUpdate:                         {                             if (_nextRoot == null) return false;                             var keyLen = reader.ReadVInt32();                             var valueLen = reader.ReadVInt32();                             var key = new byte[keyLen];                             reader.ReadBlock(key);                             var keyBuf = ByteBuffer.NewAsync(key);                             if ((command & KVCommandType.FirstParamCompressed) != 0)                             {                                 _compression.DecompressKey(ref keyBuf);                             }                              trueValue.Clear();                             var valueOfs = (uint) reader.GetCurrentPosition();                             var valueSize = (command & KVCommandType.SecondParamCompressed) != 0 ? -valueLen : valueLen;                             if (valueLen <= MaxValueSizeInlineInMemory &&                                 (command & KVCommandType.SecondParamCompressed) == 0)                             {                                 var value = 0;                                 MemoryMarshal.Write(trueValue' ref value);                                 trueValue[4] = (byte) valueLen;                                 reader.ReadBlock(trueValue.Slice(5' valueLen));                             }                             else                             {                                 MemoryMarshal.Write(trueValue' ref fileId);                                 MemoryMarshal.Write(trueValue.Slice(4)' ref valueOfs);                                 MemoryMarshal.Write(trueValue.Slice(8)' ref valueSize);                                 reader.SkipBlock(valueLen);                             }                              cursor.Upsert(keyBuf.AsSyncReadOnlySpan()' trueValue);                         }                             break;                         case KVCommandType.EraseOne:                         {                             if (_nextRoot == null) return false;                             var keyLen = reader.ReadVInt32();                             var key = new byte[keyLen];                             reader.ReadBlock(key);                             var keyBuf = ByteBuffer.NewAsync(key);                             if ((command & KVCommandType.FirstParamCompressed) != 0)                             {                                 _compression.DecompressKey(ref keyBuf);                             }                              if (cursor.FindExact(keyBuf.AsSyncReadOnlySpan()))                                 cursor.Erase();                         }                             break;                         case KVCommandType.EraseRange:                         {                             if (_nextRoot == null) return false;                             var keyLen1 = reader.ReadVInt32();                             var keyLen2 = reader.ReadVInt32();                             var key = new byte[keyLen1];                             reader.ReadBlock(key);                             var keyBuf = ByteBuffer.NewAsync(key);                             if ((command & KVCommandType.FirstParamCompressed) != 0)                             {                                 _compression.DecompressKey(ref keyBuf);                             }                              var findResult = cursor.Find(keyBuf.AsSyncReadOnlySpan());                             if (findResult == FindResult.Previous) cursor.MoveNext();                             key = new byte[keyLen2];                             reader.ReadBlock(key);                             keyBuf = ByteBuffer.NewAsync(key);                             if ((command & KVCommandType.SecondParamCompressed) != 0)                             {                                 _compression.DecompressKey(ref keyBuf);                             }                              findResult = cursor2.Find(keyBuf.AsSyncReadOnlySpan());                             if (findResult == FindResult.Next) cursor2.MovePrevious();                             cursor.EraseTo(cursor2);                         }                             break;                         case KVCommandType.DeltaUlongs:                         {                             if (_nextRoot == null) return false;                             var idx = reader.ReadVUInt32();                             var delta = reader.ReadVUInt64();                             // overflow is expected in case Ulong is decreasing but that should be rare                             _nextRoot.SetUlong(idx' unchecked(_nextRoot.GetUlong(idx) + delta));                         }                             break;                         case KVCommandType.TransactionStart:                             if (!reader.CheckMagic(MagicStartOfTransaction))                                 return false;                             if (_nextRoot != null)                             {                                 _nextRoot.Dispose();                                 _nextRoot = null;                                 return false;                             }                              _nextRoot = _lastCommitted.CreateWritableTransaction();                             cursor.SetNewRoot(_nextRoot);                             cursor2.SetNewRoot(_nextRoot);                             break;                         case KVCommandType.CommitWithDeltaUlong:                             if (_nextRoot == null) return false;                             unchecked // overflow is expected in case commitUlong is decreasing but that should be rare                             {                                 _nextRoot.CommitUlong += reader.ReadVUInt64();                             }                              goto case KVCommandType.Commit;                         case KVCommandType.Commit:                             if (_nextRoot == null) return false;                             _nextRoot.TrLogFileId = fileId;                             _nextRoot.TrLogOffset = (uint) reader.GetCurrentPosition();                             _lastCommitted.Dispose();                             _nextRoot.Commit();                             _lastCommitted = _nextRoot;                             _nextRoot = null;                             if (openUpToCommitUlong.HasValue && _lastCommitted.CommitUlong >= openUpToCommitUlong)                             {                                 finishReading = true;                             }                              break;                         case KVCommandType.Rollback:                             _nextRoot.Dispose();                             _nextRoot = null;                             break;                         case KVCommandType.EndOfFile:                             return false;                         case KVCommandType.TemporaryEndOfFile:                             _lastCommitted.TrLogFileId = fileId;                             _lastCommitted.TrLogOffset = (uint) reader.GetCurrentPosition();                             afterTemporaryEnd = true;                             break;                         default:                             if (_nextRoot != null)                             {                                 _nextRoot.Dispose();                                 _nextRoot = null;                             }                              return false;                     }
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,WriteCreateOrUpdateCommand,The following statement contains a magic number: trlPos > 256 && trlPos + key.Length + 16 + value.Length > MaxTrLogFileSize
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,WriteCreateOrUpdateCommand,The following statement contains a magic number: trlPos > 256 && trlPos + key.Length + 16 + value.Length > MaxTrLogFileSize
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,WriteCreateOrUpdateCommand,The following statement contains a magic number: trueValue[4] = (byte) value.Length;
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,WriteCreateOrUpdateCommand,The following statement contains a magic number: value.CopyTo(trueValue.Slice(5));
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,ReadValue,The following statement contains a magic number: var len = trueValue[4];
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,ReadValue,The following statement contains a magic number: return trueValue.Slice(5' len);
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,ReadValue,The following statement contains a magic number: var valueSize = MemoryMarshal.Read<int>(trueValue.Slice(8));
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,ReadValue,The following statement contains a magic number: var valueOfs = MemoryMarshal.Read<uint>(trueValue.Slice(4));
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,CreateKeyIndexFile,The following statement contains a magic number: root.KeyValueIterate(ref keyValueIterateCtx' (ref KeyValueIterateCtx ctx) =>                 {                     var memberValue = ctx.CurrentValue;                     writer.WriteVUInt32(ctx.PreviousCurrentCommonLength);                     writer.WriteVUInt32((uint) (ctx.CurrentPrefix.Length+ctx.CurrentSuffix.Length-ctx.PreviousCurrentCommonLength));                     if (ctx.CurrentPrefix.Length <= ctx.PreviousCurrentCommonLength)                     {                         writer.WriteBlock(ctx.CurrentSuffix.Slice((int)ctx.PreviousCurrentCommonLength-ctx.CurrentPrefix.Length));                     }                     else                     {                         writer.WriteBlock(ctx.CurrentPrefix.Slice((int)ctx.PreviousCurrentCommonLength));                         writer.WriteBlock(ctx.CurrentSuffix);                     }                     var vFileId = MemoryMarshal.Read<uint>(memberValue);                     if (vFileId > 0) usedFileIds.Add(vFileId);                     writer.WriteVUInt32(vFileId);                     if (vFileId == 0)                     {                         uint valueOfs;                         int valueSize;                         var inlineValueBuf = memberValue.Slice(5);                         var valueLen = memberValue[4];                         switch (valueLen)                         {                             case 0:                                 valueOfs = 0;                                 valueSize = 0;                                 break;                             case 1:                                 valueOfs = 0;                                 valueSize = 0x1000000 | (inlineValueBuf[0] << 16);                                 break;                             case 2:                                 valueOfs = 0;                                 valueSize = 0x2000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8);                                 break;                             case 3:                                 valueOfs = 0;                                 valueSize = 0x3000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 4:                                 valueOfs = inlineValueBuf[3];                                 valueSize = 0x4000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 5:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8);                                 valueSize = 0x5000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 6:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16);                                 valueSize = 0x6000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             case 7:                                 valueOfs = inlineValueBuf[3] | ((uint) inlineValueBuf[4] << 8) |                                            ((uint) inlineValueBuf[5] << 16) | ((uint) inlineValueBuf[6] << 24);                                 valueSize = 0x7000000 | (inlineValueBuf[0] << 16) | (inlineValueBuf[1] << 8) |                                             inlineValueBuf[2];                                 break;                             default:                                 throw new ArgumentOutOfRangeException();                         }                          writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     else                     {                         var valueOfs = MemoryMarshal.Read<uint>(memberValue.Slice(4));                         var valueSize = MemoryMarshal.Read<int>(memberValue.Slice(8));                         writer.WriteVUInt32(valueOfs);                         writer.WriteVInt32(valueSize);                     }                     bytesPerSecondLimiter.Limit((ulong) writer.GetCurrentPosition());                 });
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,ReplaceBTreeValues,The following statement contains a magic number: var iterationTimeOut = DateTime.UtcNow + TimeSpan.FromMilliseconds(50);
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,ReplaceBTreeValues,The following statement contains a magic number: Thread.Sleep(10);
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDBTransaction,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDBTransaction.cs,CreateOrUpdateKeyValue,The following statement contains a magic number: Span<byte> trueValue = stackalloc byte[12];
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDBTransaction,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDBTransaction.cs,SetValue,The following statement contains a magic number: Span<byte> trueValue = stackalloc byte[12];
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDBTransaction,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDBTransaction.cs,GetStorageSizeOfCurrentKey,The following statement contains a magic number: return new KeyValuePair<uint' uint>(                 (uint)keyLen'                 _keyValueDB.CalcValueSize(MemoryMarshal.Read<uint>(trueValue)' MemoryMarshal.Read<uint>(trueValue.Slice(4))' MemoryMarshal.Read<int>(trueValue.Slice(8))));
Magic Number,BTDB.KVDBLayer,BTreeKeyValueDBTransaction,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDBTransaction.cs,GetStorageSizeOfCurrentKey,The following statement contains a magic number: return new KeyValuePair<uint' uint>(                 (uint)keyLen'                 _keyValueDB.CalcValueSize(MemoryMarshal.Read<uint>(trueValue)' MemoryMarshal.Read<uint>(trueValue.Slice(4))' MemoryMarshal.Read<int>(trueValue.Slice(8))));
Magic Number,BTDB.KVDBLayer,ChunkStorageInKV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\ChunkStorageInKV.cs,CheckOrInitKeyLen,The following statement contains a magic number: keyLen != 20
Magic Number,BTDB.KVDBLayer,Compactor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,Run,The following statement contains a magic number: _keyValueDB.DistanceFromLastKeyIndex(_root) > (ulong)(_keyValueDB.MaxTrLogFileSize / 4)
Magic Number,BTDB.KVDBLayer,Compactor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,CompactOnePureValueFileIteration,The following statement contains a magic number: _keyValueDB.Logger?.CompactionCreatedPureValueFile(valueFileId' valueFile.GetSize()'                 (uint)_newPositionMap.Count' 28 * #if NETFRAMEWORK                                               (ulong) _newPositionMap.Count #else                                               (ulong)_newPositionMap.EnsureCapacity(0) #endif             );
Magic Number,BTDB.KVDBLayer,Compactor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,IsWasteSmall,The following statement contains a magic number: return totalWaste < (ulong)_keyValueDB.MaxTrLogFileSize / 4;
Magic Number,BTDB.KVDBLayer,Compactor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,MoveValuesContent,The following statement contains a magic number: const uint blockSize = 256 * 1024;
Magic Number,BTDB.KVDBLayer,Compactor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,MoveValuesContent,The following statement contains a magic number: const uint blockSize = 256 * 1024;
Magic Number,BTDB.KVDBLayer,Compactor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,MoveValuesContent,The following statement contains a magic number: _keyValueDB.IterateRoot(_root' (valueFileId' valueOfs' valueSize) =>             {                 if (valueFileId != wastefullFileId) return;                 var size = (uint)Math.Abs(valueSize);                 _newPositionMap.Add(((ulong)wastefullFileId << 32) | valueOfs'                     ((ulong)pvlFileId << 32) + (ulong)writer.GetCurrentPosition());                 pos = valueOfs;                 while (size > 0)                 {                     _cancellation.ThrowIfCancellationRequested();                     var blockId = pos / blockSize;                     var blockStart = pos % blockSize;                     var writeSize = (uint)(blockSize - blockStart);                     if (writeSize > size) writeSize = size;                     writer.WriteBlock(wasteInMemory[blockId]' (int)blockStart' (int)writeSize);                     size -= writeSize;                     pos += writeSize;                     _writerBytesPerSecondLimiter.Limit((ulong)writer.GetCurrentPosition());                 }             });
Magic Number,BTDB.KVDBLayer,Compactor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,MoveValuesContent,The following statement contains a magic number: _keyValueDB.IterateRoot(_root' (valueFileId' valueOfs' valueSize) =>             {                 if (valueFileId != wastefullFileId) return;                 var size = (uint)Math.Abs(valueSize);                 _newPositionMap.Add(((ulong)wastefullFileId << 32) | valueOfs'                     ((ulong)pvlFileId << 32) + (ulong)writer.GetCurrentPosition());                 pos = valueOfs;                 while (size > 0)                 {                     _cancellation.ThrowIfCancellationRequested();                     var blockId = pos / blockSize;                     var blockStart = pos % blockSize;                     var writeSize = (uint)(blockSize - blockStart);                     if (writeSize > size) writeSize = size;                     writer.WriteBlock(wasteInMemory[blockId]' (int)blockStart' (int)writeSize);                     size -= writeSize;                     pos += writeSize;                     _writerBytesPerSecondLimiter.Limit((ulong)writer.GetCurrentPosition());                 }             });
Magic Number,BTDB.KVDBLayer,Compactor,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,CalcTotalWaste,The following statement contains a magic number: waste > 1024
Magic Number,BTDB.KVDBLayer,CompactorScheduler,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\CompactorScheduler.cs,CompactorScheduler,The following statement contains a magic number: WaitTime = TimeSpan.FromMinutes(10 + new Random().NextDouble() * 5);
Magic Number,BTDB.KVDBLayer,CompactorScheduler,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\CompactorScheduler.cs,CompactorScheduler,The following statement contains a magic number: WaitTime = TimeSpan.FromMinutes(10 + new Random().NextDouble() * 5);
Magic Number,BTDB.KVDBLayer,Reader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\InMemoryFileCollection.cs,Reader,The following statement contains a magic number: Buf = new byte[32768];
Magic Number,BTDB.KVDBLayer,Reader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\InMemoryFileCollection.cs,Reader,The following statement contains a magic number: Buf = new byte[32768];
Magic Number,BTDB.KVDBLayer,Writer,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\InMemoryFileCollection.cs,Writer,The following statement contains a magic number: Buf = new byte[32768];
Magic Number,BTDB.KVDBLayer,Writer,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\InMemoryFileCollection.cs,Writer,The following statement contains a magic number: Buf = new byte[1024 * 32];
Magic Number,BTDB.KVDBLayer,Writer,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\InMemoryFileCollection.cs,Writer,The following statement contains a magic number: Buf = new byte[1024 * 32];
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,KeyValueDB,The following statement contains a magic number: options.FileSplitSize < 1024 || options.FileSplitSize > int.MaxValue
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,KeyValueDB,The following statement contains a magic number: CompactorRamLimitInMb = 200;
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) |                                ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) |                                 inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,WriteCreateOrUpdateCommand,The following statement contains a magic number: trlPos > 256 && trlPos + prefix.Length + key.Length + 16 + value.Length > _maxTrLogFileSize
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,WriteCreateOrUpdateCommand,The following statement contains a magic number: trlPos > 256 && trlPos + prefix.Length + key.Length + 16 + value.Length > _maxTrLogFileSize
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,CalcValueSize,The following statement contains a magic number: return (uint)(valueSize >> 24);
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: var len = valueSize >> 24;
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReplaceBTreeValues,The following statement contains a magic number: ctx._iterationTimeOut = DateTime.UtcNow + TimeSpan.FromMilliseconds(50);
Magic Number,BTDB.KVDBLayer,KeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReplaceBTreeValues,The following statement contains a magic number: Thread.Sleep(10);
Magic Number,BTDB.KVDBLayer,SnappyCompressionStrategy,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\SnappyCompressionStrategy.cs,ShouldTryToCompressKey,The following statement contains a magic number: return length > 1024;
Magic Number,BTDB.KVDBLayer,SnappyCompressionStrategy,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\SnappyCompressionStrategy.cs,CompressKey,The following statement contains a magic number: return SnappyCompress.TryCompress(ref data' 80);
Magic Number,BTDB.KVDBLayer,SnappyCompressionStrategy,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\SnappyCompressionStrategy.cs,CompressKey,The following statement contains a magic number: return SnappyCompress.TryCompress(ref data' 80);
Magic Number,BTDB.KVDBLayer,SnappyCompressionStrategy,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\SnappyCompressionStrategy.cs,CompressValue,The following statement contains a magic number: data.Length < 32
Magic Number,BTDB.KVDBLayer,SnappyCompressionStrategy,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\SnappyCompressionStrategy.cs,CompressValue,The following statement contains a magic number: return SnappyCompress.TryCompress(ref data' 80);
Magic Number,BTDB.KVDBLayer,SnappyCompressionStrategy,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\SnappyCompressionStrategy.cs,CompressValue,The following statement contains a magic number: data.Length < 32
Magic Number,BTDB.KVDBLayer,SnappyCompressionStrategy,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\SnappyCompressionStrategy.cs,CompressValue,The following statement contains a magic number: return SnappyCompress.TryCompress(ref data' 80);
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeBranch,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,Find,The following statement contains a magic number: var middle = (left + right) / 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeBranch,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,CreateOrUpdate,The following statement contains a magic number: Array.Copy(_children' index + 1' newChildren' index + 2' _children.Length - index - 1);
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeBranch,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,CreateOrUpdate,The following statement contains a magic number: var keyCountLeft = (newChildren.Length + 1) / 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeBranch,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,FillStackByIndex,The following statement contains a magic number: var middle = (left + right) / 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeBranch,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,FindLastWithPrefix,The following statement contains a magic number: var middle = (left + right) / 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,Find,The following statement contains a magic number: var middle = (left + right) / 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,Find,The following statement contains a magic number: return middle * 2 + 1;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,Find,The following statement contains a magic number: return left * 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,CreateOrUpdate,The following statement contains a magic number: index = index / 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,CreateOrUpdate,The following statement contains a magic number: index = index / 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,CreateOrUpdate,The following statement contains a magic number: var keyCountLeft = (_keyvalues.Length + 1) / 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,FindKey,The following statement contains a magic number: idx = idx / 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,FindLastWithPrefix,The following statement contains a magic number: var middle = (left + right) / 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,Find,The following statement contains a magic number: var middle = (left + right) / 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,Find,The following statement contains a magic number: return middle * 2 + 1;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,Find,The following statement contains a magic number: return left * 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,The following statement contains a magic number: index = index / 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,The following statement contains a magic number: index = index / 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,The following statement contains a magic number: var keyCountLeft = (_keyvalues.Length + 1) / 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,FindKey,The following statement contains a magic number: idx = idx / 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,FindLastWithPrefix,The following statement contains a magic number: var middle = (left + right) / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeBranch,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,Find,The following statement contains a magic number: var middle = (left + right) / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeBranch,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,CreateOrUpdate,The following statement contains a magic number: Array.Copy(_children' index + 1' newChildren' index + 2' _children.Length - index - 1);
Magic Number,BTDB.KVDBLayer.BTree,BTreeBranch,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,CreateOrUpdate,The following statement contains a magic number: var keyCountLeft = (newChildren.Length + 1) / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeBranch,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,FillStackByIndex,The following statement contains a magic number: var middle = (left + right) / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeBranch,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,FindLastWithPrefix,The following statement contains a magic number: var middle = (left + right) / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,Find,The following statement contains a magic number: var middle = (left + right) / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,Find,The following statement contains a magic number: return middle * 2 + 1;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,Find,The following statement contains a magic number: return left * 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,CreateOrUpdate,The following statement contains a magic number: index = index / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,CreateOrUpdate,The following statement contains a magic number: index = index / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,CreateOrUpdate,The following statement contains a magic number: var keyCountLeft = (_keyvalues.Length + 1) / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,FindKey,The following statement contains a magic number: idx = idx / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,FindLastWithPrefix,The following statement contains a magic number: var middle = (left + right) / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,ReplaceValues,The following statement contains a magic number: keyvalues[i].ValueFileId = (uint) (newOffset >> 32);
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,ReplaceValues,The following statement contains a magic number: map.TryGetValue(((ulong) ii.ValueFileId << 32) | ii.ValueOfs' out var newOffset)
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,Find,The following statement contains a magic number: var middle = (left + right) / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,Find,The following statement contains a magic number: return middle * 2 + 1;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,Find,The following statement contains a magic number: return left * 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,CreateOrUpdate,The following statement contains a magic number: index = index / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,CreateOrUpdate,The following statement contains a magic number: index = index / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,CreateOrUpdate,The following statement contains a magic number: var keyCountLeft = (_keyvalues.Length + 1) / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,FindKey,The following statement contains a magic number: idx = idx / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,FindLastWithPrefix,The following statement contains a magic number: var middle = (left + right) / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,ReplaceValues,The following statement contains a magic number: keyValues[i].ValueFileId = (uint) (newOffset >> 32);
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,ReplaceValues,The following statement contains a magic number: map.TryGetValue(((ulong) ii.ValueFileId << 32) | ii.ValueOfs' out var newOffset)
Magic Number,BTDB.KVDBLayer.Implementation,BytesPerSecondLimiter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BytesPerSecondLimiter.cs,BytesPerSecondLimiter,The following statement contains a magic number: _delta = bytesPerSecond >> 4;
Magic Number,BTDB.KVDBLayer.Implementation,BytesPerSecondLimiter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BytesPerSecondLimiter.cs,Limit,The following statement contains a magic number: var shouldTakeMs = (long) (bytesTillNow * 1000.0 / _bytesPerSecond);
Magic Number,BTDB.KVDBLayer.Implementation,BytesPerSecondLimiter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BytesPerSecondLimiter.cs,Limit,The following statement contains a magic number: Thread.Sleep((int) Math.Min(shouldTakeMs - msTillNow' 120000));
Magic Number,BTDB.ODBLayer,ODBDictionary<TKey;TValue>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,FreeContent,The following statement contains a magic number: ilGenerator                     .Ldarg(0)                     .Ldarg(1)                     .Ldarg(2)                     .Newobj(() => new DBReaderWithFreeInfoCtx(null' null' null))                     .Stloc(readerLoc);
Magic Number,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The following statement contains a magic number: il.Ldarg(0).Ldarg(1).Ldarg(2)                 .Call(_relationDbManipulatorType.GetConstructor(new[]                     {typeof(IObjectDBTransaction)' typeof(RelationInfo)}))                 .Ret();
Magic Number,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,BuildListByIdMethod,The following statement contains a magic number: var advancedEnumeratorCtor =                         enumType.GetConstructors().Single(ci => ci.GetParameters().Length == 8);
Magic Number,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,BuildListByMethod,The following statement contains a magic number: var secondaryKeyIndex =                     _relationInfo.ClientRelationVersionInfo.GetSecondaryKeyIndex(method.Name.Substring(6));
Magic Number,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,BuildListByMethod,The following statement contains a magic number: var advancedEnumeratorCtor =                         enumType.GetConstructors().Single(ci => ci.GetParameters().Length == 9);
Magic Number,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,BuildCountByMethod,The following statement contains a magic number: var secondaryKeyIndex =                 _relationInfo.ClientRelationVersionInfo.GetSecondaryKeyIndex(method.Name.Substring(7));
Magic Number,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,BuildAnyByMethod,The following statement contains a magic number: var secondaryKeyIndex =                 _relationInfo.ClientRelationVersionInfo.GetSecondaryKeyIndex(method.Name.Substring(5));
Magic Number,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodFindBy,The following statement contains a magic number: var skName = methodName.Substring(6);
Magic Number,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodFindBy,The following statement contains a magic number: skName = skName.Substring(0' skName.Length - 9);
Magic Number,BTDB.ODBLayer,RelationBuilder<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,GenerateApartFieldsProperties,The following statement contains a magic number: var propName = RelationInfo.GetPersistentName(method.Name.Substring(4)' properties);
Magic Number,BTDB.ODBLayer,RelationDBManipulator<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,WritePKPrefix,The following statement contains a magic number: writer.WriteInt8(3);
Magic Number,BTDB.ODBLayer,RelationDBManipulator<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,WriteSKPrefix,The following statement contains a magic number: writer.WriteInt8(4);
Magic Number,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateBytesToSKSaver,The following statement contains a magic number: InitializeBuffer(2' ref firstBuffer' ilGenerator' pks' true);
Magic Number,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateSaverWithApartFields,The following statement contains a magic number: StoreNthArgumentOfTypeIntoLoc(ilGenerator' 2' ClientType' 0);
Magic Number,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateSaverWithApartFields,The following statement contains a magic number: StoreNthArgumentOfTypeIntoLoc(ilGenerator' 3' _interfaceType' 1);
Magic Number,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateSaver,The following statement contains a magic number: StoreNthArgumentOfTypeIntoLoc(ilGenerator' 2' ClientType' 0);
Magic Number,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,FindApartFields,The following statement contains a magic number: var name = GetPersistentName(method.Name.Substring(4)' properties);
Magic Number,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,GetPKValToSKMerger,The following statement contains a magic number: var h = secondaryKeyIndex + version * 100000ul;
Magic Number,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,GetSKKeyValuetoPKMerger,The following statement contains a magic number: var h = 10000ul * secondaryKeyIndex + paramFieldCountInFirstBuffer;
Magic Number,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreatePrimaryKeyFromSKDataMerger,The following statement contains a magic number: Action<IILGen> pushWriter = il => il.Ldarg(2);
Magic Number,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateLoader,The following statement contains a magic number: ilGenerator                 .Ldarg(2)                 .Castclass(ClientType)                 .Stloc(0);
Magic Number,BTDB.ODBLayer,RelationInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateIDictFinder,The following statement contains a magic number: ilGenerator                     .Ldarg(0)                     .Ldarg(1)                     .Ldarg(2)                     .Newobj(() => new DBReaderWithFreeInfoCtx(null' null' null))                     .Stloc(0);
Magic Number,BTDB.ODBLayer,TableIdVersionId,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableIdVersionId.cs,GetHashCode,The following statement contains a magic number: return (int)(TableId * 33 + VersionId);
Magic Number,BTDB.ODBLayer,TableInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateInitializer,The following statement contains a magic number: ilGenerator                     .Ldarg(2)                     .Castclass(ClientType)                     .Stloc(0);
Magic Number,BTDB.ODBLayer,TableInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateSaver,The following statement contains a magic number: ilGenerator                 .Ldarg(3)                 .Castclass(ClientType)                 .Stloc(0);
Magic Number,BTDB.ODBLayer,TableInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateSaver,The following statement contains a magic number: ilGenerator                     .Ldarg(0)                     .Ldarg(2)                     .Newobj(() => new DBWriterCtx(null' null))                     .Stloc(1);
Magic Number,BTDB.ODBLayer,TableInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,The following statement contains a magic number: ilGenerator                 .Ldarg(3)                 .Castclass(ClientType)                 .Stloc(0);
Magic Number,BTDB.ODBLayer,TableInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,The following statement contains a magic number: ilGenerator                     .Ldarg(0)                     .Ldarg(2)                     .Newobj(() => new DBReaderCtx(null' null))                     .Stloc(1);
Magic Number,BTDB.ODBLayer,TableInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateFreeContent,The following statement contains a magic number: ilGenerator                     .Ldarg(0)                     .Ldarg(2)                     .Ldarg(3)                     .Newobj(() => new DBReaderWithFreeInfoCtx(null' null' null))                     .Stloc(0);
Magic Number,BTDB.ODBLayer,TableInfo,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateFreeContent,The following statement contains a magic number: ilGenerator                     .Ldarg(0)                     .Ldarg(2)                     .Ldarg(3)                     .Newobj(() => new DBReaderWithFreeInfoCtx(null' null' null))                     .Stloc(0);
Magic Number,BTDB.Reactive,FastBehaviourSubject<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,Unsubscribe,The following statement contains a magic number: originalArray.Length == 2
Magic Number,BTDB.Reactive,FastSubject<T>,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Reactive\FastSubject.cs,Unsubscribe,The following statement contains a magic number: originalArray.Length == 2
Magic Number,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: ilGenerator                     .Ldarg(2)                     .Ldarg(1)                     .Newobj(() => new ServiceReaderCtx((IServiceInternalServer)null' null))                     .Castclass(typeof(IReaderCtx))                     .Stloc(localReaderCtx);
Magic Number,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,CreateTaskContinuationWithResultMarshaling,The following statement contains a magic number: ilGenerator                 .Ldarg(0)                 .Call(() => new object())                 .Ldarg(0)                 .Ldarg(2)                 .Stfld(ownerField)                 .Ldarg(0)                 .Ldarg(3)                 .Stfld(resultIdField)                 .Ldarg(1)                 .Ldarg(0)                 .Ldftn(methodBuilder)                 .Newobj(actionOfTaskType.GetConstructor(new[] { typeof(object)' typeof(IntPtr) }))                 .Callvirt(taskType.GetMethod("ContinueWith"' new[] { actionOfTaskType }))                 .Pop()                 .Ret();
Magic Number,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,CreateTaskContinuationWithResultMarshaling,The following statement contains a magic number: ilGenerator                 .Ldarg(0)                 .Call(() => new object())                 .Ldarg(0)                 .Ldarg(2)                 .Stfld(ownerField)                 .Ldarg(0)                 .Ldarg(3)                 .Stfld(resultIdField)                 .Ldarg(1)                 .Ldarg(0)                 .Ldftn(methodBuilder)                 .Newobj(actionOfTaskType.GetConstructor(new[] { typeof(object)' typeof(IntPtr) }))                 .Callvirt(taskType.GetMethod("ContinueWith"' new[] { actionOfTaskType }))                 .Pop()                 .Ret();
Magic Number,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: methodBuilder.ExpectedLength(16);
Magic Number,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: methodBuilder.ExpectedLength(16);
Magic Number,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: methodBuilder.ExpectedLength(32);
Magic Number,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: ilGenerator                     .Ldarg(0)                     .Ldarg(2)                     .LdcI4(i)                     .LdelemRef()                     .Stfld(bindingFields[i]);
Magic Number,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibility,The following statement contains a magic number: result += 5;
Magic Number,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibility,The following statement contains a magic number: return 10;
Magic Number,BTDB.Service,Service,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibility,The following statement contains a magic number: return 5;
Magic Number,BTDB.Service,Client,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Service\TcpipServer.cs,ReceiveBody,The following statement contains a magic number: var buf = new byte[9];
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Equal4,The following statement contains a magic number: return buf[o1] == buf[o2] &&                    buf[o1 + 1] == buf[o2 + 1] &&                    buf[o1 + 2] == buf[o2 + 2] &&                    buf[o1 + 3] == buf[o2 + 3];
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Equal4,The following statement contains a magic number: return buf[o1] == buf[o2] &&                    buf[o1 + 1] == buf[o2 + 1] &&                    buf[o1 + 2] == buf[o2 + 2] &&                    buf[o1 + 3] == buf[o2 + 3];
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Equal4,The following statement contains a magic number: return buf[o1] == buf[o2] &&                    buf[o1 + 1] == buf[o2 + 1] &&                    buf[o1 + 2] == buf[o2 + 2] &&                    buf[o1 + 3] == buf[o2 + 3];
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Equal4,The following statement contains a magic number: return buf[o1] == buf[o2] &&                    buf[o1 + 1] == buf[o2 + 1] &&                    buf[o1 + 2] == buf[o2 + 2] &&                    buf[o1 + 3] == buf[o2 + 3];
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst[d] = (byte)((sL - 1) << 2);
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: sL < 61
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: var x = length - 4;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: dL < 2
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: dst[d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: dst[d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: d += 2;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: dL -= 2;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: 0 <= x && x < 8 && offset < 1 << 11
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: 0 <= x && x < 8 && offset < 1 << 11
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: x = 1 << 6;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: x > 1 << 6
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: dL < 3
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: dst[d] = (byte)((x - 1) << 2 | 2);
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: dst[d] = (byte)((x - 1) << 2 | 2);
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: dst[d + 2] = (byte)(offset >> 8);
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: dst[d + 2] = (byte)(offset >> 8);
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: d += 3;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: dL -= 3;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: dL < 5
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: sL <= 4
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: var shift = 32 - 8;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: var shift = 32 - 8;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: var tableSize = 1 << 8;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: tableSize *= 2;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: tableSize < 1 << 14 && tableSize < sL
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: var v = src[s] | ((uint)src[s + 1]) << 8 | ((uint)src[s + 2]) << 16 | ((uint)src[s + 3]) << 24;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: var v = src[s] | ((uint)src[s + 1]) << 8 | ((uint)src[s + 2]) << 16 | ((uint)src[s + 3]) << 24;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: var v = src[s] | ((uint)src[s + 1]) << 8 | ((uint)src[s + 2]) << 16 | ((uint)src[s + 3]) << 24;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: var v = src[s] | ((uint)src[s + 1]) << 8 | ((uint)src[s + 2]) << 16 | ((uint)src[s + 3]) << 24;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: var v = src[s] | ((uint)src[s + 1]) << 8 | ((uint)src[s + 2]) << 16 | ((uint)src[s + 3]) << 24;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: v = (v >> 8) | ((uint)src[s + 3]) << 24;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: v = (v >> 8) | ((uint)src[s + 3]) << 24;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: v = (v >> 8) | ((uint)src[s + 3]) << 24;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: sL>3
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: s += 4;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: sL -= 4;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: t += 4;
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: sL > 3
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,TryCompress,The following statement contains a magic number: var compressed = new byte[data.Length * (long)maxSizeInPercent / 100];
Magic Number,BTDB.SnappyCompression,SnappyCompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,TryCompress,The following statement contains a magic number: var compressed = new byte[data.Length * (long)maxSizeInPercent / 100];
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: var result = (uint) (b & 127);
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: b < 128
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint) (b & 127) << 7);
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint) (b & 127) << 7);
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: b < 128
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint) (b & 127) << 14);
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint) (b & 127) << 14);
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: b < 128
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint) (b & 127) << 21);
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint) (b & 127) << 21);
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: b < 128
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint) (b & 127) << 28);
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint) (b & 127) << 28);
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: b >= 16
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt8Ordered,The following statement contains a magic number: return (sbyte) (Buf[Pos++] - 128);
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt64,The following statement contains a magic number: Pos += 8;
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt64,The following statement contains a magic number: Pos + 8 <= End
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipInt64,The following statement contains a magic number: Pos += 8;
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipInt64,The following statement contains a magic number: Pos + 8 <= End
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32,The following statement contains a magic number: Pos += 4;
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32,The following statement contains a magic number: Pos + 4 <= End
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32LE,The following statement contains a magic number: Pos += 4;
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32LE,The following statement contains a magic number: Pos + 4 <= End
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipInt32,The following statement contains a magic number: Pos += 4;
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipInt32,The following statement contains a magic number: Pos + 4 <= End
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadString,The following statement contains a magic number: res[i] = (char) ((c >> 10) + 0xD800);
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadStringOrdered,The following statement contains a magic number: ReserveCharBuf(len + 2);
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadStringOrdered,The following statement contains a magic number: CharBuf[len++] = (char) ((c >> 10) + 0xD800);
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipString,The following statement contains a magic number: i += 2;
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadGuid,The following statement contains a magic number: Span<byte> res = stackalloc byte[16];
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipGuid,The following statement contains a magic number: SkipBlock(16);
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following statement contains a magic number: switch (header >> 5 & 3)             {                 case 0:                     break;                 case 1:                     first = ReadVUInt64();                     break;                 case 2:                     second = ReadVUInt32();                     first = (ulong) ReadInt64();                     break;                 case 3:                     second = (uint) ReadInt32();                     first = (ulong) ReadInt64();                     break;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following statement contains a magic number: switch (header >> 5 & 3)             {                 case 0:                     break;                 case 1:                     first = ReadVUInt64();                     break;                 case 2:                     second = ReadVUInt32();                     first = (ulong) ReadInt64();                     break;                 case 3:                     second = (uint) ReadInt32();                     first = (ulong) ReadInt64();                     break;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following statement contains a magic number: switch (header >> 5 & 3)             {                 case 0:                     break;                 case 1:                     first = ReadVUInt64();                     break;                 case 2:                     second = ReadVUInt32();                     first = (ulong) ReadInt64();                     break;                 case 3:                     second = (uint) ReadInt32();                     first = (ulong) ReadInt64();                     break;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following statement contains a magic number: switch (header >> 5 & 3)             {                 case 0:                     break;                 case 1:                     first = ReadVUInt64();                     break;                 case 2:                     second = ReadVUInt32();                     first = (ulong) ReadInt64();                     break;                 case 3:                     second = (uint) ReadInt32();                     first = (ulong) ReadInt64();                     break;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following statement contains a magic number: var res = new decimal((int) first' (int) (first >> 32)' (int) second' (header & 128) != 0'                 (byte) (header & 31));
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following statement contains a magic number: var res = new decimal((int) first' (int) (first >> 32)' (int) second' (header & 128) != 0'                 (byte) (header & 31));
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following statement contains a magic number: var res = new decimal((int) first' (int) (first >> 32)' (int) second' (header & 128) != 0'                 (byte) (header & 31));
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipDecimal,The following statement contains a magic number: switch (header >> 5 & 3)             {                 case 0:                     break;                 case 1:                     SkipVUInt64();                     break;                 case 2:                     SkipVUInt32();                     SkipInt64();                     break;                 case 3:                     SkipInt32();                     SkipInt64();                     break;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipDecimal,The following statement contains a magic number: switch (header >> 5 & 3)             {                 case 0:                     break;                 case 1:                     SkipVUInt64();                     break;                 case 2:                     SkipVUInt32();                     SkipInt64();                     break;                 case 3:                     SkipInt32();                     SkipInt64();                     break;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipDecimal,The following statement contains a magic number: switch (header >> 5 & 3)             {                 case 0:                     break;                 case 1:                     SkipVUInt64();                     break;                 case 2:                     SkipVUInt32();                     SkipInt64();                     break;                 case 3:                     SkipInt32();                     SkipInt64();                     break;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipDecimal,The following statement contains a magic number: switch (header >> 5 & 3)             {                 case 0:                     break;                 case 1:                     SkipVUInt64();                     break;                 case 2:                     SkipVUInt32();                     SkipInt64();                     break;                 case 3:                     SkipInt32();                     SkipInt64();                     break;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadIPAddress,The following statement contains a magic number: switch (ReadUInt8())             {                 case 0:                     return new IPAddress((uint) ReadInt32LE());                 case 1:                 {                     Span<byte> ip6Bytes = stackalloc byte[16];                     ReadBlock(ip6Bytes);                     return new IPAddress(ip6Bytes);                 }                 case 2:                 {                     Span<byte> ip6Bytes = stackalloc byte[16];                     ReadBlock(ip6Bytes);                     var scopeid = (long) ReadVUInt64();                     return new IPAddress(ip6Bytes' scopeid);                 }                 case 3:                     return null;                 default: throw new InvalidDataException("Unknown type of IPAddress");             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadIPAddress,The following statement contains a magic number: switch (ReadUInt8())             {                 case 0:                     return new IPAddress((uint) ReadInt32LE());                 case 1:                 {                     Span<byte> ip6Bytes = stackalloc byte[16];                     ReadBlock(ip6Bytes);                     return new IPAddress(ip6Bytes);                 }                 case 2:                 {                     Span<byte> ip6Bytes = stackalloc byte[16];                     ReadBlock(ip6Bytes);                     var scopeid = (long) ReadVUInt64();                     return new IPAddress(ip6Bytes' scopeid);                 }                 case 3:                     return null;                 default: throw new InvalidDataException("Unknown type of IPAddress");             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadIPAddress,The following statement contains a magic number: switch (ReadUInt8())             {                 case 0:                     return new IPAddress((uint) ReadInt32LE());                 case 1:                 {                     Span<byte> ip6Bytes = stackalloc byte[16];                     ReadBlock(ip6Bytes);                     return new IPAddress(ip6Bytes);                 }                 case 2:                 {                     Span<byte> ip6Bytes = stackalloc byte[16];                     ReadBlock(ip6Bytes);                     var scopeid = (long) ReadVUInt64();                     return new IPAddress(ip6Bytes' scopeid);                 }                 case 3:                     return null;                 default: throw new InvalidDataException("Unknown type of IPAddress");             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadIPAddress,The following statement contains a magic number: switch (ReadUInt8())             {                 case 0:                     return new IPAddress((uint) ReadInt32LE());                 case 1:                 {                     Span<byte> ip6Bytes = stackalloc byte[16];                     ReadBlock(ip6Bytes);                     return new IPAddress(ip6Bytes);                 }                 case 2:                 {                     Span<byte> ip6Bytes = stackalloc byte[16];                     ReadBlock(ip6Bytes);                     var scopeid = (long) ReadVUInt64();                     return new IPAddress(ip6Bytes' scopeid);                 }                 case 3:                     return null;                 default: throw new InvalidDataException("Unknown type of IPAddress");             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipIPAddress,The following statement contains a magic number: switch (ReadUInt8())             {                 case 0:                     SkipInt32();                     return;                 case 1:                     SkipBlock(16);                     return;                 case 2:                     SkipBlock(16);                     SkipVUInt64();                     return;                 case 3:                     return;                 default: throw new InvalidDataException("Unknown type of IPAddress");             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipIPAddress,The following statement contains a magic number: switch (ReadUInt8())             {                 case 0:                     SkipInt32();                     return;                 case 1:                     SkipBlock(16);                     return;                 case 2:                     SkipBlock(16);                     SkipVUInt64();                     return;                 case 3:                     return;                 default: throw new InvalidDataException("Unknown type of IPAddress");             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipIPAddress,The following statement contains a magic number: switch (ReadUInt8())             {                 case 0:                     SkipInt32();                     return;                 case 1:                     SkipBlock(16);                     return;                 case 2:                     SkipBlock(16);                     SkipVUInt64();                     return;                 case 3:                     return;                 default: throw new InvalidDataException("Unknown type of IPAddress");             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipIPAddress,The following statement contains a magic number: switch (ReadUInt8())             {                 case 0:                     SkipInt32();                     return;                 case 1:                     SkipBlock(16);                     return;                 case 2:                     SkipBlock(16);                     SkipVUInt64();                     return;                 case 3:                     return;                 default: throw new InvalidDataException("Unknown type of IPAddress");             }
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt8Ordered,The following statement contains a magic number: Buf[Pos++] = (byte) (value + 128);
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt64,The following statement contains a magic number: var b = new byte[8];
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt64,The following statement contains a magic number: Pos + 8 > End
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt64,The following statement contains a magic number: Pos + 8 > End
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt64,The following statement contains a magic number: Pos += 8;
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32,The following statement contains a magic number: var b = new byte[4];
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32,The following statement contains a magic number: Pos + 4 > End
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32,The following statement contains a magic number: Pos + 4 > End
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32,The following statement contains a magic number: Pos += 4;
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32LE,The following statement contains a magic number: var b = new byte[4];
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32LE,The following statement contains a magic number: Pos + 4 > End
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32LE,The following statement contains a magic number: Pos + 4 > End
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32LE,The following statement contains a magic number: Pos += 4;
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteStringOrdered,The following statement contains a magic number: i += 2;
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteGuid,The following statement contains a magic number: WriteBlock(new ReadOnlySpan<byte>((byte*) &value' 16));
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: var header = (byte) ((ints[3] >> 16) & 31);
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: var header = (byte) ((ints[3] >> 16) & 31);
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: var header = (byte) ((ints[3] >> 16) & 31);
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: header |= 128;
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: ints[3] < 0
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: var first = (uint) ints[0] + ((ulong) ints[1] << 32);
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: ints[2] == 0
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteIPAddress,The following statement contains a magic number: WriteUInt8(3);
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteIPAddress,The following statement contains a magic number: Span<byte> buf = stackalloc byte[16];
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteIPAddress,The following statement contains a magic number: WriteUInt8(2);
Magic Number,BTDB.StreamLayer,ByteBufferWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\ByteBufferWriter.cs,ByteBufferWriter,The following statement contains a magic number: Buf = new byte[32];
Magic Number,BTDB.StreamLayer,ByteBufferWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\ByteBufferWriter.cs,Reset,The following statement contains a magic number: Buf = new byte[32];
Magic Number,BTDB.StreamLayer,ByteBufferWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\ByteBufferWriter.cs,FlushBuffer,The following statement contains a magic number: var newLen = Math.Max((int)Math.Min((long)End * 2' 2147483591)' 128);
Magic Number,BTDB.StreamLayer,ByteBufferWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\ByteBufferWriter.cs,FlushBuffer,The following statement contains a magic number: var newLen = Math.Max((int)Math.Min((long)End * 2' 2147483591)' 128);
Magic Number,BTDB.StreamLayer,ByteBufferWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\ByteBufferWriter.cs,FlushBuffer,The following statement contains a magic number: var newLen = Math.Max((int)Math.Min((long)End * 2' 2147483591)' 128);
Magic Number,BTDB.StreamLayer,LoggingPositionLessStream,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\LoggingPositionLessStream.cs,Read,The following statement contains a magic number: var sb = new StringBuilder(8 + 16 * 3);
Magic Number,BTDB.StreamLayer,LoggingPositionLessStream,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\LoggingPositionLessStream.cs,Read,The following statement contains a magic number: var sb = new StringBuilder(8 + 16 * 3);
Magic Number,BTDB.StreamLayer,LoggingPositionLessStream,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\LoggingPositionLessStream.cs,Read,The following statement contains a magic number: var sb = new StringBuilder(8 + 16 * 3);
Magic Number,BTDB.StreamLayer,LoggingPositionLessStream,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\LoggingPositionLessStream.cs,Read,The following statement contains a magic number: j == 16
Magic Number,BTDB.StreamLayer,LoggingPositionLessStream,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\LoggingPositionLessStream.cs,Write,The following statement contains a magic number: var sb = new StringBuilder(8 + 16 * 3);
Magic Number,BTDB.StreamLayer,LoggingPositionLessStream,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\LoggingPositionLessStream.cs,Write,The following statement contains a magic number: var sb = new StringBuilder(8 + 16 * 3);
Magic Number,BTDB.StreamLayer,LoggingPositionLessStream,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\LoggingPositionLessStream.cs,Write,The following statement contains a magic number: var sb = new StringBuilder(8 + 16 * 3);
Magic Number,BTDB.StreamLayer,LoggingPositionLessStream,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\LoggingPositionLessStream.cs,Write,The following statement contains a magic number: j == 16
Magic Number,BTDB.StreamLayer,PositionLessStreamProxy,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\PositionLessStreamProxy.cs,PositionLessStreamProxy,The following statement contains a magic number: _writeBufSize = 32768;
Magic Number,BTDB.StreamLayer,PositionLessStreamWriter,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\PositionLessStreamWriter.cs,PositionLessStreamWriter,The following statement contains a magic number: Buf = new byte[8192];
Magic Number,BTDB.StreamLayer,WindowsPlatformMethods,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\WindowsPlatformMethods.cs,PRead,The following statement contains a magic number: overlapped.OffsetHigh = (int)(position >> 32);
Magic Number,BTDB.StreamLayer,WindowsPlatformMethods,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\WindowsPlatformMethods.cs,PRead,The following statement contains a magic number: lastError == 38
Magic Number,BTDB.StreamLayer,WindowsPlatformMethods,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\WindowsPlatformMethods.cs,PRead,The following statement contains a magic number: throw Marshal.GetExceptionForHR(lastError & ushort.MaxValue | -2147024896) ?? new IOException();
Magic Number,BTDB.StreamLayer,WindowsPlatformMethods,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\WindowsPlatformMethods.cs,PWrite,The following statement contains a magic number: overlapped.OffsetHigh = (int)(position >> 32);
Magic Number,BTDB.StreamLayer,WindowsPlatformMethods,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\WindowsPlatformMethods.cs,RealPath,The following statement contains a magic number: var result = new StringBuilder(512);
Magic Number,BTDB.StreamLayer,WindowsPlatformMethods,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\WindowsPlatformMethods.cs,RealPath,The following statement contains a magic number: return result.ToString(4' result.Length - 4);
Magic Number,BTDB.StreamLayer,WindowsPlatformMethods,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\WindowsPlatformMethods.cs,RealPath,The following statement contains a magic number: return result.ToString(4' result.Length - 4);
Magic Number,BTDB.StreamLayer,WindowsPlatformMethods,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\WindowsPlatformMethods.cs,RealPath,The following statement contains a magic number: result[0] == '\\' && result[1] == '\\' && result[2] == '?' && result[3] == '\\'
Magic Number,BTDB.StreamLayer,WindowsPlatformMethods,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\WindowsPlatformMethods.cs,RealPath,The following statement contains a magic number: result[0] == '\\' && result[1] == '\\' && result[2] == '?' && result[3] == '\\'
Duplicate Code,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,IncrementInt64LE,The method contains a code clone-set at the following line numbers (starting from the method definition): ((3' 25)' (7' 29))
Duplicate Code,BTDB.Buffer,PackUnpack,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,IncrementInt64LE,The method contains a code clone-set at the following line numbers (starting from the method definition): ((3' 22)' (11' 30))
Duplicate Code,BTDB.KVDBLayer,BTreeKeyValueDB,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\BTreeKeyValueDB.cs,LoadKeyIndex,The method contains a code clone-set at the following line numbers (starting from the method definition): ((33' 75)' (93' 135))
Missing Default,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetStartPosAndByte,The following switch statement is missing a default case: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeType12.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeType12.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Missing Default,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetStartPosAndByteSkipLeaf,The following switch statement is missing a default case: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeType12.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeType12.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Missing Default,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,GetEndPosAndByte,The following switch statement is missing a default case: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     return (-1' 0);                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         var pos = header._childCount - 1;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeType12.Node48:                     for (var i = 255; i >= 0; i--)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeType12.Node256:                     for (var i = 255; i >= 0; i--)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Missing Default,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The following switch statement is missing a default case: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     for (var i = leftPos; i <= rightPos; i++)                     {                         willBeChildCount--;                         if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var ptr))                         {                             children += (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                         }                         else                         {                             children++;                         }                     }                      break;                 case NodeType12.Node48:                     unsafe                     {                         var span = new Span<byte>((node + 16).ToPointer()' 256);                         for (int i = leftByte; i <= rightByte; i++)                         {                             if (span[i] == 255)                                 continue;                             willBeChildCount--;                             if (IsPtr(NodeUtils12.PtrInNode(node' span[i])' out var ptr))                             {                                 children += (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                             }                             else                             {                                 children++;                             }                         }                     }                      break;                 case NodeType12.Node256:                     for (int j = leftByte; j <= rightByte; j++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(node' j)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                             children += (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                         }                         else                         {                             children++;                         }                          willBeChildCount--;                     }                      break;             }
Missing Default,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The following switch statement is missing a default case: switch (newNodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  TreeNodeUtils.MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 TreeNodeUtils.MoveMemory(NodeUtils12.PtrInNode(node' rightPos + 1)' NodeUtils12.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeType12.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtils12.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeType12.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtils12.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtils12.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Missing Default,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The following switch statement is missing a default case: switch (header._nodeType & NodeType12.NodeSizeMask)                     {                         case NodeType12.Node4:                         case NodeType12.Node16:                             {                                 if (leftPos > 0)                                 {                                     onlyByte = TreeNodeUtils.ReadByte(node + 16);                                     onlyPtr = NodeUtils12.PtrInNode(node' 0);                                 }                                 else                                 {                                     onlyByte = TreeNodeUtils.ReadByte(node + 16 + rightPos + 1);                                     onlyPtr = NodeUtils12.PtrInNode(node' rightPos + 1);                                 }                                  break;                             }                         case NodeType12.Node48:                             {                                 for (var i = 0; i < 256; i++)                                 {                                     if (i == leftByte)                                     {                                         i = rightByte;                                         continue;                                     }                                      var idx = TreeNodeUtils.ReadByte(node + 16 + i);                                     if (idx == 255) continue;                                     onlyByte = (byte)i;                                     onlyPtr = NodeUtils12.PtrInNode(node' idx);                                     break;                                 }                                  break;                             }                         case NodeType12.Node256:                             {                                 for (int i = 0; i < 256; i++)                                 {                                     if (i == leftByte)                                     {                                         i = rightByte;                                         continue;                                     }                                      if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var j))                                     {                                         if (j == IntPtr.Zero)                                             continue;                                     }                                      onlyByte = (byte)i;                                     onlyPtr = NodeUtils12.PtrInNode(node' i);                                     break;                                 }                                  break;                             }                     }
Missing Default,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,EraseRangeFromNode,The following switch statement is missing a default case: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             for (var i = 0; i < header._childCount; i++)                             {                                 if (i == leftPos)                                 {                                     if (leftNode != IntPtr.Zero)                                         pusher.PushPtr(leftByte' leftNode);                                     i = rightPos;                                     if (rightNode != IntPtr.Zero)                                     {                                         pusher.PushPtr(rightByte' rightNode);                                     }                                      continue;                                 }                                  pusher.Push(TreeNodeUtils.ReadByte(node + 16 + i)' NodeUtils12.PtrInNode(node' i));                             }                              break;                         }                     case NodeType12.Node48:                         {                             unsafe                             {                                 var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                 for (var i = 0; i < 256; i++)                                 {                                     var idx = bytePtrs[i];                                     if (idx == 255) continue;                                     if (i == leftByte)                                     {                                         if (leftNode != IntPtr.Zero)                                             pusher.PushPtr(leftByte' leftNode);                                         i = rightByte;                                         if (rightNode != IntPtr.Zero)                                         {                                             pusher.PushPtr(rightByte' rightNode);                                         }                                          continue;                                     }                                      pusher.Push((byte)i' NodeUtils12.PtrInNode(node' idx));                                 }                             }                              break;                         }                     case NodeType12.Node256:                         {                             for (var i = 0; i < 256; i++)                             {                                 if (i == leftByte)                                 {                                     if (leftNode != IntPtr.Zero)                                         pusher.PushPtr(leftByte' leftNode);                                     i = rightByte;                                     if (rightNode != IntPtr.Zero)                                     {                                         pusher.PushPtr(rightByte' rightNode);                                     }                                      continue;                                 }                                  if (IsPtr(NodeUtils12.PtrInNode(node' i)' out var j))                                 {                                     if (j == IntPtr.Zero)                                         continue;                                 }                                  pusher.Push((byte)i' NodeUtils12.PtrInNode(node' i));                             }                              break;                         }                 }
Missing Default,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,CalcIndex,The following switch statement is missing a default case: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     res += (long)NodeUtils12.Ptr2NodeHeader(NodeUtils12.Read12Ptr(ptrInNode))                                         ._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 12;                             for (; ptrInNode != limit; ptrInNode += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(ptrInNode))                                 {                                     var child = NodeUtils12.Read12Ptr(ptrInNode);                                     if (child != IntPtr.Zero)                                         res += (long)NodeUtils12.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Missing Default,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,SeekIndex,The following switch statement is missing a default case: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         for (int j = 0; j < header._childCount; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     return true;                                 }                                  index--;                             }                         }                          break;                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 if (IsPtr(NodeUtils12.PtrInNode(top' span[j])' out var ptr))                                 {                                     var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                     if (index < rcc)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         top = ptr;                                         break;                                     }                                      index -= rcc;                                 }                                 else                                 {                                     if (index == 0)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         return true;                                     }                                      index--;                                 }                             }                         }                          break;                     case NodeType12.Node256:                         for (int j = 0; j < 256; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                     continue;                                 var rcc = (long)NodeUtils12.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     return true;                                 }                                  index--;                             }                         }                          break;                 }
Missing Default,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,MoveNext,The following switch statement is missing a default case: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.NodeLeaf:                         goto up;                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (stackItem._posInNode == header._childCount - 1)                             {                                 goto up;                             }                              stackItem._posInNode++;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeType12.Node256:                         for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                         {                             if (IsPtr(NodeUtils12.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                                  stackItem._posInNode = (short)j;                                 stackItem._byte = (byte)j;                                 PushLeftMost(ptr2' (int)stackItem._keyOffset' ref stack);                                 return true;                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             return true;                         }                          goto up;                 }
Missing Default,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,MovePrevious,The following switch statement is missing a default case: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             if (stackItem._posInNode == 0)                             {                                 goto up;                             }                              stackItem._posInNode--;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = stackItem._byte - 1; j >= 0; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeType12.Node256:                         for (int j = stackItem._byte - 1; j >= 0; j--)                         {                             if (IsPtr(NodeUtils12.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             goto down;                         }                          goto up;                 }
Missing Default,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,FindNearPosAndByte,The following switch statement is missing a default case: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         pos = ~pos;                         if (pos >= header._childCount) pos--;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeType12.Node48:                     {                         var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                         pos = @byte + 1;                         while (pos < 256)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos++;                         }                          pos = @byte - 1;                         while (true)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos--;                         }                     }                 case NodeType12.Node256:                     {                         pos = @byte + 1;                         while (pos < 256)                         {                             if (IsPtr(NodeUtils12.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos++;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          pos = @byte - 1;                         while (pos >= 0)                         {                             if (IsPtr(NodeUtils12.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos--;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          break;                     }             }
Missing Default,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushLeftMost,The following switch statement is missing a default case: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 4;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var ptr = top + 16 + 16;                             if (NodeUtils12.IsPtr12Ptr(ptr))                             {                                 top = NodeUtils12.Read12Ptr(ptr);                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var ptr = top + 16 + 256 + pos * 12;                                 if (NodeUtils12.IsPtr12Ptr(ptr))                                 {                                     top = NodeUtils12.Read12Ptr(ptr);                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 12)                             {                                 if (NodeUtils12.IsPtr12Ptr(p))                                 {                                     var child = NodeUtils12.Read12Ptr(p);                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Missing Default,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushRightMost,The following switch statement is missing a default case: switch (header._nodeType & NodeType12.NodeSizeMask)                 {                     case NodeType12.Node4:                     case NodeType12.Node16:                         {                             var pos = header._childCount - 1;                             stack.AddRef().Set(top' (uint)keyOffset' (short)pos' TreeNodeUtils.ReadByte(top + 16 + pos));                             if (IsPtr(NodeUtils12.PtrInNode(top' pos)' out var ptr))                             {                                 top = ptr;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeType12.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 255; true; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' span[j]' (byte)j);                                 if (IsPtr(NodeUtils12.PtrInNode(top' span[j])' out var ptr))                                 {                                     top = ptr;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeType12.Node256:                         for (int j = 255; true; j--)                         {                             if (IsPtr(NodeUtils12.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr != IntPtr.Zero)                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  continue;                             }                             else                             {                                 stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                 return;                             }                         }                          break;                 }
Missing Default,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,StructureCheck,The following switch statement is missing a default case: switch (header._nodeType & NodeType12.NodeSizeMask)              {                 case NodeType12.NodeLeaf:                     childrenCount = 1;                     break;                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' pos)' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeType12.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         StructureCheck48(span' header.ChildCount);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' span[j])' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeType12.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(nodePtr' j)' out var ptr))                         {                             childrenCount += StructureCheck(ptr);                         }                         else                         {                             childrenCount++;                         }                     }                      break;             }
Missing Default,BTDB.ARTLib,ARTImpl12,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,IterateNodeInfo,The following switch statement is missing a default case: switch (header._nodeType & NodeType12.NodeSizeMask)             {                 case NodeType12.NodeLeaf:                     break;                 case NodeType12.Node4:                 case NodeType12.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' pos)' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeType12.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtils12.PtrInNode(nodePtr' span[j])' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeType12.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtils12.PtrInNode(nodePtr' j)' out ptr))                         {                             IterateNodeInfo(ptr' deepness + 1' iterator);                         }                     }                     break;             }
Missing Default,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushPtr,The following switch statement is missing a default case: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4' ptr);                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4' ptr);                             _dst += 12;                             break;                         }                     case 5:                         {                             TreeNodeUtils.WriteInt32Aligned(_dst + 12 * @byte' unchecked((int)uint.MaxValue));                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 4 + 12 * @byte' ptr);                             break;                         }                 }
Missing Default,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following switch statement is missing a default case: switch (_type)                 {                     case 1:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 3:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteInt32Aligned(_dst' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             _dst += 12;                             break;                         }                     case 5:                         {                             var ofs = 12 * @byte;                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs' TreeNodeUtils.ReadInt32Aligned(source));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 4' TreeNodeUtils.ReadInt32Aligned(source + 4));                             TreeNodeUtils.WriteInt32Aligned(_dst + ofs + 8' TreeNodeUtils.ReadInt32Aligned(source + 8));                             if (NodeUtils12.IsPtr12Ptr(source))                                 NodeUtils12.Reference(NodeUtils12.Read12Ptr(source));                             break;                         }                 }
Missing Default,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,PushPtr,The following switch statement is missing a default case: switch (_type)                 {                     case 0:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' ptr);                             _dst += 8;                             break;                         }                     case 2:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' ptr);                             _dst += 8;                             break;                         }                     case 4:                         {                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 8 * @byte' ptr);                             break;                         }                 }
Missing Default,BTDB.ARTLib,Pusher,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImpl12.cs,Push,The following switch statement is missing a default case: switch (_type)                 {                     case 0:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte);                             _byteDst += 1;                             var p = TreeNodeUtils.ReadIntPtrUnaligned(source);                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' p);                             if (NodeUtilsV.IsPtrPtr(p))                                 NodeUtilsV.Reference(p);                             _dst += 8;                             break;                         }                     case 2:                         {                             TreeNodeUtils.WriteByte(_byteDst' @byte' (byte)_idx);                             _idx++;                             var p = TreeNodeUtils.ReadIntPtrUnaligned(source);                             TreeNodeUtils.WriteIntPtrUnaligned(_dst' p);                             if (NodeUtilsV.IsPtrPtr(p))                                 NodeUtilsV.Reference(p);                             _dst += 8;                             break;                         }                     case 4:                         {                             var p = TreeNodeUtils.ReadIntPtrUnaligned(source);                             TreeNodeUtils.WriteIntPtrUnaligned(_dst + 8 * @byte' p);                             if (NodeUtilsV.IsPtrPtr(p))                                 NodeUtilsV.Reference(p);                             break;                         }                 }
Missing Default,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetStartPosAndByte,The following switch statement is missing a default case: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeTypeV.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeTypeV.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Missing Default,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetStartPosAndByteSkipLeaf,The following switch statement is missing a default case: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     return (0' TreeNodeUtils.ReadByte(node + 16));                 case NodeTypeV.Node48:                     for (var i = 0; i < 256; i++)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeTypeV.Node256:                     for (var i = 0; i < 256; i++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Missing Default,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,GetEndPosAndByte,The following switch statement is missing a default case: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     return (-1' 0);                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         var pos = header._childCount - 1;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeTypeV.Node48:                     for (var i = 255; i >= 0; i--)                     {                         var pos = TreeNodeUtils.ReadByte(node + 16 + i);                         if (pos == 255)                             continue;                         return (pos' (byte)i);                     }                      break;                 case NodeTypeV.Node256:                     for (var i = 255; i >= 0; i--)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                         }                          return ((short)i' (byte)i);                     }                      break;             }
Missing Default,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The following switch statement is missing a default case: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     for (var i = leftPos; i <= rightPos; i++)                     {                         willBeChildCount--;                         if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var ptr))                         {                             children += (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                         }                         else                         {                             children++;                         }                     }                      break;                 case NodeTypeV.Node48:                     unsafe                     {                         var span = new Span<byte>((node + 16).ToPointer()' 256);                         for (int i = leftByte; i <= rightByte; i++)                         {                             if (span[i] == 255)                                 continue;                             willBeChildCount--;                             if (IsPtr(NodeUtilsV.PtrInNode(node' span[i])' out var ptr))                             {                                 children += (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                             }                             else                             {                                 children++;                             }                         }                     }                      break;                 case NodeTypeV.Node256:                     for (int j = leftByte; j <= rightByte; j++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(node' j)' out var ptr))                         {                             if (ptr == IntPtr.Zero)                                 continue;                             children += (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                         }                         else                         {                             children++;                         }                          willBeChildCount--;                     }                      break;             }
Missing Default,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The following switch statement is missing a default case: switch (newNodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftPos++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightPos--;                             }                              if (leftPos <= rightPos)                             {                                 for (var i = leftPos; i <= rightPos; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                                  MoveMemory(node + 16 + rightPos + 1' node + 16 + leftPos'                                     header._childCount - rightPos - 1);                                 MoveMemory(NodeUtilsV.PtrInNode(node' rightPos + 1)' NodeUtilsV.PtrInNode(node' leftPos)'                                     (header._childCount - rightPos - 1) * PtrSize);                             }                              break;                         }                     case NodeTypeV.Node48:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header._childCount)                             {                                 unsafe                                 {                                     Span<byte> tempItems = stackalloc byte[willBeChildCount * PtrSize]; // maximum 47*12=564                                     var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                     var outPos = 0;                                     for (var i = 0; i < 256; i++)                                     {                                         var idx = bytePtrs[i];                                         if (idx == 255) continue;                                         if ((i >= leftByte) && (i <= rightByte))                                         {                                             bytePtrs[i] = 255;                                             // Just to decrease reference count                                             WritePtrInNode(NodeUtilsV.PtrInNode(node' idx)' IntPtr.Zero);                                         }                                         else                                         {                                             bytePtrs[i] = (byte)outPos;                                             new Span<byte>((node + 16 + 256 + idx * PtrSize).ToPointer()' PtrSize).CopyTo(                                                 tempItems.Slice(outPos * PtrSize));                                             outPos++;                                         }                                     }                                      tempItems.CopyTo(new Span<byte>((node + 16 + 256).ToPointer()' tempItems.Length));                                 }                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             if (leftNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' leftPos)' leftNode);                                 leftByte++;                             }                              if (rightNode != IntPtr.Zero)                             {                                 WritePtrInNode(NodeUtilsV.PtrInNode(node' rightPos)' rightNode);                                 rightByte--;                             }                              if (willBeChildCount < header.ChildCount)                             {                                 for (int i = leftByte; i <= rightByte; i++)                                 {                                     WritePtrInNode(NodeUtilsV.PtrInNode(node' i)' IntPtr.Zero);                                 }                             }                              break;                         }                 }
Missing Default,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The following switch statement is missing a default case: switch (header._nodeType & NodeTypeV.NodeSizeMask)                     {                         case NodeTypeV.Node4:                         case NodeTypeV.Node16:                             {                                 if (leftPos > 0)                                 {                                     onlyByte = TreeNodeUtils.ReadByte(node + 16);                                     onlyPtr = NodeUtilsV.PtrInNode(node' 0);                                 }                                 else                                 {                                     onlyByte = TreeNodeUtils.ReadByte(node + 16 + rightPos + 1);                                     onlyPtr = NodeUtilsV.PtrInNode(node' rightPos + 1);                                 }                                  break;                             }                         case NodeTypeV.Node48:                             {                                 for (var i = 0; i < 256; i++)                                 {                                     if (i == leftByte)                                     {                                         i = rightByte;                                         continue;                                     }                                      var idx = TreeNodeUtils.ReadByte(node + 16 + i);                                     if (idx == 255) continue;                                     onlyByte = (byte)i;                                     onlyPtr = NodeUtilsV.PtrInNode(node' idx);                                     break;                                 }                                  break;                             }                         case NodeTypeV.Node256:                             {                                 for (int i = 0; i < 256; i++)                                 {                                     if (i == leftByte)                                     {                                         i = rightByte;                                         continue;                                     }                                      if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var j))                                     {                                         if (j == IntPtr.Zero)                                             continue;                                     }                                      onlyByte = (byte)i;                                     onlyPtr = NodeUtilsV.PtrInNode(node' i);                                     break;                                 }                                  break;                             }                     }
Missing Default,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,EraseRangeFromNode,The following switch statement is missing a default case: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             for (var i = 0; i < header._childCount; i++)                             {                                 if (i == leftPos)                                 {                                     if (leftNode != IntPtr.Zero)                                         pusher.PushPtr(leftByte' leftNode);                                     i = rightPos;                                     if (rightNode != IntPtr.Zero)                                     {                                         pusher.PushPtr(rightByte' rightNode);                                     }                                      continue;                                 }                                  pusher.Push(TreeNodeUtils.ReadByte(node + 16 + i)' NodeUtilsV.PtrInNode(node' i));                             }                              break;                         }                     case NodeTypeV.Node48:                         {                             unsafe                             {                                 var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                                 for (var i = 0; i < 256; i++)                                 {                                     var idx = bytePtrs[i];                                     if (idx == 255) continue;                                     if (i == leftByte)                                     {                                         if (leftNode != IntPtr.Zero)                                             pusher.PushPtr(leftByte' leftNode);                                         i = rightByte;                                         if (rightNode != IntPtr.Zero)                                         {                                             pusher.PushPtr(rightByte' rightNode);                                         }                                          continue;                                     }                                      pusher.Push((byte)i' NodeUtilsV.PtrInNode(node' idx));                                 }                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             for (var i = 0; i < 256; i++)                             {                                 if (i == leftByte)                                 {                                     if (leftNode != IntPtr.Zero)                                         pusher.PushPtr(leftByte' leftNode);                                     i = rightByte;                                     if (rightNode != IntPtr.Zero)                                     {                                         pusher.PushPtr(rightByte' rightNode);                                     }                                      continue;                                 }                                  if (IsPtr(NodeUtilsV.PtrInNode(node' i)' out var j))                                 {                                     if (j == IntPtr.Zero)                                         continue;                                 }                                  pusher.Push((byte)i' NodeUtilsV.PtrInNode(node' i));                             }                              break;                         }                 }
Missing Default,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,CalcIndex,The following switch statement is missing a default case: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             var ptrInNode = stackItem._node + 16 + 4;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node16:                         {                             var ptrInNode = stackItem._node + 16 + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' stackItem._byte);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 var ptrInNode = stackItem._node + 16 + 256 + span[j] * 8;                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         {                             var ptrInNode = stackItem._node + 16;                             var limit = ptrInNode + stackItem._posInNode * 8;                             for (; ptrInNode != limit; ptrInNode += 8)                             {                                 var child = NodeUtilsV.ReadPtr(ptrInNode);                                 if (child == IntPtr.Zero)                                     continue;                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     res += (long)NodeUtilsV.Ptr2NodeHeader(child)._recursiveChildCount;                                 }                                 else                                 {                                     res++;                                 }                             }                         }                         break;                 }
Missing Default,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,SeekIndex,The following switch statement is missing a default case: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         for (int j = 0; j < header._childCount; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' TreeNodeUtils.ReadByte(top + 16 + j));                                     return true;                                 }                                  index--;                             }                         }                          break;                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; j < span.Length; j++)                             {                                 if (span[j] == 255)                                     continue;                                 if (IsPtr(NodeUtilsV.PtrInNode(top' span[j])' out var ptr))                                 {                                     var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                     if (index < rcc)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         top = ptr;                                         break;                                     }                                      index -= rcc;                                 }                                 else                                 {                                     if (index == 0)                                     {                                         stack.AddRef().Set(top' keyOffset' span[j]' (byte)j);                                         return true;                                     }                                      index--;                                 }                             }                         }                          break;                     case NodeTypeV.Node256:                         for (int j = 0; j < 256; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                     continue;                                 var rcc = (long)NodeUtilsV.Ptr2NodeHeader(ptr)._recursiveChildCount;                                 if (index < rcc)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  index -= rcc;                             }                             else                             {                                 if (index == 0)                                 {                                     stack.AddRef().Set(top' keyOffset' (short)j' (byte)j);                                     return true;                                 }                                  index--;                             }                         }                          break;                 }
Missing Default,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,MoveNext,The following switch statement is missing a default case: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.NodeLeaf:                         goto up;                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (stackItem._posInNode == header._childCount - 1)                             {                                 goto up;                             }                              stackItem._posInNode++;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeTypeV.Node256:                         for (int j = (stackItem._posInNode == -1) ? 0 : (stackItem._byte + 1); j < 256; j++)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                                  stackItem._posInNode = (short)j;                                 stackItem._byte = (byte)j;                                 PushLeftMost(ptr2' (int)stackItem._keyOffset' ref stack);                                 return true;                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             return true;                         }                          goto up;                 }
Missing Default,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,MovePrevious,The following switch statement is missing a default case: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             if (stackItem._posInNode == 0)                             {                                 goto up;                             }                              stackItem._posInNode--;                             stackItem._byte = TreeNodeUtils.ReadByte(stackItem._node + 16 + stackItem._posInNode);                             goto down;                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((stackItem._node + 16).ToPointer()' 256);                             for (int j = stackItem._byte - 1; j >= 0; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stackItem._posInNode = span[j];                                 stackItem._byte = (byte)j;                                 goto down;                             }                              goto up;                         }                     case NodeTypeV.Node256:                         for (int j = stackItem._byte - 1; j >= 0; j--)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(stackItem._node' j)' out var ptr2))                             {                                 if (ptr2 == IntPtr.Zero)                                 {                                     continue;                                 }                             }                              stackItem._posInNode = (short)j;                             stackItem._byte = (byte)j;                             goto down;                         }                          goto up;                 }
Missing Default,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,FindNearPosAndByte,The following switch statement is missing a default case: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         pos = ~pos;                         if (pos >= header._childCount) pos--;                         return ((short)pos' TreeNodeUtils.ReadByte(node + 16 + pos));                     }                 case NodeTypeV.Node48:                     {                         var bytePtrs = new Span<byte>((node + 16).ToPointer()' 256);                         pos = @byte + 1;                         while (pos < 256)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos++;                         }                          pos = @byte - 1;                         while (true)                         {                             if (bytePtrs[pos] != 255)                             {                                 return (bytePtrs[pos]' (byte)pos);                             }                              pos--;                         }                     }                 case NodeTypeV.Node256:                     {                         pos = @byte + 1;                         while (pos < 256)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos++;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          pos = @byte - 1;                         while (pos >= 0)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(node' pos)' out var ptr))                             {                                 if (ptr == IntPtr.Zero)                                 {                                     pos--;                                     continue;                                 }                             }                              return ((short)pos' (byte)pos);                         }                          break;                     }             }
Missing Default,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushLeftMost,The following switch statement is missing a default case: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 4);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node16:                         {                             stack.AddRef().Set(top' (uint)keyOffset' 0' TreeNodeUtils.ReadByte(top + 16));                             var child = NodeUtilsV.ReadPtr(top + 16 + 16);                             if (NodeUtilsV.IsPtrPtr(child))                             {                                 top = child;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 0; true; j++)                             {                                 var pos = span[j];                                 if (pos == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' pos' (byte)j);                                 var child = NodeUtilsV.ReadPtr(top + 16 + 256 + pos * 8);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     top = child;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         {                             var p = top + 16;                             for (var j = 0; true; j++' p += 8)                             {                                 var child = NodeUtilsV.ReadPtr(p);                                 if (NodeUtilsV.IsPtrPtr(child))                                 {                                     if (child != IntPtr.Zero)                                     {                                         stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                         top = child;                                         break;                                     }                                      continue;                                 }                                 else                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     return;                                 }                             }                         }                         break;                 }
Missing Default,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,PushRightMost,The following switch statement is missing a default case: switch (header._nodeType & NodeTypeV.NodeSizeMask)                 {                     case NodeTypeV.Node4:                     case NodeTypeV.Node16:                         {                             var pos = header._childCount - 1;                             stack.AddRef().Set(top' (uint)keyOffset' (short)pos' TreeNodeUtils.ReadByte(top + 16 + pos));                             if (IsPtr(NodeUtilsV.PtrInNode(top' pos)' out var ptr))                             {                                 top = ptr;                                 break;                             }                             else                             {                                 return;                             }                         }                     case NodeTypeV.Node48:                         unsafe                         {                             var span = new Span<byte>((top + 16).ToPointer()' 256);                             for (int j = 255; true; j--)                             {                                 if (span[j] == 255)                                     continue;                                 stack.AddRef().Set(top' (uint)keyOffset' span[j]' (byte)j);                                 if (IsPtr(NodeUtilsV.PtrInNode(top' span[j])' out var ptr))                                 {                                     top = ptr;                                     break;                                 }                                  return;                             }                              break;                         }                     case NodeTypeV.Node256:                         for (int j = 255; true; j--)                         {                             if (IsPtr(NodeUtilsV.PtrInNode(top' j)' out var ptr))                             {                                 if (ptr != IntPtr.Zero)                                 {                                     stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                     top = ptr;                                     break;                                 }                                  continue;                             }                             else                             {                                 stack.AddRef().Set(top' (uint)keyOffset' (short)j' (byte)j);                                 return;                             }                         }                          break;                 }
Missing Default,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,StructureCheck,The following switch statement is missing a default case: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     childrenCount = 1;                     break;                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' pos)' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeTypeV.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         StructureCheck48(span' header.ChildCount);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' span[j])' out var ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 childrenCount += StructureCheck(ptr);                             }                             else                             {                                 childrenCount++;                             }                         }                          break;                     }                 case NodeTypeV.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' j)' out var ptr))                         {                             childrenCount += StructureCheck(ptr);                         }                         else                         {                             childrenCount++;                         }                     }                      break;             }
Missing Default,BTDB.ARTLib,ARTImplV,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\ARTLib\ARTImplV.cs,IterateNodeInfo,The following switch statement is missing a default case: switch (header._nodeType & NodeTypeV.NodeSizeMask)             {                 case NodeTypeV.NodeLeaf:                     break;                 case NodeTypeV.Node4:                 case NodeTypeV.Node16:                     {                         for (var pos = 0; pos < header._childCount; pos++)                         {                             var b = TreeNodeUtils.ReadByte(nodePtr + 16 + pos);                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' pos)' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeTypeV.Node48:                     unsafe                     {                         var span = new Span<byte>((nodePtr + 16).ToPointer()' 256);                         for (int j = 0; j < 256; j++)                         {                             if (span[j] == 255)                                 continue;                             if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' span[j])' out ptr))                             {                                 Debug.Assert(ptr != IntPtr.Zero);                                 IterateNodeInfo(ptr' deepness + 1' iterator);                             }                         }                         break;                     }                 case NodeTypeV.Node256:                     for (int j = 0; j < 256; j++)                     {                         if (IsPtr(NodeUtilsV.PtrInNode(nodePtr' j)' out ptr))                         {                             IterateNodeInfo(ptr' deepness + 1' iterator);                         }                     }                     break;             }
Missing Default,BTDB.SnappyCompression,SnappyDecompress,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following switch statement is missing a default case: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                          if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         src.Slice(s' len).CopyTo(dst.AsSpan(d));                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Missing Default,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following switch statement is missing a default case: switch (header >> 5 & 3)             {                 case 0:                     break;                 case 1:                     first = ReadVUInt64();                     break;                 case 2:                     second = ReadVUInt32();                     first = (ulong) ReadInt64();                     break;                 case 3:                     second = (uint) ReadInt32();                     first = (ulong) ReadInt64();                     break;             }
Missing Default,BTDB.StreamLayer,AbstractBufferedReader,D:\research\architectureSmells\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipDecimal,The following switch statement is missing a default case: switch (header >> 5 & 3)             {                 case 0:                     break;                 case 1:                     SkipVUInt64();                     break;                 case 2:                     SkipVUInt32();                     SkipInt64();                     break;                 case 3:                     SkipInt32();                     SkipInt64();                     break;             }
