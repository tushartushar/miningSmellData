Implementation smell,Namespace,Class,File,Method,Description
Long Method,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The method has 139 lines of code.
Long Method,BTDB.EventStoreLayer,DictionaryTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateSave,The method has 101 lines of code.
Long Method,BTDB.EventStoreLayer,ReadOnlyEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The method has 152 lines of code.
Long Method,BTDB.KVDBLayer.BTree,BTreeBranch,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,CreateOrUpdate,The method has 114 lines of code.
Long Method,BTDB.KVDBLayer.BTree,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,CreateOrUpdate,The method has 141 lines of code.
Long Method,BTDB.KVDBLayer.BTreeMem,BTreeBranch,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,CreateOrUpdate,The method has 114 lines of code.
Long Method,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,The method has 131 lines of code.
Long Method,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadTransactionLog,The method has 169 lines of code.
Long Method,BTDB.ODBLayer,ODBIterator,C:\repos\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,IterateHandler,The method has 154 lines of code.
Long Method,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The method has 142 lines of code.
Long Method,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The method has 274 lines of code.
Complex Method,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,IncrementInt64LE,Cyclomatic complexity of the method is 8
Complex Method,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,Cyclomatic complexity of the method is 9
Complex Method,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,Cyclomatic complexity of the method is 8
Complex Method,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,Cyclomatic complexity of the method is 9
Complex Method,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,Cyclomatic complexity of the method is 9
Complex Method,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,Cyclomatic complexity of the method is 8
Complex Method,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,Cyclomatic complexity of the method is 8
Complex Method,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,Cyclomatic complexity of the method is 9
Complex Method,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,Cyclomatic complexity of the method is 15
Complex Method,BTDB.ChunkCache,DiskChunkCache,C:\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,LoadContent,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ChunkCache,DiskChunkCache,C:\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,CompactionCore,Cyclomatic complexity of the method is 11
Complex Method,BTDB.EventStore2Layer,EventDeserializer,C:\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventDeserializer.cs,ProcessMetadataLog,Cyclomatic complexity of the method is 12
Complex Method,BTDB.EventStore2Layer,EventSerializer,C:\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,ProcessMetadataLog,Cyclomatic complexity of the method is 12
Complex Method,BTDB.EventStore2Layer,EventSerializer,C:\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,Create,Cyclomatic complexity of the method is 13
Complex Method,BTDB.EventStore2Layer,EventSerializer,C:\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,MergeTypesByShapeAndStoreNew,Cyclomatic complexity of the method is 9
Complex Method,BTDB.EventStore2Layer,EventSerializer,C:\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,StoreObject,Cyclomatic complexity of the method is 8
Complex Method,BTDB.EventStoreLayer,AppendingEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,SerializeIntoBuffer,Cyclomatic complexity of the method is 11
Complex Method,BTDB.EventStoreLayer,EnumTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,UlongValueToStringFlags,Cyclomatic complexity of the method is 8
Complex Method,BTDB.EventStoreLayer,ObjectTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,CheckObjectTypeIsGoodDTO,Cyclomatic complexity of the method is 9
Complex Method,BTDB.EventStoreLayer,ObjectTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,BTDB.EventStoreLayer,ReadOnlyEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,Cyclomatic complexity of the method is 25
Complex Method,BTDB.EventStoreLayer,BuildFromTypeCtx,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,Create,Cyclomatic complexity of the method is 8
Complex Method,BTDB.EventStoreLayer,TypeSerializersMapping,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializersMapping.cs,LoadTypeDescriptors,Cyclomatic complexity of the method is 9
Complex Method,BTDB.EventStoreLayer,TypeSerializersMapping,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializersMapping.cs,StoreNewDescriptors,Cyclomatic complexity of the method is 9
Complex Method,BTDB.FieldHandler,DefaultFieldHandlerFactory,C:\repos\Bobris_BTDB\BTDB\FieldHandler\DefaultFieldHandlerFactory.cs,CreateFromName,Cyclomatic complexity of the method is 9
Complex Method,BTDB.IL,EmitHelpers,C:\repos\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,ToSimpleName,Cyclomatic complexity of the method is 22
Complex Method,BTDB.IOC,BuildContext,C:\repos\Bobris_BTDB\BTDB\IOC\BuildContext.cs,ResolveNeedBy,Cyclomatic complexity of the method is 8
Complex Method,BTDB.IOC,GenerationContext,C:\repos\Bobris_BTDB\BTDB\IOC\GenerationContext.cs,PushToILStack,Cyclomatic complexity of the method is 8
Complex Method,BTDB.IOC,GenerationContext,C:\repos\Bobris_BTDB\BTDB\IOC\GenerationContext.cs,GatherNeeds,Cyclomatic complexity of the method is 10
Complex Method,BTDB.IOC,MultiRegistration,C:\repos\Bobris_BTDB\BTDB\IOC\MultiRegistration.cs,Register,Cyclomatic complexity of the method is 9
Complex Method,BTDB.KVDBLayer.BTree,BTreeBranch,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,CreateOrUpdate,Cyclomatic complexity of the method is 13
Complex Method,BTDB.KVDBLayer.BTree,BTreeBranch,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,EraseRange,Cyclomatic complexity of the method is 16
Complex Method,BTDB.KVDBLayer.BTree,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,CreateOrUpdate,Cyclomatic complexity of the method is 8
Complex Method,BTDB.KVDBLayer.BTreeMem,BTreeBranch,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,CreateOrUpdate,Cyclomatic complexity of the method is 13
Complex Method,BTDB.KVDBLayer.BTreeMem,BTreeBranch,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,EraseRange,Cyclomatic complexity of the method is 16
Complex Method,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,Cyclomatic complexity of the method is 8
Complex Method,BTDB.KVDBLayer,Compactor,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,Run,Cyclomatic complexity of the method is 13
Complex Method,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadInfoAboutFiles,Cyclomatic complexity of the method is 15
Complex Method,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadTransactionLog,Cyclomatic complexity of the method is 8
Complex Method,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,WriteCreateOrUpdateCommand,Cyclomatic complexity of the method is 8
Complex Method,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,Cyclomatic complexity of the method is 8
Complex Method,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,Cyclomatic complexity of the method is 20
Complex Method,BTDB.KVDBLayer,PtrLenList,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryInclude,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ODBLayer,ODBIterator,C:\repos\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,Iterate,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ODBLayer,ODBIterator,C:\repos\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,IterateRelation,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ODBLayer,ODBIterator,C:\repos\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,IterateDict,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateVersionInfoByReflection,Cyclomatic complexity of the method is 11
Complex Method,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateLoader,Cyclomatic complexity of the method is 13
Complex Method,BTDB.ODBLayer,RelationVersionInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationVersionInfo.cs,CreateSecondaryKeyInfo,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ODBLayer,RelationVersionInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationVersionInfo.cs,Equal,Cyclomatic complexity of the method is 11
Complex Method,BTDB.ODBLayer,TableFieldInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableFieldInfo.cs,Equal,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ODBLayer,ObjectDBTransaction,C:\repos\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,Enumerate,Cyclomatic complexity of the method is 11
Complex Method,BTDB.ODBLayer,ObjectDBTransaction,C:\repos\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,Delete,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ODBLayer,ObjectDBTransaction,C:\repos\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,Delete,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateInitializer,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,Cyclomatic complexity of the method is 13
Complex Method,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,Cyclomatic complexity of the method is 10
Complex Method,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,Cyclomatic complexity of the method is 20
Complex Method,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibility,Cyclomatic complexity of the method is 11
Complex Method,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibilityIgnoringName,Cyclomatic complexity of the method is 20
Complex Method,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,WriteObjectForServer,Cyclomatic complexity of the method is 8
Complex Method,BTDB.Service,Client,C:\repos\Bobris_BTDB\BTDB\Service\TcpipServer.cs,ReceiveBody,Cyclomatic complexity of the method is 8
Complex Method,BTDB.Service,TypeInf,C:\repos\Bobris_BTDB\BTDB\Service\TypeInf.cs,IsMethodSupported,Cyclomatic complexity of the method is 8
Complex Method,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,Cyclomatic complexity of the method is 15
Complex Method,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,Cyclomatic complexity of the method is 11
Complex Method,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadString,Cyclomatic complexity of the method is 9
Long Parameter List,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,CompareByteArray,The method has 6 parameters. Parameters: a1' o1' l1' a2' o2' l2
Long Parameter List,BTDB.EventStore2Layer,PlaceHolderDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStore2Layer\PlaceHolderDescriptor.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushCtx' pushDescriptor' targetType
Long Parameter List,BTDB.EventStore2Layer,PlaceHolderDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStore2Layer\PlaceHolderDescriptor.cs,GenerateSave,The method has 5 parameters. Parameters: ilGenerator' pushWriter' pushCtx' pushValue' valueType
Long Parameter List,BTDB.EventStoreLayer,AppendingEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,SerializeIntoBuffer,The method has 7 parameters. Parameters: metadata' events' startOffset' serializerContext' blockType' lenWithoutEndPadding' block
Long Parameter List,BTDB.EventStoreLayer,ByteArrayTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ByteArrayTypeDescriptor.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushCtx' pushDescriptor' targetType
Long Parameter List,BTDB.EventStoreLayer,ByteArrayTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ByteArrayTypeDescriptor.cs,GenerateSave,The method has 5 parameters. Parameters: ilGenerator' pushWriter' pushCtx' pushValue' valueType
Long Parameter List,BTDB.EventStoreLayer,DictionaryTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushCtx' pushDescriptor' targetType
Long Parameter List,BTDB.EventStoreLayer,DictionaryTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateSave,The method has 5 parameters. Parameters: ilGenerator' pushWriter' pushCtx' pushValue' saveType
Long Parameter List,BTDB.EventStoreLayer,EnumTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,EnumTypeDescriptor,The method has 6 parameters. Parameters: typeSerializers' type' name' signed' flags' pairs
Long Parameter List,BTDB.EventStoreLayer,EnumTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushCtx' pushDescriptor' targetType
Long Parameter List,BTDB.EventStoreLayer,EnumTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,GenerateSave,The method has 5 parameters. Parameters: ilGenerator' pushWriter' pushCtx' pushValue' valueType
Long Parameter List,BTDB.EventStoreLayer,ListTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushCtx' pushDescriptor' targetType
Long Parameter List,BTDB.EventStoreLayer,ListTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateSave,The method has 5 parameters. Parameters: ilGenerator' pushWriter' pushCtx' pushValue' valueType
Long Parameter List,BTDB.EventStoreLayer,NullableTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\NullableTypeDescriptor.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushCtx' pushDescriptor' targetType
Long Parameter List,BTDB.EventStoreLayer,NullableTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\NullableTypeDescriptor.cs,GenerateSave,The method has 5 parameters. Parameters: ilGenerator' pushWriter' pushCtx' pushValue' valueType
Long Parameter List,BTDB.EventStoreLayer,TypeDescriptorExtensions,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeDescriptorExtensions.cs,GenerateSaveEx,The method has 6 parameters. Parameters: descriptor' ilGenerator' pushWriter' pushCtx' pushSubValue' subValueType
Long Parameter List,BTDB.EventStoreLayer,TypeDescriptorExtensions,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeDescriptorExtensions.cs,GenerateLoadEx,The method has 7 parameters. Parameters: descriptor' ilGenerator' pushReader' pushCtx' pushDescriptor' asType' convertorGenerator
Long Parameter List,BTDB.EventStoreLayer,ITypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ITypeDescriptor.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushCtx' pushDescriptor' targetType
Long Parameter List,BTDB.EventStoreLayer,ITypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ITypeDescriptor.cs,GenerateSave,The method has 5 parameters. Parameters: ilGenerator' pushWriter' pushCtx' pushValue' valueType
Long Parameter List,BTDB.EventStoreLayer,ObjectTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushCtx' pushDescriptor' targetType
Long Parameter List,BTDB.EventStoreLayer,ObjectTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,GenerateSave,The method has 5 parameters. Parameters: ilGenerator' pushWriter' pushCtx' pushValue' valueType
Long Parameter List,BTDB.EventStoreLayer,SimpleTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\SimpleTypeDescriptor.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushCtx' pushDescriptor' targetType
Long Parameter List,BTDB.EventStoreLayer,SimpleTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\SimpleTypeDescriptor.cs,GenerateSave,The method has 5 parameters. Parameters: ilGenerator' pushWriter' pushCtx' pushValue' valueType
Long Parameter List,BTDB.EventStoreLayer,TypeSerializersMapping,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializersMapping.cs,StoreObjectCore,The method has 5 parameters. Parameters: typeSerializers' writer' obj' infoForType' mapping
Long Parameter List,BTDB.EventStoreLayer,PlaceHolderDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializersMapping.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushCtx' pushDescriptor' targetType
Long Parameter List,BTDB.EventStoreLayer,PlaceHolderDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializersMapping.cs,GenerateSave,The method has 5 parameters. Parameters: ilGenerator' pushWriter' pushCtx' pushValue' valueType
Long Parameter List,BTDB.FieldHandler,BasicSerializersFactory,C:\repos\Bobris_BTDB\BTDB\FieldHandler\BasicSerializersFactory.cs,AddJustOrderable,The method has 5 parameters. Parameters: fh' name' readMethodInfo' skipMethodInfo' writeMethodInfo
Long Parameter List,BTDB.FieldHandler,BasicSerializersFactory,C:\repos\Bobris_BTDB\BTDB\FieldHandler\BasicSerializersFactory.cs,AddDescriptor,The method has 5 parameters. Parameters: des' name' readMethodInfo' skipMethodInfo' writeMethodInfo
Long Parameter List,BTDB.FieldHandler,BasicSerializersFactory,C:\repos\Bobris_BTDB\BTDB\FieldHandler\BasicSerializersFactory.cs,Add,The method has 6 parameters. Parameters: fh' des' name' readMethodInfo' skipMethodInfo' writeMethodInfo
Long Parameter List,BTDB.FieldHandler,DictionaryFieldHandler,C:\repos\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,DictionaryFieldHandler,The method has 5 parameters. Parameters: fieldHandlerFactory' typeConvertorGenerator' type' keySpecialized' valueSpecialized
Long Parameter List,BTDB.FieldHandler,Extensions,C:\repos\Bobris_BTDB\BTDB\FieldHandler\Extensions.cs,GenerateLoad,The method has 5 parameters. Parameters: ilGenerator' fieldHandler' typeWanted' pushReaderOrCtx' typeConvertorGenerator
Long Parameter List,BTDB.IL.Caching,Method,C:\repos\Bobris_BTDB\BTDB\IL\Caching\CachingILDynamicType.cs,Method,The method has 5 parameters. Parameters: id' name' returns' parameters' methodAttributes
Long Parameter List,BTDB.IL,ILDynamicTypeDebugImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILDynamicTypeDebugImpl.cs,AddNameShorteningSection,The method has 5 parameters. Parameters: name' sections' pos' sectionEnd' sb
Long Parameter List,BTDB.IL,ILMethodDebugImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILMethodDebugImpl.cs,ILMethodDebugImpl,The method has 6 parameters. Parameters: method' sourceCodeWriter' name' returnType' parameters' forbidenInstructions
Long Parameter List,BTDB.IL,EmitHelpers,C:\repos\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateJumpIfEqual,The method has 5 parameters. Parameters: ilGenerator' type' jumpTo' loadLeft' loadRight
Long Parameter List,BTDB.IOC.CRegs,EnumerableImpl,C:\repos\Bobris_BTDB\BTDB\IOC\CRegs\EnumerableImpl.cs,EnumerableImpl,The method has 5 parameters. Parameters: key' type' resultType' firstBuildCtx' firstReg
Long Parameter List,BTDB.KVDBLayer,FileKeyIndex,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\FileKeyIndex.cs,FileKeyIndex,The method has 5 parameters. Parameters: reader' guid' withCommitUlong' modern' withUlongs
Long Parameter List,BTDB.KVDBLayer,FileKeyIndex,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\FileKeyIndex.cs,FileKeyIndex,The method has 8 parameters. Parameters: generation' guid' trLogFileId' trLogOffset' keyCount' commitUlong' compression' ulongs
Long Parameter List,BTDB.KVDBLayer,File,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\OnDiskMemoryMappedFileCollection.cs,RandomRead,The method has 5 parameters. Parameters: data' offset' size' position' doNotCache
Long Parameter List,BTDB.KVDBLayer,File,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\OnDiskMemoryMappedFileCollection.cs,RandomRead,The method has 5 parameters. Parameters: data' offset' size' position' doNotCache
Long Parameter List,BTDB.KVDBLayer,File,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\OnDiskMemoryMappedFileCollection.cs,RandomRead,The method has 5 parameters. Parameters: data' offset' size' position' doNotCache
Long Parameter List,BTDB.KVDBLayer,IFileCollectionFile,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Interface\IFileCollectionFile.cs,RandomRead,The method has 5 parameters. Parameters: data' offset' size' position' doNotCache
Long Parameter List,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,WriteCreateOrUpdateCommand,The method has 6 parameters. Parameters: prefix' key' value' valueFileId' valueOfs' valueSize
Long Parameter List,BTDB.ODBLayer,ConcurrentDictionaryExtensions,C:\repos\Bobris_BTDB\BTDB\ODBLayer\ConcurrentDictionaryExtensions.cs,GetOrAdd,The method has 5 parameters. Parameters: dictionary' key' valueFactory' arg1' arg2
Long Parameter List,BTDB.ODBLayer,ConcurrentDictionaryExtensions,C:\repos\Bobris_BTDB\BTDB\ODBLayer\ConcurrentDictionaryExtensions.cs,GetOrAdd,The method has 6 parameters. Parameters: dictionary' key' valueFactory' arg1' arg2' arg3
Long Parameter List,BTDB.ODBLayer,AdvancedEnumeratorParam<TKey>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\IOrderedDictionary.cs,AdvancedEnumeratorParam,The method has 5 parameters. Parameters: order' start' startProposition' end' endProposition
Long Parameter List,BTDB.ODBLayer,ODBDictionaryFieldHandler,C:\repos\Bobris_BTDB\BTDB\ODBLayer\ODBDictionaryFieldHandler.cs,ODBDictionaryFieldHandler,The method has 5 parameters. Parameters: odb' configuration' configurationId' specializedKeyHandler' specializedValueHandler
Long Parameter List,BTDB.ODBLayer,RelationBuilder<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodFindById,The method has 8 parameters. Parameters: ilGenerator' relationDBManipulatorType' methodName' methodParameters' methodReturnType' apartFields' pushWriter' writerLoc
Long Parameter List,BTDB.ODBLayer,RelationBuilder<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodFindBy,The method has 8 parameters. Parameters: ilGenerator' relationDBManipulatorType' methodName' methodParameters' methodReturnType' apartFields' pushWriter' writerLoc
Long Parameter List,BTDB.ODBLayer,RelationBuilder<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,SaveMethodParameters,The method has 7 parameters. Parameters: ilGenerator' methodName' methodParameters' paramCount' apartFields' fields' writerLoc
Long Parameter List,BTDB.ODBLayer,RelationBuilder<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,FillBufferWhenNotIgnoredKeyPropositionIl,The method has 5 parameters. Parameters: advEnumParamOrder' field' emptyBufferLoc' instField' ilGenerator
Long Parameter List,BTDB.ODBLayer,RelationBuilder<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,SaveListPrefixBytes,The method has 5 parameters. Parameters: secondaryKeyIndex' ilGenerator' methodName' methodParameters' apartFields
Long Parameter List,BTDB.ODBLayer,RelationBuilder<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,SaveKeyFieldFromArgument,The method has 5 parameters. Parameters: ilGenerator' field' parameterId' parameterType' writerLoc
Long Parameter List,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,RelationInfo,The method has 5 parameters. Parameters: id' name' relationInfoResolver' interfaceType' tr
Long Parameter List,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateSaverIl,The method has 6 parameters. Parameters: ilGen' fields' pushInstance' pushRelationIface' pushWriter' pushTransaction
Long Parameter List,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CopyToOutput,The method has 6 parameters. Parameters: ilGenerator' valueHandler' writerCtxLocal' pushWriter' skHandler' buffer
Long Parameter List,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,StoreIntoLocal,The method has 6 parameters. Parameters: ilGenerator' valueHandler' bufferInfo' outOfOrderSkParts' skFieldIdx' skFieldHandler
Long Parameter List,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CopyFromBuffer,The method has 10 parameters. Parameters: ilGenerator' bufferIdx' skFieldIdx' bi' outOfOrderPKParts' pks' skFields' positionLoc' memoPositionLoc' pushWriter
Long Parameter List,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,FindPosition,The method has 5 parameters. Parameters: pkIdx' skFields' paramFieldCountInFirstBuffer' bufferIdx' skFieldIdx
Long Parameter List,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,SkipWithMemorizing,The method has 5 parameters. Parameters: activeBuffer' ilGenerator' pushReader' handler' tempPosition
Long Parameter List,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CopyFromMemorizedPosition,The method has 5 parameters. Parameters: ilGenerator' pushReader' pushWriter' memo' memoPositionLoc
Long Parameter List,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,GenerateCopyFieldFromByteBufferToWriterIl,The method has 6 parameters. Parameters: ilGenerator' handler' pushReader' pushWriter' positionLoc' memoPositionLoc
Long Parameter List,BTDB.ODBLayer,RelationSecondaryKeyEnumerator<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,RelationSecondaryKeyEnumerator,The method has 6 parameters. Parameters: tr' relationInfo' keyBytes' secondaryKeyIndex' fieldCountInKey' manipulator
Long Parameter List,BTDB.ODBLayer,RelationAdvancedEnumerator<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,RelationAdvancedEnumerator,The method has 8 parameters. Parameters: manipulator' prefixBytes' prefixFieldCount' order' startKeyProposition' startKeyBytes' endKeyProposition' endKeyBytes
Long Parameter List,BTDB.ODBLayer,RelationAdvancedSecondaryKeyEnumerator<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,RelationAdvancedSecondaryKeyEnumerator,The method has 9 parameters. Parameters: manipulator' prefixBytes' prefixFieldCount' order' startKeyProposition' startKeyBytes' endKeyProposition' endKeyBytes' secondaryKeyIndex
Long Parameter List,BTDB.ODBLayer,RelationAdvancedOrderedEnumerator<TKey;TValue>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,RelationAdvancedOrderedEnumerator,The method has 9 parameters. Parameters: manipulator' prefixBytes' prefixFieldCount' order' startKeyProposition' startKeyBytes' endKeyProposition' endKeyBytes' initKeyReader
Long Parameter List,BTDB.ODBLayer,RelationAdvancedOrderedSecondaryKeyEnumerator<TKey;TValue>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,RelationAdvancedOrderedSecondaryKeyEnumerator,The method has 9 parameters. Parameters: manipulator' prefixBytes' prefixFieldCount' order' startKeyProposition' startKeyBytes' endKeyProposition' endKeyBytes' secondaryKeyIndex
Long Parameter List,BTDB.ODBLayer,RelationVersionInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationVersionInfo.cs,RelationVersionInfo,The method has 5 parameters. Parameters: primaryKeyFields' secondaryKeys' secondaryKeyFields' fields' prevVersion
Long Parameter List,BTDB.ODBLayer,RelationVersionInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationVersionInfo.cs,RelationVersionInfo,The method has 5 parameters. Parameters: primaryKeyFields' secondaryKeys' secondaryKeysNames' secondaryKeyFields' fields
Long Parameter List,BTDB.ODBLayer,UnresolvedTableFieldInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableFieldInfo.cs,UnresolvedTableFieldInfo,The method has 5 parameters. Parameters: name' handlerName' configuration' tableName' handlerOptions
Long Parameter List,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,GenerateOneFieldHandlerSave,The method has 5 parameters. Parameters: loadInput' fieldHandler' inputType' ilGenerator' pushWriterOrCtx
Long Parameter List,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The method has 6 parameters. Parameters: dst' d' dL' src' s' sL
Long Parameter List,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The method has 5 parameters. Parameters: dst' d' dL' offset' length
Long Identifier,BTDB.EventStoreLayer,TypeSerializers,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,,The length of the parameter _newDescriptorSaverFactoryAction is 32.
Long Identifier,BTDB.IL,EmitHelpers,C:\repos\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateAddRemoveEvent,The length of the parameter typePropertyChangedEventHandler is 31.
Long Identifier,BTDB.KVDBLayer,Compactor,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,Run,The length of the parameter dontTouchGenerationDueToPreserve is 32.
Long Identifier,BTDB.KVDBLayer,FileTransactionLog,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\FileTransactionLog.cs,FileTransactionLog,The length of the parameter fileIdWithPreviousTransactionLog is 32.
Long Identifier,BTDB.KVDBLayer,KeyValueDBOptions,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,,The length of the parameter PreserveHistoryUpToCommitUlong is 30.
Long Identifier,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,CalculatePreserveKeyIndexKeyFromKeyIndexInfos,The length of the parameter preserveHistoryUpToCommitUlong is 30.
Long Identifier,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,RevertWrittingTransaction,The length of the parameter nothingWrittenToTransactionLog is 30.
Long Identifier,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,,The length of the parameter _preserveHistoryUpToCommitUlong is 31.
Long Identifier,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,,The length of the parameter _fileIdWithPreviousTransactionLog is 33.
Long Identifier,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,,The length of the parameter _freeContentNeedDetectionInProgress is 35.
Long Identifier,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,RegisterLocalTypeInternalUnlocked,The length of the parameter iFieldHandlerWithNestedFieldHandlers is 36.
Long Statement,BTDB.Buffer,ByteBuffer,C:\repos\Bobris_BTDB\BTDB\Buffer\ByteBuffer.cs,SubBuffer,The length of the statement  "            return AsyncSafe ? NewAsync(Buffer' Offset + offset' Length - offset) : NewSync(Buffer' Offset + offset' Length - offset);" is 122.
Long Statement,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The length of the statement  "            result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)" is 126.
Long Statement,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "                    result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];" is 127.
Long Statement,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "                    result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];" is 157.
Long Statement,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "                    result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];" is 156.
Long Statement,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "                result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)" is 122.
Long Statement,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "                result = ((long)(first - 0x08) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];" is 127.
Long Statement,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "                result = ((long)(first - 0x04) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];" is 157.
Long Statement,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "                result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];" is 170.
Long Statement,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "            result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)" is 122.
Long Statement,BTDB.DtoChannel,Receiver,C:\repos\Bobris_BTDB\BTDB\DtoChannel\DtoChannel.cs,OnNext,The length of the statement  "                    _dtoChannel._onReceive.OnError(new InvalidDataException("Data received from other side must Start with byte 99 or 100"));" is 121.
Long Statement,BTDB.EventStore2Layer,EventDeserializer,C:\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventDeserializer.cs,LoaderFactory,The length of the statement  "            var methodBuilder = ILBuilder.Instance.NewMethod<Func<AbstractBufferedReader' ITypeBinaryDeserializerContext' ITypeDescriptor' object>>("DeserializerFor" + descriptor.Name);" is 173.
Long Statement,BTDB.EventStore2Layer,EventSerializer,C:\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,BuildComplexSaver,The length of the statement  "            var method = ILBuilder.Instance.NewMethod<Action<AbstractBufferedWriter' ITypeBinarySerializerContext' object>>(descriptor.Name + "Saver");" is 139.
Long Statement,BTDB.EventStore2Layer,EventSerializer,C:\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,BuildNestedObjGatherer,The length of the statement  "                var method = ILBuilder.Instance.NewMethod<Action<object' IDescriptorSerializerLiteContext>>("GatherAllObjectsForTypeExtraction_" + descriptor.Name);" is 148.
Long Statement,BTDB.EventStore2Layer,EventSerializer,C:\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,Create,The length of the statement  "                            if (_typeOrDescriptor2Info.TryGetValue(typeAlternative' out result)) { _typeOrDescriptor2Info[type] = result; return result.Descriptor; }" is 137.
Long Statement,BTDB.EventStore2Layer,EventSerializer,C:\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,Create,The length of the statement  "                            if (_typeOrDescriptor2InfoNew.TryGetValue(typeAlternative' out result)) { _typeOrDescriptor2InfoNew[type] = result; return result.Descriptor; }" is 143.
Long Statement,BTDB.EventStore2Layer,EventSerializer,C:\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,Create,The length of the statement  "                                if (_typeOrDescriptor2Info.TryGetValue(typeAlternative' out result)) { _typeOrDescriptor2Info[type] = result; return result.Descriptor; }" is 137.
Long Statement,BTDB.EventStore2Layer,EventSerializer,C:\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,Create,The length of the statement  "                                if (_typeOrDescriptor2InfoNew.TryGetValue(typeAlternative' out result)) { _typeOrDescriptor2InfoNew[type] = result; return result.Descriptor; }" is 143.
Long Statement,BTDB.EventStore2Layer,EventSerializer,C:\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,Create,The length of the statement  "                    if (_typeOrDescriptor2Info.TryGetValue(typeAlternative' out result)) { _typeOrDescriptor2Info[type] = result; return result.Descriptor; }" is 137.
Long Statement,BTDB.EventStore2Layer,EventSerializer,C:\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,Create,The length of the statement  "                    if (_typeOrDescriptor2InfoNew.TryGetValue(typeAlternative' out result)) { _typeOrDescriptor2InfoNew[type] = result; return result.Descriptor; }" is 143.
Long Statement,BTDB.EventStoreLayer,AppendingEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,Store,The length of the statement  "            SerializeIntoBuffer(metadata' events' out startOffset' out serializerContext' out blockType' out lenWithoutEndPadding' out block);" is 130.
Long Statement,BTDB.EventStoreLayer,AppendingEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,Store,The length of the statement  "                SerializeIntoBuffer(metadata' events' out startOffset' out serializerContext' out blockType' out lenWithoutEndPadding' out block);" is 130.
Long Statement,BTDB.EventStoreLayer,AppendingEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,KnownAppendablePosition,The length of the statement  "            if (!IsKnownAsAppendable()) throw new InvalidOperationException("IsKnownAsAppendable needs to return true before calling this method. Use ReadToEnd(new SkippingEventObserver()).Wait() to initialize.");" is 201.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateLoad,The length of the statement  "            _keyDescriptor.GenerateLoadEx(ilGenerator' pushReader' pushCtx' il => il.Do(pushDescriptor).LdcI4(0).Callvirt(() => default(ITypeDescriptor).NestedType(0))' keyType' _convertorGenerator);" is 187.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateLoad,The length of the statement  "            _valueDescriptor.GenerateLoadEx(ilGenerator' pushReader' pushCtx' il => il.Do(pushDescriptor).LdcI4(1).Callvirt(() => default(ITypeDescriptor).NestedType(0))' valueType' _convertorGenerator);" is 191.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateSave,The length of the statement  "                _keyDescriptor.GenerateSaveEx(ilGenerator' pushWriter' pushCtx' il => il.Ldloca(localPair).Call(typeKeyValuePair.GetProperty("Key").GetGetMethod())' keyType);" is 158.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateSave,The length of the statement  "                _valueDescriptor.GenerateSaveEx(ilGenerator' pushWriter' pushCtx' il => il.Ldloca(localPair).Call(typeKeyValuePair.GetProperty("Value").GetGetMethod())' valueType);" is 164.
Long Statement,BTDB.EventStoreLayer,ListTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateLoad,The length of the statement  "                _itemDescriptor.GenerateLoadEx(ilGenerator' pushReader' pushCtx' il => il.Do(pushDescriptor).LdcI4(0).Callvirt(() => default(ITypeDescriptor).NestedType(0))' itemType' _convertorGenerator);" is 189.
Long Statement,BTDB.EventStoreLayer,ListTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateLoad,The length of the statement  "                _itemDescriptor.GenerateLoadEx(ilGenerator' pushReader' pushCtx' il => il.Do(pushDescriptor).LdcI4(0).Callvirt(() => default(ITypeDescriptor).NestedType(0))' itemType' _convertorGenerator);" is 189.
Long Statement,BTDB.EventStoreLayer,NullableTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\NullableTypeDescriptor.cs,GenerateLoad,The length of the statement  "            _itemDescriptor.GenerateLoadEx(ilGenerator' pushReader' pushCtx' il => il.Do(pushDescriptor).LdcI4(0).Callvirt(() => default(ITypeDescriptor).NestedType(0))' itemType' _convertorGenerator);" is 189.
Long Statement,BTDB.EventStoreLayer,TypeDescriptorExtensions,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeDescriptorExtensions.cs,Describe,The length of the statement  "            descriptor.BuildHumanReadableFullName(sb' new HashSet<ITypeDescriptor>(ReferenceEqualityComparer<ITypeDescriptor>.Instance)' 0);" is 128.
Long Statement,BTDB.EventStoreLayer,ObjectTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,CheckObjectTypeIsGoodDTO,The length of the statement  "                    throw new InvalidOperationException("Trying to serialize type " + type.ToSimpleName() + " and property " + propertyInfo.Name + " does not have getter. If you don't want to serialize this property add [NotStored] attribute.");" is 225.
Long Statement,BTDB.EventStoreLayer,ObjectTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,CheckObjectTypeIsGoodDTO,The length of the statement  "                    throw new InvalidOperationException("Trying to serialize type " + type.ToSimpleName() + " and property " + propertyInfo.Name + " does not have setter. If you don't want to serialize this property add [NotStored] attribute.");" is 225.
Long Statement,BTDB.EventStoreLayer,ObjectTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,CheckObjectTypeIsGoodDTO,The length of the statement  "            foreach (var fieldInfo in _type.GetFields(System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance))" is 166.
Long Statement,BTDB.EventStoreLayer,ObjectTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,CheckObjectTypeIsGoodDTO,The length of the statement  "                throw new InvalidOperationException("Serialize type " + type.ToSimpleName() + " with nonprivate field " + fieldInfo.Name + " is forbidden without marking it with [NotStored] attribute");" is 186.
Long Statement,BTDB.EventStoreLayer,ObjectTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,GetPersitentName,The length of the statement  "            var a = propertyInfo.GetCustomAttributes(typeof(PersistedNameAttribute)' false).Cast<PersistedNameAttribute>().FirstOrDefault();" is 128.
Long Statement,BTDB.EventStoreLayer,ObjectTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,GenerateSave,The length of the statement  "                pair.Value.GenerateSaveEx(ilGenerator' pushWriter' pushCtx' il => il.Ldloc(locValue).Callvirt(methodInfo)' methodInfo.ReturnType);" is 130.
Long Statement,BTDB.EventStoreLayer,TypeSerializers,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,ForgotAllTypesAndSerializers,The length of the statement  "            _type2DescriptorMap = new ConcurrentDictionary<Type' ITypeDescriptor>(EnumDefaultTypes()' ReferenceEqualityComparer<Type>.Instance);" is 132.
Long Statement,BTDB.EventStoreLayer,TypeSerializers,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,LoaderFactory,The length of the statement  "            var methodBuilder = ILBuilder.Instance.NewMethod<Func<AbstractBufferedReader' ITypeBinaryDeserializerContext' ITypeSerializersId2LoaderMapping' ITypeDescriptor' object>>("DeserializerFor" + descriptor.Name);" is 207.
Long Statement,BTDB.EventStoreLayer,TypeSerializers,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,LoaderFactory,The length of the statement  "                descriptor.GenerateLoad(il' ilGen => ilGen.Ldarg(0)' ilGen => ilGen.Ldloc(localCtx)' ilGen => ilGen.Ldarg(3)' loadAsType);" is 122.
Long Statement,BTDB.EventStoreLayer,TypeSerializers,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,NewComplexSaver,The length of the statement  "            var method = ILBuilder.Instance.NewMethod<Action<AbstractBufferedWriter' ITypeBinarySerializerContext' object>>(descriptor.Name + "ComplexSaver");" is 146.
Long Statement,BTDB.EventStoreLayer,TypeSerializers,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,NewDescriptorSaverFactory,The length of the statement  "            var method = ILBuilder.Instance.NewMethod<Action<object' IDescriptorSerializerLiteContext>>("GatherAllObjectsForTypeExtraction_" + descriptor.Name);" is 148.
Long Statement,BTDB.EventStoreLayer,DescriptorSerializerContext,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializersMapping.cs,GetInfoFromObject,The length of the statement  "                    if (!_typeOrDescriptor2InfoMap.TryGetValue(objType' out infoForType) && !_typeSerializersMapping._typeOrDescriptor2Info.TryGetValue(objType' out infoForType))" is 158.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,C:\repos\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,IsCompatibleWith,The length of the statement  "            return type.GetGenericTypeDefinition() == typeof(IDictionary<'>) || type.GetGenericTypeDefinition() == typeof(Dictionary<'>);" is 125.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,C:\repos\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,HandledType,The length of the statement  "            return _type ?? (_type = typeof(IDictionary<'>).MakeGenericType(_keysHandler.HandledType()' _valuesHandler.HandledType()));" is 123.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,C:\repos\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,Save,The length of the statement  "            _valuesHandler.Save(ilGenerator' Extensions.PushWriterOrCtxAsNeeded(pushWriterOrCtx' _valuesHandler.NeedsCtx())' il => il" is 121.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,C:\repos\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,SpecializeLoadForType,The length of the statement  "            return new DictionaryFieldHandler(_fieldHandlerFactory' _typeConvertorGenerator' type' keySpecialized' valueSpecialized);" is 121.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,C:\repos\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,SpecializeSaveForType,The length of the statement  "            return new DictionaryFieldHandler(_fieldHandlerFactory' _typeConvertorGenerator' type' keySpecialized' valueSpecialized);" is 121.
Long Statement,BTDB.FieldHandler,Extensions,C:\repos\Bobris_BTDB\BTDB\FieldHandler\Extensions.cs,GenerateFreeContent,The length of the statement  "            if (fieldHandler.FreeContent(ilGenerator' fieldHandler.NeedsCtx() ? pushReaderOrCtx : PushReaderFromCtx(pushReaderOrCtx)))" is 122.
Long Statement,BTDB.FieldHandler,EnumFieldHandler,C:\repos\Bobris_BTDB\BTDB\FieldHandler\EnumFieldHandler.cs,IsCompatibleWith,The length of the statement  "            return SignedFieldHandler.IsCompatibleWith(enumUnderlyingType) || UnsignedFieldHandler.IsCompatibleWith(enumUnderlyingType);" is 124.
Long Statement,BTDB.FieldHandler,EnumFieldHandler,C:\repos\Bobris_BTDB\BTDB\FieldHandler\EnumFieldHandler.cs,SpecializeLoadForType,The length of the statement  "                    if (new EnumConfiguration(Configuration).IsBinaryRepresentationSubsetOf(new EnumConfiguration(enumTypeHandler.Configuration)))" is 126.
Long Statement,BTDB.FieldHandler,ConvertingHandler,C:\repos\Bobris_BTDB\BTDB\FieldHandler\SimpleFieldHandlerBase.cs,Save,The length of the statement  "                _fieldHandler.Save(ilGenerator' pushWriterOrCtx' il => il.Do(pushValue).Do(new DefaultTypeConvertorGenerator().GenerateConversion(_type' _fieldHandler.HandledType())));" is 168.
Long Statement,BTDB.FieldHandler,DefaultFieldHandlerFactory,C:\repos\Bobris_BTDB\BTDB\FieldHandler\DefaultFieldHandlerFactory.cs,CreateFromType,The length of the statement  "            if (ListFieldHandler.IsCompatibleWith(type)) return new ListFieldHandler(_provider.FieldHandlerFactory' _provider.TypeConvertorGenerator' type);" is 144.
Long Statement,BTDB.FieldHandler,DefaultFieldHandlerFactory,C:\repos\Bobris_BTDB\BTDB\FieldHandler\DefaultFieldHandlerFactory.cs,CreateFromType,The length of the statement  "            if (DictionaryFieldHandler.IsCompatibleWith(type)) return new DictionaryFieldHandler(_provider.FieldHandlerFactory' _provider.TypeConvertorGenerator' type);" is 156.
Long Statement,BTDB.FieldHandler,DefaultFieldHandlerFactory,C:\repos\Bobris_BTDB\BTDB\FieldHandler\DefaultFieldHandlerFactory.cs,CreateFromType,The length of the statement  "            if (NullableFieldHandler.IsCompatibleWith(type)) return new NullableFieldHandler(_provider.FieldHandlerFactory' _provider.TypeConvertorGenerator' type);" is 152.
Long Statement,BTDB.FieldHandler,DefaultFieldHandlerFactory,C:\repos\Bobris_BTDB\BTDB\FieldHandler\DefaultFieldHandlerFactory.cs,CreateFromName,The length of the statement  "            if (handlerName == ListFieldHandler.HandlerName) return new ListFieldHandler(_provider.FieldHandlerFactory' _provider.TypeConvertorGenerator' configuration);" is 157.
Long Statement,BTDB.FieldHandler,DefaultFieldHandlerFactory,C:\repos\Bobris_BTDB\BTDB\FieldHandler\DefaultFieldHandlerFactory.cs,CreateFromName,The length of the statement  "            if (handlerName == DictionaryFieldHandler.HandlerName) return new DictionaryFieldHandler(_provider.FieldHandlerFactory' _provider.TypeConvertorGenerator' configuration);" is 169.
Long Statement,BTDB.FieldHandler,DefaultFieldHandlerFactory,C:\repos\Bobris_BTDB\BTDB\FieldHandler\DefaultFieldHandlerFactory.cs,CreateFromName,The length of the statement  "            if (handlerName == NullableFieldHandler.HandlerName) return new NullableFieldHandler(_provider.FieldHandlerFactory' _provider.TypeConvertorGenerator' configuration);" is 165.
Long Statement,BTDB.IL,ILDynamicTypeDebugImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILDynamicTypeDebugImpl.cs,DefineConstructor,The length of the statement  "            return new ILConstructorDebugImpl(_typeBuilder.DefineConstructor(MethodAttributes.Public' CallingConventions.Standard' parameters)' _forbidenInstructions' _sourceCodeWriter);" is 174.
Long Statement,BTDB.IL,ILDynamicTypeImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILDynamicTypeImpl.cs,DefineConstructor,The length of the statement  "            return new ILConstructorImpl(_typeBuilder.DefineConstructor(MethodAttributes.Public' CallingConventions.Standard' parameters)' _forbidenInstructions);" is 150.
Long Statement,BTDB.IL,ILGenDebugImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILGenDebugImpl.cs,DeclareLocal,The length of the statement  "            _sourceCodeWriter.WriteLine(string.Format("{3}{0} {1} // index {2}"' type.ToSimpleName()' name' localBuilder.LocalIndex' pinned ? "pinned " : ""));" is 147.
Long Statement,BTDB.IL,ILGenDebugImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILGenDebugImpl.cs,Emit,The length of the statement  "            _sourceCodeWriter.MarkAndWriteLine(_ilGenerator' string.Format("{0} {3} {1}({2})"' opCode' param.Name' FormatParams(param.GetParameters())' param.ReturnType.ToSimpleName()));" is 174.
Long Statement,BTDB.IL,ILGenDebugImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILGenDebugImpl.cs,Emit,The length of the statement  "            _sourceCodeWriter.MarkAndWriteLine(_ilGenerator' string.Format("{0} {1} {3} {2}"' opCode' ilLocal.Index' ((ILLocalImpl)ilLocal).Name' ilLocal.LocalType.ToSimpleName()));" is 169.
Long Statement,BTDB.IL,ILDynamicMethodDebugImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILDynamicMethodDebugImpl.cs,CheckInPeVerify,The length of the statement  "            var nameInExeDirectory = Path.Combine(Path.GetDirectoryName(Path.GetDirectoryName(fullyQualifiedName))' Path.GetFileName(fullyQualifiedName));" is 142.
Long Statement,BTDB.IL,ILDynamicMethodDebugImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILDynamicMethodDebugImpl.cs,CheckInPeVerify,The length of the statement  "            var additionalDlls = new List<string>(Assembly.ReflectionOnlyLoadFrom(nameInExeDirectory).GetReferencedAssemblies().Select(a => a.Name + ".dll").Where(a => File.Exists(Path.Combine(DynamicILDirectoryPath.DynamicIL' a))));" is 221.
Long Statement,BTDB.IL,Call,C:\repos\Bobris_BTDB\BTDB\IL\ILGenForbidenInstructionsCheating.cs,GenerateStaticParts,The length of the statement  "                    _staticMethod = typeBuilder.DefineMethod(_name' MethodAttributes.Private | MethodAttributes.Static' _methodInfo.ReturnType' paramTypesWithoutResult);" is 149.
Long Statement,BTDB.IL,Call,C:\repos\Bobris_BTDB\BTDB\IL\ILGenForbidenInstructionsCheating.cs,GenerateStaticParts,The length of the statement  "                    _staticMethod = typeBuilder.DefineMethod(_name' MethodAttributes.Private | MethodAttributes.Static' accesibleConstructorType' paramTypesWithoutResult);" is 151.
Long Statement,BTDB.IL,SourceCodeWriter,C:\repos\Bobris_BTDB\BTDB\IL\SourceCodeWriter.cs,StartMethod,The length of the statement  "                    WriteLine(String.Format("{2}{0} {1}({3} arg{4})"' returns.ToSimpleName()' name' before' parameters[0].ToSimpleName()' firstArgIdx));" is 132.
Long Statement,BTDB.IL,EmitHelpers,C:\repos\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateINotifyPropertyChangedImpl,The length of the statement  "            var fieldBuilder = typeBuilder.DefineField("_propertyChanged"' typeof(PropertyChangedEventHandler)' FieldAttributes.Private);" is 125.
Long Statement,BTDB.IL,EmitHelpers,C:\repos\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateINotifyPropertyChangedImpl,The length of the statement  "            var eventBuilder = typeBuilder.DefineEvent("PropertyChanged"' EventAttributes.None' typeof(PropertyChangedEventHandler));" is 121.
Long Statement,BTDB.IL,EmitHelpers,C:\repos\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateINotifyPropertyChangedImpl,The length of the statement  "            var methodBuilder = typeBuilder.DefineMethod("RaisePropertyChanged"' null' new[] { typeof(string) }' MethodAttributes.Family);" is 126.
Long Statement,BTDB.IL,EmitHelpers,C:\repos\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateAddRemoveEvent,The length of the statement  "            typeBuilder.DefineMethodOverride(methodBuilder' add ? eventPropertyChanged.GetAddMethod() : eventPropertyChanged.GetRemoveMethod());" is 132.
Long Statement,BTDB.IOC,ConstructorTraitImpl,C:\repos\Bobris_BTDB\BTDB\IOC\ConstructorTraitImpl.cs,ChooseConstructor,The length of the statement  "                return candidates.FirstOrDefault(ci => ci.GetParameters().Select(pi => pi.ParameterType).SequenceEqual(_parameterTypes));" is 121.
Long Statement,BTDB.IOC,ConstructorTraitImpl,C:\repos\Bobris_BTDB\BTDB\IOC\ConstructorTraitImpl.cs,UsingConstructor,The length of the statement  "            if (_parameterTypes != null) throw new InvalidOperationException("UsingConstructor specification could be used only once");" is 123.
Long Statement,BTDB.IOC,ClosureOfObjBuilder,C:\repos\Bobris_BTDB\BTDB\IOC\ClosureOfObjBuilder.cs,Build,The length of the statement  "                                            typeof(ClosureOfObj<'>).MakeGenericType(methodInfo.ReturnType' parameters[0].ParameterType).GetConstructors()[0].Invoke(new[] { toReturn })'" is 140.
Long Statement,BTDB.IOC,GenerationContext,C:\repos\Bobris_BTDB\BTDB\IOC\GenerationContext.cs,PushToCycleDetector,The length of the statement  "                throw new InvalidOperationException("Cycle detected in registrations: " + string.Join("' "' _cycleDetectionStack.Select(t => t.Item2)) + ". Consider using Lazy<> to break cycle.");" is 180.
Long Statement,BTDB.IOC,SingleRegistration,C:\repos\Bobris_BTDB\BTDB\IOC\SingleRegistration.cs,Register,The length of the statement  "                    reg = new SingletonImpl(_implementationType' new AlwaysNewImpl(_implementationType' bestConstructor)' context.SingletonCount);" is 126.
Long Statement,BTDB.IOC.CRegs,DelegateImpl,C:\repos\Bobris_BTDB\BTDB\IOC\CRegs\DelegateImpl.cs,GetNeeds,The length of the statement  "                var genCtx = new GenerationContext(context.Container' _nestedRegistration' buildContext' _type.GetMethod("Invoke").GetParameters());" is 132.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,CreateOrUpdate,The length of the statement  "                Array.Copy(_keyvalues' index' rightNode._keyvalues' index - keyCountLeft + 1' keyCountLeft + keyCountRight - 1 - index);" is 120.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,EraseRange,The length of the statement  "            Array.Copy(_keyvalues' (int)lastKeyIndex + 1' newKeyValues' (int)firstKeyIndex' newKeyValues.Length - (int)firstKeyIndex);" is 122.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,CreateOrUpdate,The length of the statement  "                Array.Copy(_keyBytes' ofs + leftKeyBytesLen' newKeyBytes' ofs + newKey.Length' _keyBytes.Length - ofs - leftKeyBytesLen);" is 121.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,CreateOrUpdate,The length of the statement  "                Array.Copy(_keyvalues' index' rightNode._keyvalues' index - keyCountLeft + 1' keyCountLeft + keyCountRight - 1 - index);" is 120.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,EraseRange,The length of the statement  "            var newKeyBytes = new byte[_keyBytes.Length + _keyvalues[firstKeyIndex].KeyOffset - _keyvalues[lastKeyIndex].KeyOffset - _keyvalues[lastKeyIndex].KeyLength];" is 157.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,EraseRange,The length of the statement  "            Array.Copy(_keyvalues' (int)lastKeyIndex + 1' newKeyValues' (int)firstKeyIndex' newKeyValues.Length - (int)firstKeyIndex);" is 122.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,EraseRange,The length of the statement  "            Array.Copy(_keyBytes' _keyvalues[lastKeyIndex].KeyOffset + _keyvalues[lastKeyIndex].KeyLength' newKeyBytes' _keyvalues[firstKeyIndex].KeyOffset' newKeyBytes.Length - _keyvalues[firstKeyIndex].KeyOffset);" is 203.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,CreateOrUpdate,The length of the statement  "                Array.Copy(_keyvalues' index' rightNode._keyvalues' index - keyCountLeft + 1' keyCountLeft + keyCountRight - 1 - index);" is 120.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,EraseRange,The length of the statement  "            Array.Copy(_keyvalues' (int)lastKeyIndex + 1' newKeyValues' (int)firstKeyIndex' newKeyValues.Length - (int)firstKeyIndex);" is 122.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,The length of the statement  "                Array.Copy(_keyBytes' ofs + leftKeyBytesLen' newKeyBytes' ofs + newKey.Length' _keyBytes.Length - ofs - leftKeyBytesLen);" is 121.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,The length of the statement  "                Array.Copy(_keyvalues' index' rightNode._keyvalues' index - keyCountLeft + 1' keyCountLeft + keyCountRight - 1 - index);" is 120.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,EraseRange,The length of the statement  "            var newKeyBytes = new byte[_keyBytes.Length + _keyvalues[firstKeyIndex].KeyOffset - _keyvalues[lastKeyIndex].KeyOffset - _keyvalues[lastKeyIndex].KeyLength];" is 157.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,EraseRange,The length of the statement  "            Array.Copy(_keyvalues' (int)lastKeyIndex + 1' newKeyValues' (int)firstKeyIndex' newKeyValues.Length - (int)firstKeyIndex);" is 122.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,EraseRange,The length of the statement  "            Array.Copy(_keyBytes' _keyvalues[lastKeyIndex].KeyOffset + _keyvalues[lastKeyIndex].KeyLength' newKeyBytes' _keyvalues[firstKeyIndex].KeyOffset' newKeyBytes.Length - _keyvalues[firstKeyIndex].KeyOffset);" is 203.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeRoot,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeRoot.cs,NewTransactionRoot,The length of the statement  "            return new BTreeRoot(_transactionId + 1) { _keyValueCount = _keyValueCount' _rootNode = _rootNode' CommitUlong = CommitUlong' _ulongs = newulongs };" is 148.
Long Statement,BTDB.KVDBLayer,Compactor,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,ForbidDeletePreservingHistory,The length of the statement  "                    || (usedFilesFromOldGenerations != null && Array.BinarySearch(usedFilesFromOldGenerations' _keyValueDB.GetGeneration((uint)i)) >= 0))" is 133.
Long Statement,BTDB.KVDBLayer,Compactor,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,Run,The length of the statement  "                    dontTouchGenerationDueToPreserve = Math.Min(dontTouchGenerationDueToPreserve' _keyValueDB.GetGeneration(fileInfo.TrLogFileId));" is 127.
Long Statement,BTDB.KVDBLayer,Compactor,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,Run,The length of the statement  "            var btreesCorrectInTransactionId = _keyValueDB.AtomicallyChangeBTree(root => root.RemappingIterate((uint oldFileId' uint oldOffset' out uint newFileId' out uint newOffset) =>" is 174.
Long Statement,BTDB.KVDBLayer,FileKeyIndex,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\FileKeyIndex.cs,SkipHeader,The length of the statement  "            var withCommitUlong = type == KVFileType.KeyIndexWithCommitUlong || type == KVFileType.ModernKeyIndex || type == KVFileType.ModernKeyIndexWithUlongs;" is 149.
Long Statement,BTDB.KVDBLayer,File,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\OnDiskMemoryMappedFileCollection.cs,MapContent,The length of the statement  "                _memoryMappedFile = MemoryMappedFile.CreateFromFile(_stream' null' 0' MemoryMappedFileAccess.ReadWrite' null' HandleInheritability.None' true);" is 143.
Long Statement,BTDB.KVDBLayer,File,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\OnDiskMemoryMappedFileCollection.cs,SetSize,The length of the statement  "                    throw new InvalidOperationException("For in memory collection SetSize should never be set to something else than GetSize");" is 123.
Long Statement,BTDB.KVDBLayer,InMemoryKeyValueDBTransaction,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\MemoryImplementation\InMemoryKeyValueDBTransaction.cs,CalcPrefixKeyStart,The length of the statement  "            if (BtreeRoot.FindKey(new List<NodeIdxPair>()' out _prefixKeyStart' _prefix' ByteBuffer.NewEmpty()) == FindResult.NotFound)" is 123.
Long Statement,BTDB.KVDBLayer,InMemoryKeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\MemoryImplementation\InMemoryKeyValueDB.cs,Dispose,The length of the statement  "                if (_writingTransaction != null) throw new BTDBException("Cannot dispose KeyValueDB when writting transaction still running");" is 126.
Long Statement,BTDB.KVDBLayer,InMemoryKeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\MemoryImplementation\InMemoryKeyValueDB.cs,MakeWrittableTransaction,The length of the statement  "                if (_writingTransaction != null) throw new BTDBTransactionRetryException("Another writting transaction already running");" is 121.
Long Statement,BTDB.KVDBLayer,InMemoryKeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\MemoryImplementation\InMemoryKeyValueDB.cs,MakeWrittableTransaction,The length of the statement  "                if (LastCommited != btreeRoot) throw new BTDBTransactionRetryException("Another writting transaction already finished");" is 120.
Long Statement,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,BuildKeyIndexInfos,The length of the statement  "                keyIndexes.Add(new KeyIndexInfo { Key = fileInfo.Key' Generation = keyIndex.Generation' CommitUlong = keyIndex.CommitUlong });" is 126.
Long Statement,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadInfoAboutFiles,The length of the statement  "            if (openUpToCommitUlong.HasValue || lastestTrLogFileId != firstTrLogId && firstTrLogId != 0 || !hasKeyIndex && _fileCollection.FileInfos.Any(p => p.Value.SubDBId == 0))" is 168.
Long Statement,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,CreateIndexFile,The length of the statement  "            MarkAsUnknown(_fileCollection.FileInfos.Where(p => p.Value.FileType == KVFileType.KeyIndex && p.Key != idxFileId && p.Value.Generation != preserveKeyIndexGeneration).Select(p => p.Key));" is 186.
Long Statement,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadUsedFilesFromKeyIndex,The length of the statement  "                    info.UsedFilesInOlderGenerations = usedFileIds.Select(fi => GetGeneration(fi)).Where(gen => gen < trlGeneration).OrderBy(a => a).ToArray();" is 139.
Long Statement,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadKeyIndex,The length of the statement  "                    info.UsedFilesInOlderGenerations = usedFileIds.Select(fi => GetGeneration(fi)).Where(gen => gen < trlGeneration).OrderBy(a => a).ToArray();" is 139.
Long Statement,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The length of the statement  "                    valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);" is 156.
Long Statement,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,Dispose,The length of the statement  "                if (_writingTransaction != null) throw new BTDBException("Cannot dispose KeyValueDB when writting transaction still running");" is 126.
Long Statement,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,MakeWrittableTransaction,The length of the statement  "                if (_writingTransaction != null) throw new BTDBTransactionRetryException("Another writting transaction already running");" is 121.
Long Statement,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,MakeWrittableTransaction,The length of the statement  "                if (LastCommited != btreeRoot) throw new BTDBTransactionRetryException("Another writting transaction already finished");" is 120.
Long Statement,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,WriteStartOfNewTransactionLogFile,The length of the statement  "            var transactionLog = new FileTransactionLog(FileCollection.NextGeneration()' FileCollection.Guid' _fileIdWithPreviousTransactionLog);" is 133.
Long Statement,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The length of the statement  "                throw new BTDBException($"ReadValue({valueFileId}'{valueOfs}'{valueSize}) compressed: {compressed} file does not exist in {CalcStats()}");" is 138.
Long Statement,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,CreateKeyIndexFile,The length of the statement  "            var keyIndex = new FileKeyIndex(FileCollection.NextGeneration()' FileCollection.Guid' root.TrLogFileId' root.TrLogOffset' keyCount' root.CommitUlong' KeyIndexCompression.None' root.UlongsArray);" is 194.
Long Statement,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,CreateKeyIndexFile,The length of the statement  "            keyIndex.UsedFilesInOlderGenerations = usedFileIds.Select(fi => GetGeneration(fi)).Where(gen => gen < trlGeneration).OrderBy(a => a).ToArray();" is 143.
Long Statement,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,DistanceFromLastKeyIndex,The length of the statement  "            var keyIndex = FileCollection.FileInfos.Where(p => p.Value.FileType == KVFileType.KeyIndex).Select(p => (IKeyIndex)p.Value).FirstOrDefault();" is 141.
Long Statement,BTDB.KVDBLayer,KeyValueDBTransaction,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDBTransaction.cs,CalcPrefixKeyStart,The length of the statement  "            if (BtreeRoot.FindKey(new List<NodeIdxPair>()' out _prefixKeyStart' _prefix' ByteBuffer.NewEmpty()) == FindResult.NotFound)" is 123.
Long Statement,BTDB.KVDBLayer,KeyValueDBTransaction,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDBTransaction.cs,GetValue,The length of the statement  "                throw new BTDBException($"GetValue failed in TrId:{BtreeRoot.TransactionId}'TRL:{BtreeRoot.TrLogFileId}'Ofs:{BtreeRoot.TrLogOffset}'ComUlong:{BtreeRoot.CommitUlong} and LastTrId:{_keyValueDB.LastCommited.TransactionId}'ComUlong:{_keyValueDB.LastCommited.CommitUlong} OldestTrId:{_keyValueDB.OldestRoot.TransactionId}'TRL:{_keyValueDB.OldestRoot.TrLogFileId}'ComUlong:{_keyValueDB.OldestRoot.CommitUlong} innerMessage:{ex.Message}"' ex);" is 436.
Long Statement,BTDB.KVDBLayer,KeyValueDBTransaction,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDBTransaction.cs,SetValue,The length of the statement  "            _keyValueDB.WriteCreateOrUpdateCommand(BitArrayManipulation.EmptyByteArray' memberKey' value' out memberValue.ValueFileId' out memberValue.ValueOfs' out memberValue.ValueSize);" is 176.
Long Statement,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The length of the statement  "            if (tempbuf[0] != 'B' || tempbuf[1] != 'T' || tempbuf[2] != 'D' || tempbuf[3] != 'B' || tempbuf[4] != 'E' || tempbuf[5] != 'X' || tempbuf[6] != 'P' || tempbuf[7] != '2')" is 169.
Long Statement,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The length of the statement  "                transaction.CreateOrUpdateKeyValue(ByteBuffer.NewSync(tempbuf' 0' keySize)' ByteBuffer.NewSync(tempbuf2' 0' valueSize));" is 120.
Long Statement,BTDB.KVDBLayer,PtrLenList,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryInclude,The length of the statement  "                    _list[m] = new KeyValuePair<ulong' ulong>(cur.Key' Math.Max(lastOk.Key + lastOk.Value' includePos + includeLen) - cur.Key);" is 123.
Long Statement,BTDB.KVDBLayer,PtrLenList,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryInclude,The length of the statement  "            _list[l] = new KeyValuePair<ulong' ulong>(includePos' Math.Max(cur.Key + cur.Value' includePos + includeLen) - includePos);" is 123.
Long Statement,BTDB.ODBLayer,ODBDictionary<TKey;TValue>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,FreeContent,The length of the statement  "            var findIDictAction = (Action<IInternalObjectDBTransaction' AbstractBufferedReader' IList<ulong>' IList <ulong>>)config.FreeContent;" is 132.
Long Statement,BTDB.ODBLayer,ODBDictionaryFieldHandler,C:\repos\Bobris_BTDB\BTDB\ODBLayer\ODBDictionaryFieldHandler.cs,SpecializeLoadForType,The length of the statement  "            if (wantedKeyHandler == specializedKeyHandler && (wantedValueHandler == specializedValueHandler || wantedValueHandler.HandledType() == specializedValueHandler.HandledType()))" is 174.
Long Statement,BTDB.ODBLayer,ODBDictionaryFieldHandler,C:\repos\Bobris_BTDB\BTDB\ODBLayer\ODBDictionaryFieldHandler.cs,SpecializeLoadForType,The length of the statement  "            var res = new ODBDictionaryFieldHandler(_odb' _configuration' _configurationId' specializedKeyHandler' specializedValueHandler);" is 128.
Long Statement,BTDB.ODBLayer,ODBIterator,C:\repos\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,IterateOid,The length of the statement  "            if (_visitor != null && !_visitor.StartObject(oid' tableId' _tableId2Name.TryGetValue(tableId' out tableName) ? tableName : null'" is 129.
Long Statement,BTDB.ODBLayer,RelationBuilder<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The length of the statement  "            var classImpl = ILBuilder.Instance.NewType("Relation" + relationName' relationDBManipulatorType' new[] { interfaceType });" is 122.
Long Statement,BTDB.ODBLayer,RelationBuilder<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The length of the statement  "            il.Ldarg(0).Ldarg(1).Ldarg(2).Call(relationDBManipulatorType.GetConstructor(new[] { typeof(IObjectDBTransaction)' typeof(RelationInfo) }))" is 138.
Long Statement,BTDB.ODBLayer,RelationBuilder<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The length of the statement  "                else if (method.Name.StartsWith("ListBy"' StringComparison.Ordinal)) //ListBy{Name}(tenantId' ..' AdvancedEnumeratorParam)" is 122.
Long Statement,BTDB.ODBLayer,RelationBuilder<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,BuildContainsMethod,The length of the statement  "                throw new BTDBException($"Number of parameters in Contains does not match primary key count {primaryKeyFields.Count}.");" is 120.
Long Statement,BTDB.ODBLayer,RelationBuilder<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,BuildRemoveByMethod,The length of the statement  "            var count = SaveMethodParameters(reqMethod.Generator' method.Name' method.GetParameters()' method.GetParameters().Length'" is 121.
Long Statement,BTDB.ODBLayer,RelationBuilder<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,BuildRemoveByMethod,The length of the statement  "                throw new BTDBException($"Number of parameters in {method.Name} does not match primary key count {primaryKeyFields.Count}.");" is 125.
Long Statement,BTDB.ODBLayer,RelationBuilder<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,BuildRelationCreatorInstance,The length of the statement  "            var methodBuilder = ILBuilder.Instance.NewMethod("RelationFactory" + relationName' typeof(Func<IObjectDBTransaction' T1>)' typeof(RelationInfo));" is 145.
Long Statement,BTDB.ODBLayer,RelationBuilder<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodFindBy,The length of the statement  "            //call public T FindBySecondaryKeyOrDefault(uint secondaryKeyIndex' uint prefixParametersCount' ByteBuffer secKeyBytes' bool throwWhenNotFound)" is 143.
Long Statement,BTDB.ODBLayer,RelationBuilder<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,SaveMethodParameters,The length of the statement  "                    throw new BTDBException($"Parameter type mismatch in {methodName} (expected '{field.Handler.HandledType().ToSimpleName()}' but '{par.ParameterType.ToSimpleName()}' found).");" is 174.
Long Statement,BTDB.ODBLayer,RelationDBManipulator<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,KeyBytes,The length of the statement  "            _relationInfo.PrimaryKeysSaver(_transaction' keyWriter' obj' this);  //this for relation interface which is same with manipulator" is 129.
Long Statement,BTDB.ODBLayer,RelationDBManipulator<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,RemoveByPrimaryKeyPrefix,The length of the statement  "            var enumerator = new RelationPrimaryKeyEnumerator<T>(_transaction' _relationInfo' keyBytesPrefix' _modificationCounter);" is 120.
Long Statement,BTDB.ODBLayer,RelationDBManipulator<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,GetEnumerator,The length of the statement  "            return new RelationEnumerator<T>(_transaction' _relationInfo' ByteBuffer.NewSync(_relationInfo.Prefix)' _modificationCounter);" is 126.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CheckThatPrimaryKeyHasNotChanged,The length of the statement  "                throw new BTDBException($"Change of primary key in relation '{name}' is not allowed. Field count {pkFields.Count} != {prevPkFields.Count}.");" is 141.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CheckThatPrimaryKeyHasNotChanged,The length of the statement  "                    throw new BTDBException($"Change of primary key in relation '{name}' is not allowed. Field '{en.Current.Name}' is not compatible.");" is 132.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CalculateSecondaryKey,The length of the statement  "            var enumerator = (IEnumerator)Activator.CreateInstance(enumeratorType' tr' this' keyWriter.GetDataAndRewind().ToAsyncSafe()' new SimpleModificationCounter());" is 158.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,GetPrimaryKeysLoader,The length of the statement  "                var loader = CreateLoader(ClientTypeVersion' ClientRelationVersionInfo.GetPrimaryKeyFields()' $"RelationKeyLoader_{Name}");" is 123.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateBytesToSKSaver,The length of the statement  "            var method = ILBuilder.Instance.NewMethod<Action<IInternalObjectDBTransaction' AbstractBufferedWriter' byte[]' byte[]' object>>(saverName);" is 139.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateBytesToSKSaver,The length of the statement  "                        StoreIntoLocal(ilGenerator' pks[pkIdx].Handler' firstBuffer' outOfOrderSkParts' skFieldIdxForPk' skFields[skFieldIdxForPk].Handler);" is 132.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateBytesToSKSaver,The length of the statement  "                    CopyToOutput(ilGenerator' pks[(int)skf.Index].Handler' writerCtxLocal' pushWriter' skFields[skFieldIdx].Handler' firstBuffer);" is 126.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateBytesToSKSaver,The length of the statement  "                                StoreIntoLocal(ilGenerator' valueField.Handler' secondBuffer' outOfOrderSkParts' storeForSkIndex' skFields[storeForSkIndex].Handler);" is 133.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateBytesToSKSaver,The length of the statement  "                        CopyToOutput(ilGenerator' valueFields[valueFieldIdx].Handler' writerCtxLocal' pushWriter' skFields[skFieldIdx].Handler' secondBuffer);" is 134.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateBytesToSKSaver,The length of the statement  "                    { //older version of value does not contain sk field - store field from default value (can be initialized in constructor)" is 121.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateVersionInfoByReflection,The length of the statement  "            var secondaryKeys = new List<Tuple<int' IList<SecondaryKeyAttribute>>>(); //positive: sec key field idx' negative: pk order' attrs" is 130.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateVersionInfoByReflection,The length of the statement  "                            secondaryKeyFields.Add(TableFieldInfo.Build(Name' pi' _relationInfoResolver.FieldHandlerFactory' FieldHandlerOptions.Orderable));" is 129.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateVersionInfoByReflection,The length of the statement  "            return new RelationVersionInfo(primaryKeys' secondaryKeys' secondaryKeyFields.ToArray()' fields.ToArray()' prevVersion);" is 120.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,GetSecondaryKeysKeySaver,The length of the statement  "                (secKeyIndex' relationInfo) => CreateSaverWithApartFields(relationInfo.ClientRelationVersionInfo.GetSecondaryKeyFields(secKeyIndex)'" is 132.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,GetSecondaryKeysKeySaver,The length of the statement  "                    $"Relation_{relationInfo.Name}_SK_{relationInfo.ClientRelationVersionInfo.SecondaryKeys[secKeyIndex].Name}_KeySaver")' this);" is 125.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,GetPKValToSKMerger,The length of the statement  "                    $"Relation_{relationInfo.Name}_PkVal_to_SK_{relationInfo.ClientRelationVersionInfo.SecondaryKeys[secKeyIndex].Name}_v{ver}")'" is 125.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,GetSKKeyValuetoPKMerger,The length of the statement  "                (_' secKeyIndex' relationInfo' paramFieldCount) => relationInfo.CreatePrimaryKeyFromSKDataMerger(secKeyIndex' paramFieldCount'" is 126.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreatePrimaryKeyFromSKDataMerger,The length of the statement  "            var outOfOrderPKParts = new Dictionary<int' MemorizedPositionWithLength>(); //index -> bufferIdx' IMemorizedPosition' length" is 124.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateSimpleLoader,The length of the statement  "            var delegateType = typeof(Func<''>).MakeGenericType(typeof(AbstractBufferedReader)' typeof(IReaderCtx)' loaderType.RealType);" is 125.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateLoader,The length of the statement  "            var method = ILBuilder.Instance.NewMethod<Action<IInternalObjectDBTransaction' AbstractBufferedReader' object>>(loaderName);" is 124.
Long Statement,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateLoader,The length of the statement  "                    var converterGenerator = _relationInfoResolver.TypeConvertorGenerator.GenerateConversion(willLoad' setterMethod.GetParameters()[0].ParameterType);" is 146.
Long Statement,BTDB.ODBLayer,RelationPrimaryKeyEnumerator<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,GetKeyBytes,The length of the statement  "            keyWriter.WriteBlock(KeyBytes.Buffer' KeyBytes.Offset + ObjectDB.AllRelationsPKPrefix.Length' KeyBytes.Length - ObjectDB.AllRelationsPKPrefix.Length);" is 150.
Long Statement,BTDB.ODBLayer,RelationAdvancedEnumerator<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,CreateInstance,The length of the statement  "            writer.WriteBlock(_keyBytes.Buffer' _keyBytes.Offset + _lengthOfNonDataPrefix' _keyBytes.Length - _lengthOfNonDataPrefix);" is 122.
Long Statement,BTDB.ODBLayer,RelationAdvancedOrderedEnumerator<TKey;TValue>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,CreateInstance,The length of the statement  "            writer.WriteBlock(_keyBytes.Buffer' _keyBytes.Offset + _lengthOfNonDataPrefix' _keyBytes.Length - _lengthOfNonDataPrefix);" is 122.
Long Statement,BTDB.ODBLayer,DefaultODBFieldHandlerFactory,C:\repos\Bobris_BTDB\BTDB\ODBLayer\DefaultODBFieldHandlerFactory.cs,CreateFromType,The length of the statement  "            if (ODBDictionaryFieldHandler.IsCompatibleWithStatic(type' options)) return new ODBDictionaryFieldHandler(_odb' type' false' this);" is 131.
Long Statement,BTDB.ODBLayer,TableFieldInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableFieldInfo.cs,Build,The length of the statement  "            if (fieldHandler == null) throw new BTDBException(string.Format("FieldHandlerFactory did not build property {0} of type {2} in {1}"' pi.Name' tableName' pi.PropertyType.FullName));" is 180.
Long Statement,BTDB.ODBLayer,ObjectDB,C:\repos\Bobris_BTDB\BTDB\ODBLayer\ObjectDB.cs,StartWritingTransaction,The length of the statement  "                .ContinueWith<IObjectDBTransaction>(t => new ObjectDBTransaction(this' t.Result' false)' CancellationToken.None' TaskContinuationOptions.ExecuteSynchronously' TaskScheduler.Default);" is 182.
Long Statement,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateInitializer,The length of the statement  "                    var converterGenerator = _tableInfoResolver.TypeConvertorGenerator.GenerateConversion(willLoad' setterMethod.GetParameters()[0].ParameterType);" is 143.
Long Statement,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateSaver,The length of the statement  "            var method = ILBuilder.Instance.NewMethod<Action<IInternalObjectDBTransaction' DBObjectMetadata' AbstractBufferedWriter' object>>(" is 130.
Long Statement,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,EnsureClientTypeVersion,The length of the statement  "                var last = _tableVersions.GetOrAdd(LastPersistedVersion' (ver' tableInfo) => tableInfo._tableInfoResolver.LoadTableVersionInfo(tableInfo._id' ver' tableInfo.Name)' this);" is 170.
Long Statement,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,The length of the statement  "            var method = ILBuilder.Instance.NewMethod<Action<IInternalObjectDBTransaction' DBObjectMetadata' AbstractBufferedReader' object>>(" is 130.
Long Statement,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,The length of the statement  "            var tableVersionInfo = _tableVersions.GetOrAdd(version' (ver' tableInfo) => tableInfo._tableInfoResolver.LoadTableVersionInfo(tableInfo._id' ver' tableInfo.Name)' this);" is 169.
Long Statement,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,The length of the statement  "                    var converterGenerator = _tableInfoResolver.TypeConvertorGenerator.GenerateConversion(willLoad' setterMethod.GetParameters()[0].ParameterType);" is 143.
Long Statement,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,IsFreeContentNeeded,The length of the statement  "            Tuple<bool' Action<IInternalObjectDBTransaction' DBObjectMetadata' AbstractBufferedReader' IList<ulong>' IList<ulong>>> freeContent;" is 132.
Long Statement,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateFreeContent,The length of the statement  "            var tableVersionInfo = _tableVersions.GetOrAdd(version' (ver' tableInfo) => tableInfo._tableInfoResolver.LoadTableVersionInfo(tableInfo._id' ver' tableInfo.Name)' this);" is 169.
Long Statement,BTDB.Reactive,FastSubject<T>,C:\repos\Bobris_BTDB\BTDB\Reactive\FastSubject.cs,OnCompleted,The length of the statement  "            } while (Interlocked.CompareExchange(ref _current' FastSubjectHelpers<T>.CompletedSubjectMarker' original) != original);" is 120.
Long Statement,BTDB.Reactive,FastSubject<T>,C:\repos\Bobris_BTDB\BTDB\Reactive\FastSubject.cs,OnError,The length of the statement  "            } while (Interlocked.CompareExchange(ref _current' new FastSubjectHelpers<T>.ExceptionedSubject(error)' original) != original);" is 127.
Long Statement,BTDB.Reactive,FastBehaviourSubject<T>,C:\repos\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,OnCompleted,The length of the statement  "            } while (Interlocked.CompareExchange(ref _current' FastSubjectHelpers<T>.CompletedSubjectMarker' original) != original);" is 120.
Long Statement,BTDB.Reactive,FastBehaviourSubject<T>,C:\repos\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,OnError,The length of the statement  "            } while (Interlocked.CompareExchange(ref _current' new FastSubjectHelpers<T>.ExceptionedSubject(error)' original) != original);" is 127.
Long Statement,BTDB.Reactive,FastBehaviourSubject<T>,C:\repos\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,OnNext,The length of the statement  "                else if (original is FastSubjectHelpers<T>.EmptySubjectWithValue || original == FastSubjectHelpers<T>.EmptySubjectMarker)" is 121.
Long Statement,BTDB.Service,DefaultServiceFieldHandlerFactory,C:\repos\Bobris_BTDB\BTDB\Service\DefaultServiceFieldHandlerFactory.cs,CreateFromName,The length of the statement  "            if (handlerName == ServiceObjectFieldHandler.HandlerName) return new ServiceObjectFieldHandler(_service' configuration);" is 120.
Long Statement,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The length of the statement  "                    resultFieldHandler.Save(ilGenerator' il => il.Ldloc(resultFieldHandler.NeedsCtx() ? localWriterCtx : localWriter)' il => il.Ldloc(localResult));" is 144.
Long Statement,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,CreateTaskContinuationWithResultMarshaling,The length of the statement  "                resultFieldHandler.Save(ilGenerator' il => il.Ldloc(resultFieldHandler.NeedsCtx() ? localWriterCtx : localWriter)' il =>" is 120.
Long Statement,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The length of the statement  "                var methodBuilder = tb.DefineMethod(methodInfo.Name' methodInfo.ReturnType' parameterTypes' MethodAttributes.Public | MethodAttributes.Virtual);" is 144.
Long Statement,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The length of the statement  "                                                new[] { typeof(object)' typeof(AbstractBufferedReader)' typeof(IServiceInternalClient) }' MethodAttributes.Public | MethodAttributes.Static);" is 141.
Long Statement,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The length of the statement  "                    finalType.GetMethod("HandleResult_" + resultType).CreateDelegate<Action<object' AbstractBufferedReader' IServiceInternalClient>>();" is 131.
Long Statement,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibilityIgnoringName,The length of the statement  "                result = EvaluateCompatibility(to.ResultFieldHandler' from.ResultFieldHandler); // from to is exchanged because return value going back" is 135.
Long Statement,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibility,The length of the statement  "            if (from.Name == to.Name && (from.Configuration == to.Configuration || from.Configuration.SequenceEqual(to.Configuration))) return 10;" is 134.
Long Statement,BTDB.Service,TcpipServer,C:\repos\Bobris_BTDB\BTDB\Service\TcpipServer.cs,StartListening,The length of the statement  "            _acceptClientsTask = Task.Factory.StartNew(AcceptNewClients' CancellationToken.None' TaskCreationOptions.LongRunning' TaskScheduler.Default);" is 141.
Long Statement,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,Decompress,The length of the statement  "            if (!DecompressRaw(dstBuf' ByteBuffer.NewSync(compressedBytes.Buffer' compressedBytes.Offset + ofs' compressedBytes.Length - ofs)))" is 131.
Complex Conditional,BTDB.IL,EmitHelpers,C:\repos\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateJumpIfEqual,The conditional expression  "type == typeof(sbyte) || type == typeof(byte) || type == typeof(short) || type == typeof(ushort)                 || type == typeof(int) || type == typeof(uint) || type == typeof(long) || type == typeof(ulong)                 || type == typeof(float) || type == typeof(double) || type == typeof(bool) || type.IsEnum"  is complex.
Complex Conditional,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadInfoAboutFiles,The conditional expression  "openUpToCommitUlong.HasValue || lastestTrLogFileId != firstTrLogId && firstTrLogId != 0 || !hasKeyIndex && _fileCollection.FileInfos.Any(p => p.Value.SubDBId == 0)"  is complex.
Complex Conditional,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The conditional expression  "tempbuf[0] != 'B' || tempbuf[1] != 'T' || tempbuf[2] != 'D' || tempbuf[3] != 'B' || tempbuf[4] != 'E' || tempbuf[5] != 'X' || tempbuf[6] != 'P' || tempbuf[7] != '2'"  is complex.
Empty Catch Block,BTDB.ChunkCache,DiskChunkCache,C:\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,QuickFinishCompaction,The method has an empty catch block.
Empty Catch Block,BTDB.ChunkCache,DiskChunkCache,C:\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,Get,The method has an empty catch block.
Empty Catch Block,BTDB.ODBLayer,ObjectDBTransaction,C:\repos\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,EnumerateSingletonTypes,The method has an empty catch block.
Empty Catch Block,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,SendDataIgnoringExceptions,The method has an empty catch block.
Empty Catch Block,BTDB.Service,Client,C:\repos\Bobris_BTDB\BTDB\Service\TcpipServer.cs,Dispose,The method has an empty catch block.
Empty Catch Block,BTDB.Service,Client,C:\repos\Bobris_BTDB\BTDB\Service\TcpipServer.cs,Dispose,The method has an empty catch block.
Magic Number,BTDB.Buffer,ByteBuffer,C:\repos\Bobris_BTDB\BTDB\Buffer\ByteBuffer.cs,ResizingAppend,The following statement contains a magic number: var newCapacity = Math.Max(Length + append.Length' Length * 2);
Magic Number,BTDB.Buffer,Key20,C:\repos\Bobris_BTDB\BTDB\Buffer\ByteStructs.cs,Key20,The following statement contains a magic number: V2 = PackUnpack.UnpackUInt64LE(value.Buffer' value.Offset + 8);
Magic Number,BTDB.Buffer,Key20,C:\repos\Bobris_BTDB\BTDB\Buffer\ByteStructs.cs,Key20,The following statement contains a magic number: V3 = PackUnpack.UnpackUInt32LE(value.Buffer' value.Offset + 16);
Magic Number,BTDB.Buffer,Key20,C:\repos\Bobris_BTDB\BTDB\Buffer\ByteStructs.cs,FillBuffer,The following statement contains a magic number: PackUnpack.PackUInt64LE(buf.Buffer' o + 8' V2);
Magic Number,BTDB.Buffer,Key20,C:\repos\Bobris_BTDB\BTDB\Buffer\ByteStructs.cs,FillBuffer,The following statement contains a magic number: PackUnpack.PackUInt32LE(buf.Buffer' o + 16' V3);
Magic Number,BTDB.Buffer,Key32,C:\repos\Bobris_BTDB\BTDB\Buffer\ByteStructs.cs,Key32,The following statement contains a magic number: V2 = PackUnpack.UnpackUInt64LE(value.Buffer' value.Offset + 8);
Magic Number,BTDB.Buffer,Key32,C:\repos\Bobris_BTDB\BTDB\Buffer\ByteStructs.cs,Key32,The following statement contains a magic number: V3 = PackUnpack.UnpackUInt64LE(value.Buffer' value.Offset + 16);
Magic Number,BTDB.Buffer,Key32,C:\repos\Bobris_BTDB\BTDB\Buffer\ByteStructs.cs,Key32,The following statement contains a magic number: V4 = PackUnpack.UnpackUInt64LE(value.Buffer' value.Offset + 23);
Magic Number,BTDB.Buffer,Key32,C:\repos\Bobris_BTDB\BTDB\Buffer\ByteStructs.cs,FillBuffer,The following statement contains a magic number: PackUnpack.PackUInt64LE(buf.Buffer' o + 8' V2);
Magic Number,BTDB.Buffer,Key32,C:\repos\Bobris_BTDB\BTDB\Buffer\ByteStructs.cs,FillBuffer,The following statement contains a magic number: PackUnpack.PackUInt64LE(buf.Buffer' o + 16' V3);
Magic Number,BTDB.Buffer,Key32,C:\repos\Bobris_BTDB\BTDB\Buffer\ByteStructs.cs,FillBuffer,The following statement contains a magic number: PackUnpack.PackUInt64LE(buf.Buffer' o + 24' V4);
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: var pos = (uint) (startOffset / 8);
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: var firstByteFill = (byte)(255 >> (8 - (startOffset & 7)));
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: var firstByteFill = (byte)(255 >> (8 - (startOffset & 7)));
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: var firstByteFill = (byte)(255 >> (8 - (startOffset & 7)));
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: uint laststart = pos * 8;
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: switch (b)             {                 case 255:                     laststart += 8;                     break;                 case 0:                     sizetill += 8;                     break;                 default:                     if (FirstHoleSize[b] >= size) return (int) laststart;                     if (MaxHoleSize[b] >= size) return (int) (pos * 8 + MaxHoleOffset[b] - 8);                     sizetill = LastHoleSize[b];                     laststart += 8 - sizetill;                     break;             }
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: switch (b)             {                 case 255:                     laststart += 8;                     break;                 case 0:                     sizetill += 8;                     break;                 default:                     if (FirstHoleSize[b] >= size) return (int) laststart;                     if (MaxHoleSize[b] >= size) return (int) (pos * 8 + MaxHoleOffset[b] - 8);                     sizetill = LastHoleSize[b];                     laststart += 8 - sizetill;                     break;             }
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: switch (b)             {                 case 255:                     laststart += 8;                     break;                 case 0:                     sizetill += 8;                     break;                 default:                     if (FirstHoleSize[b] >= size) return (int) laststart;                     if (MaxHoleSize[b] >= size) return (int) (pos * 8 + MaxHoleOffset[b] - 8);                     sizetill = LastHoleSize[b];                     laststart += 8 - sizetill;                     break;             }
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: switch (b)             {                 case 255:                     laststart += 8;                     break;                 case 0:                     sizetill += 8;                     break;                 default:                     if (FirstHoleSize[b] >= size) return (int) laststart;                     if (MaxHoleSize[b] >= size) return (int) (pos * 8 + MaxHoleOffset[b] - 8);                     sizetill = LastHoleSize[b];                     laststart += 8 - sizetill;                     break;             }
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: switch (b)             {                 case 255:                     laststart += 8;                     break;                 case 0:                     sizetill += 8;                     break;                 default:                     if (FirstHoleSize[b] >= size) return (int) laststart;                     if (MaxHoleSize[b] >= size) return (int) (pos * 8 + MaxHoleOffset[b] - 8);                     sizetill = LastHoleSize[b];                     laststart += 8 - sizetill;                     break;             }
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: switch (b)             {                 case 255:                     laststart += 8;                     break;                 case 0:                     sizetill += 8;                     break;                 default:                     if (FirstHoleSize[b] >= size) return (int) laststart;                     if (MaxHoleSize[b] >= size) return (int) (pos * 8 + MaxHoleOffset[b] - 8);                     sizetill = LastHoleSize[b];                     laststart += 8 - sizetill;                     break;             }
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: while (pos < len)             {                 b = data[pos];                 pos++;                 switch (b)                 {                     case 255:                         if (sizetill >= size) return (int) laststart;                         sizetill = 0;                         laststart = pos * 8;                         break;                     case 0:                         sizetill += 8;                         break;                     default:                         sizetill += FirstHoleSize[b];                         if (sizetill >= size) return (int) laststart;                         if (MaxHoleSize[b] >= size) return (int) (pos * 8 + MaxHoleOffset[b] - 8);                         sizetill = LastHoleSize[b];                         laststart = pos * 8 - sizetill;                         break;                 }             }
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: while (pos < len)             {                 b = data[pos];                 pos++;                 switch (b)                 {                     case 255:                         if (sizetill >= size) return (int) laststart;                         sizetill = 0;                         laststart = pos * 8;                         break;                     case 0:                         sizetill += 8;                         break;                     default:                         sizetill += FirstHoleSize[b];                         if (sizetill >= size) return (int) laststart;                         if (MaxHoleSize[b] >= size) return (int) (pos * 8 + MaxHoleOffset[b] - 8);                         sizetill = LastHoleSize[b];                         laststart = pos * 8 - sizetill;                         break;                 }             }
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: while (pos < len)             {                 b = data[pos];                 pos++;                 switch (b)                 {                     case 255:                         if (sizetill >= size) return (int) laststart;                         sizetill = 0;                         laststart = pos * 8;                         break;                     case 0:                         sizetill += 8;                         break;                     default:                         sizetill += FirstHoleSize[b];                         if (sizetill >= size) return (int) laststart;                         if (MaxHoleSize[b] >= size) return (int) (pos * 8 + MaxHoleOffset[b] - 8);                         sizetill = LastHoleSize[b];                         laststart = pos * 8 - sizetill;                         break;                 }             }
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: while (pos < len)             {                 b = data[pos];                 pos++;                 switch (b)                 {                     case 255:                         if (sizetill >= size) return (int) laststart;                         sizetill = 0;                         laststart = pos * 8;                         break;                     case 0:                         sizetill += 8;                         break;                     default:                         sizetill += FirstHoleSize[b];                         if (sizetill >= size) return (int) laststart;                         if (MaxHoleSize[b] >= size) return (int) (pos * 8 + MaxHoleOffset[b] - 8);                         sizetill = LastHoleSize[b];                         laststart = pos * 8 - sizetill;                         break;                 }             }
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: while (pos < len)             {                 b = data[pos];                 pos++;                 switch (b)                 {                     case 255:                         if (sizetill >= size) return (int) laststart;                         sizetill = 0;                         laststart = pos * 8;                         break;                     case 0:                         sizetill += 8;                         break;                     default:                         sizetill += FirstHoleSize[b];                         if (sizetill >= size) return (int) laststart;                         if (MaxHoleSize[b] >= size) return (int) (pos * 8 + MaxHoleOffset[b] - 8);                         sizetill = LastHoleSize[b];                         laststart = pos * 8 - sizetill;                         break;                 }             }
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: while (pos < len)             {                 b = data[pos];                 pos++;                 switch (b)                 {                     case 255:                         if (sizetill >= size) return (int) laststart;                         sizetill = 0;                         laststart = pos * 8;                         break;                     case 0:                         sizetill += 8;                         break;                     default:                         sizetill += FirstHoleSize[b];                         if (sizetill >= size) return (int) laststart;                         if (MaxHoleSize[b] >= size) return (int) (pos * 8 + MaxHoleOffset[b] - 8);                         sizetill = LastHoleSize[b];                         laststart = pos * 8 - sizetill;                         break;                 }             }
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,SetBits,The following statement contains a magic number: Debug.Assert(position >= 0 && size > 0 && position + size <= data.Length * 8);
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,SetBits,The following statement contains a magic number: var startMask = (byte)~(255 >> (8 - (position & 7)));
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,SetBits,The following statement contains a magic number: var startMask = (byte)~(255 >> (8 - (position & 7)));
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,SetBits,The following statement contains a magic number: var startMask = (byte)~(255 >> (8 - (position & 7)));
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,SetBits,The following statement contains a magic number: int startBytePos = position / 8;
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,SetBits,The following statement contains a magic number: var endMask = (byte)(255 >> (7 - ((position + size - 1) & 7)));
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,SetBits,The following statement contains a magic number: var endMask = (byte)(255 >> (7 - ((position + size - 1) & 7)));
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,SetBits,The following statement contains a magic number: var endMask = (byte)(255 >> (7 - ((position + size - 1) & 7)));
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,SetBits,The following statement contains a magic number: int endBytePos = (position + size - 1) / 8;
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,SetBits,The following statement contains a magic number: if (startBytePos == endBytePos)             {                 data[startBytePos] |= (byte)(startMask & endMask);             }             else             {                 data[startBytePos] |= startMask;                 startBytePos++;                 while (startBytePos < endBytePos)                 {                     data[startBytePos] = 255;                     startBytePos++;                 }                 data[endBytePos] |= endMask;             }
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,UnsetBits,The following statement contains a magic number: Debug.Assert(position >= 0 && size > 0 && position + size <= data.Length * 8);
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,UnsetBits,The following statement contains a magic number: var startMask = (byte)~(255 >> (8 - (position & 7)));
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,UnsetBits,The following statement contains a magic number: var startMask = (byte)~(255 >> (8 - (position & 7)));
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,UnsetBits,The following statement contains a magic number: var startMask = (byte)~(255 >> (8 - (position & 7)));
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,UnsetBits,The following statement contains a magic number: int startBytePos = position / 8;
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,UnsetBits,The following statement contains a magic number: var endMask = (byte)(255 >> (7 - ((position + size - 1) & 7)));
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,UnsetBits,The following statement contains a magic number: var endMask = (byte)(255 >> (7 - ((position + size - 1) & 7)));
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,UnsetBits,The following statement contains a magic number: var endMask = (byte)(255 >> (7 - ((position + size - 1) & 7)));
Magic Number,BTDB.Buffer,BitArrayManipulation,C:\repos\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,UnsetBits,The following statement contains a magic number: int endBytePos = (position + size - 1) / 8;
Magic Number,BTDB.Buffer,Checksum,C:\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: while (length > 0)             {                 uint tlen = length > 360 ? 360 : length;                 length -= tlen;                 do                 {                     sum1 += (uint)(data[position] + data[position + 1] * 256);                     position += 2;                     sum2 += sum1;                 }                 while (--tlen > 0);                 sum1 = (sum1 & 0xffff) + (sum1 >> 16);                 sum2 = (sum2 & 0xffff) + (sum2 >> 16);             }
Magic Number,BTDB.Buffer,Checksum,C:\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: while (length > 0)             {                 uint tlen = length > 360 ? 360 : length;                 length -= tlen;                 do                 {                     sum1 += (uint)(data[position] + data[position + 1] * 256);                     position += 2;                     sum2 += sum1;                 }                 while (--tlen > 0);                 sum1 = (sum1 & 0xffff) + (sum1 >> 16);                 sum2 = (sum2 & 0xffff) + (sum2 >> 16);             }
Magic Number,BTDB.Buffer,Checksum,C:\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: while (length > 0)             {                 uint tlen = length > 360 ? 360 : length;                 length -= tlen;                 do                 {                     sum1 += (uint)(data[position] + data[position + 1] * 256);                     position += 2;                     sum2 += sum1;                 }                 while (--tlen > 0);                 sum1 = (sum1 & 0xffff) + (sum1 >> 16);                 sum2 = (sum2 & 0xffff) + (sum2 >> 16);             }
Magic Number,BTDB.Buffer,Checksum,C:\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: while (length > 0)             {                 uint tlen = length > 360 ? 360 : length;                 length -= tlen;                 do                 {                     sum1 += (uint)(data[position] + data[position + 1] * 256);                     position += 2;                     sum2 += sum1;                 }                 while (--tlen > 0);                 sum1 = (sum1 & 0xffff) + (sum1 >> 16);                 sum2 = (sum2 & 0xffff) + (sum2 >> 16);             }
Magic Number,BTDB.Buffer,Checksum,C:\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: while (length > 0)             {                 uint tlen = length > 360 ? 360 : length;                 length -= tlen;                 do                 {                     sum1 += (uint)(data[position] + data[position + 1] * 256);                     position += 2;                     sum2 += sum1;                 }                 while (--tlen > 0);                 sum1 = (sum1 & 0xffff) + (sum1 >> 16);                 sum2 = (sum2 & 0xffff) + (sum2 >> 16);             }
Magic Number,BTDB.Buffer,Checksum,C:\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: while (length > 0)             {                 uint tlen = length > 360 ? 360 : length;                 length -= tlen;                 do                 {                     sum1 += (uint)(data[position] + data[position + 1] * 256);                     position += 2;                     sum2 += sum1;                 }                 while (--tlen > 0);                 sum1 = (sum1 & 0xffff) + (sum1 >> 16);                 sum2 = (sum2 & 0xffff) + (sum2 >> 16);             }
Magic Number,BTDB.Buffer,Checksum,C:\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: if (odd)             {                 sum1 += data[position];                 sum2 += sum1;                 sum1 = (sum1 & 0xffff) + (sum1 >> 16);                 sum2 = (sum2 & 0xffff) + (sum2 >> 16);             }
Magic Number,BTDB.Buffer,Checksum,C:\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: if (odd)             {                 sum1 += data[position];                 sum2 += sum1;                 sum1 = (sum1 & 0xffff) + (sum1 >> 16);                 sum2 = (sum2 & 0xffff) + (sum2 >> 16);             }
Magic Number,BTDB.Buffer,Checksum,C:\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: sum1 = (sum1 & 0xffff) + (sum1 >> 16);
Magic Number,BTDB.Buffer,Checksum,C:\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: sum2 = (sum2 & 0xffff) + (sum2 >> 16);
Magic Number,BTDB.Buffer,Checksum,C:\repos\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: return sum2 << 16 | sum1;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt16LE,The following statement contains a magic number: data[offset + 1] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt16LE,The following statement contains a magic number: return (ushort)(data[offset] | (data[offset + 1] << 8));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt16LE,The following statement contains a magic number: data[offset + 1] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt16LE,The following statement contains a magic number: return (short)(data[offset] | (data[offset + 1] << 8));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt32LE,The following statement contains a magic number: data[offset + 1] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt32LE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt32LE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt32LE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt32LE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt32LE,The following statement contains a magic number: return (uint)(data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt32LE,The following statement contains a magic number: return (uint)(data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt32LE,The following statement contains a magic number: return (uint)(data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt32LE,The following statement contains a magic number: return (uint)(data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt32LE,The following statement contains a magic number: return (uint)(data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32LE,The following statement contains a magic number: data[offset + 1] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32LE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32LE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32LE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32LE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32BE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32BE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32BE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32BE,The following statement contains a magic number: data[offset + 1] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32BE,The following statement contains a magic number: data[offset] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32LE,The following statement contains a magic number: return data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32LE,The following statement contains a magic number: return data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32LE,The following statement contains a magic number: return data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32LE,The following statement contains a magic number: return data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32LE,The following statement contains a magic number: return data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32BE,The following statement contains a magic number: return data[offset + 3] | (data[offset + 2] << 8) | (data[offset + 1] << 16) | (data[offset] << 24);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32BE,The following statement contains a magic number: return data[offset + 3] | (data[offset + 2] << 8) | (data[offset + 1] << 16) | (data[offset] << 24);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32BE,The following statement contains a magic number: return data[offset + 3] | (data[offset + 2] << 8) | (data[offset + 1] << 16) | (data[offset] << 24);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32BE,The following statement contains a magic number: return data[offset + 3] | (data[offset + 2] << 8) | (data[offset + 1] << 16) | (data[offset] << 24);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32BE,The following statement contains a magic number: return data[offset + 3] | (data[offset + 2] << 8) | (data[offset + 1] << 16) | (data[offset] << 24);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 1] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 4] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 4] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 5] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 5] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 6] = unchecked((byte)(value >> 48));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 6] = unchecked((byte)(value >> 48));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 7] = unchecked((byte)(value >> 56));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data[offset + 7] = unchecked((byte)(value >> 56));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data[offset] | ((ulong)data[offset + 1] << 8) |                    ((ulong)data[offset + 2] << 16) | ((ulong)data[offset + 3] << 24) |                    ((ulong)data[offset + 4] << 32) | ((ulong)data[offset + 5] << 40) |                    ((ulong)data[offset + 6] << 48) | ((ulong)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 1] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 4] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 4] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 5] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 5] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 6] = unchecked((byte)(value >> 48));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 6] = unchecked((byte)(value >> 48));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 7] = unchecked((byte)(value >> 56));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data[offset + 7] = unchecked((byte)(value >> 56));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 7] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 6] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 6] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 5] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 5] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 4] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 4] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 3] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 2] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset + 1] = unchecked((byte)(value >> 48));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data[offset] = unchecked((byte)(value >> 56));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data[offset] | ((long)data[offset + 1] << 8) |                    ((long)data[offset + 2] << 16) | ((long)data[offset + 3] << 24) |                    ((long)data[offset + 4] << 32) | ((long)data[offset + 5] << 40) |                    ((long)data[offset + 6] << 48) | ((long)data[offset + 7] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data[offset + 7] | ((long)data[offset + 6] << 8) |                    ((long)data[offset + 5] << 16) | ((long)data[offset + 4] << 24) |                    ((long)data[offset + 3] << 32) | ((long)data[offset + 2] << 40) |                    ((long)data[offset + 1] << 48) | ((long)data[offset] << 56);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (value < 0x4000) return 2;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (value < 0x200000) return 3;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (value < 0x10000000) return 4;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 5;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (value < 0x4000) return 2;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (value < 0x200000) return 3;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (value < 0x10000000) return 4;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (value < 0x0800000000) return 5;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (value < 0x040000000000) return 6;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (value < 0x02000000000000) return 7;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (value < 0x0100000000000000) return 8;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 9;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (first < 0xC0) return 2;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (first < 0xE0) return 3;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (first < 0xF0) return 4;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (first < 0xF8) return 5;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (first < 0xFC) return 6;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (first < 0xFE) return 7;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return first == 0xFE ? 8 : 9;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return first == 0xFE ? 8 : 9;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x4000)             {                 data[ofs] = (byte)(0x80 + (value >> 8));                 data[ofs + 1] = unchecked((byte)value);                 ofs += 2;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x4000)             {                 data[ofs] = (byte)(0x80 + (value >> 8));                 data[ofs + 1] = unchecked((byte)value);                 ofs += 2;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x200000)             {                 data[ofs] = (byte)(0xC0 + (value >> 16));                 data[ofs + 1] = unchecked((byte)(value >> 8));                 data[ofs + 2] = unchecked((byte)value);                 ofs += 3;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x200000)             {                 data[ofs] = (byte)(0xC0 + (value >> 16));                 data[ofs + 1] = unchecked((byte)(value >> 8));                 data[ofs + 2] = unchecked((byte)value);                 ofs += 3;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x200000)             {                 data[ofs] = (byte)(0xC0 + (value >> 16));                 data[ofs + 1] = unchecked((byte)(value >> 8));                 data[ofs + 2] = unchecked((byte)value);                 ofs += 3;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x200000)             {                 data[ofs] = (byte)(0xC0 + (value >> 16));                 data[ofs + 1] = unchecked((byte)(value >> 8));                 data[ofs + 2] = unchecked((byte)value);                 ofs += 3;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000)             {                 data[ofs] = (byte)(0xE0 + (value >> 24));                 data[ofs + 1] = unchecked((byte)(value >> 16));                 data[ofs + 2] = unchecked((byte)(value >> 8));                 data[ofs + 3] = unchecked((byte)value);                 ofs += 4;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000)             {                 data[ofs] = (byte)(0xE0 + (value >> 24));                 data[ofs + 1] = unchecked((byte)(value >> 16));                 data[ofs + 2] = unchecked((byte)(value >> 8));                 data[ofs + 3] = unchecked((byte)value);                 ofs += 4;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000)             {                 data[ofs] = (byte)(0xE0 + (value >> 24));                 data[ofs + 1] = unchecked((byte)(value >> 16));                 data[ofs + 2] = unchecked((byte)(value >> 8));                 data[ofs + 3] = unchecked((byte)value);                 ofs += 4;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000)             {                 data[ofs] = (byte)(0xE0 + (value >> 24));                 data[ofs + 1] = unchecked((byte)(value >> 16));                 data[ofs + 2] = unchecked((byte)(value >> 8));                 data[ofs + 3] = unchecked((byte)value);                 ofs += 4;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000)             {                 data[ofs] = (byte)(0xE0 + (value >> 24));                 data[ofs + 1] = unchecked((byte)(value >> 16));                 data[ofs + 2] = unchecked((byte)(value >> 8));                 data[ofs + 3] = unchecked((byte)value);                 ofs += 4;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000)             {                 data[ofs] = (byte)(0xE0 + (value >> 24));                 data[ofs + 1] = unchecked((byte)(value >> 16));                 data[ofs + 2] = unchecked((byte)(value >> 8));                 data[ofs + 3] = unchecked((byte)value);                 ofs += 4;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 1] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 5;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x4000)             {                 data[ofs] = (byte)(0x80 + (value >> 8));                 data[ofs + 1] = unchecked((byte)value);                 ofs += 2;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x4000)             {                 data[ofs] = (byte)(0x80 + (value >> 8));                 data[ofs + 1] = unchecked((byte)value);                 ofs += 2;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x200000)             {                 data[ofs] = (byte)(0xC0 + (value >> 16));                 data[ofs + 1] = unchecked((byte)(value >> 8));                 data[ofs + 2] = unchecked((byte)value);                 ofs += 3;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x200000)             {                 data[ofs] = (byte)(0xC0 + (value >> 16));                 data[ofs + 1] = unchecked((byte)(value >> 8));                 data[ofs + 2] = unchecked((byte)value);                 ofs += 3;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x200000)             {                 data[ofs] = (byte)(0xC0 + (value >> 16));                 data[ofs + 1] = unchecked((byte)(value >> 8));                 data[ofs + 2] = unchecked((byte)value);                 ofs += 3;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x200000)             {                 data[ofs] = (byte)(0xC0 + (value >> 16));                 data[ofs + 1] = unchecked((byte)(value >> 8));                 data[ofs + 2] = unchecked((byte)value);                 ofs += 3;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000)             {                 data[ofs] = (byte)(0xE0 + (value >> 24));                 data[ofs + 1] = unchecked((byte)(value >> 16));                 data[ofs + 2] = unchecked((byte)(value >> 8));                 data[ofs + 3] = unchecked((byte)value);                 ofs += 4;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000)             {                 data[ofs] = (byte)(0xE0 + (value >> 24));                 data[ofs + 1] = unchecked((byte)(value >> 16));                 data[ofs + 2] = unchecked((byte)(value >> 8));                 data[ofs + 3] = unchecked((byte)value);                 ofs += 4;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000)             {                 data[ofs] = (byte)(0xE0 + (value >> 24));                 data[ofs + 1] = unchecked((byte)(value >> 16));                 data[ofs + 2] = unchecked((byte)(value >> 8));                 data[ofs + 3] = unchecked((byte)value);                 ofs += 4;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000)             {                 data[ofs] = (byte)(0xE0 + (value >> 24));                 data[ofs + 1] = unchecked((byte)(value >> 16));                 data[ofs + 2] = unchecked((byte)(value >> 8));                 data[ofs + 3] = unchecked((byte)value);                 ofs += 4;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000)             {                 data[ofs] = (byte)(0xE0 + (value >> 24));                 data[ofs + 1] = unchecked((byte)(value >> 16));                 data[ofs + 2] = unchecked((byte)(value >> 8));                 data[ofs + 3] = unchecked((byte)value);                 ofs += 4;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000)             {                 data[ofs] = (byte)(0xE0 + (value >> 24));                 data[ofs + 1] = unchecked((byte)(value >> 16));                 data[ofs + 2] = unchecked((byte)(value >> 8));                 data[ofs + 3] = unchecked((byte)value);                 ofs += 4;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0800000000)             {                 data[ofs] = (byte)(0xF0 + (value >> 32));                 data[ofs + 1] = unchecked((byte)(value >> 24));                 data[ofs + 2] = unchecked((byte)(value >> 16));                 data[ofs + 3] = unchecked((byte)(value >> 8));                 data[ofs + 4] = unchecked((byte)value);                 ofs += 5;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0800000000)             {                 data[ofs] = (byte)(0xF0 + (value >> 32));                 data[ofs + 1] = unchecked((byte)(value >> 24));                 data[ofs + 2] = unchecked((byte)(value >> 16));                 data[ofs + 3] = unchecked((byte)(value >> 8));                 data[ofs + 4] = unchecked((byte)value);                 ofs += 5;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0800000000)             {                 data[ofs] = (byte)(0xF0 + (value >> 32));                 data[ofs + 1] = unchecked((byte)(value >> 24));                 data[ofs + 2] = unchecked((byte)(value >> 16));                 data[ofs + 3] = unchecked((byte)(value >> 8));                 data[ofs + 4] = unchecked((byte)value);                 ofs += 5;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0800000000)             {                 data[ofs] = (byte)(0xF0 + (value >> 32));                 data[ofs + 1] = unchecked((byte)(value >> 24));                 data[ofs + 2] = unchecked((byte)(value >> 16));                 data[ofs + 3] = unchecked((byte)(value >> 8));                 data[ofs + 4] = unchecked((byte)value);                 ofs += 5;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0800000000)             {                 data[ofs] = (byte)(0xF0 + (value >> 32));                 data[ofs + 1] = unchecked((byte)(value >> 24));                 data[ofs + 2] = unchecked((byte)(value >> 16));                 data[ofs + 3] = unchecked((byte)(value >> 8));                 data[ofs + 4] = unchecked((byte)value);                 ofs += 5;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0800000000)             {                 data[ofs] = (byte)(0xF0 + (value >> 32));                 data[ofs + 1] = unchecked((byte)(value >> 24));                 data[ofs + 2] = unchecked((byte)(value >> 16));                 data[ofs + 3] = unchecked((byte)(value >> 8));                 data[ofs + 4] = unchecked((byte)value);                 ofs += 5;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0800000000)             {                 data[ofs] = (byte)(0xF0 + (value >> 32));                 data[ofs + 1] = unchecked((byte)(value >> 24));                 data[ofs + 2] = unchecked((byte)(value >> 16));                 data[ofs + 3] = unchecked((byte)(value >> 8));                 data[ofs + 4] = unchecked((byte)value);                 ofs += 5;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0800000000)             {                 data[ofs] = (byte)(0xF0 + (value >> 32));                 data[ofs + 1] = unchecked((byte)(value >> 24));                 data[ofs + 2] = unchecked((byte)(value >> 16));                 data[ofs + 3] = unchecked((byte)(value >> 8));                 data[ofs + 4] = unchecked((byte)value);                 ofs += 5;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x040000000000)             {                 data[ofs] = (byte)(0xF8 + (value >> 40));                 data[ofs + 1] = unchecked((byte)(value >> 32));                 data[ofs + 2] = unchecked((byte)(value >> 24));                 data[ofs + 3] = unchecked((byte)(value >> 16));                 data[ofs + 4] = unchecked((byte)(value >> 8));                 data[ofs + 5] = unchecked((byte)value);                 ofs += 6;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x040000000000)             {                 data[ofs] = (byte)(0xF8 + (value >> 40));                 data[ofs + 1] = unchecked((byte)(value >> 32));                 data[ofs + 2] = unchecked((byte)(value >> 24));                 data[ofs + 3] = unchecked((byte)(value >> 16));                 data[ofs + 4] = unchecked((byte)(value >> 8));                 data[ofs + 5] = unchecked((byte)value);                 ofs += 6;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x040000000000)             {                 data[ofs] = (byte)(0xF8 + (value >> 40));                 data[ofs + 1] = unchecked((byte)(value >> 32));                 data[ofs + 2] = unchecked((byte)(value >> 24));                 data[ofs + 3] = unchecked((byte)(value >> 16));                 data[ofs + 4] = unchecked((byte)(value >> 8));                 data[ofs + 5] = unchecked((byte)value);                 ofs += 6;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x040000000000)             {                 data[ofs] = (byte)(0xF8 + (value >> 40));                 data[ofs + 1] = unchecked((byte)(value >> 32));                 data[ofs + 2] = unchecked((byte)(value >> 24));                 data[ofs + 3] = unchecked((byte)(value >> 16));                 data[ofs + 4] = unchecked((byte)(value >> 8));                 data[ofs + 5] = unchecked((byte)value);                 ofs += 6;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x040000000000)             {                 data[ofs] = (byte)(0xF8 + (value >> 40));                 data[ofs + 1] = unchecked((byte)(value >> 32));                 data[ofs + 2] = unchecked((byte)(value >> 24));                 data[ofs + 3] = unchecked((byte)(value >> 16));                 data[ofs + 4] = unchecked((byte)(value >> 8));                 data[ofs + 5] = unchecked((byte)value);                 ofs += 6;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x040000000000)             {                 data[ofs] = (byte)(0xF8 + (value >> 40));                 data[ofs + 1] = unchecked((byte)(value >> 32));                 data[ofs + 2] = unchecked((byte)(value >> 24));                 data[ofs + 3] = unchecked((byte)(value >> 16));                 data[ofs + 4] = unchecked((byte)(value >> 8));                 data[ofs + 5] = unchecked((byte)value);                 ofs += 6;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x040000000000)             {                 data[ofs] = (byte)(0xF8 + (value >> 40));                 data[ofs + 1] = unchecked((byte)(value >> 32));                 data[ofs + 2] = unchecked((byte)(value >> 24));                 data[ofs + 3] = unchecked((byte)(value >> 16));                 data[ofs + 4] = unchecked((byte)(value >> 8));                 data[ofs + 5] = unchecked((byte)value);                 ofs += 6;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x040000000000)             {                 data[ofs] = (byte)(0xF8 + (value >> 40));                 data[ofs + 1] = unchecked((byte)(value >> 32));                 data[ofs + 2] = unchecked((byte)(value >> 24));                 data[ofs + 3] = unchecked((byte)(value >> 16));                 data[ofs + 4] = unchecked((byte)(value >> 8));                 data[ofs + 5] = unchecked((byte)value);                 ofs += 6;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x040000000000)             {                 data[ofs] = (byte)(0xF8 + (value >> 40));                 data[ofs + 1] = unchecked((byte)(value >> 32));                 data[ofs + 2] = unchecked((byte)(value >> 24));                 data[ofs + 3] = unchecked((byte)(value >> 16));                 data[ofs + 4] = unchecked((byte)(value >> 8));                 data[ofs + 5] = unchecked((byte)value);                 ofs += 6;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x040000000000)             {                 data[ofs] = (byte)(0xF8 + (value >> 40));                 data[ofs + 1] = unchecked((byte)(value >> 32));                 data[ofs + 2] = unchecked((byte)(value >> 24));                 data[ofs + 3] = unchecked((byte)(value >> 16));                 data[ofs + 4] = unchecked((byte)(value >> 8));                 data[ofs + 5] = unchecked((byte)value);                 ofs += 6;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000)             {                 data[ofs] = (byte)(0xFC + (value >> 48));                 data[ofs + 1] = unchecked((byte)(value >> 40));                 data[ofs + 2] = unchecked((byte)(value >> 32));                 data[ofs + 3] = unchecked((byte)(value >> 24));                 data[ofs + 4] = unchecked((byte)(value >> 16));                 data[ofs + 5] = unchecked((byte)(value >> 8));                 data[ofs + 6] = unchecked((byte)value);                 ofs += 7;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000)             {                 data[ofs] = (byte)(0xFC + (value >> 48));                 data[ofs + 1] = unchecked((byte)(value >> 40));                 data[ofs + 2] = unchecked((byte)(value >> 32));                 data[ofs + 3] = unchecked((byte)(value >> 24));                 data[ofs + 4] = unchecked((byte)(value >> 16));                 data[ofs + 5] = unchecked((byte)(value >> 8));                 data[ofs + 6] = unchecked((byte)value);                 ofs += 7;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000)             {                 data[ofs] = (byte)(0xFC + (value >> 48));                 data[ofs + 1] = unchecked((byte)(value >> 40));                 data[ofs + 2] = unchecked((byte)(value >> 32));                 data[ofs + 3] = unchecked((byte)(value >> 24));                 data[ofs + 4] = unchecked((byte)(value >> 16));                 data[ofs + 5] = unchecked((byte)(value >> 8));                 data[ofs + 6] = unchecked((byte)value);                 ofs += 7;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000)             {                 data[ofs] = (byte)(0xFC + (value >> 48));                 data[ofs + 1] = unchecked((byte)(value >> 40));                 data[ofs + 2] = unchecked((byte)(value >> 32));                 data[ofs + 3] = unchecked((byte)(value >> 24));                 data[ofs + 4] = unchecked((byte)(value >> 16));                 data[ofs + 5] = unchecked((byte)(value >> 8));                 data[ofs + 6] = unchecked((byte)value);                 ofs += 7;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000)             {                 data[ofs] = (byte)(0xFC + (value >> 48));                 data[ofs + 1] = unchecked((byte)(value >> 40));                 data[ofs + 2] = unchecked((byte)(value >> 32));                 data[ofs + 3] = unchecked((byte)(value >> 24));                 data[ofs + 4] = unchecked((byte)(value >> 16));                 data[ofs + 5] = unchecked((byte)(value >> 8));                 data[ofs + 6] = unchecked((byte)value);                 ofs += 7;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000)             {                 data[ofs] = (byte)(0xFC + (value >> 48));                 data[ofs + 1] = unchecked((byte)(value >> 40));                 data[ofs + 2] = unchecked((byte)(value >> 32));                 data[ofs + 3] = unchecked((byte)(value >> 24));                 data[ofs + 4] = unchecked((byte)(value >> 16));                 data[ofs + 5] = unchecked((byte)(value >> 8));                 data[ofs + 6] = unchecked((byte)value);                 ofs += 7;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000)             {                 data[ofs] = (byte)(0xFC + (value >> 48));                 data[ofs + 1] = unchecked((byte)(value >> 40));                 data[ofs + 2] = unchecked((byte)(value >> 32));                 data[ofs + 3] = unchecked((byte)(value >> 24));                 data[ofs + 4] = unchecked((byte)(value >> 16));                 data[ofs + 5] = unchecked((byte)(value >> 8));                 data[ofs + 6] = unchecked((byte)value);                 ofs += 7;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000)             {                 data[ofs] = (byte)(0xFC + (value >> 48));                 data[ofs + 1] = unchecked((byte)(value >> 40));                 data[ofs + 2] = unchecked((byte)(value >> 32));                 data[ofs + 3] = unchecked((byte)(value >> 24));                 data[ofs + 4] = unchecked((byte)(value >> 16));                 data[ofs + 5] = unchecked((byte)(value >> 8));                 data[ofs + 6] = unchecked((byte)value);                 ofs += 7;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000)             {                 data[ofs] = (byte)(0xFC + (value >> 48));                 data[ofs + 1] = unchecked((byte)(value >> 40));                 data[ofs + 2] = unchecked((byte)(value >> 32));                 data[ofs + 3] = unchecked((byte)(value >> 24));                 data[ofs + 4] = unchecked((byte)(value >> 16));                 data[ofs + 5] = unchecked((byte)(value >> 8));                 data[ofs + 6] = unchecked((byte)value);                 ofs += 7;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000)             {                 data[ofs] = (byte)(0xFC + (value >> 48));                 data[ofs + 1] = unchecked((byte)(value >> 40));                 data[ofs + 2] = unchecked((byte)(value >> 32));                 data[ofs + 3] = unchecked((byte)(value >> 24));                 data[ofs + 4] = unchecked((byte)(value >> 16));                 data[ofs + 5] = unchecked((byte)(value >> 8));                 data[ofs + 6] = unchecked((byte)value);                 ofs += 7;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000)             {                 data[ofs] = (byte)(0xFC + (value >> 48));                 data[ofs + 1] = unchecked((byte)(value >> 40));                 data[ofs + 2] = unchecked((byte)(value >> 32));                 data[ofs + 3] = unchecked((byte)(value >> 24));                 data[ofs + 4] = unchecked((byte)(value >> 16));                 data[ofs + 5] = unchecked((byte)(value >> 8));                 data[ofs + 6] = unchecked((byte)value);                 ofs += 7;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000)             {                 data[ofs] = (byte)(0xFC + (value >> 48));                 data[ofs + 1] = unchecked((byte)(value >> 40));                 data[ofs + 2] = unchecked((byte)(value >> 32));                 data[ofs + 3] = unchecked((byte)(value >> 24));                 data[ofs + 4] = unchecked((byte)(value >> 16));                 data[ofs + 5] = unchecked((byte)(value >> 8));                 data[ofs + 6] = unchecked((byte)value);                 ofs += 7;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000)             {                 data[ofs] = (byte)(0xFE + (value >> 56));                 data[ofs + 1] = unchecked((byte)(value >> 48));                 data[ofs + 2] = unchecked((byte)(value >> 40));                 data[ofs + 3] = unchecked((byte)(value >> 32));                 data[ofs + 4] = unchecked((byte)(value >> 24));                 data[ofs + 5] = unchecked((byte)(value >> 16));                 data[ofs + 6] = unchecked((byte)(value >> 8));                 data[ofs + 7] = unchecked((byte)value);                 ofs += 8;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000)             {                 data[ofs] = (byte)(0xFE + (value >> 56));                 data[ofs + 1] = unchecked((byte)(value >> 48));                 data[ofs + 2] = unchecked((byte)(value >> 40));                 data[ofs + 3] = unchecked((byte)(value >> 32));                 data[ofs + 4] = unchecked((byte)(value >> 24));                 data[ofs + 5] = unchecked((byte)(value >> 16));                 data[ofs + 6] = unchecked((byte)(value >> 8));                 data[ofs + 7] = unchecked((byte)value);                 ofs += 8;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000)             {                 data[ofs] = (byte)(0xFE + (value >> 56));                 data[ofs + 1] = unchecked((byte)(value >> 48));                 data[ofs + 2] = unchecked((byte)(value >> 40));                 data[ofs + 3] = unchecked((byte)(value >> 32));                 data[ofs + 4] = unchecked((byte)(value >> 24));                 data[ofs + 5] = unchecked((byte)(value >> 16));                 data[ofs + 6] = unchecked((byte)(value >> 8));                 data[ofs + 7] = unchecked((byte)value);                 ofs += 8;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000)             {                 data[ofs] = (byte)(0xFE + (value >> 56));                 data[ofs + 1] = unchecked((byte)(value >> 48));                 data[ofs + 2] = unchecked((byte)(value >> 40));                 data[ofs + 3] = unchecked((byte)(value >> 32));                 data[ofs + 4] = unchecked((byte)(value >> 24));                 data[ofs + 5] = unchecked((byte)(value >> 16));                 data[ofs + 6] = unchecked((byte)(value >> 8));                 data[ofs + 7] = unchecked((byte)value);                 ofs += 8;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000)             {                 data[ofs] = (byte)(0xFE + (value >> 56));                 data[ofs + 1] = unchecked((byte)(value >> 48));                 data[ofs + 2] = unchecked((byte)(value >> 40));                 data[ofs + 3] = unchecked((byte)(value >> 32));                 data[ofs + 4] = unchecked((byte)(value >> 24));                 data[ofs + 5] = unchecked((byte)(value >> 16));                 data[ofs + 6] = unchecked((byte)(value >> 8));                 data[ofs + 7] = unchecked((byte)value);                 ofs += 8;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000)             {                 data[ofs] = (byte)(0xFE + (value >> 56));                 data[ofs + 1] = unchecked((byte)(value >> 48));                 data[ofs + 2] = unchecked((byte)(value >> 40));                 data[ofs + 3] = unchecked((byte)(value >> 32));                 data[ofs + 4] = unchecked((byte)(value >> 24));                 data[ofs + 5] = unchecked((byte)(value >> 16));                 data[ofs + 6] = unchecked((byte)(value >> 8));                 data[ofs + 7] = unchecked((byte)value);                 ofs += 8;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000)             {                 data[ofs] = (byte)(0xFE + (value >> 56));                 data[ofs + 1] = unchecked((byte)(value >> 48));                 data[ofs + 2] = unchecked((byte)(value >> 40));                 data[ofs + 3] = unchecked((byte)(value >> 32));                 data[ofs + 4] = unchecked((byte)(value >> 24));                 data[ofs + 5] = unchecked((byte)(value >> 16));                 data[ofs + 6] = unchecked((byte)(value >> 8));                 data[ofs + 7] = unchecked((byte)value);                 ofs += 8;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000)             {                 data[ofs] = (byte)(0xFE + (value >> 56));                 data[ofs + 1] = unchecked((byte)(value >> 48));                 data[ofs + 2] = unchecked((byte)(value >> 40));                 data[ofs + 3] = unchecked((byte)(value >> 32));                 data[ofs + 4] = unchecked((byte)(value >> 24));                 data[ofs + 5] = unchecked((byte)(value >> 16));                 data[ofs + 6] = unchecked((byte)(value >> 8));                 data[ofs + 7] = unchecked((byte)value);                 ofs += 8;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000)             {                 data[ofs] = (byte)(0xFE + (value >> 56));                 data[ofs + 1] = unchecked((byte)(value >> 48));                 data[ofs + 2] = unchecked((byte)(value >> 40));                 data[ofs + 3] = unchecked((byte)(value >> 32));                 data[ofs + 4] = unchecked((byte)(value >> 24));                 data[ofs + 5] = unchecked((byte)(value >> 16));                 data[ofs + 6] = unchecked((byte)(value >> 8));                 data[ofs + 7] = unchecked((byte)value);                 ofs += 8;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000)             {                 data[ofs] = (byte)(0xFE + (value >> 56));                 data[ofs + 1] = unchecked((byte)(value >> 48));                 data[ofs + 2] = unchecked((byte)(value >> 40));                 data[ofs + 3] = unchecked((byte)(value >> 32));                 data[ofs + 4] = unchecked((byte)(value >> 24));                 data[ofs + 5] = unchecked((byte)(value >> 16));                 data[ofs + 6] = unchecked((byte)(value >> 8));                 data[ofs + 7] = unchecked((byte)value);                 ofs += 8;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000)             {                 data[ofs] = (byte)(0xFE + (value >> 56));                 data[ofs + 1] = unchecked((byte)(value >> 48));                 data[ofs + 2] = unchecked((byte)(value >> 40));                 data[ofs + 3] = unchecked((byte)(value >> 32));                 data[ofs + 4] = unchecked((byte)(value >> 24));                 data[ofs + 5] = unchecked((byte)(value >> 16));                 data[ofs + 6] = unchecked((byte)(value >> 8));                 data[ofs + 7] = unchecked((byte)value);                 ofs += 8;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000)             {                 data[ofs] = (byte)(0xFE + (value >> 56));                 data[ofs + 1] = unchecked((byte)(value >> 48));                 data[ofs + 2] = unchecked((byte)(value >> 40));                 data[ofs + 3] = unchecked((byte)(value >> 32));                 data[ofs + 4] = unchecked((byte)(value >> 24));                 data[ofs + 5] = unchecked((byte)(value >> 16));                 data[ofs + 6] = unchecked((byte)(value >> 8));                 data[ofs + 7] = unchecked((byte)value);                 ofs += 8;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000)             {                 data[ofs] = (byte)(0xFE + (value >> 56));                 data[ofs + 1] = unchecked((byte)(value >> 48));                 data[ofs + 2] = unchecked((byte)(value >> 40));                 data[ofs + 3] = unchecked((byte)(value >> 32));                 data[ofs + 4] = unchecked((byte)(value >> 24));                 data[ofs + 5] = unchecked((byte)(value >> 16));                 data[ofs + 6] = unchecked((byte)(value >> 8));                 data[ofs + 7] = unchecked((byte)value);                 ofs += 8;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000)             {                 data[ofs] = (byte)(0xFE + (value >> 56));                 data[ofs + 1] = unchecked((byte)(value >> 48));                 data[ofs + 2] = unchecked((byte)(value >> 40));                 data[ofs + 3] = unchecked((byte)(value >> 32));                 data[ofs + 4] = unchecked((byte)(value >> 24));                 data[ofs + 5] = unchecked((byte)(value >> 16));                 data[ofs + 6] = unchecked((byte)(value >> 8));                 data[ofs + 7] = unchecked((byte)value);                 ofs += 8;                 return;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 1] = unchecked((byte)(value >> 56));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 48));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 48));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 5] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 5] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 6] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 6] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 7] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 7] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data[ofs + 8] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 9;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xC0)             {                 result = ((first & 0x3F) << 8) + data[ofs];                 ofs++;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xE0)             {                 result = ((first & 0x1Fu) << 16) + ((uint)data[ofs] << 8) + data[ofs + 1];                 ofs += 2;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xE0)             {                 result = ((first & 0x1Fu) << 16) + ((uint)data[ofs] << 8) + data[ofs + 1];                 ofs += 2;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xE0)             {                 result = ((first & 0x1Fu) << 16) + ((uint)data[ofs] << 8) + data[ofs + 1];                 ofs += 2;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF0)             {                 result = ((first & 0x0Fu) << 24) + ((uint)data[ofs] << 16) + ((uint)data[ofs + 1] << 8) + data[ofs + 2];                 ofs += 3;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF0)             {                 result = ((first & 0x0Fu) << 24) + ((uint)data[ofs] << 16) + ((uint)data[ofs + 1] << 8) + data[ofs + 2];                 ofs += 3;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF0)             {                 result = ((first & 0x0Fu) << 24) + ((uint)data[ofs] << 16) + ((uint)data[ofs + 1] << 8) + data[ofs + 2];                 ofs += 3;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF0)             {                 result = ((first & 0x0Fu) << 24) + ((uint)data[ofs] << 16) + ((uint)data[ofs + 1] << 8) + data[ofs + 2];                 ofs += 3;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF0)             {                 result = ((first & 0x0Fu) << 24) + ((uint)data[ofs] << 16) + ((uint)data[ofs + 1] << 8) + data[ofs + 2];                 ofs += 3;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF8)             {                 result = ((ulong)(first & 0x07u) << 32) + ((uint)data[ofs] << 24) + ((uint)data[ofs + 1] << 16)                     + ((uint)data[ofs + 2] << 8) + data[ofs + 3];                 ofs += 4;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF8)             {                 result = ((ulong)(first & 0x07u) << 32) + ((uint)data[ofs] << 24) + ((uint)data[ofs + 1] << 16)                     + ((uint)data[ofs + 2] << 8) + data[ofs + 3];                 ofs += 4;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF8)             {                 result = ((ulong)(first & 0x07u) << 32) + ((uint)data[ofs] << 24) + ((uint)data[ofs + 1] << 16)                     + ((uint)data[ofs + 2] << 8) + data[ofs + 3];                 ofs += 4;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF8)             {                 result = ((ulong)(first & 0x07u) << 32) + ((uint)data[ofs] << 24) + ((uint)data[ofs + 1] << 16)                     + ((uint)data[ofs + 2] << 8) + data[ofs + 3];                 ofs += 4;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF8)             {                 result = ((ulong)(first & 0x07u) << 32) + ((uint)data[ofs] << 24) + ((uint)data[ofs + 1] << 16)                     + ((uint)data[ofs + 2] << 8) + data[ofs + 3];                 ofs += 4;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF8)             {                 result = ((ulong)(first & 0x07u) << 32) + ((uint)data[ofs] << 24) + ((uint)data[ofs + 1] << 16)                     + ((uint)data[ofs + 2] << 8) + data[ofs + 3];                 ofs += 4;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF8)             {                 result = ((ulong)(first & 0x07u) << 32) + ((uint)data[ofs] << 24) + ((uint)data[ofs + 1] << 16)                     + ((uint)data[ofs + 2] << 8) + data[ofs + 3];                 ofs += 4;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFC)             {                 result = ((ulong)(first & 0x03u) << 40) + ((ulong)data[ofs] << 32) + ((uint)data[ofs + 1] << 24)                     + ((uint)data[ofs + 2] << 16) + ((uint)data[ofs + 3] << 8) + data[ofs + 4];                 ofs += 5;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFC)             {                 result = ((ulong)(first & 0x03u) << 40) + ((ulong)data[ofs] << 32) + ((uint)data[ofs + 1] << 24)                     + ((uint)data[ofs + 2] << 16) + ((uint)data[ofs + 3] << 8) + data[ofs + 4];                 ofs += 5;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFC)             {                 result = ((ulong)(first & 0x03u) << 40) + ((ulong)data[ofs] << 32) + ((uint)data[ofs + 1] << 24)                     + ((uint)data[ofs + 2] << 16) + ((uint)data[ofs + 3] << 8) + data[ofs + 4];                 ofs += 5;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFC)             {                 result = ((ulong)(first & 0x03u) << 40) + ((ulong)data[ofs] << 32) + ((uint)data[ofs + 1] << 24)                     + ((uint)data[ofs + 2] << 16) + ((uint)data[ofs + 3] << 8) + data[ofs + 4];                 ofs += 5;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFC)             {                 result = ((ulong)(first & 0x03u) << 40) + ((ulong)data[ofs] << 32) + ((uint)data[ofs + 1] << 24)                     + ((uint)data[ofs + 2] << 16) + ((uint)data[ofs + 3] << 8) + data[ofs + 4];                 ofs += 5;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFC)             {                 result = ((ulong)(first & 0x03u) << 40) + ((ulong)data[ofs] << 32) + ((uint)data[ofs + 1] << 24)                     + ((uint)data[ofs + 2] << 16) + ((uint)data[ofs + 3] << 8) + data[ofs + 4];                 ofs += 5;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFC)             {                 result = ((ulong)(first & 0x03u) << 40) + ((ulong)data[ofs] << 32) + ((uint)data[ofs + 1] << 24)                     + ((uint)data[ofs + 2] << 16) + ((uint)data[ofs + 3] << 8) + data[ofs + 4];                 ofs += 5;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFC)             {                 result = ((ulong)(first & 0x03u) << 40) + ((ulong)data[ofs] << 32) + ((uint)data[ofs + 1] << 24)                     + ((uint)data[ofs + 2] << 16) + ((uint)data[ofs + 3] << 8) + data[ofs + 4];                 ofs += 5;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFC)             {                 result = ((ulong)(first & 0x03u) << 40) + ((ulong)data[ofs] << 32) + ((uint)data[ofs + 1] << 24)                     + ((uint)data[ofs + 2] << 16) + ((uint)data[ofs + 3] << 8) + data[ofs + 4];                 ofs += 5;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE)             {                 result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE)             {                 result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE)             {                 result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE)             {                 result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE)             {                 result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE)             {                 result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE)             {                 result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE)             {                 result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE)             {                 result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE)             {                 result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE)             {                 result = ((ulong)(first & 0x01u) << 48) + ((ulong)data[ofs] << 40) + ((ulong)data[ofs + 1] << 32)                     + ((uint)data[ofs + 2] << 24) + ((uint)data[ofs + 3] << 16) + ((uint)data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE)             {                 result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];                 ofs += 7;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE)             {                 result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];                 ofs += 7;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE)             {                 result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];                 ofs += 7;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE)             {                 result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];                 ofs += 7;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE)             {                 result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];                 ofs += 7;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE)             {                 result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];                 ofs += 7;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE)             {                 result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];                 ofs += 7;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE)             {                 result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];                 ofs += 7;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE)             {                 result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];                 ofs += 7;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE)             {                 result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];                 ofs += 7;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE)             {                 result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];                 ofs += 7;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE)             {                 result = ((ulong)data[ofs] << 48) + ((ulong)data[ofs + 1] << 40) + ((ulong)data[ofs + 2] << 32)                     + ((uint)data[ofs + 3] << 24) + ((uint)data[ofs + 4] << 16) + ((uint)data[ofs + 5] << 8) + data[ofs + 6];                 ofs += 7;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data[ofs] << 56) + ((ulong)data[ofs + 1] << 48) + ((ulong)data[ofs + 2] << 40) + ((ulong)data[ofs + 3] << 32)                 + ((uint)data[ofs + 4] << 24) + ((uint)data[ofs + 5] << 16) + ((uint)data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: ofs += 8;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (-0x2000 <= value && value < 0x2000) return 2;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (-0x100000 <= value && value < 0x100000) return 3;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (-0x08000000 <= value && value < 0x08000000) return 4;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 5;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (-0x2000 <= value && value < 0x2000) return 2;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (-0x100000 <= value && value < 0x100000) return 3;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (-0x08000000 <= value && value < 0x08000000) return 4;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (-0x0400000000 <= value && value < 0x0400000000) return 5;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (-0x020000000000 <= value && value < 0x020000000000) return 6;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (-0x01000000000000 <= value && value < 0x01000000000000) return 7;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 9;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (0x20 <= first && first < 0xE0) return 2;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (0x10 <= first && first < 0xF0) return 3;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (0x08 <= first && first < 0xF8) return 4;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (0x04 <= first && first < 0xFC) return 5;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (0x02 <= first && first < 0xFE) return 6;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (0x01 <= first && first < 0xFF) return 7;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 9;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0)             {                 if (value < 0x2000)                 {                     data[ofs] = (byte)(0xC0 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value < 0x100000)                 {                     data[ofs] = (byte)(0xE0 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value < 0x08000000)                 {                     data[ofs] = (byte)(0xF0 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value < 0x0400000000)                 {                     data[ofs] = (byte)(0xF8 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value < 0x020000000000)                 {                     data[ofs] = (byte)(0xFC + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value < 0x01000000000000)                 {                     data[ofs] = 0xFE;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0xFF;             }             else             {                 if (value >= -0x2000)                 {                     data[ofs] = (byte)(0x40 + (value >> 8));                     data[ofs + 1] = unchecked((byte)value);                     ofs += 2;                     return;                 }                 if (value >= -0x100000)                 {                     data[ofs] = (byte)(0x20 + (value >> 16));                     data[ofs + 1] = unchecked((byte)(value >> 8));                     data[ofs + 2] = unchecked((byte)value);                     ofs += 3;                     return;                 }                 if (value >= -0x08000000)                 {                     data[ofs] = (byte)(0x10 + (value >> 24));                     data[ofs + 1] = unchecked((byte)(value >> 16));                     data[ofs + 2] = unchecked((byte)(value >> 8));                     data[ofs + 3] = unchecked((byte)value);                     ofs += 4;                     return;                 }                 if (value >= -0x0400000000)                 {                     data[ofs] = (byte)(0x08 + (value >> 32));                     data[ofs + 1] = unchecked((byte)(value >> 24));                     data[ofs + 2] = unchecked((byte)(value >> 16));                     data[ofs + 3] = unchecked((byte)(value >> 8));                     data[ofs + 4] = unchecked((byte)value);                     ofs += 5;                     return;                 }                 if (value >= -0x020000000000)                 {                     data[ofs] = (byte)(0x04 + (value >> 40));                     data[ofs + 1] = unchecked((byte)(value >> 32));                     data[ofs + 2] = unchecked((byte)(value >> 24));                     data[ofs + 3] = unchecked((byte)(value >> 16));                     data[ofs + 4] = unchecked((byte)(value >> 8));                     data[ofs + 5] = unchecked((byte)value);                     ofs += 6;                     return;                 }                 if (value >= -0x01000000000000)                 {                     data[ofs] = 0x01;                     data[ofs + 1] = unchecked((byte)(value >> 40));                     data[ofs + 2] = unchecked((byte)(value >> 32));                     data[ofs + 3] = unchecked((byte)(value >> 24));                     data[ofs + 4] = unchecked((byte)(value >> 16));                     data[ofs + 5] = unchecked((byte)(value >> 8));                     data[ofs + 6] = unchecked((byte)value);                     ofs += 7;                     return;                 }                 data[ofs] = 0;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 1] = unchecked((byte)(value >> 56));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 48));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 2] = unchecked((byte)(value >> 48));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 3] = unchecked((byte)(value >> 40));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 4] = unchecked((byte)(value >> 32));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 5] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 5] = unchecked((byte)(value >> 24));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 6] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 6] = unchecked((byte)(value >> 16));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 7] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 7] = unchecked((byte)(value >> 8));
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data[ofs + 8] = unchecked((byte)value);
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 9;
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80)             {                 if (first < 0xE0)                 {                     result = ((first & 0x1F) << 8) + data[ofs];                     ofs++;                     return result;                 }                 if (first < 0xF0)                 {                     result = ((first & 0x0F) << 16) + (data[ofs] << 8) + data[ofs + 1];                     ofs += 2;                     return result;                 }                 if (first < 0xF8)                 {                     result = ((first & 0x07) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                     ofs += 3;                     return result;                 }                 if (first < 0xFC)                 {                     result = ((long)(first & 0x03) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                     ofs += 4;                     return result;                 }                 if (first < 0xFE)                 {                     result = ((long)(first & 0x01) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                     ofs += 5;                     return result;                 }                 if (first < 0xFF)                 {                     result = ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                     ofs += 6;                     return result;                 }                 result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                     + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];                 ofs += 8;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x20)             {                 result = ((int)(first - 0x40) << 8) + data[ofs];                 ofs++;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x10)             {                 result = ((int)(first - 0x20) << 16) + (data[ofs] << 8) + data[ofs + 1];                 ofs += 2;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x10)             {                 result = ((int)(first - 0x20) << 16) + (data[ofs] << 8) + data[ofs + 1];                 ofs += 2;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x10)             {                 result = ((int)(first - 0x20) << 16) + (data[ofs] << 8) + data[ofs + 1];                 ofs += 2;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x08)             {                 result = ((int)(first - 0x10) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                 ofs += 3;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x08)             {                 result = ((int)(first - 0x10) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                 ofs += 3;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x08)             {                 result = ((int)(first - 0x10) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                 ofs += 3;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x08)             {                 result = ((int)(first - 0x10) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                 ofs += 3;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x08)             {                 result = ((int)(first - 0x10) << 24) + (data[ofs] << 16) + (data[ofs + 1] << 8) + data[ofs + 2];                 ofs += 3;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x04)             {                 result = ((long)(first - 0x08) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                 ofs += 4;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x04)             {                 result = ((long)(first - 0x08) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                 ofs += 4;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x04)             {                 result = ((long)(first - 0x08) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                 ofs += 4;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x04)             {                 result = ((long)(first - 0x08) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                 ofs += 4;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x04)             {                 result = ((long)(first - 0x08) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                 ofs += 4;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x04)             {                 result = ((long)(first - 0x08) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                 ofs += 4;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x04)             {                 result = ((long)(first - 0x08) << 32) + ((long)data[ofs] << 24) + (data[ofs + 1] << 16) + (data[ofs + 2] << 8) + data[ofs + 3];                 ofs += 4;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x02)             {                 result = ((long)(first - 0x04) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                 ofs += 5;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x02)             {                 result = ((long)(first - 0x04) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                 ofs += 5;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x02)             {                 result = ((long)(first - 0x04) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                 ofs += 5;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x02)             {                 result = ((long)(first - 0x04) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                 ofs += 5;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x02)             {                 result = ((long)(first - 0x04) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                 ofs += 5;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x02)             {                 result = ((long)(first - 0x04) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                 ofs += 5;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x02)             {                 result = ((long)(first - 0x04) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                 ofs += 5;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x02)             {                 result = ((long)(first - 0x04) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                 ofs += 5;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x02)             {                 result = ((long)(first - 0x04) << 40) + ((long)data[ofs] << 32) + ((long)data[ofs + 1] << 24) + (data[ofs + 2] << 16) + (data[ofs + 3] << 8) + data[ofs + 4];                 ofs += 5;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01)             {                 result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01)             {                 result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01)             {                 result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01)             {                 result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01)             {                 result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01)             {                 result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01)             {                 result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01)             {                 result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01)             {                 result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01)             {                 result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01)             {                 result = (-1L << 48) + ((long)data[ofs] << 40) + ((long)data[ofs + 1] << 32) + ((long)data[ofs + 2] << 24) + (data[ofs + 3] << 16) + (data[ofs + 4] << 8) + data[ofs + 5];                 ofs += 6;                 return result;             }
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data[ofs] << 56) + ((long)data[ofs + 1] << 48) + ((long)data[ofs + 2] << 40) + ((long)data[ofs + 3] << 32)                 + ((long)data[ofs + 4] << 24) + (data[ofs + 5] << 16) + (data[ofs + 6] << 8) + data[ofs + 7];
Magic Number,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 8;
Magic Number,BTDB.ChunkCache,DiskChunkCache,C:\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: if (keySize != 20) throw new NotSupportedException("Only keySize of 20 (Usefull for SHA1) is supported for now");
Magic Number,BTDB.ChunkCache,DiskChunkCache,C:\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: if (cacheCapacity < 1000) throw new ArgumentOutOfRangeException(nameof(cacheCapacity)' "Minimum for cache capacity is 1kB");
Magic Number,BTDB.ChunkCache,DiskChunkCache,C:\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: cacheCapacity = cacheCapacity / 1000 * (980 - keySize);
Magic Number,BTDB.ChunkCache,DiskChunkCache,C:\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: cacheCapacity = cacheCapacity / 1000 * (980 - keySize);
Magic Number,BTDB.ChunkCache,DiskChunkCache,C:\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: if (cacheCapacity / 8 > int.MaxValue)             {                 _maxValueFileCount = checked((int)(cacheCapacity / int.MaxValue));                 _sizeLimitOfOneValueFile = int.MaxValue;             }             else             {                 _maxValueFileCount = 8;                 _sizeLimitOfOneValueFile = (int)(cacheCapacity / 8);             }
Magic Number,BTDB.ChunkCache,DiskChunkCache,C:\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: if (cacheCapacity / 8 > int.MaxValue)             {                 _maxValueFileCount = checked((int)(cacheCapacity / int.MaxValue));                 _sizeLimitOfOneValueFile = int.MaxValue;             }             else             {                 _maxValueFileCount = 8;                 _sizeLimitOfOneValueFile = (int)(cacheCapacity / 8);             }
Magic Number,BTDB.ChunkCache,DiskChunkCache,C:\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: if (cacheCapacity / 8 > int.MaxValue)             {                 _maxValueFileCount = checked((int)(cacheCapacity / int.MaxValue));                 _sizeLimitOfOneValueFile = int.MaxValue;             }             else             {                 _maxValueFileCount = 8;                 _sizeLimitOfOneValueFile = (int)(cacheCapacity / 8);             }
Magic Number,BTDB.ChunkCache,DiskChunkCache,C:\repos\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,PreserveJustMostOftenUsed,The following statement contains a magic number: var preserveRate = freqencies.OrderByDescending(r => r).Skip(freqencies.Count / 5).FirstOrDefault();
Magic Number,BTDB.DtoChannel,DtoChannel,C:\repos\Bobris_BTDB\BTDB\DtoChannel\DtoChannel.cs,Send,The following statement contains a magic number: lock (_sendLocker)             {                 IDescriptorSerializerContext serializerContext = _sendingMapping;                 var writer = new ByteBufferWriter();                 writer.WriteUInt8(100);                 serializerContext = serializerContext.StoreNewDescriptors(writer' dto);                 serializerContext.FinishNewDescriptors(writer);                 serializerContext.StoreObject(writer' dto);                 var block = writer.Data;                 if (serializerContext.SomeTypeStored)                 {                     block[0] = 99;                 }                 _channel.Send(block);                 serializerContext.CommitNewDescriptors();             }
Magic Number,BTDB.DtoChannel,DtoChannel,C:\repos\Bobris_BTDB\BTDB\DtoChannel\DtoChannel.cs,Send,The following statement contains a magic number: lock (_sendLocker)             {                 IDescriptorSerializerContext serializerContext = _sendingMapping;                 var writer = new ByteBufferWriter();                 writer.WriteUInt8(100);                 serializerContext = serializerContext.StoreNewDescriptors(writer' dto);                 serializerContext.FinishNewDescriptors(writer);                 serializerContext.StoreObject(writer' dto);                 var block = writer.Data;                 if (serializerContext.SomeTypeStored)                 {                     block[0] = 99;                 }                 _channel.Send(block);                 serializerContext.CommitNewDescriptors();             }
Magic Number,BTDB.DtoChannel,Receiver,C:\repos\Bobris_BTDB\BTDB\DtoChannel\DtoChannel.cs,OnNext,The following statement contains a magic number: if (c0 == 99)                 {                     _dtoChannel._receivingMapping.LoadTypeDescriptors(reader);                 }                 else if (c0 != 100)                 {                     _dtoChannel._onReceive.OnError(new InvalidDataException("Data received from other side must Start with byte 99 or 100"));                     return;                 }
Magic Number,BTDB.DtoChannel,Receiver,C:\repos\Bobris_BTDB\BTDB\DtoChannel\DtoChannel.cs,OnNext,The following statement contains a magic number: if (c0 == 99)                 {                     _dtoChannel._receivingMapping.LoadTypeDescriptors(reader);                 }                 else if (c0 != 100)                 {                     _dtoChannel._onReceive.OnError(new InvalidDataException("Data received from other side must Start with byte 99 or 100"));                     return;                 }
Magic Number,BTDB.EventStore2Layer,EventDeserializer,C:\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventDeserializer.cs,LoaderFactory,The following statement contains a magic number: descriptor.GenerateLoad(il' ilGen => ilGen.Ldarg(0)' ilGen => ilGen.Ldarg(1)' ilGen => ilGen.Ldarg(2)' loadAsType);
Magic Number,BTDB.EventStore2Layer,EventSerializer,C:\repos\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,BuildComplexSaver,The following statement contains a magic number: descriptor.GenerateSave(il' ilgen => ilgen.Ldarg(0)' ilgen => ilgen.Ldarg(1)' ilgen =>             {                 ilgen.Ldarg(2);                 var type = descriptor.GetPreferedType();                 if (type != typeof(object))                 {                     ilgen.UnboxAny(type);                 }             }' descriptor.GetPreferedType());
Magic Number,BTDB.EventStoreLayer,AppendingEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,FinalizeStore,The following statement contains a magic number: if (EndBufferPosition + (ulong)startOffset <= File.MaxFileSize)             {                 WriteOneBlock(ByteBuffer.NewSync(new byte[SectorSize * 2]' startOffset' 0)' BlockType.LastBlock);             }
Magic Number,BTDB.EventStoreLayer,AppendingEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,WriteOneBlock,The following statement contains a magic number: var o = block.Offset - 4;
Magic Number,BTDB.EventStoreLayer,AppendingEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,WriteOneBlock,The following statement contains a magic number: PackUnpack.PackUInt32LE(block.Buffer' o' (blockLen << 8) + (uint)blockType);
Magic Number,BTDB.EventStoreLayer,AppendingEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,WriteOneBlock,The following statement contains a magic number: var checksum = Checksum.CalcFletcher32(block.Buffer' (uint)o' blockLen + 4);
Magic Number,BTDB.EventStoreLayer,AppendingEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,WriteOneBlock,The following statement contains a magic number: o -= 4;
Magic Number,BTDB.EventStoreLayer,EnumTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,EnumTypeDescriptor,The following statement contains a magic number: _flags = (header & 2) != 0;
Magic Number,BTDB.EventStoreLayer,EnumTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,EnumTypeDescriptor,The following statement contains a magic number: var count = header >> 2;
Magic Number,BTDB.EventStoreLayer,EnumTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,AppendIndent,The following statement contains a magic number: text.Append(' '' (int)(indent * 4));
Magic Number,BTDB.EventStoreLayer,ListTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GetHashCode,The following statement contains a magic number: return 33 *_itemDescriptor.GetHashCode();
Magic Number,BTDB.EventStoreLayer,NullableTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\NullableTypeDescriptor.cs,GetHashCode,The following statement contains a magic number: return 17 * _itemDescriptor.GetHashCode();
Magic Number,BTDB.EventStoreLayer,SnappyCompressionStrategy,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\SnappyCompressionStrategy.cs,ShouldTryToCompress,The following statement contains a magic number: return length > 512;
Magic Number,BTDB.EventStoreLayer,SnappyCompressionStrategy,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\SnappyCompressionStrategy.cs,Compress,The following statement contains a magic number: return SnappyCompress.TryCompress(ref data' 80);
Magic Number,BTDB.EventStoreLayer,StreamEventFileStorage,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\StreamEventFileStorage.cs,StreamEventFileStorage,The following statement contains a magic number: MaxBlockSize = 4*1024*1024;
Magic Number,BTDB.EventStoreLayer,StreamEventFileStorage,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\StreamEventFileStorage.cs,StreamEventFileStorage,The following statement contains a magic number: MaxBlockSize = 4*1024*1024;
Magic Number,BTDB.EventStoreLayer,StreamEventFileStorage,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\StreamEventFileStorage.cs,StreamEventFileStorage,The following statement contains a magic number: MaxBlockSize = 4*1024*1024;
Magic Number,BTDB.EventStoreLayer,ObjectTypeDescriptor,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,AppendIndent,The following statement contains a magic number: text.Append(' '' (int)(indent * 4));
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: while (true)             {                 if (bufferStartPosition + (ulong)bufferReadOffset + HeaderSize > File.MaxFileSize)                 {                     KnownAsFinished = true;                     return;                 }                 if (bufferReadOffset == bufferFullLength)                 {                     break;                 }                 if (bufferReadOffset + HeaderSize > bufferFullLength)                 {                     for (var i = bufferReadOffset; i < bufferFullLength; i++)                     {                         if (bufferBlock[i] != 0)                         {                             SetCorrupted();                             return;                         }                     }                     break;                 }                 var blockCheckSum = PackUnpack.UnpackUInt32LE(bufferBlock' bufferReadOffset);                 bufferReadOffset += 4;                 var blockLen = PackUnpack.UnpackUInt32LE(bufferBlock' bufferReadOffset);                 if (blockCheckSum == 0 && blockLen == 0)                 {                     bufferReadOffset -= 4;                     break;                 }                 var blockType = (BlockType)(blockLen & 0xff);                 blockLen >>= 8;                 if (blockType == BlockType.LastBlock && blockLen == 0)                 {                     if (Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum)                     {                         SetCorrupted();                         return;                     }                     KnownAsFinished = true;                     return;                 }                 if (blockLen == 0 && blockType != (BlockType.FirstBlock | BlockType.LastBlock))                 {                     SetCorrupted();                     return;                 }                 if (blockLen + HeaderSize > MaxBlockSize)                 {                     SetCorrupted();                     return;                 }                 bufferReadOffset += 4;                 var bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + FirstReadAhead) & SectorMaskUInt;                 if (bufferLenToFill > bufferBlock.Length) bufferLenToFill = (uint)bufferBlock.Length;                 buf = ByteBuffer.NewSync(bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));                 if (buf.Length > 0)                 {                     bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + currentReadAhead) & SectorMaskUInt;                     if (bufferLenToFill > bufferBlock.Length) bufferLenToFill = (uint)bufferBlock.Length;                     if (bufferStartPosition + bufferLenToFill > File.MaxFileSize)                     {                         bufferLenToFill = (uint)(File.MaxFileSize - bufferStartPosition);                     }                     buf = ByteBuffer.NewSync(bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));                     if (buf.Length > 0) {                         if (currentReadAhead * 4 < MaxBlockSize)                         {                             currentReadAhead = currentReadAhead * 2;                         }                         bufReadLength = (int)File.Read(buf' bufferStartPosition + (ulong)bufferFullLength);                         bufferFullLength += bufReadLength;                     }                 }                 if (bufferReadOffset + (int)blockLen > bufferFullLength)                 {                     SetCorrupted();                     return;                 }                 if (Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum)                 {                     SetCorrupted();                     return;                 }                 var blockTypeBlock = blockType & (BlockType.FirstBlock | BlockType.MiddleBlock | BlockType.LastBlock);                 var stopReadingRequested = false;                 if (blockTypeBlock == (BlockType.FirstBlock | BlockType.LastBlock))                 {                     stopReadingRequested = Process(blockType' ByteBuffer.NewSync(bufferBlock' bufferReadOffset' (int)blockLen)' observer);                 }                 else                 {                     if (blockTypeBlock == BlockType.FirstBlock)                     {                         overflowWriter = new ByteBufferWriter();                     }                     else if (blockTypeBlock == BlockType.MiddleBlock || blockTypeBlock == BlockType.LastBlock)                     {                         if (overflowWriter == null)                         {                             SetCorrupted();                             return;                         }                     }                     else                     {                         SetCorrupted();                         return;                     }                     overflowWriter.WriteBlock(ByteBuffer.NewSync(bufferBlock' bufferReadOffset' (int)blockLen));                     if (blockTypeBlock == BlockType.LastBlock)                     {                         stopReadingRequested = Process(blockType' overflowWriter.Data' observer);                         overflowWriter = null;                     }                 }                 bufferReadOffset += (int)blockLen;                 if (overflowWriter == null)                     NextReadPosition = bufferStartPosition + (ulong)bufferReadOffset;                 if (stopReadingRequested)                 {                     return;                 }                 var nextBufferStartPosition = (bufferStartPosition + (ulong)bufferReadOffset) & SectorMask;                 var bufferMoveDistance = (int)(nextBufferStartPosition - bufferStartPosition);                 if (bufferMoveDistance <= 0) continue;                 Array.Copy(bufferBlock' bufferMoveDistance' bufferBlock' 0' bufferFullLength - bufferMoveDistance);                 bufferStartPosition = nextBufferStartPosition;                 bufferFullLength -= bufferMoveDistance;                 bufferReadOffset -= bufferMoveDistance;             }
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: while (true)             {                 if (bufferStartPosition + (ulong)bufferReadOffset + HeaderSize > File.MaxFileSize)                 {                     KnownAsFinished = true;                     return;                 }                 if (bufferReadOffset == bufferFullLength)                 {                     break;                 }                 if (bufferReadOffset + HeaderSize > bufferFullLength)                 {                     for (var i = bufferReadOffset; i < bufferFullLength; i++)                     {                         if (bufferBlock[i] != 0)                         {                             SetCorrupted();                             return;                         }                     }                     break;                 }                 var blockCheckSum = PackUnpack.UnpackUInt32LE(bufferBlock' bufferReadOffset);                 bufferReadOffset += 4;                 var blockLen = PackUnpack.UnpackUInt32LE(bufferBlock' bufferReadOffset);                 if (blockCheckSum == 0 && blockLen == 0)                 {                     bufferReadOffset -= 4;                     break;                 }                 var blockType = (BlockType)(blockLen & 0xff);                 blockLen >>= 8;                 if (blockType == BlockType.LastBlock && blockLen == 0)                 {                     if (Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum)                     {                         SetCorrupted();                         return;                     }                     KnownAsFinished = true;                     return;                 }                 if (blockLen == 0 && blockType != (BlockType.FirstBlock | BlockType.LastBlock))                 {                     SetCorrupted();                     return;                 }                 if (blockLen + HeaderSize > MaxBlockSize)                 {                     SetCorrupted();                     return;                 }                 bufferReadOffset += 4;                 var bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + FirstReadAhead) & SectorMaskUInt;                 if (bufferLenToFill > bufferBlock.Length) bufferLenToFill = (uint)bufferBlock.Length;                 buf = ByteBuffer.NewSync(bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));                 if (buf.Length > 0)                 {                     bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + currentReadAhead) & SectorMaskUInt;                     if (bufferLenToFill > bufferBlock.Length) bufferLenToFill = (uint)bufferBlock.Length;                     if (bufferStartPosition + bufferLenToFill > File.MaxFileSize)                     {                         bufferLenToFill = (uint)(File.MaxFileSize - bufferStartPosition);                     }                     buf = ByteBuffer.NewSync(bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));                     if (buf.Length > 0) {                         if (currentReadAhead * 4 < MaxBlockSize)                         {                             currentReadAhead = currentReadAhead * 2;                         }                         bufReadLength = (int)File.Read(buf' bufferStartPosition + (ulong)bufferFullLength);                         bufferFullLength += bufReadLength;                     }                 }                 if (bufferReadOffset + (int)blockLen > bufferFullLength)                 {                     SetCorrupted();                     return;                 }                 if (Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum)                 {                     SetCorrupted();                     return;                 }                 var blockTypeBlock = blockType & (BlockType.FirstBlock | BlockType.MiddleBlock | BlockType.LastBlock);                 var stopReadingRequested = false;                 if (blockTypeBlock == (BlockType.FirstBlock | BlockType.LastBlock))                 {                     stopReadingRequested = Process(blockType' ByteBuffer.NewSync(bufferBlock' bufferReadOffset' (int)blockLen)' observer);                 }                 else                 {                     if (blockTypeBlock == BlockType.FirstBlock)                     {                         overflowWriter = new ByteBufferWriter();                     }                     else if (blockTypeBlock == BlockType.MiddleBlock || blockTypeBlock == BlockType.LastBlock)                     {                         if (overflowWriter == null)                         {                             SetCorrupted();                             return;                         }                     }                     else                     {                         SetCorrupted();                         return;                     }                     overflowWriter.WriteBlock(ByteBuffer.NewSync(bufferBlock' bufferReadOffset' (int)blockLen));                     if (blockTypeBlock == BlockType.LastBlock)                     {                         stopReadingRequested = Process(blockType' overflowWriter.Data' observer);                         overflowWriter = null;                     }                 }                 bufferReadOffset += (int)blockLen;                 if (overflowWriter == null)                     NextReadPosition = bufferStartPosition + (ulong)bufferReadOffset;                 if (stopReadingRequested)                 {                     return;                 }                 var nextBufferStartPosition = (bufferStartPosition + (ulong)bufferReadOffset) & SectorMask;                 var bufferMoveDistance = (int)(nextBufferStartPosition - bufferStartPosition);                 if (bufferMoveDistance <= 0) continue;                 Array.Copy(bufferBlock' bufferMoveDistance' bufferBlock' 0' bufferFullLength - bufferMoveDistance);                 bufferStartPosition = nextBufferStartPosition;                 bufferFullLength -= bufferMoveDistance;                 bufferReadOffset -= bufferMoveDistance;             }
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: while (true)             {                 if (bufferStartPosition + (ulong)bufferReadOffset + HeaderSize > File.MaxFileSize)                 {                     KnownAsFinished = true;                     return;                 }                 if (bufferReadOffset == bufferFullLength)                 {                     break;                 }                 if (bufferReadOffset + HeaderSize > bufferFullLength)                 {                     for (var i = bufferReadOffset; i < bufferFullLength; i++)                     {                         if (bufferBlock[i] != 0)                         {                             SetCorrupted();                             return;                         }                     }                     break;                 }                 var blockCheckSum = PackUnpack.UnpackUInt32LE(bufferBlock' bufferReadOffset);                 bufferReadOffset += 4;                 var blockLen = PackUnpack.UnpackUInt32LE(bufferBlock' bufferReadOffset);                 if (blockCheckSum == 0 && blockLen == 0)                 {                     bufferReadOffset -= 4;                     break;                 }                 var blockType = (BlockType)(blockLen & 0xff);                 blockLen >>= 8;                 if (blockType == BlockType.LastBlock && blockLen == 0)                 {                     if (Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum)                     {                         SetCorrupted();                         return;                     }                     KnownAsFinished = true;                     return;                 }                 if (blockLen == 0 && blockType != (BlockType.FirstBlock | BlockType.LastBlock))                 {                     SetCorrupted();                     return;                 }                 if (blockLen + HeaderSize > MaxBlockSize)                 {                     SetCorrupted();                     return;                 }                 bufferReadOffset += 4;                 var bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + FirstReadAhead) & SectorMaskUInt;                 if (bufferLenToFill > bufferBlock.Length) bufferLenToFill = (uint)bufferBlock.Length;                 buf = ByteBuffer.NewSync(bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));                 if (buf.Length > 0)                 {                     bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + currentReadAhead) & SectorMaskUInt;                     if (bufferLenToFill > bufferBlock.Length) bufferLenToFill = (uint)bufferBlock.Length;                     if (bufferStartPosition + bufferLenToFill > File.MaxFileSize)                     {                         bufferLenToFill = (uint)(File.MaxFileSize - bufferStartPosition);                     }                     buf = ByteBuffer.NewSync(bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));                     if (buf.Length > 0) {                         if (currentReadAhead * 4 < MaxBlockSize)                         {                             currentReadAhead = currentReadAhead * 2;                         }                         bufReadLength = (int)File.Read(buf' bufferStartPosition + (ulong)bufferFullLength);                         bufferFullLength += bufReadLength;                     }                 }                 if (bufferReadOffset + (int)blockLen > bufferFullLength)                 {                     SetCorrupted();                     return;                 }                 if (Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum)                 {                     SetCorrupted();                     return;                 }                 var blockTypeBlock = blockType & (BlockType.FirstBlock | BlockType.MiddleBlock | BlockType.LastBlock);                 var stopReadingRequested = false;                 if (blockTypeBlock == (BlockType.FirstBlock | BlockType.LastBlock))                 {                     stopReadingRequested = Process(blockType' ByteBuffer.NewSync(bufferBlock' bufferReadOffset' (int)blockLen)' observer);                 }                 else                 {                     if (blockTypeBlock == BlockType.FirstBlock)                     {                         overflowWriter = new ByteBufferWriter();                     }                     else if (blockTypeBlock == BlockType.MiddleBlock || blockTypeBlock == BlockType.LastBlock)                     {                         if (overflowWriter == null)                         {                             SetCorrupted();                             return;                         }                     }                     else                     {                         SetCorrupted();                         return;                     }                     overflowWriter.WriteBlock(ByteBuffer.NewSync(bufferBlock' bufferReadOffset' (int)blockLen));                     if (blockTypeBlock == BlockType.LastBlock)                     {                         stopReadingRequested = Process(blockType' overflowWriter.Data' observer);                         overflowWriter = null;                     }                 }                 bufferReadOffset += (int)blockLen;                 if (overflowWriter == null)                     NextReadPosition = bufferStartPosition + (ulong)bufferReadOffset;                 if (stopReadingRequested)                 {                     return;                 }                 var nextBufferStartPosition = (bufferStartPosition + (ulong)bufferReadOffset) & SectorMask;                 var bufferMoveDistance = (int)(nextBufferStartPosition - bufferStartPosition);                 if (bufferMoveDistance <= 0) continue;                 Array.Copy(bufferBlock' bufferMoveDistance' bufferBlock' 0' bufferFullLength - bufferMoveDistance);                 bufferStartPosition = nextBufferStartPosition;                 bufferFullLength -= bufferMoveDistance;                 bufferReadOffset -= bufferMoveDistance;             }
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: while (true)             {                 if (bufferStartPosition + (ulong)bufferReadOffset + HeaderSize > File.MaxFileSize)                 {                     KnownAsFinished = true;                     return;                 }                 if (bufferReadOffset == bufferFullLength)                 {                     break;                 }                 if (bufferReadOffset + HeaderSize > bufferFullLength)                 {                     for (var i = bufferReadOffset; i < bufferFullLength; i++)                     {                         if (bufferBlock[i] != 0)                         {                             SetCorrupted();                             return;                         }                     }                     break;                 }                 var blockCheckSum = PackUnpack.UnpackUInt32LE(bufferBlock' bufferReadOffset);                 bufferReadOffset += 4;                 var blockLen = PackUnpack.UnpackUInt32LE(bufferBlock' bufferReadOffset);                 if (blockCheckSum == 0 && blockLen == 0)                 {                     bufferReadOffset -= 4;                     break;                 }                 var blockType = (BlockType)(blockLen & 0xff);                 blockLen >>= 8;                 if (blockType == BlockType.LastBlock && blockLen == 0)                 {                     if (Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum)                     {                         SetCorrupted();                         return;                     }                     KnownAsFinished = true;                     return;                 }                 if (blockLen == 0 && blockType != (BlockType.FirstBlock | BlockType.LastBlock))                 {                     SetCorrupted();                     return;                 }                 if (blockLen + HeaderSize > MaxBlockSize)                 {                     SetCorrupted();                     return;                 }                 bufferReadOffset += 4;                 var bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + FirstReadAhead) & SectorMaskUInt;                 if (bufferLenToFill > bufferBlock.Length) bufferLenToFill = (uint)bufferBlock.Length;                 buf = ByteBuffer.NewSync(bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));                 if (buf.Length > 0)                 {                     bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + currentReadAhead) & SectorMaskUInt;                     if (bufferLenToFill > bufferBlock.Length) bufferLenToFill = (uint)bufferBlock.Length;                     if (bufferStartPosition + bufferLenToFill > File.MaxFileSize)                     {                         bufferLenToFill = (uint)(File.MaxFileSize - bufferStartPosition);                     }                     buf = ByteBuffer.NewSync(bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));                     if (buf.Length > 0) {                         if (currentReadAhead * 4 < MaxBlockSize)                         {                             currentReadAhead = currentReadAhead * 2;                         }                         bufReadLength = (int)File.Read(buf' bufferStartPosition + (ulong)bufferFullLength);                         bufferFullLength += bufReadLength;                     }                 }                 if (bufferReadOffset + (int)blockLen > bufferFullLength)                 {                     SetCorrupted();                     return;                 }                 if (Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum)                 {                     SetCorrupted();                     return;                 }                 var blockTypeBlock = blockType & (BlockType.FirstBlock | BlockType.MiddleBlock | BlockType.LastBlock);                 var stopReadingRequested = false;                 if (blockTypeBlock == (BlockType.FirstBlock | BlockType.LastBlock))                 {                     stopReadingRequested = Process(blockType' ByteBuffer.NewSync(bufferBlock' bufferReadOffset' (int)blockLen)' observer);                 }                 else                 {                     if (blockTypeBlock == BlockType.FirstBlock)                     {                         overflowWriter = new ByteBufferWriter();                     }                     else if (blockTypeBlock == BlockType.MiddleBlock || blockTypeBlock == BlockType.LastBlock)                     {                         if (overflowWriter == null)                         {                             SetCorrupted();                             return;                         }                     }                     else                     {                         SetCorrupted();                         return;                     }                     overflowWriter.WriteBlock(ByteBuffer.NewSync(bufferBlock' bufferReadOffset' (int)blockLen));                     if (blockTypeBlock == BlockType.LastBlock)                     {                         stopReadingRequested = Process(blockType' overflowWriter.Data' observer);                         overflowWriter = null;                     }                 }                 bufferReadOffset += (int)blockLen;                 if (overflowWriter == null)                     NextReadPosition = bufferStartPosition + (ulong)bufferReadOffset;                 if (stopReadingRequested)                 {                     return;                 }                 var nextBufferStartPosition = (bufferStartPosition + (ulong)bufferReadOffset) & SectorMask;                 var bufferMoveDistance = (int)(nextBufferStartPosition - bufferStartPosition);                 if (bufferMoveDistance <= 0) continue;                 Array.Copy(bufferBlock' bufferMoveDistance' bufferBlock' 0' bufferFullLength - bufferMoveDistance);                 bufferStartPosition = nextBufferStartPosition;                 bufferFullLength -= bufferMoveDistance;                 bufferReadOffset -= bufferMoveDistance;             }
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: while (true)             {                 if (bufferStartPosition + (ulong)bufferReadOffset + HeaderSize > File.MaxFileSize)                 {                     KnownAsFinished = true;                     return;                 }                 if (bufferReadOffset == bufferFullLength)                 {                     break;                 }                 if (bufferReadOffset + HeaderSize > bufferFullLength)                 {                     for (var i = bufferReadOffset; i < bufferFullLength; i++)                     {                         if (bufferBlock[i] != 0)                         {                             SetCorrupted();                             return;                         }                     }                     break;                 }                 var blockCheckSum = PackUnpack.UnpackUInt32LE(bufferBlock' bufferReadOffset);                 bufferReadOffset += 4;                 var blockLen = PackUnpack.UnpackUInt32LE(bufferBlock' bufferReadOffset);                 if (blockCheckSum == 0 && blockLen == 0)                 {                     bufferReadOffset -= 4;                     break;                 }                 var blockType = (BlockType)(blockLen & 0xff);                 blockLen >>= 8;                 if (blockType == BlockType.LastBlock && blockLen == 0)                 {                     if (Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum)                     {                         SetCorrupted();                         return;                     }                     KnownAsFinished = true;                     return;                 }                 if (blockLen == 0 && blockType != (BlockType.FirstBlock | BlockType.LastBlock))                 {                     SetCorrupted();                     return;                 }                 if (blockLen + HeaderSize > MaxBlockSize)                 {                     SetCorrupted();                     return;                 }                 bufferReadOffset += 4;                 var bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + FirstReadAhead) & SectorMaskUInt;                 if (bufferLenToFill > bufferBlock.Length) bufferLenToFill = (uint)bufferBlock.Length;                 buf = ByteBuffer.NewSync(bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));                 if (buf.Length > 0)                 {                     bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + currentReadAhead) & SectorMaskUInt;                     if (bufferLenToFill > bufferBlock.Length) bufferLenToFill = (uint)bufferBlock.Length;                     if (bufferStartPosition + bufferLenToFill > File.MaxFileSize)                     {                         bufferLenToFill = (uint)(File.MaxFileSize - bufferStartPosition);                     }                     buf = ByteBuffer.NewSync(bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));                     if (buf.Length > 0) {                         if (currentReadAhead * 4 < MaxBlockSize)                         {                             currentReadAhead = currentReadAhead * 2;                         }                         bufReadLength = (int)File.Read(buf' bufferStartPosition + (ulong)bufferFullLength);                         bufferFullLength += bufReadLength;                     }                 }                 if (bufferReadOffset + (int)blockLen > bufferFullLength)                 {                     SetCorrupted();                     return;                 }                 if (Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum)                 {                     SetCorrupted();                     return;                 }                 var blockTypeBlock = blockType & (BlockType.FirstBlock | BlockType.MiddleBlock | BlockType.LastBlock);                 var stopReadingRequested = false;                 if (blockTypeBlock == (BlockType.FirstBlock | BlockType.LastBlock))                 {                     stopReadingRequested = Process(blockType' ByteBuffer.NewSync(bufferBlock' bufferReadOffset' (int)blockLen)' observer);                 }                 else                 {                     if (blockTypeBlock == BlockType.FirstBlock)                     {                         overflowWriter = new ByteBufferWriter();                     }                     else if (blockTypeBlock == BlockType.MiddleBlock || blockTypeBlock == BlockType.LastBlock)                     {                         if (overflowWriter == null)                         {                             SetCorrupted();                             return;                         }                     }                     else                     {                         SetCorrupted();                         return;                     }                     overflowWriter.WriteBlock(ByteBuffer.NewSync(bufferBlock' bufferReadOffset' (int)blockLen));                     if (blockTypeBlock == BlockType.LastBlock)                     {                         stopReadingRequested = Process(blockType' overflowWriter.Data' observer);                         overflowWriter = null;                     }                 }                 bufferReadOffset += (int)blockLen;                 if (overflowWriter == null)                     NextReadPosition = bufferStartPosition + (ulong)bufferReadOffset;                 if (stopReadingRequested)                 {                     return;                 }                 var nextBufferStartPosition = (bufferStartPosition + (ulong)bufferReadOffset) & SectorMask;                 var bufferMoveDistance = (int)(nextBufferStartPosition - bufferStartPosition);                 if (bufferMoveDistance <= 0) continue;                 Array.Copy(bufferBlock' bufferMoveDistance' bufferBlock' 0' bufferFullLength - bufferMoveDistance);                 bufferStartPosition = nextBufferStartPosition;                 bufferFullLength -= bufferMoveDistance;                 bufferReadOffset -= bufferMoveDistance;             }
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: while (true)             {                 if (bufferStartPosition + (ulong)bufferReadOffset + HeaderSize > File.MaxFileSize)                 {                     KnownAsFinished = true;                     return;                 }                 if (bufferReadOffset == bufferFullLength)                 {                     break;                 }                 if (bufferReadOffset + HeaderSize > bufferFullLength)                 {                     for (var i = bufferReadOffset; i < bufferFullLength; i++)                     {                         if (bufferBlock[i] != 0)                         {                             SetCorrupted();                             return;                         }                     }                     break;                 }                 var blockCheckSum = PackUnpack.UnpackUInt32LE(bufferBlock' bufferReadOffset);                 bufferReadOffset += 4;                 var blockLen = PackUnpack.UnpackUInt32LE(bufferBlock' bufferReadOffset);                 if (blockCheckSum == 0 && blockLen == 0)                 {                     bufferReadOffset -= 4;                     break;                 }                 var blockType = (BlockType)(blockLen & 0xff);                 blockLen >>= 8;                 if (blockType == BlockType.LastBlock && blockLen == 0)                 {                     if (Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum)                     {                         SetCorrupted();                         return;                     }                     KnownAsFinished = true;                     return;                 }                 if (blockLen == 0 && blockType != (BlockType.FirstBlock | BlockType.LastBlock))                 {                     SetCorrupted();                     return;                 }                 if (blockLen + HeaderSize > MaxBlockSize)                 {                     SetCorrupted();                     return;                 }                 bufferReadOffset += 4;                 var bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + FirstReadAhead) & SectorMaskUInt;                 if (bufferLenToFill > bufferBlock.Length) bufferLenToFill = (uint)bufferBlock.Length;                 buf = ByteBuffer.NewSync(bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));                 if (buf.Length > 0)                 {                     bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + currentReadAhead) & SectorMaskUInt;                     if (bufferLenToFill > bufferBlock.Length) bufferLenToFill = (uint)bufferBlock.Length;                     if (bufferStartPosition + bufferLenToFill > File.MaxFileSize)                     {                         bufferLenToFill = (uint)(File.MaxFileSize - bufferStartPosition);                     }                     buf = ByteBuffer.NewSync(bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));                     if (buf.Length > 0) {                         if (currentReadAhead * 4 < MaxBlockSize)                         {                             currentReadAhead = currentReadAhead * 2;                         }                         bufReadLength = (int)File.Read(buf' bufferStartPosition + (ulong)bufferFullLength);                         bufferFullLength += bufReadLength;                     }                 }                 if (bufferReadOffset + (int)blockLen > bufferFullLength)                 {                     SetCorrupted();                     return;                 }                 if (Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum)                 {                     SetCorrupted();                     return;                 }                 var blockTypeBlock = blockType & (BlockType.FirstBlock | BlockType.MiddleBlock | BlockType.LastBlock);                 var stopReadingRequested = false;                 if (blockTypeBlock == (BlockType.FirstBlock | BlockType.LastBlock))                 {                     stopReadingRequested = Process(blockType' ByteBuffer.NewSync(bufferBlock' bufferReadOffset' (int)blockLen)' observer);                 }                 else                 {                     if (blockTypeBlock == BlockType.FirstBlock)                     {                         overflowWriter = new ByteBufferWriter();                     }                     else if (blockTypeBlock == BlockType.MiddleBlock || blockTypeBlock == BlockType.LastBlock)                     {                         if (overflowWriter == null)                         {                             SetCorrupted();                             return;                         }                     }                     else                     {                         SetCorrupted();                         return;                     }                     overflowWriter.WriteBlock(ByteBuffer.NewSync(bufferBlock' bufferReadOffset' (int)blockLen));                     if (blockTypeBlock == BlockType.LastBlock)                     {                         stopReadingRequested = Process(blockType' overflowWriter.Data' observer);                         overflowWriter = null;                     }                 }                 bufferReadOffset += (int)blockLen;                 if (overflowWriter == null)                     NextReadPosition = bufferStartPosition + (ulong)bufferReadOffset;                 if (stopReadingRequested)                 {                     return;                 }                 var nextBufferStartPosition = (bufferStartPosition + (ulong)bufferReadOffset) & SectorMask;                 var bufferMoveDistance = (int)(nextBufferStartPosition - bufferStartPosition);                 if (bufferMoveDistance <= 0) continue;                 Array.Copy(bufferBlock' bufferMoveDistance' bufferBlock' 0' bufferFullLength - bufferMoveDistance);                 bufferStartPosition = nextBufferStartPosition;                 bufferFullLength -= bufferMoveDistance;                 bufferReadOffset -= bufferMoveDistance;             }
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: while (true)             {                 if (bufferStartPosition + (ulong)bufferReadOffset + HeaderSize > File.MaxFileSize)                 {                     KnownAsFinished = true;                     return;                 }                 if (bufferReadOffset == bufferFullLength)                 {                     break;                 }                 if (bufferReadOffset + HeaderSize > bufferFullLength)                 {                     for (var i = bufferReadOffset; i < bufferFullLength; i++)                     {                         if (bufferBlock[i] != 0)                         {                             SetCorrupted();                             return;                         }                     }                     break;                 }                 var blockCheckSum = PackUnpack.UnpackUInt32LE(bufferBlock' bufferReadOffset);                 bufferReadOffset += 4;                 var blockLen = PackUnpack.UnpackUInt32LE(bufferBlock' bufferReadOffset);                 if (blockCheckSum == 0 && blockLen == 0)                 {                     bufferReadOffset -= 4;                     break;                 }                 var blockType = (BlockType)(blockLen & 0xff);                 blockLen >>= 8;                 if (blockType == BlockType.LastBlock && blockLen == 0)                 {                     if (Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum)                     {                         SetCorrupted();                         return;                     }                     KnownAsFinished = true;                     return;                 }                 if (blockLen == 0 && blockType != (BlockType.FirstBlock | BlockType.LastBlock))                 {                     SetCorrupted();                     return;                 }                 if (blockLen + HeaderSize > MaxBlockSize)                 {                     SetCorrupted();                     return;                 }                 bufferReadOffset += 4;                 var bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + FirstReadAhead) & SectorMaskUInt;                 if (bufferLenToFill > bufferBlock.Length) bufferLenToFill = (uint)bufferBlock.Length;                 buf = ByteBuffer.NewSync(bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));                 if (buf.Length > 0)                 {                     bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + currentReadAhead) & SectorMaskUInt;                     if (bufferLenToFill > bufferBlock.Length) bufferLenToFill = (uint)bufferBlock.Length;                     if (bufferStartPosition + bufferLenToFill > File.MaxFileSize)                     {                         bufferLenToFill = (uint)(File.MaxFileSize - bufferStartPosition);                     }                     buf = ByteBuffer.NewSync(bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));                     if (buf.Length > 0) {                         if (currentReadAhead * 4 < MaxBlockSize)                         {                             currentReadAhead = currentReadAhead * 2;                         }                         bufReadLength = (int)File.Read(buf' bufferStartPosition + (ulong)bufferFullLength);                         bufferFullLength += bufReadLength;                     }                 }                 if (bufferReadOffset + (int)blockLen > bufferFullLength)                 {                     SetCorrupted();                     return;                 }                 if (Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum)                 {                     SetCorrupted();                     return;                 }                 var blockTypeBlock = blockType & (BlockType.FirstBlock | BlockType.MiddleBlock | BlockType.LastBlock);                 var stopReadingRequested = false;                 if (blockTypeBlock == (BlockType.FirstBlock | BlockType.LastBlock))                 {                     stopReadingRequested = Process(blockType' ByteBuffer.NewSync(bufferBlock' bufferReadOffset' (int)blockLen)' observer);                 }                 else                 {                     if (blockTypeBlock == BlockType.FirstBlock)                     {                         overflowWriter = new ByteBufferWriter();                     }                     else if (blockTypeBlock == BlockType.MiddleBlock || blockTypeBlock == BlockType.LastBlock)                     {                         if (overflowWriter == null)                         {                             SetCorrupted();                             return;                         }                     }                     else                     {                         SetCorrupted();                         return;                     }                     overflowWriter.WriteBlock(ByteBuffer.NewSync(bufferBlock' bufferReadOffset' (int)blockLen));                     if (blockTypeBlock == BlockType.LastBlock)                     {                         stopReadingRequested = Process(blockType' overflowWriter.Data' observer);                         overflowWriter = null;                     }                 }                 bufferReadOffset += (int)blockLen;                 if (overflowWriter == null)                     NextReadPosition = bufferStartPosition + (ulong)bufferReadOffset;                 if (stopReadingRequested)                 {                     return;                 }                 var nextBufferStartPosition = (bufferStartPosition + (ulong)bufferReadOffset) & SectorMask;                 var bufferMoveDistance = (int)(nextBufferStartPosition - bufferStartPosition);                 if (bufferMoveDistance <= 0) continue;                 Array.Copy(bufferBlock' bufferMoveDistance' bufferBlock' 0' bufferFullLength - bufferMoveDistance);                 bufferStartPosition = nextBufferStartPosition;                 bufferFullLength -= bufferMoveDistance;                 bufferReadOffset -= bufferMoveDistance;             }
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: while (true)             {                 if (bufferStartPosition + (ulong)bufferReadOffset + HeaderSize > File.MaxFileSize)                 {                     KnownAsFinished = true;                     return;                 }                 if (bufferReadOffset == bufferFullLength)                 {                     break;                 }                 if (bufferReadOffset + HeaderSize > bufferFullLength)                 {                     for (var i = bufferReadOffset; i < bufferFullLength; i++)                     {                         if (bufferBlock[i] != 0)                         {                             SetCorrupted();                             return;                         }                     }                     break;                 }                 var blockCheckSum = PackUnpack.UnpackUInt32LE(bufferBlock' bufferReadOffset);                 bufferReadOffset += 4;                 var blockLen = PackUnpack.UnpackUInt32LE(bufferBlock' bufferReadOffset);                 if (blockCheckSum == 0 && blockLen == 0)                 {                     bufferReadOffset -= 4;                     break;                 }                 var blockType = (BlockType)(blockLen & 0xff);                 blockLen >>= 8;                 if (blockType == BlockType.LastBlock && blockLen == 0)                 {                     if (Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum)                     {                         SetCorrupted();                         return;                     }                     KnownAsFinished = true;                     return;                 }                 if (blockLen == 0 && blockType != (BlockType.FirstBlock | BlockType.LastBlock))                 {                     SetCorrupted();                     return;                 }                 if (blockLen + HeaderSize > MaxBlockSize)                 {                     SetCorrupted();                     return;                 }                 bufferReadOffset += 4;                 var bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + FirstReadAhead) & SectorMaskUInt;                 if (bufferLenToFill > bufferBlock.Length) bufferLenToFill = (uint)bufferBlock.Length;                 buf = ByteBuffer.NewSync(bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));                 if (buf.Length > 0)                 {                     bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + currentReadAhead) & SectorMaskUInt;                     if (bufferLenToFill > bufferBlock.Length) bufferLenToFill = (uint)bufferBlock.Length;                     if (bufferStartPosition + bufferLenToFill > File.MaxFileSize)                     {                         bufferLenToFill = (uint)(File.MaxFileSize - bufferStartPosition);                     }                     buf = ByteBuffer.NewSync(bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));                     if (buf.Length > 0) {                         if (currentReadAhead * 4 < MaxBlockSize)                         {                             currentReadAhead = currentReadAhead * 2;                         }                         bufReadLength = (int)File.Read(buf' bufferStartPosition + (ulong)bufferFullLength);                         bufferFullLength += bufReadLength;                     }                 }                 if (bufferReadOffset + (int)blockLen > bufferFullLength)                 {                     SetCorrupted();                     return;                 }                 if (Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum)                 {                     SetCorrupted();                     return;                 }                 var blockTypeBlock = blockType & (BlockType.FirstBlock | BlockType.MiddleBlock | BlockType.LastBlock);                 var stopReadingRequested = false;                 if (blockTypeBlock == (BlockType.FirstBlock | BlockType.LastBlock))                 {                     stopReadingRequested = Process(blockType' ByteBuffer.NewSync(bufferBlock' bufferReadOffset' (int)blockLen)' observer);                 }                 else                 {                     if (blockTypeBlock == BlockType.FirstBlock)                     {                         overflowWriter = new ByteBufferWriter();                     }                     else if (blockTypeBlock == BlockType.MiddleBlock || blockTypeBlock == BlockType.LastBlock)                     {                         if (overflowWriter == null)                         {                             SetCorrupted();                             return;                         }                     }                     else                     {                         SetCorrupted();                         return;                     }                     overflowWriter.WriteBlock(ByteBuffer.NewSync(bufferBlock' bufferReadOffset' (int)blockLen));                     if (blockTypeBlock == BlockType.LastBlock)                     {                         stopReadingRequested = Process(blockType' overflowWriter.Data' observer);                         overflowWriter = null;                     }                 }                 bufferReadOffset += (int)blockLen;                 if (overflowWriter == null)                     NextReadPosition = bufferStartPosition + (ulong)bufferReadOffset;                 if (stopReadingRequested)                 {                     return;                 }                 var nextBufferStartPosition = (bufferStartPosition + (ulong)bufferReadOffset) & SectorMask;                 var bufferMoveDistance = (int)(nextBufferStartPosition - bufferStartPosition);                 if (bufferMoveDistance <= 0) continue;                 Array.Copy(bufferBlock' bufferMoveDistance' bufferBlock' 0' bufferFullLength - bufferMoveDistance);                 bufferStartPosition = nextBufferStartPosition;                 bufferFullLength -= bufferMoveDistance;                 bufferReadOffset -= bufferMoveDistance;             }
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: while (true)             {                 if (bufferStartPosition + (ulong)bufferReadOffset + HeaderSize > File.MaxFileSize)                 {                     KnownAsFinished = true;                     return;                 }                 if (bufferReadOffset == bufferFullLength)                 {                     break;                 }                 if (bufferReadOffset + HeaderSize > bufferFullLength)                 {                     for (var i = bufferReadOffset; i < bufferFullLength; i++)                     {                         if (bufferBlock[i] != 0)                         {                             SetCorrupted();                             return;                         }                     }                     break;                 }                 var blockCheckSum = PackUnpack.UnpackUInt32LE(bufferBlock' bufferReadOffset);                 bufferReadOffset += 4;                 var blockLen = PackUnpack.UnpackUInt32LE(bufferBlock' bufferReadOffset);                 if (blockCheckSum == 0 && blockLen == 0)                 {                     bufferReadOffset -= 4;                     break;                 }                 var blockType = (BlockType)(blockLen & 0xff);                 blockLen >>= 8;                 if (blockType == BlockType.LastBlock && blockLen == 0)                 {                     if (Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum)                     {                         SetCorrupted();                         return;                     }                     KnownAsFinished = true;                     return;                 }                 if (blockLen == 0 && blockType != (BlockType.FirstBlock | BlockType.LastBlock))                 {                     SetCorrupted();                     return;                 }                 if (blockLen + HeaderSize > MaxBlockSize)                 {                     SetCorrupted();                     return;                 }                 bufferReadOffset += 4;                 var bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + FirstReadAhead) & SectorMaskUInt;                 if (bufferLenToFill > bufferBlock.Length) bufferLenToFill = (uint)bufferBlock.Length;                 buf = ByteBuffer.NewSync(bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));                 if (buf.Length > 0)                 {                     bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + currentReadAhead) & SectorMaskUInt;                     if (bufferLenToFill > bufferBlock.Length) bufferLenToFill = (uint)bufferBlock.Length;                     if (bufferStartPosition + bufferLenToFill > File.MaxFileSize)                     {                         bufferLenToFill = (uint)(File.MaxFileSize - bufferStartPosition);                     }                     buf = ByteBuffer.NewSync(bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));                     if (buf.Length > 0) {                         if (currentReadAhead * 4 < MaxBlockSize)                         {                             currentReadAhead = currentReadAhead * 2;                         }                         bufReadLength = (int)File.Read(buf' bufferStartPosition + (ulong)bufferFullLength);                         bufferFullLength += bufReadLength;                     }                 }                 if (bufferReadOffset + (int)blockLen > bufferFullLength)                 {                     SetCorrupted();                     return;                 }                 if (Checksum.CalcFletcher32(bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum)                 {                     SetCorrupted();                     return;                 }                 var blockTypeBlock = blockType & (BlockType.FirstBlock | BlockType.MiddleBlock | BlockType.LastBlock);                 var stopReadingRequested = false;                 if (blockTypeBlock == (BlockType.FirstBlock | BlockType.LastBlock))                 {                     stopReadingRequested = Process(blockType' ByteBuffer.NewSync(bufferBlock' bufferReadOffset' (int)blockLen)' observer);                 }                 else                 {                     if (blockTypeBlock == BlockType.FirstBlock)                     {                         overflowWriter = new ByteBufferWriter();                     }                     else if (blockTypeBlock == BlockType.MiddleBlock || blockTypeBlock == BlockType.LastBlock)                     {                         if (overflowWriter == null)                         {                             SetCorrupted();                             return;                         }                     }                     else                     {                         SetCorrupted();                         return;                     }                     overflowWriter.WriteBlock(ByteBuffer.NewSync(bufferBlock' bufferReadOffset' (int)blockLen));                     if (blockTypeBlock == BlockType.LastBlock)                     {                         stopReadingRequested = Process(blockType' overflowWriter.Data' observer);                         overflowWriter = null;                     }                 }                 bufferReadOffset += (int)blockLen;                 if (overflowWriter == null)                     NextReadPosition = bufferStartPosition + (ulong)bufferReadOffset;                 if (stopReadingRequested)                 {                     return;                 }                 var nextBufferStartPosition = (bufferStartPosition + (ulong)bufferReadOffset) & SectorMask;                 var bufferMoveDistance = (int)(nextBufferStartPosition - bufferStartPosition);                 if (bufferMoveDistance <= 0) continue;                 Array.Copy(bufferBlock' bufferMoveDistance' bufferBlock' 0' bufferFullLength - bufferMoveDistance);                 bufferStartPosition = nextBufferStartPosition;                 bufferFullLength -= bufferMoveDistance;                 bufferReadOffset -= bufferMoveDistance;             }
Magic Number,BTDB.EventStoreLayer,TypeSerializers,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,LoaderFactory,The following statement contains a magic number: if (descriptor.AnyOpNeedsCtx())             {                 var localCtx = il.DeclareLocal(typeof(ITypeBinaryDeserializerContext)' "ctx");                 var haveCtx = il.DefineLabel();                 il                     .Ldarg(1)                     .Dup()                     .Stloc(localCtx)                     .Brtrue(haveCtx)                     .Ldarg(0)                     .Ldarg(2)                     .Newobj(() => new DeserializerCtx(null' null))                     .Castclass(typeof(ITypeBinaryDeserializerContext))                     .Stloc(localCtx)                     .Mark(haveCtx);                 descriptor.GenerateLoad(il' ilGen => ilGen.Ldarg(0)' ilGen => ilGen.Ldloc(localCtx)' ilGen => ilGen.Ldarg(3)' loadAsType);             }             else             {                 descriptor.GenerateLoad(il' ilGen => ilGen.Ldarg(0)' ilGen => ilGen.Ldarg(1)' ilGen => ilGen.Ldarg(3)' loadAsType);             }
Magic Number,BTDB.EventStoreLayer,TypeSerializers,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,LoaderFactory,The following statement contains a magic number: if (descriptor.AnyOpNeedsCtx())             {                 var localCtx = il.DeclareLocal(typeof(ITypeBinaryDeserializerContext)' "ctx");                 var haveCtx = il.DefineLabel();                 il                     .Ldarg(1)                     .Dup()                     .Stloc(localCtx)                     .Brtrue(haveCtx)                     .Ldarg(0)                     .Ldarg(2)                     .Newobj(() => new DeserializerCtx(null' null))                     .Castclass(typeof(ITypeBinaryDeserializerContext))                     .Stloc(localCtx)                     .Mark(haveCtx);                 descriptor.GenerateLoad(il' ilGen => ilGen.Ldarg(0)' ilGen => ilGen.Ldloc(localCtx)' ilGen => ilGen.Ldarg(3)' loadAsType);             }             else             {                 descriptor.GenerateLoad(il' ilGen => ilGen.Ldarg(0)' ilGen => ilGen.Ldarg(1)' ilGen => ilGen.Ldarg(3)' loadAsType);             }
Magic Number,BTDB.EventStoreLayer,TypeSerializers,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,LoaderFactory,The following statement contains a magic number: if (descriptor.AnyOpNeedsCtx())             {                 var localCtx = il.DeclareLocal(typeof(ITypeBinaryDeserializerContext)' "ctx");                 var haveCtx = il.DefineLabel();                 il                     .Ldarg(1)                     .Dup()                     .Stloc(localCtx)                     .Brtrue(haveCtx)                     .Ldarg(0)                     .Ldarg(2)                     .Newobj(() => new DeserializerCtx(null' null))                     .Castclass(typeof(ITypeBinaryDeserializerContext))                     .Stloc(localCtx)                     .Mark(haveCtx);                 descriptor.GenerateLoad(il' ilGen => ilGen.Ldarg(0)' ilGen => ilGen.Ldloc(localCtx)' ilGen => ilGen.Ldarg(3)' loadAsType);             }             else             {                 descriptor.GenerateLoad(il' ilGen => ilGen.Ldarg(0)' ilGen => ilGen.Ldarg(1)' ilGen => ilGen.Ldarg(3)' loadAsType);             }
Magic Number,BTDB.EventStoreLayer,TypeSerializers,C:\repos\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,NewComplexSaver,The following statement contains a magic number: descriptor.GenerateSave(il' ilgen => ilgen.Ldarg(0)' ilgen => ilgen.Ldarg(1)' ilgen =>             {                 ilgen.Ldarg(2);                 var type = descriptor.GetPreferedType();                 if (type != typeof(object))                 {                     ilgen.UnboxAny(type);                 }             }' descriptor.GetPreferedType());
Magic Number,BTDB.FieldHandler,EnumConfiguration,C:\repos\Bobris_BTDB\BTDB\FieldHandler\EnumFieldHandler.cs,EnumConfiguration,The following statement contains a magic number: _flags = (header & 2) != 0;
Magic Number,BTDB.FieldHandler,EnumConfiguration,C:\repos\Bobris_BTDB\BTDB\FieldHandler\EnumFieldHandler.cs,EnumConfiguration,The following statement contains a magic number: var count = header >> 2;
Magic Number,BTDB.FieldHandler,EnumConfiguration,C:\repos\Bobris_BTDB\BTDB\FieldHandler\EnumFieldHandler.cs,GetHashCode,The following statement contains a magic number: unchecked                 {                     int result = _flags.GetHashCode();                     result = (result * 397) ^ _names.GetHashCode();                     result = (result * 397) ^ _values.GetHashCode();                     return result;                 }
Magic Number,BTDB.FieldHandler,EnumConfiguration,C:\repos\Bobris_BTDB\BTDB\FieldHandler\EnumFieldHandler.cs,GetHashCode,The following statement contains a magic number: unchecked                 {                     int result = _flags.GetHashCode();                     result = (result * 397) ^ _names.GetHashCode();                     result = (result * 397) ^ _values.GetHashCode();                     return result;                 }
Magic Number,BTDB.IL.Caching,EnumKey,C:\repos\Bobris_BTDB\BTDB\IL\Caching\CachingILBuilder.cs,GetHashCode,The following statement contains a magic number: return _name.GetHashCode() * 33 + _baseType.GetHashCode();
Magic Number,BTDB.IL.Caching,CacheItem,C:\repos\Bobris_BTDB\BTDB\IL\Caching\CachingILDynamicMethod.cs,GetHashCode,The following statement contains a magic number: return _name.GetHashCode() * 33 + _delegate.GetHashCode();
Magic Number,BTDB.IL.Caching,CachingILDynamicType,C:\repos\Bobris_BTDB\BTDB\IL\Caching\CachingILDynamicType.cs,GetHashCode,The following statement contains a magic number: return _name.GetHashCode() * 33 + _insts.Count;
Magic Number,BTDB.IL.Caching,Method,C:\repos\Bobris_BTDB\BTDB\IL\Caching\CachingILDynamicType.cs,GetHashCode,The following statement contains a magic number: unchecked                 {                     var hashCode = _id;                     hashCode = (hashCode * 397) ^ _name.GetHashCode();                     hashCode = (hashCode * 397) ^ _returns.GetHashCode();                     return hashCode;                 }
Magic Number,BTDB.IL.Caching,Method,C:\repos\Bobris_BTDB\BTDB\IL\Caching\CachingILDynamicType.cs,GetHashCode,The following statement contains a magic number: unchecked                 {                     var hashCode = _id;                     hashCode = (hashCode * 397) ^ _name.GetHashCode();                     hashCode = (hashCode * 397) ^ _returns.GetHashCode();                     return hashCode;                 }
Magic Number,BTDB.IL.Caching,Field,C:\repos\Bobris_BTDB\BTDB\IL\Caching\CachingILDynamicType.cs,GetHashCode,The following statement contains a magic number: unchecked                 {                     var hashCode = _id;                     hashCode = (hashCode * 397) ^ _name.GetHashCode();                     hashCode = (hashCode * 397) ^ _type.GetHashCode();                     return hashCode;                 }
Magic Number,BTDB.IL.Caching,Field,C:\repos\Bobris_BTDB\BTDB\IL\Caching\CachingILDynamicType.cs,GetHashCode,The following statement contains a magic number: unchecked                 {                     var hashCode = _id;                     hashCode = (hashCode * 397) ^ _name.GetHashCode();                     hashCode = (hashCode * 397) ^ _type.GetHashCode();                     return hashCode;                 }
Magic Number,BTDB.IL.Caching,Event,C:\repos\Bobris_BTDB\BTDB\IL\Caching\CachingILDynamicType.cs,GetHashCode,The following statement contains a magic number: unchecked                 {                     var hashCode = _id;                     hashCode = (hashCode * 397) ^ _name.GetHashCode();                     hashCode = (hashCode * 397) ^ _type.GetHashCode();                     return hashCode;                 }
Magic Number,BTDB.IL.Caching,Event,C:\repos\Bobris_BTDB\BTDB\IL\Caching\CachingILDynamicType.cs,GetHashCode,The following statement contains a magic number: unchecked                 {                     var hashCode = _id;                     hashCode = (hashCode * 397) ^ _name.GetHashCode();                     hashCode = (hashCode * 397) ^ _type.GetHashCode();                     return hashCode;                 }
Magic Number,BTDB.IL,ILConstructorDebugImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILConstructorDebugImpl.cs,ILConstructorDebugImpl,The following statement contains a magic number: _expectedLength = 64;
Magic Number,BTDB.IL,ILConstructorImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILConstructorImpl.cs,ILConstructorImpl,The following statement contains a magic number: _expectedLength = 64;
Magic Number,BTDB.IL,ILDynamicMethodWithThisImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILDynamicMethodWithThisImpl.cs,ILDynamicMethodWithThisImpl,The following statement contains a magic number: _expectedLength = 64;
Magic Number,BTDB.IL,ILDynamicTypeDebugImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILDynamicTypeDebugImpl.cs,ILDynamicTypeDebugImpl,The following statement contains a magic number: var uniqueName = UniqueName(name' 259 - (DynamicILDirectoryPath.DynamicIL.Length + 1 + 4));
Magic Number,BTDB.IL,ILDynamicTypeDebugImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILDynamicTypeDebugImpl.cs,ILDynamicTypeDebugImpl,The following statement contains a magic number: var uniqueName = UniqueName(name' 259 - (DynamicILDirectoryPath.DynamicIL.Length + 1 + 4));
Magic Number,BTDB.IL,ILDynamicTypeDebugImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILDynamicTypeDebugImpl.cs,UniqueName,The following statement contains a magic number: var uniqueName = maxLength == -1                 ? name                 : ShortenIfNeeded(name' maxLength - 5);
Magic Number,BTDB.IL,ILDynamicTypeDebugImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILDynamicTypeDebugImpl.cs,AddNameShorteningSection,The following statement contains a magic number: var prevSectionPos = pos - sections[pos] - 2;
Magic Number,BTDB.IL,ILDynamicTypeDebugImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILDynamicTypeDebugImpl.cs,SelectSubsectionsToRemove,The following statement contains a magic number: while (needRemove > 0)             {                 var newPos = pos - sections[pos] - 2;                 for (var i = newPos + 2; i < pos; i++)                 {                     if (sections[i] == 1)                         continue;                     needRemove -= sections[i];                     sections[i] = -sections[i];                     if (needRemove <= 0)                         return;                 }                 if (newPos <=0)                     throw new BTDBException($"Cannot shorten dynamic assembly path {name}.");                 pos = newPos;             }
Magic Number,BTDB.IL,ILDynamicTypeDebugImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILDynamicTypeDebugImpl.cs,SelectSubsectionsToRemove,The following statement contains a magic number: while (needRemove > 0)             {                 var newPos = pos - sections[pos] - 2;                 for (var i = newPos + 2; i < pos; i++)                 {                     if (sections[i] == 1)                         continue;                     needRemove -= sections[i];                     sections[i] = -sections[i];                     if (needRemove <= 0)                         return;                 }                 if (newPos <=0)                     throw new BTDBException($"Cannot shorten dynamic assembly path {name}.");                 pos = newPos;             }
Magic Number,BTDB.IL,ILDynamicMethodImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILDynamicMethodImpl.cs,ILDynamicMethodImpl,The following statement contains a magic number: _expectedLength = 64;
Magic Number,BTDB.IL,ILDynamicMethodDebugImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILDynamicMethodDebugImpl.cs,ILDynamicMethodDebugImpl,The following statement contains a magic number: _expectedLength = 64;
Magic Number,BTDB.IL,ILDynamicMethodDebugImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILDynamicMethodDebugImpl.cs,ILDynamicMethodDebugImpl,The following statement contains a magic number: var uniqueName = ILDynamicTypeDebugImpl.UniqueName(name' 259 - (DynamicILDirectoryPath.DynamicIL.Length + 1 + 4));
Magic Number,BTDB.IL,ILDynamicMethodDebugImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILDynamicMethodDebugImpl.cs,ILDynamicMethodDebugImpl,The following statement contains a magic number: var uniqueName = ILDynamicTypeDebugImpl.UniqueName(name' 259 - (DynamicILDirectoryPath.DynamicIL.Length + 1 + 4));
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value)             {                 case 0:                     il.Emit(OpCodes.Ldc_I4_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldc_I4_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldc_I4_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldc_I4_3);                     break;                 case 4:                     il.Emit(OpCodes.Ldc_I4_4);                     break;                 case 5:                     il.Emit(OpCodes.Ldc_I4_5);                     break;                 case 6:                     il.Emit(OpCodes.Ldc_I4_6);                     break;                 case 7:                     il.Emit(OpCodes.Ldc_I4_7);                     break;                 case 8:                     il.Emit(OpCodes.Ldc_I4_8);                     break;                 case -1:                     il.Emit(OpCodes.Ldc_I4_M1);                     break;                 default:                     if (value >= -128 && value <= 127)                         il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                     else                         il.Emit(OpCodes.Ldc_I4' value);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value)             {                 case 0:                     il.Emit(OpCodes.Ldc_I4_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldc_I4_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldc_I4_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldc_I4_3);                     break;                 case 4:                     il.Emit(OpCodes.Ldc_I4_4);                     break;                 case 5:                     il.Emit(OpCodes.Ldc_I4_5);                     break;                 case 6:                     il.Emit(OpCodes.Ldc_I4_6);                     break;                 case 7:                     il.Emit(OpCodes.Ldc_I4_7);                     break;                 case 8:                     il.Emit(OpCodes.Ldc_I4_8);                     break;                 case -1:                     il.Emit(OpCodes.Ldc_I4_M1);                     break;                 default:                     if (value >= -128 && value <= 127)                         il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                     else                         il.Emit(OpCodes.Ldc_I4' value);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value)             {                 case 0:                     il.Emit(OpCodes.Ldc_I4_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldc_I4_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldc_I4_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldc_I4_3);                     break;                 case 4:                     il.Emit(OpCodes.Ldc_I4_4);                     break;                 case 5:                     il.Emit(OpCodes.Ldc_I4_5);                     break;                 case 6:                     il.Emit(OpCodes.Ldc_I4_6);                     break;                 case 7:                     il.Emit(OpCodes.Ldc_I4_7);                     break;                 case 8:                     il.Emit(OpCodes.Ldc_I4_8);                     break;                 case -1:                     il.Emit(OpCodes.Ldc_I4_M1);                     break;                 default:                     if (value >= -128 && value <= 127)                         il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                     else                         il.Emit(OpCodes.Ldc_I4' value);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value)             {                 case 0:                     il.Emit(OpCodes.Ldc_I4_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldc_I4_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldc_I4_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldc_I4_3);                     break;                 case 4:                     il.Emit(OpCodes.Ldc_I4_4);                     break;                 case 5:                     il.Emit(OpCodes.Ldc_I4_5);                     break;                 case 6:                     il.Emit(OpCodes.Ldc_I4_6);                     break;                 case 7:                     il.Emit(OpCodes.Ldc_I4_7);                     break;                 case 8:                     il.Emit(OpCodes.Ldc_I4_8);                     break;                 case -1:                     il.Emit(OpCodes.Ldc_I4_M1);                     break;                 default:                     if (value >= -128 && value <= 127)                         il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                     else                         il.Emit(OpCodes.Ldc_I4' value);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value)             {                 case 0:                     il.Emit(OpCodes.Ldc_I4_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldc_I4_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldc_I4_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldc_I4_3);                     break;                 case 4:                     il.Emit(OpCodes.Ldc_I4_4);                     break;                 case 5:                     il.Emit(OpCodes.Ldc_I4_5);                     break;                 case 6:                     il.Emit(OpCodes.Ldc_I4_6);                     break;                 case 7:                     il.Emit(OpCodes.Ldc_I4_7);                     break;                 case 8:                     il.Emit(OpCodes.Ldc_I4_8);                     break;                 case -1:                     il.Emit(OpCodes.Ldc_I4_M1);                     break;                 default:                     if (value >= -128 && value <= 127)                         il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                     else                         il.Emit(OpCodes.Ldc_I4' value);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value)             {                 case 0:                     il.Emit(OpCodes.Ldc_I4_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldc_I4_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldc_I4_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldc_I4_3);                     break;                 case 4:                     il.Emit(OpCodes.Ldc_I4_4);                     break;                 case 5:                     il.Emit(OpCodes.Ldc_I4_5);                     break;                 case 6:                     il.Emit(OpCodes.Ldc_I4_6);                     break;                 case 7:                     il.Emit(OpCodes.Ldc_I4_7);                     break;                 case 8:                     il.Emit(OpCodes.Ldc_I4_8);                     break;                 case -1:                     il.Emit(OpCodes.Ldc_I4_M1);                     break;                 default:                     if (value >= -128 && value <= 127)                         il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                     else                         il.Emit(OpCodes.Ldc_I4' value);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value)             {                 case 0:                     il.Emit(OpCodes.Ldc_I4_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldc_I4_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldc_I4_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldc_I4_3);                     break;                 case 4:                     il.Emit(OpCodes.Ldc_I4_4);                     break;                 case 5:                     il.Emit(OpCodes.Ldc_I4_5);                     break;                 case 6:                     il.Emit(OpCodes.Ldc_I4_6);                     break;                 case 7:                     il.Emit(OpCodes.Ldc_I4_7);                     break;                 case 8:                     il.Emit(OpCodes.Ldc_I4_8);                     break;                 case -1:                     il.Emit(OpCodes.Ldc_I4_M1);                     break;                 default:                     if (value >= -128 && value <= 127)                         il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                     else                         il.Emit(OpCodes.Ldc_I4' value);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value)             {                 case 0:                     il.Emit(OpCodes.Ldc_I4_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldc_I4_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldc_I4_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldc_I4_3);                     break;                 case 4:                     il.Emit(OpCodes.Ldc_I4_4);                     break;                 case 5:                     il.Emit(OpCodes.Ldc_I4_5);                     break;                 case 6:                     il.Emit(OpCodes.Ldc_I4_6);                     break;                 case 7:                     il.Emit(OpCodes.Ldc_I4_7);                     break;                 case 8:                     il.Emit(OpCodes.Ldc_I4_8);                     break;                 case -1:                     il.Emit(OpCodes.Ldc_I4_M1);                     break;                 default:                     if (value >= -128 && value <= 127)                         il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                     else                         il.Emit(OpCodes.Ldc_I4' value);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value)             {                 case 0:                     il.Emit(OpCodes.Ldc_I4_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldc_I4_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldc_I4_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldc_I4_3);                     break;                 case 4:                     il.Emit(OpCodes.Ldc_I4_4);                     break;                 case 5:                     il.Emit(OpCodes.Ldc_I4_5);                     break;                 case 6:                     il.Emit(OpCodes.Ldc_I4_6);                     break;                 case 7:                     il.Emit(OpCodes.Ldc_I4_7);                     break;                 case 8:                     il.Emit(OpCodes.Ldc_I4_8);                     break;                 case -1:                     il.Emit(OpCodes.Ldc_I4_M1);                     break;                 default:                     if (value >= -128 && value <= 127)                         il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                     else                         il.Emit(OpCodes.Ldc_I4' value);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldarg,The following statement contains a magic number: switch (parameterIndex)             {                 case 0:                     il.Emit(OpCodes.Ldarg_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldarg_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldarg_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldarg_3);                     break;                 default:                     if (parameterIndex <= 255)                         il.Emit(OpCodes.Ldarg_S' (byte)parameterIndex);                     else                         il.Emit(OpCodes.Ldarg' parameterIndex);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldarg,The following statement contains a magic number: switch (parameterIndex)             {                 case 0:                     il.Emit(OpCodes.Ldarg_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldarg_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldarg_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldarg_3);                     break;                 default:                     if (parameterIndex <= 255)                         il.Emit(OpCodes.Ldarg_S' (byte)parameterIndex);                     else                         il.Emit(OpCodes.Ldarg' parameterIndex);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldarg,The following statement contains a magic number: switch (parameterIndex)             {                 case 0:                     il.Emit(OpCodes.Ldarg_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldarg_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldarg_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldarg_3);                     break;                 default:                     if (parameterIndex <= 255)                         il.Emit(OpCodes.Ldarg_S' (byte)parameterIndex);                     else                         il.Emit(OpCodes.Ldarg' parameterIndex);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Starg,The following statement contains a magic number: if (parameterIndex <= 255)                 il.Emit(OpCodes.Starg_S' (byte)parameterIndex);             else                 il.Emit(OpCodes.Starg' parameterIndex);
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Stloc,The following statement contains a magic number: switch (localVariableIndex)             {                 case 0:                     il.Emit(OpCodes.Stloc_0);                     break;                 case 1:                     il.Emit(OpCodes.Stloc_1);                     break;                 case 2:                     il.Emit(OpCodes.Stloc_2);                     break;                 case 3:                     il.Emit(OpCodes.Stloc_3);                     break;                 case 65535:                     throw new ArgumentOutOfRangeException(nameof(localVariableIndex));                 default:                     if (localVariableIndex <= 255)                         il.Emit(OpCodes.Stloc_S' (byte)localVariableIndex);                     else                         il.Emit(OpCodes.Stloc' localVariableIndex);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Stloc,The following statement contains a magic number: switch (localVariableIndex)             {                 case 0:                     il.Emit(OpCodes.Stloc_0);                     break;                 case 1:                     il.Emit(OpCodes.Stloc_1);                     break;                 case 2:                     il.Emit(OpCodes.Stloc_2);                     break;                 case 3:                     il.Emit(OpCodes.Stloc_3);                     break;                 case 65535:                     throw new ArgumentOutOfRangeException(nameof(localVariableIndex));                 default:                     if (localVariableIndex <= 255)                         il.Emit(OpCodes.Stloc_S' (byte)localVariableIndex);                     else                         il.Emit(OpCodes.Stloc' localVariableIndex);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Stloc,The following statement contains a magic number: switch (localVariableIndex)             {                 case 0:                     il.Emit(OpCodes.Stloc_0);                     break;                 case 1:                     il.Emit(OpCodes.Stloc_1);                     break;                 case 2:                     il.Emit(OpCodes.Stloc_2);                     break;                 case 3:                     il.Emit(OpCodes.Stloc_3);                     break;                 case 65535:                     throw new ArgumentOutOfRangeException(nameof(localVariableIndex));                 default:                     if (localVariableIndex <= 255)                         il.Emit(OpCodes.Stloc_S' (byte)localVariableIndex);                     else                         il.Emit(OpCodes.Stloc' localVariableIndex);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Stloc,The following statement contains a magic number: switch (localVariableIndex)             {                 case 0:                     il.Emit(OpCodes.Stloc_0);                     break;                 case 1:                     il.Emit(OpCodes.Stloc_1);                     break;                 case 2:                     il.Emit(OpCodes.Stloc_2);                     break;                 case 3:                     il.Emit(OpCodes.Stloc_3);                     break;                 case 65535:                     throw new ArgumentOutOfRangeException(nameof(localVariableIndex));                 default:                     if (localVariableIndex <= 255)                         il.Emit(OpCodes.Stloc_S' (byte)localVariableIndex);                     else                         il.Emit(OpCodes.Stloc' localVariableIndex);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldloc,The following statement contains a magic number: switch (localVariableIndex)             {                 case 0:                     il.Emit(OpCodes.Ldloc_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldloc_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldloc_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldloc_3);                     break;                 case 65535:                     throw new ArgumentOutOfRangeException(nameof(localVariableIndex));                 default:                     if (localVariableIndex <= 255)                         il.Emit(OpCodes.Ldloc_S' (byte)localVariableIndex);                     else                         il.Emit(OpCodes.Ldloc' localVariableIndex);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldloc,The following statement contains a magic number: switch (localVariableIndex)             {                 case 0:                     il.Emit(OpCodes.Ldloc_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldloc_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldloc_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldloc_3);                     break;                 case 65535:                     throw new ArgumentOutOfRangeException(nameof(localVariableIndex));                 default:                     if (localVariableIndex <= 255)                         il.Emit(OpCodes.Ldloc_S' (byte)localVariableIndex);                     else                         il.Emit(OpCodes.Ldloc' localVariableIndex);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldloc,The following statement contains a magic number: switch (localVariableIndex)             {                 case 0:                     il.Emit(OpCodes.Ldloc_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldloc_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldloc_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldloc_3);                     break;                 case 65535:                     throw new ArgumentOutOfRangeException(nameof(localVariableIndex));                 default:                     if (localVariableIndex <= 255)                         il.Emit(OpCodes.Ldloc_S' (byte)localVariableIndex);                     else                         il.Emit(OpCodes.Ldloc' localVariableIndex);                     break;             }
Magic Number,BTDB.IL,ILGenExtensions,C:\repos\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldloc,The following statement contains a magic number: switch (localVariableIndex)             {                 case 0:                     il.Emit(OpCodes.Ldloc_0);                     break;                 case 1:                     il.Emit(OpCodes.Ldloc_1);                     break;                 case 2:                     il.Emit(OpCodes.Ldloc_2);                     break;                 case 3:                     il.Emit(OpCodes.Ldloc_3);                     break;                 case 65535:                     throw new ArgumentOutOfRangeException(nameof(localVariableIndex));                 default:                     if (localVariableIndex <= 255)                         il.Emit(OpCodes.Ldloc_S' (byte)localVariableIndex);                     else                         il.Emit(OpCodes.Ldloc' localVariableIndex);                     break;             }
Magic Number,BTDB.IL,Call,C:\repos\Bobris_BTDB\BTDB\IL\ILGenForbidenInstructionsCheating.cs,GetHashCode,The following statement contains a magic number: if (_methodInfo != null)                     return _opCode.GetHashCode() * 33 + _methodInfo.GetHashCode() * 2;
Magic Number,BTDB.IL,Call,C:\repos\Bobris_BTDB\BTDB\IL\ILGenForbidenInstructionsCheating.cs,GetHashCode,The following statement contains a magic number: if (_methodInfo != null)                     return _opCode.GetHashCode() * 33 + _methodInfo.GetHashCode() * 2;
Magic Number,BTDB.IL,Call,C:\repos\Bobris_BTDB\BTDB\IL\ILGenForbidenInstructionsCheating.cs,GetHashCode,The following statement contains a magic number: return _opCode.GetHashCode() * 33 + _constructorInfo.GetHashCode() * 2 + 1;
Magic Number,BTDB.IL,Call,C:\repos\Bobris_BTDB\BTDB\IL\ILGenForbidenInstructionsCheating.cs,GetHashCode,The following statement contains a magic number: return _opCode.GetHashCode() * 33 + _constructorInfo.GetHashCode() * 2 + 1;
Magic Number,BTDB.IL,ILMethodDebugImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILMethodDebugImpl.cs,ILMethodDebugImpl,The following statement contains a magic number: _expectedLength = 64;
Magic Number,BTDB.IL,ILMethodImpl,C:\repos\Bobris_BTDB\BTDB\IL\ILMethodImpl.cs,ILMethodImpl,The following statement contains a magic number: _expectedLength = 64;
Magic Number,BTDB.IL,EmitHelpers,C:\repos\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateAddRemoveEvent,The following statement contains a magic number: ilGenerator                 .Ldarg(0)                 .Ldfld(fieldBuilder)                 .Stloc(0)                 .Mark(label)                 .Ldloc(0)                 .Stloc(1)                 .Ldloc(1)                 .Ldarg(1)                 .Call(add                           ? GetMethodInfo(() => Delegate.Combine(null' null))                           : GetMethodInfo(() => Delegate.Remove(null' null)))                 .Castclass(typePropertyChangedEventHandler)                 .Stloc(2)                 .Ldarg(0)                 .Ldflda(fieldBuilder)                 .Ldloc(2)                 .Ldloc(1);
Magic Number,BTDB.IL,EmitHelpers,C:\repos\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateAddRemoveEvent,The following statement contains a magic number: ilGenerator                 .Ldarg(0)                 .Ldfld(fieldBuilder)                 .Stloc(0)                 .Mark(label)                 .Ldloc(0)                 .Stloc(1)                 .Ldloc(1)                 .Ldarg(1)                 .Call(add                           ? GetMethodInfo(() => Delegate.Combine(null' null))                           : GetMethodInfo(() => Delegate.Remove(null' null)))                 .Castclass(typePropertyChangedEventHandler)                 .Stloc(2)                 .Ldarg(0)                 .Ldflda(fieldBuilder)                 .Ldloc(2)                 .Ldloc(1);
Magic Number,BTDB.IOC,Comparer,C:\repos\Bobris_BTDB\BTDB\IOC\GenerationContext.cs,GetHashCode,The following statement contains a magic number: return obj.Item1.GetHashCode() * 33 + obj.Item2.ClrType.GetHashCode();
Magic Number,BTDB.IOC,ComparerConst,C:\repos\Bobris_BTDB\BTDB\IOC\GenerationContext.cs,GetHashCode,The following statement contains a magic number: return obj.Item1.GetHashCode() * 33 + obj.Item2.GetHashCode();
Magic Number,BTDB.IOC,ComparerProcessingContext,C:\repos\Bobris_BTDB\BTDB\IOC\GenerationContext.cs,GetHashCode,The following statement contains a magic number: return obj.Item1.GetHashCode() * 33 + obj.Item2.GetHashCode();
Magic Number,BTDB.IOC,KeyAndType,C:\repos\Bobris_BTDB\BTDB\IOC\KeyAndType.cs,GetHashCode,The following statement contains a magic number: return Key.GetHashCode()*33 + Type.GetHashCode();
Magic Number,BTDB.KVDBLayer.BTree,BTreeBranch,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,Find,The following statement contains a magic number: while (left < right)             {                 var middle = (left + right) / 2;                 var currentKey = _keys[middle];                 var result = BitArrayManipulation.CompareByteArray(prefix' prefix.Length'                                                                    currentKey' Math.Min(currentKey.Length' prefix.Length));                 if (result == 0)                 {                     result = BitArrayManipulation.CompareByteArray(key.Buffer' key.Offset' key.Length'                                                                    currentKey' prefix.Length' currentKey.Length - prefix.Length);                 }                 if (result < 0)                 {                     right = middle;                 }                 else                 {                     left = middle + 1;                 }             }
Magic Number,BTDB.KVDBLayer.BTree,BTreeBranch,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,CreateOrUpdate,The following statement contains a magic number: if (ctx.Split)             {                 ctx.Split = false;                 var newKeys = new byte[_children.Length][];                 var newChildren = new IBTreeNode[_children.Length + 1];                 var newPairCounts = new long[_children.Length + 1];                 Array.Copy(_keys' 0' newKeys' 0' index);                 newKeys[index] = ctx.Node2.GetLeftMostKey();                 Array.Copy(_keys' index' newKeys' index + 1' _keys.Length - index);                 Array.Copy(_children' 0' newChildren' 0' index);                 newChildren[index] = ctx.Node1;                 newChildren[index + 1] = ctx.Node2;                 Array.Copy(_children' index + 1' newChildren' index + 2' _children.Length - index - 1);                 Array.Copy(_pairCounts' newPairCounts' index);                 var previousPairCount = index > 0 ? newPairCounts[index - 1] : 0;                 for (var i = index; i < newPairCounts.Length; i++)                 {                     previousPairCount += newChildren[i].CalcKeyCount();                     newPairCounts[i] = previousPairCount;                 }                 ctx.Node1 = null;                 ctx.Node2 = null;                 if (_children.Length < MaxChildren)                 {                     if (TransactionId != ctx.TransactionId)                     {                         newBranch = new BTreeBranch(ctx.TransactionId' newKeys' newChildren' newPairCounts);                         ctx.Node1 = newBranch;                         ctx.Update = true;                     }                     else                     {                         _keys = newKeys;                         _children = newChildren;                         _pairCounts = newPairCounts;                     }                     if (ctx.SplitInRight) index++;                     ctx.Stack[ctx.Depth] = new NodeIdxPair { Node = newBranch' Idx = index };                     return;                 }                 if (ctx.SplitInRight) index++;                 ctx.Split = true;                  var keyCountLeft = (newChildren.Length + 1) / 2;                 var keyCountRight = newChildren.Length - keyCountLeft;                  var splitKeys = new byte[keyCountLeft - 1][];                 var splitChildren = new IBTreeNode[keyCountLeft];                 var splitPairCounts = new long[keyCountLeft];                 Array.Copy(newKeys' splitKeys' splitKeys.Length);                 Array.Copy(newChildren' splitChildren' splitChildren.Length);                 Array.Copy(newPairCounts' splitPairCounts' splitPairCounts.Length);                 ctx.Node1 = new BTreeBranch(ctx.TransactionId' splitKeys' splitChildren' splitPairCounts);                  splitKeys = new byte[keyCountRight - 1][];                 splitChildren = new IBTreeNode[keyCountRight];                 splitPairCounts = new long[keyCountRight];                 Array.Copy(newKeys' keyCountLeft' splitKeys' 0' splitKeys.Length);                 Array.Copy(newChildren' keyCountLeft' splitChildren' 0' splitChildren.Length);                 for (int i = 0; i < splitPairCounts.Length; i++)                 {                     splitPairCounts[i] = newPairCounts[keyCountLeft + i] - newPairCounts[keyCountLeft - 1];                 }                 ctx.Node2 = new BTreeBranch(ctx.TransactionId' splitKeys' splitChildren' splitPairCounts);                  if (index < keyCountLeft)                 {                     ctx.Stack[ctx.Depth] = new NodeIdxPair { Node = ctx.Node1' Idx = index };                     ctx.SplitInRight = false;                 }                 else                 {                     ctx.Stack[ctx.Depth] = new NodeIdxPair { Node = ctx.Node2' Idx = index - keyCountLeft };                     ctx.SplitInRight = true;                 }                 return;             }
Magic Number,BTDB.KVDBLayer.BTree,BTreeBranch,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,CreateOrUpdate,The following statement contains a magic number: if (ctx.Split)             {                 ctx.Split = false;                 var newKeys = new byte[_children.Length][];                 var newChildren = new IBTreeNode[_children.Length + 1];                 var newPairCounts = new long[_children.Length + 1];                 Array.Copy(_keys' 0' newKeys' 0' index);                 newKeys[index] = ctx.Node2.GetLeftMostKey();                 Array.Copy(_keys' index' newKeys' index + 1' _keys.Length - index);                 Array.Copy(_children' 0' newChildren' 0' index);                 newChildren[index] = ctx.Node1;                 newChildren[index + 1] = ctx.Node2;                 Array.Copy(_children' index + 1' newChildren' index + 2' _children.Length - index - 1);                 Array.Copy(_pairCounts' newPairCounts' index);                 var previousPairCount = index > 0 ? newPairCounts[index - 1] : 0;                 for (var i = index; i < newPairCounts.Length; i++)                 {                     previousPairCount += newChildren[i].CalcKeyCount();                     newPairCounts[i] = previousPairCount;                 }                 ctx.Node1 = null;                 ctx.Node2 = null;                 if (_children.Length < MaxChildren)                 {                     if (TransactionId != ctx.TransactionId)                     {                         newBranch = new BTreeBranch(ctx.TransactionId' newKeys' newChildren' newPairCounts);                         ctx.Node1 = newBranch;                         ctx.Update = true;                     }                     else                     {                         _keys = newKeys;                         _children = newChildren;                         _pairCounts = newPairCounts;                     }                     if (ctx.SplitInRight) index++;                     ctx.Stack[ctx.Depth] = new NodeIdxPair { Node = newBranch' Idx = index };                     return;                 }                 if (ctx.SplitInRight) index++;                 ctx.Split = true;                  var keyCountLeft = (newChildren.Length + 1) / 2;                 var keyCountRight = newChildren.Length - keyCountLeft;                  var splitKeys = new byte[keyCountLeft - 1][];                 var splitChildren = new IBTreeNode[keyCountLeft];                 var splitPairCounts = new long[keyCountLeft];                 Array.Copy(newKeys' splitKeys' splitKeys.Length);                 Array.Copy(newChildren' splitChildren' splitChildren.Length);                 Array.Copy(newPairCounts' splitPairCounts' splitPairCounts.Length);                 ctx.Node1 = new BTreeBranch(ctx.TransactionId' splitKeys' splitChildren' splitPairCounts);                  splitKeys = new byte[keyCountRight - 1][];                 splitChildren = new IBTreeNode[keyCountRight];                 splitPairCounts = new long[keyCountRight];                 Array.Copy(newKeys' keyCountLeft' splitKeys' 0' splitKeys.Length);                 Array.Copy(newChildren' keyCountLeft' splitChildren' 0' splitChildren.Length);                 for (int i = 0; i < splitPairCounts.Length; i++)                 {                     splitPairCounts[i] = newPairCounts[keyCountLeft + i] - newPairCounts[keyCountLeft - 1];                 }                 ctx.Node2 = new BTreeBranch(ctx.TransactionId' splitKeys' splitChildren' splitPairCounts);                  if (index < keyCountLeft)                 {                     ctx.Stack[ctx.Depth] = new NodeIdxPair { Node = ctx.Node1' Idx = index };                     ctx.SplitInRight = false;                 }                 else                 {                     ctx.Stack[ctx.Depth] = new NodeIdxPair { Node = ctx.Node2' Idx = index - keyCountLeft };                     ctx.SplitInRight = true;                 }                 return;             }
Magic Number,BTDB.KVDBLayer.BTree,BTreeBranch,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,FillStackByIndex,The following statement contains a magic number: while (left < right)             {                 var middle = (left + right) / 2;                 var currentIndex = _pairCounts[middle];                 if (keyIndex < currentIndex)                 {                     right = middle;                 }                 else                 {                     left = middle + 1;                 }             }
Magic Number,BTDB.KVDBLayer.BTree,BTreeBranch,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,FindLastWithPrefix,The following statement contains a magic number: while (left < right)             {                 var middle = (left + right) / 2;                 var currentKey = _keys[middle];                 var result = BitArrayManipulation.CompareByteArray(prefix' prefix.Length'                                                                    currentKey' Math.Min(currentKey.Length' prefix.Length));                 if (result < 0)                 {                     right = middle;                 }                 else                 {                     left = middle + 1;                 }             }
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,Find,The following statement contains a magic number: while (left < right)             {                 var middle = (left + right) / 2;                 var currentKey = _keyvalues[middle].Key;                 var result = BitArrayManipulation.CompareByteArray(prefix' prefix.Length'                                                                    currentKey' Math.Min(currentKey.Length' prefix.Length));                 if (result == 0)                 {                     result = BitArrayManipulation.CompareByteArray(key.Buffer' key.Offset' key.Length'                                                                    currentKey' prefix.Length' currentKey.Length - prefix.Length);                     if (result == 0)                     {                         return middle * 2 + 1;                     }                 }                 if (result < 0)                 {                     right = middle;                 }                 else                 {                     left = middle + 1;                 }              }
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,Find,The following statement contains a magic number: while (left < right)             {                 var middle = (left + right) / 2;                 var currentKey = _keyvalues[middle].Key;                 var result = BitArrayManipulation.CompareByteArray(prefix' prefix.Length'                                                                    currentKey' Math.Min(currentKey.Length' prefix.Length));                 if (result == 0)                 {                     result = BitArrayManipulation.CompareByteArray(key.Buffer' key.Offset' key.Length'                                                                    currentKey' prefix.Length' currentKey.Length - prefix.Length);                     if (result == 0)                     {                         return middle * 2 + 1;                     }                 }                 if (result < 0)                 {                     right = middle;                 }                 else                 {                     left = middle + 1;                 }              }
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,Find,The following statement contains a magic number: return left * 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,CreateOrUpdate,The following statement contains a magic number: if ((index & 1) == 1)             {                 index = index / 2;                 ctx.Created = false;                 ctx.KeyIndex = index;                 var m = _keyvalues[index];                 m.ValueFileId = ctx.ValueFileId;                 m.ValueOfs = ctx.ValueOfs;                 m.ValueSize = ctx.ValueSize;                 var leaf = this;                 if (ctx.TransactionId != TransactionId)                 {                     leaf = new BTreeLeaf(ctx.TransactionId' _keyvalues.Length);                     Array.Copy(_keyvalues' leaf._keyvalues' _keyvalues.Length);                     ctx.Node1 = leaf;                     ctx.Update = true;                 }                 leaf._keyvalues[index] = m;                 ctx.Stack.Add(new NodeIdxPair { Node = leaf' Idx = index });                 return;             }
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,CreateOrUpdate,The following statement contains a magic number: index = index / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,CreateOrUpdate,The following statement contains a magic number: var keyCountLeft = (_keyvalues.Length + 1) / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,FindKey,The following statement contains a magic number: if ((idx & 1) == 1)             {                 result = FindResult.Exact;                 idx = idx / 2;             }             else             {                 result = FindResult.Previous;                 idx = idx / 2 - 1;             }
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,FindKey,The following statement contains a magic number: if ((idx & 1) == 1)             {                 result = FindResult.Exact;                 idx = idx / 2;             }             else             {                 result = FindResult.Previous;                 idx = idx / 2 - 1;             }
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,FindLastWithPrefix,The following statement contains a magic number: while (left < right)             {                 var middle = (left + right) / 2;                 currentKey = _keyvalues[middle].Key;                 result = BitArrayManipulation.CompareByteArray(prefix' prefix.Length'                                                                currentKey' Math.Min(currentKey.Length' prefix.Length));                 if (result < 0)                 {                     right = middle;                 }                 else                 {                     left = middle + 1;                 }              }
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,Find,The following statement contains a magic number: while (left < right)             {                 var middle = (left + right) / 2;                 int currentKeyOfs = _keyvalues[middle].KeyOffset;                 int currentKeyLen = _keyvalues[middle].KeyLength;                 var result = BitArrayManipulation.CompareByteArray(prefix' 0' prefix.Length'                                                                    keyBytes' currentKeyOfs' Math.Min(currentKeyLen' prefix.Length));                 if (result == 0)                 {                     result = BitArrayManipulation.CompareByteArray(key.Buffer' key.Offset' key.Length'                                                                    keyBytes' currentKeyOfs + prefix.Length' currentKeyLen - prefix.Length);                     if (result == 0)                     {                         return middle * 2 + 1;                     }                 }                 if (result < 0)                 {                     right = middle;                 }                 else                 {                     left = middle + 1;                 }              }
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,Find,The following statement contains a magic number: while (left < right)             {                 var middle = (left + right) / 2;                 int currentKeyOfs = _keyvalues[middle].KeyOffset;                 int currentKeyLen = _keyvalues[middle].KeyLength;                 var result = BitArrayManipulation.CompareByteArray(prefix' 0' prefix.Length'                                                                    keyBytes' currentKeyOfs' Math.Min(currentKeyLen' prefix.Length));                 if (result == 0)                 {                     result = BitArrayManipulation.CompareByteArray(key.Buffer' key.Offset' key.Length'                                                                    keyBytes' currentKeyOfs + prefix.Length' currentKeyLen - prefix.Length);                     if (result == 0)                     {                         return middle * 2 + 1;                     }                 }                 if (result < 0)                 {                     right = middle;                 }                 else                 {                     left = middle + 1;                 }              }
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,Find,The following statement contains a magic number: return left * 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,CreateOrUpdate,The following statement contains a magic number: if ((index & 1) == 1)             {                 index = index / 2;                 ctx.Created = false;                 ctx.KeyIndex = index;                 var m = _keyvalues[index];                 m.ValueFileId = ctx.ValueFileId;                 m.ValueOfs = ctx.ValueOfs;                 m.ValueSize = ctx.ValueSize;                 var leaf = this;                 if (ctx.TransactionId != TransactionId)                 {                     leaf = new BTreeLeafComp(ctx.TransactionId' _keyvalues.Length);                     Array.Copy(_keyvalues' leaf._keyvalues' _keyvalues.Length);                     leaf._keyBytes = _keyBytes;                     ctx.Node1 = leaf;                     ctx.Update = true;                 }                 leaf._keyvalues[index] = m;                 ctx.Stack.Add(new NodeIdxPair { Node = leaf' Idx = index });                 return;             }
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,CreateOrUpdate,The following statement contains a magic number: index = index / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,CreateOrUpdate,The following statement contains a magic number: var keyCountLeft = (_keyvalues.Length + 1) / 2;
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,FindKey,The following statement contains a magic number: if ((idx & 1) == 1)             {                 result = FindResult.Exact;                 idx = idx / 2;             }             else             {                 result = FindResult.Previous;                 idx = idx / 2 - 1;             }
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,FindKey,The following statement contains a magic number: if ((idx & 1) == 1)             {                 result = FindResult.Exact;                 idx = idx / 2;             }             else             {                 result = FindResult.Previous;                 idx = idx / 2 - 1;             }
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,FindLastWithPrefix,The following statement contains a magic number: while (left < right)             {                 var middle = (left + right) / 2;                 currentKeyOfs = _keyvalues[middle].KeyOffset;                 currentKeyLen = _keyvalues[middle].KeyLength;                 result = BitArrayManipulation.CompareByteArray(prefix' 0' prefix.Length'                                                                keyBytes' currentKeyOfs' Math.Min(currentKeyLen' prefix.Length));                 if (result < 0)                 {                     right = middle;                 }                 else                 {                     left = middle + 1;                 }              }
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeBranch,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,Find,The following statement contains a magic number: while (left < right)             {                 var middle = (left + right) / 2;                 var currentKey = _keys[middle];                 var result = BitArrayManipulation.CompareByteArray(prefix' prefix.Length'                                                                    currentKey' Math.Min(currentKey.Length' prefix.Length));                 if (result == 0)                 {                     result = BitArrayManipulation.CompareByteArray(key.Buffer' key.Offset' key.Length'                                                                    currentKey' prefix.Length' currentKey.Length - prefix.Length);                 }                 if (result < 0)                 {                     right = middle;                 }                 else                 {                     left = middle + 1;                 }             }
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeBranch,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,CreateOrUpdate,The following statement contains a magic number: if (ctx.Split)             {                 ctx.Split = false;                 var newKeys = new byte[_children.Length][];                 var newChildren = new IBTreeNode[_children.Length + 1];                 var newPairCounts = new long[_children.Length + 1];                 Array.Copy(_keys' 0' newKeys' 0' index);                 newKeys[index] = ctx.Node2.GetLeftMostKey();                 Array.Copy(_keys' index' newKeys' index + 1' _keys.Length - index);                 Array.Copy(_children' 0' newChildren' 0' index);                 newChildren[index] = ctx.Node1;                 newChildren[index + 1] = ctx.Node2;                 Array.Copy(_children' index + 1' newChildren' index + 2' _children.Length - index - 1);                 Array.Copy(_pairCounts' newPairCounts' index);                 var previousPairCount = index > 0 ? newPairCounts[index - 1] : 0;                 for (var i = index; i < newPairCounts.Length; i++)                 {                     previousPairCount += newChildren[i].CalcKeyCount();                     newPairCounts[i] = previousPairCount;                 }                 ctx.Node1 = null;                 ctx.Node2 = null;                 if (_children.Length < MaxChildren)                 {                     if (TransactionId != ctx.TransactionId)                     {                         newBranch = new BTreeBranch(ctx.TransactionId' newKeys' newChildren' newPairCounts);                         ctx.Node1 = newBranch;                         ctx.Update = true;                     }                     else                     {                         _keys = newKeys;                         _children = newChildren;                         _pairCounts = newPairCounts;                     }                     if (ctx.SplitInRight) index++;                     ctx.Stack[ctx.Depth] = new NodeIdxPair { Node = newBranch' Idx = index };                     return;                 }                 if (ctx.SplitInRight) index++;                 ctx.Split = true;                  var keyCountLeft = (newChildren.Length + 1) / 2;                 var keyCountRight = newChildren.Length - keyCountLeft;                  var splitKeys = new byte[keyCountLeft - 1][];                 var splitChildren = new IBTreeNode[keyCountLeft];                 var splitPairCounts = new long[keyCountLeft];                 Array.Copy(newKeys' splitKeys' splitKeys.Length);                 Array.Copy(newChildren' splitChildren' splitChildren.Length);                 Array.Copy(newPairCounts' splitPairCounts' splitPairCounts.Length);                 ctx.Node1 = new BTreeBranch(ctx.TransactionId' splitKeys' splitChildren' splitPairCounts);                  splitKeys = new byte[keyCountRight - 1][];                 splitChildren = new IBTreeNode[keyCountRight];                 splitPairCounts = new long[keyCountRight];                 Array.Copy(newKeys' keyCountLeft' splitKeys' 0' splitKeys.Length);                 Array.Copy(newChildren' keyCountLeft' splitChildren' 0' splitChildren.Length);                 for (int i = 0; i < splitPairCounts.Length; i++)                 {                     splitPairCounts[i] = newPairCounts[keyCountLeft + i] - newPairCounts[keyCountLeft - 1];                 }                 ctx.Node2 = new BTreeBranch(ctx.TransactionId' splitKeys' splitChildren' splitPairCounts);                  if (index < keyCountLeft)                 {                     ctx.Stack[ctx.Depth] = new NodeIdxPair { Node = ctx.Node1' Idx = index };                     ctx.SplitInRight = false;                 }                 else                 {                     ctx.Stack[ctx.Depth] = new NodeIdxPair { Node = ctx.Node2' Idx = index - keyCountLeft };                     ctx.SplitInRight = true;                 }                 return;             }
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeBranch,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,CreateOrUpdate,The following statement contains a magic number: if (ctx.Split)             {                 ctx.Split = false;                 var newKeys = new byte[_children.Length][];                 var newChildren = new IBTreeNode[_children.Length + 1];                 var newPairCounts = new long[_children.Length + 1];                 Array.Copy(_keys' 0' newKeys' 0' index);                 newKeys[index] = ctx.Node2.GetLeftMostKey();                 Array.Copy(_keys' index' newKeys' index + 1' _keys.Length - index);                 Array.Copy(_children' 0' newChildren' 0' index);                 newChildren[index] = ctx.Node1;                 newChildren[index + 1] = ctx.Node2;                 Array.Copy(_children' index + 1' newChildren' index + 2' _children.Length - index - 1);                 Array.Copy(_pairCounts' newPairCounts' index);                 var previousPairCount = index > 0 ? newPairCounts[index - 1] : 0;                 for (var i = index; i < newPairCounts.Length; i++)                 {                     previousPairCount += newChildren[i].CalcKeyCount();                     newPairCounts[i] = previousPairCount;                 }                 ctx.Node1 = null;                 ctx.Node2 = null;                 if (_children.Length < MaxChildren)                 {                     if (TransactionId != ctx.TransactionId)                     {                         newBranch = new BTreeBranch(ctx.TransactionId' newKeys' newChildren' newPairCounts);                         ctx.Node1 = newBranch;                         ctx.Update = true;                     }                     else                     {                         _keys = newKeys;                         _children = newChildren;                         _pairCounts = newPairCounts;                     }                     if (ctx.SplitInRight) index++;                     ctx.Stack[ctx.Depth] = new NodeIdxPair { Node = newBranch' Idx = index };                     return;                 }                 if (ctx.SplitInRight) index++;                 ctx.Split = true;                  var keyCountLeft = (newChildren.Length + 1) / 2;                 var keyCountRight = newChildren.Length - keyCountLeft;                  var splitKeys = new byte[keyCountLeft - 1][];                 var splitChildren = new IBTreeNode[keyCountLeft];                 var splitPairCounts = new long[keyCountLeft];                 Array.Copy(newKeys' splitKeys' splitKeys.Length);                 Array.Copy(newChildren' splitChildren' splitChildren.Length);                 Array.Copy(newPairCounts' splitPairCounts' splitPairCounts.Length);                 ctx.Node1 = new BTreeBranch(ctx.TransactionId' splitKeys' splitChildren' splitPairCounts);                  splitKeys = new byte[keyCountRight - 1][];                 splitChildren = new IBTreeNode[keyCountRight];                 splitPairCounts = new long[keyCountRight];                 Array.Copy(newKeys' keyCountLeft' splitKeys' 0' splitKeys.Length);                 Array.Copy(newChildren' keyCountLeft' splitChildren' 0' splitChildren.Length);                 for (int i = 0; i < splitPairCounts.Length; i++)                 {                     splitPairCounts[i] = newPairCounts[keyCountLeft + i] - newPairCounts[keyCountLeft - 1];                 }                 ctx.Node2 = new BTreeBranch(ctx.TransactionId' splitKeys' splitChildren' splitPairCounts);                  if (index < keyCountLeft)                 {                     ctx.Stack[ctx.Depth] = new NodeIdxPair { Node = ctx.Node1' Idx = index };                     ctx.SplitInRight = false;                 }                 else                 {                     ctx.Stack[ctx.Depth] = new NodeIdxPair { Node = ctx.Node2' Idx = index - keyCountLeft };                     ctx.SplitInRight = true;                 }                 return;             }
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeBranch,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,FillStackByIndex,The following statement contains a magic number: while (left < right)             {                 var middle = (left + right) / 2;                 var currentIndex = _pairCounts[middle];                 if (keyIndex < currentIndex)                 {                     right = middle;                 }                 else                 {                     left = middle + 1;                 }             }
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeBranch,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,FindLastWithPrefix,The following statement contains a magic number: while (left < right)             {                 var middle = (left + right) / 2;                 var currentKey = _keys[middle];                 var result = BitArrayManipulation.CompareByteArray(prefix' prefix.Length'                                                                    currentKey' Math.Min(currentKey.Length' prefix.Length));                 if (result < 0)                 {                     right = middle;                 }                 else                 {                     left = middle + 1;                 }             }
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,Find,The following statement contains a magic number: while (left < right)             {                 var middle = (left + right) / 2;                 var currentKey = _keyvalues[middle].Key;                 var result = BitArrayManipulation.CompareByteArray(prefix' prefix.Length'                                                                    currentKey' Math.Min(currentKey.Length' prefix.Length));                 if (result == 0)                 {                     result = BitArrayManipulation.CompareByteArray(key.Buffer' key.Offset' key.Length'                                                                    currentKey' prefix.Length' currentKey.Length - prefix.Length);                     if (result == 0)                     {                         return middle * 2 + 1;                     }                 }                 if (result < 0)                 {                     right = middle;                 }                 else                 {                     left = middle + 1;                 }              }
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,Find,The following statement contains a magic number: while (left < right)             {                 var middle = (left + right) / 2;                 var currentKey = _keyvalues[middle].Key;                 var result = BitArrayManipulation.CompareByteArray(prefix' prefix.Length'                                                                    currentKey' Math.Min(currentKey.Length' prefix.Length));                 if (result == 0)                 {                     result = BitArrayManipulation.CompareByteArray(key.Buffer' key.Offset' key.Length'                                                                    currentKey' prefix.Length' currentKey.Length - prefix.Length);                     if (result == 0)                     {                         return middle * 2 + 1;                     }                 }                 if (result < 0)                 {                     right = middle;                 }                 else                 {                     left = middle + 1;                 }              }
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,Find,The following statement contains a magic number: return left * 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,CreateOrUpdate,The following statement contains a magic number: if ((index & 1) == 1)             {                 index = index / 2;                 ctx.Created = false;                 ctx.KeyIndex = index;                 var m = _keyvalues[index];                 m.Value = ctx.Value.ToByteArray();                 var leaf = this;                 if (ctx.TransactionId != TransactionId)                 {                     leaf = new BTreeLeaf(ctx.TransactionId' _keyvalues.Length);                     Array.Copy(_keyvalues' leaf._keyvalues' _keyvalues.Length);                     ctx.Node1 = leaf;                     ctx.Update = true;                 }                 leaf._keyvalues[index] = m;                 ctx.Stack.Add(new NodeIdxPair { Node = leaf' Idx = index });                 return;             }
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,CreateOrUpdate,The following statement contains a magic number: index = index / 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,CreateOrUpdate,The following statement contains a magic number: var keyCountLeft = (_keyvalues.Length + 1) / 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,FindKey,The following statement contains a magic number: if ((idx & 1) == 1)             {                 result = FindResult.Exact;                 idx = idx / 2;             }             else             {                 result = FindResult.Previous;                 idx = idx / 2 - 1;             }
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,FindKey,The following statement contains a magic number: if ((idx & 1) == 1)             {                 result = FindResult.Exact;                 idx = idx / 2;             }             else             {                 result = FindResult.Previous;                 idx = idx / 2 - 1;             }
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,FindLastWithPrefix,The following statement contains a magic number: while (left < right)             {                 var middle = (left + right) / 2;                 currentKey = _keyvalues[middle].Key;                 result = BitArrayManipulation.CompareByteArray(prefix' prefix.Length'                                                                currentKey' Math.Min(currentKey.Length' prefix.Length));                 if (result < 0)                 {                     right = middle;                 }                 else                 {                     left = middle + 1;                 }              }
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,Find,The following statement contains a magic number: while (left < right)             {                 var middle = (left + right) / 2;                 int currentKeyOfs = _keyvalues[middle].KeyOffset;                 int currentKeyLen = _keyvalues[middle].KeyLength;                 var result = BitArrayManipulation.CompareByteArray(prefix' 0' prefix.Length'                                                                    keyBytes' currentKeyOfs' Math.Min(currentKeyLen' prefix.Length));                 if (result == 0)                 {                     result = BitArrayManipulation.CompareByteArray(key.Buffer' key.Offset' key.Length'                                                                    keyBytes' currentKeyOfs + prefix.Length' currentKeyLen - prefix.Length);                     if (result == 0)                     {                         return middle * 2 + 1;                     }                 }                 if (result < 0)                 {                     right = middle;                 }                 else                 {                     left = middle + 1;                 }              }
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,Find,The following statement contains a magic number: while (left < right)             {                 var middle = (left + right) / 2;                 int currentKeyOfs = _keyvalues[middle].KeyOffset;                 int currentKeyLen = _keyvalues[middle].KeyLength;                 var result = BitArrayManipulation.CompareByteArray(prefix' 0' prefix.Length'                                                                    keyBytes' currentKeyOfs' Math.Min(currentKeyLen' prefix.Length));                 if (result == 0)                 {                     result = BitArrayManipulation.CompareByteArray(key.Buffer' key.Offset' key.Length'                                                                    keyBytes' currentKeyOfs + prefix.Length' currentKeyLen - prefix.Length);                     if (result == 0)                     {                         return middle * 2 + 1;                     }                 }                 if (result < 0)                 {                     right = middle;                 }                 else                 {                     left = middle + 1;                 }              }
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,Find,The following statement contains a magic number: return left * 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,The following statement contains a magic number: if ((index & 1) == 1)             {                 index = index / 2;                 ctx.Created = false;                 ctx.KeyIndex = index;                 var m = _keyvalues[index];                 m.Value = ctx.Value.ToByteArray();                 var leaf = this;                 if (ctx.TransactionId != TransactionId)                 {                     leaf = new BTreeLeafComp(ctx.TransactionId' _keyvalues.Length);                     Array.Copy(_keyvalues' leaf._keyvalues' _keyvalues.Length);                     leaf._keyBytes = _keyBytes;                     ctx.Node1 = leaf;                     ctx.Update = true;                 }                 leaf._keyvalues[index] = m;                 ctx.Stack.Add(new NodeIdxPair { Node = leaf' Idx = index });                 return;             }
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,The following statement contains a magic number: index = index / 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,The following statement contains a magic number: var keyCountLeft = (_keyvalues.Length + 1) / 2;
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,FindKey,The following statement contains a magic number: if ((idx & 1) == 1)             {                 result = FindResult.Exact;                 idx = idx / 2;             }             else             {                 result = FindResult.Previous;                 idx = idx / 2 - 1;             }
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,FindKey,The following statement contains a magic number: if ((idx & 1) == 1)             {                 result = FindResult.Exact;                 idx = idx / 2;             }             else             {                 result = FindResult.Previous;                 idx = idx / 2 - 1;             }
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,FindLastWithPrefix,The following statement contains a magic number: while (left < right)             {                 var middle = (left + right) / 2;                 currentKeyOfs = _keyvalues[middle].KeyOffset;                 currentKeyLen = _keyvalues[middle].KeyLength;                 result = BitArrayManipulation.CompareByteArray(prefix' 0' prefix.Length'                                                                keyBytes' currentKeyOfs' Math.Min(currentKeyLen' prefix.Length));                 if (result < 0)                 {                     right = middle;                 }                 else                 {                     left = middle + 1;                 }              }
Magic Number,BTDB.KVDBLayer,ChunkStorageInKV,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\ChunkStorageInKV.cs,CheckOrInitKeyLen,The following statement contains a magic number: if (_keyLen == -1)             {                 if (keyLen != 20) throw new ArgumentException("Length of Key must be 20 bytes"); #pragma warning disable 420                 Interlocked.CompareExchange(ref _keyLen' keyLen' -1); #pragma warning restore 420             }
Magic Number,BTDB.KVDBLayer,Compactor,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,Run,The following statement contains a magic number: if (IsWasteSmall(totalWaste))             {                 if (_keyValueDB.DistanceFromLastKeyIndex(_root) > (ulong)(_keyValueDB.MaxTrLogFileSize / 4))                     _keyValueDB.CreateIndexFile(_cancellation' preserveKeyIndexGeneration);                 _keyValueDB.FileCollection.DeleteAllUnknownFiles();                 return false;             }
Magic Number,BTDB.KVDBLayer,Compactor,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,Run,The following statement contains a magic number: var btreesCorrectInTransactionId = _keyValueDB.AtomicallyChangeBTree(root => root.RemappingIterate((uint oldFileId' uint oldOffset' out uint newFileId' out uint newOffset) =>             {                 newFileId = valueFileId;                 _cancellation.ThrowIfCancellationRequested();                 return _newPositionMap.TryGetValue(((ulong)oldFileId << 32) | oldOffset' out newOffset);             }));
Magic Number,BTDB.KVDBLayer,Compactor,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,IsWasteSmall,The following statement contains a magic number: return totalWaste < (ulong)_keyValueDB.MaxTrLogFileSize / 4;
Magic Number,BTDB.KVDBLayer,Compactor,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,MoveValuesContent,The following statement contains a magic number: const uint blockSize = 128 * 1024;
Magic Number,BTDB.KVDBLayer,Compactor,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,MoveValuesContent,The following statement contains a magic number: const uint blockSize = 128 * 1024;
Magic Number,BTDB.KVDBLayer,Compactor,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,MoveValuesContent,The following statement contains a magic number: _root.Iterate((valueFileId' valueOfs' valueSize) =>                 {                     if (valueFileId != wastefullFileId) return;                     var size = (uint)Math.Abs(valueSize);                     _newPositionMap.Add(((ulong)wastefullFileId << 32) | valueOfs' (uint)writer.GetCurrentPosition());                     pos = valueOfs;                     while (size > 0)                     {                         _cancellation.ThrowIfCancellationRequested();                         var blockId = pos / blockSize;                         var blockStart = pos % blockSize;                         var writeSize = (uint)(blockSize - blockStart);                         if (writeSize > size) writeSize = size;                         writer.WriteBlock(wasteInMemory[blockId]' (int)blockStart' (int)writeSize);                         size -= writeSize;                         pos += writeSize;                     }                 });
Magic Number,BTDB.KVDBLayer,Compactor,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,CalcTotalWaste,The following statement contains a magic number: foreach (var fileStat in _fileStats)             {                 var waste = fileStat.CalcWasteIgnoreUseless();                 if (waste > 1024) total += waste;             }
Magic Number,BTDB.KVDBLayer,CompactorScheduler,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\CompactorScheduler.cs,CompactorScheduler,The following statement contains a magic number: WaitTime = TimeSpan.FromMinutes(10 + new Random().NextDouble() * 5);
Magic Number,BTDB.KVDBLayer,CompactorScheduler,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\CompactorScheduler.cs,CompactorScheduler,The following statement contains a magic number: WaitTime = TimeSpan.FromMinutes(10 + new Random().NextDouble() * 5);
Magic Number,BTDB.KVDBLayer,Reader,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\OnDiskMemoryMappedFileCollection.cs,Reader,The following statement contains a magic number: Buf = new byte[32768];
Magic Number,BTDB.KVDBLayer,Reader,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\OnDiskMemoryMappedFileCollection.cs,Reader,The following statement contains a magic number: Buf = new byte[32768];
Magic Number,BTDB.KVDBLayer,Writer,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\OnDiskMemoryMappedFileCollection.cs,Writer,The following statement contains a magic number: Buf = new byte[1024 * 32];
Magic Number,BTDB.KVDBLayer,Writer,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\OnDiskMemoryMappedFileCollection.cs,Writer,The following statement contains a magic number: Buf = new byte[1024 * 32];
Magic Number,BTDB.KVDBLayer,Writer,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\OnDiskMemoryMappedFileCollection.cs,Writer,The following statement contains a magic number: Buf = new byte[32768];
Magic Number,BTDB.KVDBLayer,SnappyCompressionStrategy,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\SnappyCompressionStrategy.cs,ShouldTryToCompressKey,The following statement contains a magic number: return length > 1024;
Magic Number,BTDB.KVDBLayer,SnappyCompressionStrategy,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\SnappyCompressionStrategy.cs,CompressKey,The following statement contains a magic number: return SnappyCompress.TryCompress(ref data' 80);
Magic Number,BTDB.KVDBLayer,SnappyCompressionStrategy,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\SnappyCompressionStrategy.cs,CompressValue,The following statement contains a magic number: if (data.Length < 32) return false;
Magic Number,BTDB.KVDBLayer,SnappyCompressionStrategy,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\SnappyCompressionStrategy.cs,CompressValue,The following statement contains a magic number: return SnappyCompress.TryCompress(ref data' 80);
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,KeyValueDB,The following statement contains a magic number: if (options.FileSplitSize < 1024 || options.FileSplitSize > int.MaxValue) throw new ArgumentOutOfRangeException(nameof(options.FileSplitSize)' "Allowed range 1024 - 2G");
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen)             {                 case 0:                     valueOfs = 0;                     valueSize = 0;                     break;                 case 1:                     valueOfs = 0;                     valueSize = 0x1000000 | (inlineValueBuf[ofs] << 16);                     break;                 case 2:                     valueOfs = 0;                     valueSize = 0x2000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8);                     break;                 case 3:                     valueOfs = 0;                     valueSize = 0x3000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 4:                     valueOfs = inlineValueBuf[ofs + 3];                     valueSize = 0x4000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 5:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8);                     valueSize = 0x5000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 6:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16);                     valueSize = 0x6000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 case 7:                     valueOfs = inlineValueBuf[ofs + 3] | ((uint)inlineValueBuf[ofs + 4] << 8) | ((uint)inlineValueBuf[ofs + 5] << 16) | (((uint)inlineValueBuf[ofs + 6]) << 24);                     valueSize = 0x7000000 | (inlineValueBuf[ofs] << 16) | (inlineValueBuf[ofs + 1] << 8) | inlineValueBuf[ofs + 2];                     break;                 default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,WriteCreateOrUpdateCommand,The following statement contains a magic number: if (trlPos > 256 && trlPos + prefix.Length + key.Length + 16 + value.Length > MaxTrLogFileSize)             {                 WriteStartOfNewTransactionLogFile();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,WriteCreateOrUpdateCommand,The following statement contains a magic number: if (trlPos > 256 && trlPos + prefix.Length + key.Length + 16 + value.Length > MaxTrLogFileSize)             {                 WriteStartOfNewTransactionLogFile();             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,CalcValueSize,The following statement contains a magic number: if (valueFileId == 0)             {                 return (uint)(valueSize >> 24);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDB,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0)             {                 var len = valueSize >> 24;                 var buf = new byte[len];                 switch (len)                 {                     case 7:                         buf[6] = (byte)(valueOfs >> 24);                         goto case 6;                     case 6:                         buf[5] = (byte)(valueOfs >> 16);                         goto case 5;                     case 5:                         buf[4] = (byte)(valueOfs >> 8);                         goto case 4;                     case 4:                         buf[3] = (byte)valueOfs;                         goto case 3;                     case 3:                         buf[2] = (byte)valueSize;                         goto case 2;                     case 2:                         buf[1] = (byte)(valueSize >> 8);                         goto case 1;                     case 1:                         buf[0] = (byte)(valueSize >> 16);                         break;                     default:                         throw new BTDBException("Corrupted DB");                 }                 return ByteBuffer.NewAsync(buf);             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: var tempbuf = new byte[16];
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: tempbuf[2] = (byte)'D';
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: tempbuf[3] = (byte)'B';
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: tempbuf[4] = (byte)'E';
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: tempbuf[5] = (byte)'X';
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: tempbuf[6] = (byte)'P';
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: tempbuf[7] = (byte)'2';
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: PackUnpack.PackInt64LE(tempbuf' 8' keyValueCount);
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: stream.Write(tempbuf' 0' 16);
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: for (long kv = 0; kv < keyValueCount; kv++)             {                 var key = transaction.GetKey();                 PackUnpack.PackInt32LE(tempbuf' 0' key.Length);                 stream.Write(tempbuf' 0' 4);                 stream.Write(key.Buffer' key.Offset' key.Length);                 var value = transaction.GetValue();                 PackUnpack.PackInt32LE(tempbuf' 0' value.Length);                 stream.Write(tempbuf' 0' 4);                 stream.Write(value.Buffer' value.Offset' value.Length);                 transaction.FindNextKey();             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: for (long kv = 0; kv < keyValueCount; kv++)             {                 var key = transaction.GetKey();                 PackUnpack.PackInt32LE(tempbuf' 0' key.Length);                 stream.Write(tempbuf' 0' 4);                 stream.Write(key.Buffer' key.Offset' key.Length);                 var value = transaction.GetValue();                 PackUnpack.PackInt32LE(tempbuf' 0' value.Length);                 stream.Write(tempbuf' 0' 4);                 stream.Write(value.Buffer' value.Offset' value.Length);                 transaction.FindNextKey();             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: if (transaction.GetCommitUlong() != 0 || ulongCount != 0)             {                 PackUnpack.PackUInt64LE(tempbuf' 0' transaction.GetCommitUlong());                 stream.Write(tempbuf' 0' 8);             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: if (ulongCount != 0)             {                 PackUnpack.PackUInt32LE(tempbuf' 0' ulongCount);                 stream.Write(tempbuf' 0' 4);                 for (var i = 0u; i < ulongCount; i++)                 {                     PackUnpack.PackUInt64LE(tempbuf' 0' transaction.GetUlong(i));                     stream.Write(tempbuf' 0' 8);                 }             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: if (ulongCount != 0)             {                 PackUnpack.PackUInt32LE(tempbuf' 0' ulongCount);                 stream.Write(tempbuf' 0' 4);                 for (var i = 0u; i < ulongCount; i++)                 {                     PackUnpack.PackUInt64LE(tempbuf' 0' transaction.GetUlong(i));                     stream.Write(tempbuf' 0' 8);                 }             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: var tempbuf = new byte[4096];
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: var tempbuf2 = new byte[4096];
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (stream.Read(tempbuf' 0' 16) != 16) throw new EndOfStreamException();
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (stream.Read(tempbuf' 0' 16) != 16) throw new EndOfStreamException();
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (tempbuf[0] != 'B' || tempbuf[1] != 'T' || tempbuf[2] != 'D' || tempbuf[3] != 'B' || tempbuf[4] != 'E' || tempbuf[5] != 'X' || tempbuf[6] != 'P' || tempbuf[7] != '2')             {                 throw new BTDBException("Invalid header (it should Start with BTDBEXP2)");             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (tempbuf[0] != 'B' || tempbuf[1] != 'T' || tempbuf[2] != 'D' || tempbuf[3] != 'B' || tempbuf[4] != 'E' || tempbuf[5] != 'X' || tempbuf[6] != 'P' || tempbuf[7] != '2')             {                 throw new BTDBException("Invalid header (it should Start with BTDBEXP2)");             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (tempbuf[0] != 'B' || tempbuf[1] != 'T' || tempbuf[2] != 'D' || tempbuf[3] != 'B' || tempbuf[4] != 'E' || tempbuf[5] != 'X' || tempbuf[6] != 'P' || tempbuf[7] != '2')             {                 throw new BTDBException("Invalid header (it should Start with BTDBEXP2)");             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (tempbuf[0] != 'B' || tempbuf[1] != 'T' || tempbuf[2] != 'D' || tempbuf[3] != 'B' || tempbuf[4] != 'E' || tempbuf[5] != 'X' || tempbuf[6] != 'P' || tempbuf[7] != '2')             {                 throw new BTDBException("Invalid header (it should Start with BTDBEXP2)");             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (tempbuf[0] != 'B' || tempbuf[1] != 'T' || tempbuf[2] != 'D' || tempbuf[3] != 'B' || tempbuf[4] != 'E' || tempbuf[5] != 'X' || tempbuf[6] != 'P' || tempbuf[7] != '2')             {                 throw new BTDBException("Invalid header (it should Start with BTDBEXP2)");             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (tempbuf[0] != 'B' || tempbuf[1] != 'T' || tempbuf[2] != 'D' || tempbuf[3] != 'B' || tempbuf[4] != 'E' || tempbuf[5] != 'X' || tempbuf[6] != 'P' || tempbuf[7] != '2')             {                 throw new BTDBException("Invalid header (it should Start with BTDBEXP2)");             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: var keyValuePairs = PackUnpack.UnpackInt64LE(tempbuf' 8);
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: for (var kv = 0; kv < keyValuePairs; kv++)             {                 if (stream.Read(tempbuf' 0' 4) != 4) throw new EndOfStreamException();                 var keySize = PackUnpack.UnpackInt32LE(tempbuf' 0);                 if (keySize < 0) throw new BTDBException("Negative key size");                 if (keySize > tempbuf.Length) tempbuf = new byte[keySize];                 if (stream.Read(tempbuf' 0' keySize) != keySize) throw new EndOfStreamException();                 if (stream.Read(tempbuf2' 0' 4) != 4) throw new EndOfStreamException();                 var valueSize = PackUnpack.UnpackInt32LE(tempbuf2' 0);                 if (valueSize < 0) throw new BTDBException("Negative value size");                 if (valueSize > tempbuf2.Length) tempbuf2 = new byte[valueSize];                 if (stream.Read(tempbuf2' 0' valueSize) != valueSize) throw new EndOfStreamException();                 transaction.CreateOrUpdateKeyValue(ByteBuffer.NewSync(tempbuf' 0' keySize)' ByteBuffer.NewSync(tempbuf2' 0' valueSize));             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: for (var kv = 0; kv < keyValuePairs; kv++)             {                 if (stream.Read(tempbuf' 0' 4) != 4) throw new EndOfStreamException();                 var keySize = PackUnpack.UnpackInt32LE(tempbuf' 0);                 if (keySize < 0) throw new BTDBException("Negative key size");                 if (keySize > tempbuf.Length) tempbuf = new byte[keySize];                 if (stream.Read(tempbuf' 0' keySize) != keySize) throw new EndOfStreamException();                 if (stream.Read(tempbuf2' 0' 4) != 4) throw new EndOfStreamException();                 var valueSize = PackUnpack.UnpackInt32LE(tempbuf2' 0);                 if (valueSize < 0) throw new BTDBException("Negative value size");                 if (valueSize > tempbuf2.Length) tempbuf2 = new byte[valueSize];                 if (stream.Read(tempbuf2' 0' valueSize) != valueSize) throw new EndOfStreamException();                 transaction.CreateOrUpdateKeyValue(ByteBuffer.NewSync(tempbuf' 0' keySize)' ByteBuffer.NewSync(tempbuf2' 0' valueSize));             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: for (var kv = 0; kv < keyValuePairs; kv++)             {                 if (stream.Read(tempbuf' 0' 4) != 4) throw new EndOfStreamException();                 var keySize = PackUnpack.UnpackInt32LE(tempbuf' 0);                 if (keySize < 0) throw new BTDBException("Negative key size");                 if (keySize > tempbuf.Length) tempbuf = new byte[keySize];                 if (stream.Read(tempbuf' 0' keySize) != keySize) throw new EndOfStreamException();                 if (stream.Read(tempbuf2' 0' 4) != 4) throw new EndOfStreamException();                 var valueSize = PackUnpack.UnpackInt32LE(tempbuf2' 0);                 if (valueSize < 0) throw new BTDBException("Negative value size");                 if (valueSize > tempbuf2.Length) tempbuf2 = new byte[valueSize];                 if (stream.Read(tempbuf2' 0' valueSize) != valueSize) throw new EndOfStreamException();                 transaction.CreateOrUpdateKeyValue(ByteBuffer.NewSync(tempbuf' 0' keySize)' ByteBuffer.NewSync(tempbuf2' 0' valueSize));             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: for (var kv = 0; kv < keyValuePairs; kv++)             {                 if (stream.Read(tempbuf' 0' 4) != 4) throw new EndOfStreamException();                 var keySize = PackUnpack.UnpackInt32LE(tempbuf' 0);                 if (keySize < 0) throw new BTDBException("Negative key size");                 if (keySize > tempbuf.Length) tempbuf = new byte[keySize];                 if (stream.Read(tempbuf' 0' keySize) != keySize) throw new EndOfStreamException();                 if (stream.Read(tempbuf2' 0' 4) != 4) throw new EndOfStreamException();                 var valueSize = PackUnpack.UnpackInt32LE(tempbuf2' 0);                 if (valueSize < 0) throw new BTDBException("Negative value size");                 if (valueSize > tempbuf2.Length) tempbuf2 = new byte[valueSize];                 if (stream.Read(tempbuf2' 0' valueSize) != valueSize) throw new EndOfStreamException();                 transaction.CreateOrUpdateKeyValue(ByteBuffer.NewSync(tempbuf' 0' keySize)' ByteBuffer.NewSync(tempbuf2' 0' valueSize));             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (stream.Read(tempbuf' 0' 8) == 8)             {                 transaction.SetCommitUlong(PackUnpack.UnpackUInt64LE(tempbuf' 0));                 if (stream.Read(tempbuf' 0' 4) == 4)                 {                     var ulongCount = PackUnpack.UnpackUInt32LE(tempbuf' 0);                     for (var i = 0u; i < ulongCount; i++)                     {                         if (stream.Read(tempbuf' 0' 8) != 8) throw new EndOfStreamException();                         transaction.SetUlong(i' PackUnpack.UnpackUInt64LE(tempbuf' 0));                     }                 }             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (stream.Read(tempbuf' 0' 8) == 8)             {                 transaction.SetCommitUlong(PackUnpack.UnpackUInt64LE(tempbuf' 0));                 if (stream.Read(tempbuf' 0' 4) == 4)                 {                     var ulongCount = PackUnpack.UnpackUInt32LE(tempbuf' 0);                     for (var i = 0u; i < ulongCount; i++)                     {                         if (stream.Read(tempbuf' 0' 8) != 8) throw new EndOfStreamException();                         transaction.SetUlong(i' PackUnpack.UnpackUInt64LE(tempbuf' 0));                     }                 }             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (stream.Read(tempbuf' 0' 8) == 8)             {                 transaction.SetCommitUlong(PackUnpack.UnpackUInt64LE(tempbuf' 0));                 if (stream.Read(tempbuf' 0' 4) == 4)                 {                     var ulongCount = PackUnpack.UnpackUInt32LE(tempbuf' 0);                     for (var i = 0u; i < ulongCount; i++)                     {                         if (stream.Read(tempbuf' 0' 8) != 8) throw new EndOfStreamException();                         transaction.SetUlong(i' PackUnpack.UnpackUInt64LE(tempbuf' 0));                     }                 }             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (stream.Read(tempbuf' 0' 8) == 8)             {                 transaction.SetCommitUlong(PackUnpack.UnpackUInt64LE(tempbuf' 0));                 if (stream.Read(tempbuf' 0' 4) == 4)                 {                     var ulongCount = PackUnpack.UnpackUInt32LE(tempbuf' 0);                     for (var i = 0u; i < ulongCount; i++)                     {                         if (stream.Read(tempbuf' 0' 8) != 8) throw new EndOfStreamException();                         transaction.SetUlong(i' PackUnpack.UnpackUInt64LE(tempbuf' 0));                     }                 }             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (stream.Read(tempbuf' 0' 8) == 8)             {                 transaction.SetCommitUlong(PackUnpack.UnpackUInt64LE(tempbuf' 0));                 if (stream.Read(tempbuf' 0' 4) == 4)                 {                     var ulongCount = PackUnpack.UnpackUInt32LE(tempbuf' 0);                     for (var i = 0u; i < ulongCount; i++)                     {                         if (stream.Read(tempbuf' 0' 8) != 8) throw new EndOfStreamException();                         transaction.SetUlong(i' PackUnpack.UnpackUInt64LE(tempbuf' 0));                     }                 }             }
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (stream.Read(tempbuf' 0' 8) == 8)             {                 transaction.SetCommitUlong(PackUnpack.UnpackUInt64LE(tempbuf' 0));                 if (stream.Read(tempbuf' 0' 4) == 4)                 {                     var ulongCount = PackUnpack.UnpackUInt32LE(tempbuf' 0);                     for (var i = 0u; i < ulongCount; i++)                     {                         if (stream.Read(tempbuf' 0' 8) != 8) throw new EndOfStreamException();                         transaction.SetUlong(i' PackUnpack.UnpackUInt64LE(tempbuf' 0));                     }                 }             }
Magic Number,BTDB.KVDBLayer,PtrLenList,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,FindFreeSizeAfter,The following statement contains a magic number: while (l < r)             {                 uint m = (l + r)/2;                 cur = _list[m];                 if (pos < cur.Key)                 {                     r = m;                 }                 else if (cur.Key + cur.Value <= pos)                 {                     l = m + 1;                 }                 else                 {                     pos = cur.Key + cur.Value;                     l = m + 1;                     break;                 }             }
Magic Number,BTDB.KVDBLayer,PtrLenList,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryExclude,The following statement contains a magic number: while (l < r)             {                 uint m = (l + r) / 2;                 cur = _list[m];                 if (excludePos < cur.Key)                 {                     r = m;                 }                 else if (cur.Key + cur.Value <= excludePos)                 {                     l = m + 1;                 }                 else                 {                     if (excludePos == cur.Key)                     {                         if (excludePos + excludeLen < cur.Key + cur.Value)                         {                             _list[m] = new KeyValuePair<ulong' ulong>(excludePos + excludeLen' cur.Value - excludeLen);                             return true;                         }                         if (excludePos + excludeLen == cur.Key + cur.Value)                         {                             _size--;                             Array.Copy(_list' m + 1' _list' m' _size - m);                             return true;                         }                         r = m + 1;                         while (r < _size && excludePos + excludeLen > _list[r].Key)                         {                             r++;                         }                         cur = _list[r - 1];                         if (excludePos + excludeLen < cur.Key + cur.Value)                         {                             r--;                             _list[r] = new KeyValuePair<ulong' ulong>(excludePos + excludeLen' cur.Key - excludePos + cur.Value - excludeLen);                         }                         Array.Copy(_list' r' _list' m' _size - r);                         _size -= r - m;                         return false;                     }                     if (excludePos + excludeLen == cur.Key + cur.Value)                     {                         _list[m] = new KeyValuePair<ulong' ulong>(cur.Key' excludePos - cur.Key);                         return true;                     }                     if (excludePos + excludeLen < cur.Key + cur.Value)                     {                         GrowIfNeeded();                         Array.Copy(_list' m + 1' _list' m + 2' _size - m - 1);                         _size++;                         _list[m] = new KeyValuePair<ulong' ulong>(cur.Key' excludePos - cur.Key);                         _list[m + 1] = new KeyValuePair<ulong' ulong>(excludePos + excludeLen' cur.Key + cur.Value - excludePos - excludeLen);                         return true;                     }                     _list[m] = new KeyValuePair<ulong' ulong>(cur.Key' excludePos - cur.Key);                     l = m + 1;                     break;                 }             }
Magic Number,BTDB.KVDBLayer,PtrLenList,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryExclude,The following statement contains a magic number: while (l < r)             {                 uint m = (l + r) / 2;                 cur = _list[m];                 if (excludePos < cur.Key)                 {                     r = m;                 }                 else if (cur.Key + cur.Value <= excludePos)                 {                     l = m + 1;                 }                 else                 {                     if (excludePos == cur.Key)                     {                         if (excludePos + excludeLen < cur.Key + cur.Value)                         {                             _list[m] = new KeyValuePair<ulong' ulong>(excludePos + excludeLen' cur.Value - excludeLen);                             return true;                         }                         if (excludePos + excludeLen == cur.Key + cur.Value)                         {                             _size--;                             Array.Copy(_list' m + 1' _list' m' _size - m);                             return true;                         }                         r = m + 1;                         while (r < _size && excludePos + excludeLen > _list[r].Key)                         {                             r++;                         }                         cur = _list[r - 1];                         if (excludePos + excludeLen < cur.Key + cur.Value)                         {                             r--;                             _list[r] = new KeyValuePair<ulong' ulong>(excludePos + excludeLen' cur.Key - excludePos + cur.Value - excludeLen);                         }                         Array.Copy(_list' r' _list' m' _size - r);                         _size -= r - m;                         return false;                     }                     if (excludePos + excludeLen == cur.Key + cur.Value)                     {                         _list[m] = new KeyValuePair<ulong' ulong>(cur.Key' excludePos - cur.Key);                         return true;                     }                     if (excludePos + excludeLen < cur.Key + cur.Value)                     {                         GrowIfNeeded();                         Array.Copy(_list' m + 1' _list' m + 2' _size - m - 1);                         _size++;                         _list[m] = new KeyValuePair<ulong' ulong>(cur.Key' excludePos - cur.Key);                         _list[m + 1] = new KeyValuePair<ulong' ulong>(excludePos + excludeLen' cur.Key + cur.Value - excludePos - excludeLen);                         return true;                     }                     _list[m] = new KeyValuePair<ulong' ulong>(cur.Key' excludePos - cur.Key);                     l = m + 1;                     break;                 }             }
Magic Number,BTDB.KVDBLayer,PtrLenList,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryInclude,The following statement contains a magic number: if (_list == null)             {                 _list = new KeyValuePair<ulong' ulong>[4];                 _size = 1;                 _list[0] = new KeyValuePair<ulong' ulong>(includePos' includeLen);                 return true;             }
Magic Number,BTDB.KVDBLayer,PtrLenList,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryInclude,The following statement contains a magic number: while (l < r)             {                 uint m = (l + r) / 2;                 cur = _list[m];                 if (includePos < cur.Key)                 {                     r = m;                 }                 else if (cur.Key + cur.Value < includePos)                 {                     l = m + 1;                 }                 else                 {                     if (includePos + includeLen <= cur.Key + cur.Value)                     {                         return false;                     }                     bool result = true;                     l = m + 1;                     if (includePos < cur.Key + cur.Value) result = false;                     else                     {                         if (l < _size && includePos + includeLen > _list[l].Key)                         {                             l++;                             result = false;                         }                     }                     while (l < _size && includePos + includeLen >= _list[l].Key)                     {                         l++;                     }                     var lastOk = _list[l - 1];                     _list[m] = new KeyValuePair<ulong' ulong>(cur.Key' Math.Max(lastOk.Key + lastOk.Value' includePos + includeLen) - cur.Key);                     Array.Copy(_list' l' _list' m + 1' _size - l);                     _size -= l - (m + 1);                     return result;                 }             }
Magic Number,BTDB.KVDBLayer,PtrLenList,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,Contains,The following statement contains a magic number: while (l < r)             {                 uint m = (l + r) / 2;                 var cur = _list[m];                 if (position < cur.Key)                 {                     r = m;                 }                 else if (cur.Key + cur.Value <= position)                 {                     l = m + 1;                 }                 else                 {                     return true;                 }             }
Magic Number,BTDB.KVDBLayer,PtrLenList,C:\repos\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,GrowIfNeeded,The following statement contains a magic number: if (_size == _list.Length)             {                 Array.Resize(ref _list' (int)_size * 2);             }
Magic Number,BTDB.ODBLayer,ODBDictionary<TKey;TValue>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,FreeContent,The following statement contains a magic number: if (config.FreeContent == null)             {                 var method = ILBuilder.Instance                 .NewMethod<Action<IInternalObjectDBTransaction' AbstractBufferedReader' IList<ulong>' IList<ulong>>>(                     $"IDictFinder_Cfg_{cfgId}");                 var ilGenerator = method.Generator;                  var readerLoc = ilGenerator.DeclareLocal(typeof(IReaderCtx));                 ilGenerator                     .Ldarg(0)                     .Ldarg(1)                     .Ldarg(2)                     .Ldarg(3)                     .Newobj(() => new DBReaderWithFreeInfoCtx(null' null' null' null))                     .Stloc(readerLoc);                  Action<IILGen> readerOrCtx;                 if (_valueHandler.NeedsCtx())                     readerOrCtx = il => il.Ldloc(readerLoc);                 else                     readerOrCtx = il => il.Ldarg(1);                 _valueHandler.FreeContent(ilGenerator' readerOrCtx);                 ilGenerator.Ret();                 config.FreeContent = method.Create();             }
Magic Number,BTDB.ODBLayer,ODBDictionary<TKey;TValue>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,FreeContent,The following statement contains a magic number: if (config.FreeContent == null)             {                 var method = ILBuilder.Instance                 .NewMethod<Action<IInternalObjectDBTransaction' AbstractBufferedReader' IList<ulong>' IList<ulong>>>(                     $"IDictFinder_Cfg_{cfgId}");                 var ilGenerator = method.Generator;                  var readerLoc = ilGenerator.DeclareLocal(typeof(IReaderCtx));                 ilGenerator                     .Ldarg(0)                     .Ldarg(1)                     .Ldarg(2)                     .Ldarg(3)                     .Newobj(() => new DBReaderWithFreeInfoCtx(null' null' null' null))                     .Stloc(readerLoc);                  Action<IILGen> readerOrCtx;                 if (_valueHandler.NeedsCtx())                     readerOrCtx = il => il.Ldloc(readerLoc);                 else                     readerOrCtx = il => il.Ldarg(1);                 _valueHandler.FreeContent(ilGenerator' readerOrCtx);                 ilGenerator.Ret();                 config.FreeContent = method.Create();             }
Magic Number,BTDB.ODBLayer,TableIdVersion,C:\repos\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,GetHashCode,The following statement contains a magic number: return (int)(_tableid * 33 + _version);
Magic Number,BTDB.ODBLayer,RelationBuilder<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The following statement contains a magic number: il.Ldarg(0).Ldarg(1).Ldarg(2).Call(relationDBManipulatorType.GetConstructor(new[] { typeof(IObjectDBTransaction)' typeof(RelationInfo) }))                 .Ret();
Magic Number,BTDB.ODBLayer,RelationBuilder<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,BuildListByMethod,The following statement contains a magic number: var secondaryKeyIndex = _relationInfo.ClientRelationVersionInfo.GetSecondaryKeyIndex(method.Name.Substring(6));
Magic Number,BTDB.ODBLayer,RelationBuilder<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodFindBy,The following statement contains a magic number: var skName = methodName.Substring(6);
Magic Number,BTDB.ODBLayer,RelationBuilder<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodFindBy,The following statement contains a magic number: if (skName.EndsWith("OrDefault"))             {                 skName = skName.Substring(0' skName.Length - 9);                 allowDefault = true;             }
Magic Number,BTDB.ODBLayer,RelationBuilder<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,GenerateApartFieldsProperties,The following statement contains a magic number: foreach (var method in methods)             {                 var name = method.Name;                 if (!name.StartsWith("get_") && !name.StartsWith("set_"))                     continue;                  IILField field;                 IILField initCheckField;                 var propName = method.Name.Substring(4);                  if (!_relationInfo.ApartFields.ContainsKey(propName))                     throw new BTDBException($"Invalid property name {propName}.");                  if (!apartFields.TryGetValue(propName' out field))                 {                     field = classImpl.DefineField("_" + propName' method.ReturnType' FieldAttributes.Private);                     apartFields[propName] = field;                     initCheckField = classImpl.DefineField("_initialized_" + propName' typeof(bool)' FieldAttributes.Private);                     initializedFields[propName] = initCheckField;                 }                 else                 {                     initCheckField = initializedFields[propName];                 }                  var reqMethod = classImpl.DefineMethod(method.Name' method.ReturnType'                     method.GetParameters().Select(pi => pi.ParameterType).ToArray()'                     MethodAttributes.Virtual | MethodAttributes.Public);                 if (name.StartsWith("set_"))                 {                     reqMethod.Generator.Ldarg(0).Ldarg(1).Stfld(field)                         .Ldarg(0).LdcI4(1).Stfld(initCheckField)                         .Ret();                 }                 else                 {                     var initializedLabel = reqMethod.Generator.DefineLabel("initialized");                     reqMethod.Generator                         .Ldarg(0).Ldfld(initCheckField)                         .Brtrue(initializedLabel)                         .Ldstr($"Cannot use uninitialized apart field {propName}")                         .Newobj(() => new BTDBException(null))                         .Throw()                         .Mark(initializedLabel)                         .Ldarg(0).Ldfld(field).Ret();                 }                 classImpl.DefineMethodOverride(reqMethod' method);             }
Magic Number,BTDB.ODBLayer,RelationDBManipulator<T>,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,CompareAndRelease,The following statement contains a magic number: if (newItems.Count == 0)             {                 foreach (var id in oldItems)                     freeAction(_transaction' id);             }             else if (newItems.Count < 10)             {                 foreach (var id in oldItems)                 {                     if (newItems.Contains(id))                         continue;                     freeAction(_transaction' id);                 }             }             else             {                 var newItemsDictionary = new Dictionary<ulong' object>();                 foreach (var id in newItems)                     newItemsDictionary[id] = null;                 foreach (var id in oldItems)                 {                     if (newItemsDictionary.ContainsKey(id))                         continue;                     freeAction(_transaction' id);                 }             }
Magic Number,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateBytesToSKSaver,The following statement contains a magic number: for (var skFieldIdx = 0; skFieldIdx < skFieldIds.Count; skFieldIdx++)             {                 LocalAndHandler saveLocalInfo;                 if (outOfOrderSkParts.TryGetValue(skFieldIdx' out saveLocalInfo))                 {                     var writerOrCtx = WriterOrContextForHandler(saveLocalInfo.Handler' writerCtxLocal' pushWriter);                     saveLocalInfo.Handler.Save(ilGenerator' writerOrCtx' il => il.Ldloc(saveLocalInfo.Local));                     continue;                 }                 var skf = skFieldIds[skFieldIdx];                 if (skf.IsFromPrimaryKey)                 {                     InitializeBuffer(2' ref firstBuffer' ilGenerator' pks);                     //firstBuffer.ActualFieldIdx == number of processed PK's                     for (var pkIdx = firstBuffer.ActualFieldIdx; pkIdx < skf.Index; pkIdx++)                     {                         //all PK parts are contained in SK                         int skFieldIdxForPk' tmp;                         FindPosition(pkIdx' skFieldIds' 0' out tmp' out skFieldIdxForPk);                         StoreIntoLocal(ilGenerator' pks[pkIdx].Handler' firstBuffer' outOfOrderSkParts' skFieldIdxForPk' skFields[skFieldIdxForPk].Handler);                     }                     CopyToOutput(ilGenerator' pks[(int)skf.Index].Handler' writerCtxLocal' pushWriter' skFields[skFieldIdx].Handler' firstBuffer);                     firstBuffer.ActualFieldIdx = (int)skf.Index + 1;                 }                 else                 {                     InitializeBuffer(3' ref secondBuffer' ilGenerator' valueFields);                      var valueFieldIdx = valueFields.FindIndex(tfi => tfi.Name == skFields[skFieldIdx].Name);                     if (valueFieldIdx >= 0)                     {                         for (var valueIdx = secondBuffer.ActualFieldIdx; valueIdx < valueFieldIdx; valueIdx++)                         {                             var valueField = valueFields[valueIdx];                             var storeForSkIndex = skFields.FindIndex(skFieldIdx' fi => fi.Name == valueField.Name);                             if (storeForSkIndex == -1)                                 valueField.Handler.Skip(ilGenerator' valueField.Handler.NeedsCtx() ? secondBuffer.PushCtx : secondBuffer.PushReader);                             else                                 StoreIntoLocal(ilGenerator' valueField.Handler' secondBuffer' outOfOrderSkParts' storeForSkIndex' skFields[storeForSkIndex].Handler);                         }                         CopyToOutput(ilGenerator' valueFields[valueFieldIdx].Handler' writerCtxLocal' pushWriter' skFields[skFieldIdx].Handler' secondBuffer);                         secondBuffer.ActualFieldIdx = valueFieldIdx + 1;                     }                     else                     { //older version of value does not contain sk field - store field from default value (can be initialized in constructor)                         if (defaultObjectLoc == null)                         {                             defaultObjectLoc = ilGenerator.DeclareLocal(ClientType);                             ilGenerator.Ldarg(4)                                 .Castclass(ClientType)                                 .Stloc(defaultObjectLoc);                          }                         var loc = defaultObjectLoc;                         CreateSaverIl(ilGenerator' new[] { ClientRelationVersionInfo.GetSecondaryKeyField(skFieldIdx) }'                             il => il.Ldloc(loc)' null' pushWriter' il => il.Ldarg(0));                     }                 }             }
Magic Number,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateBytesToSKSaver,The following statement contains a magic number: for (var skFieldIdx = 0; skFieldIdx < skFieldIds.Count; skFieldIdx++)             {                 LocalAndHandler saveLocalInfo;                 if (outOfOrderSkParts.TryGetValue(skFieldIdx' out saveLocalInfo))                 {                     var writerOrCtx = WriterOrContextForHandler(saveLocalInfo.Handler' writerCtxLocal' pushWriter);                     saveLocalInfo.Handler.Save(ilGenerator' writerOrCtx' il => il.Ldloc(saveLocalInfo.Local));                     continue;                 }                 var skf = skFieldIds[skFieldIdx];                 if (skf.IsFromPrimaryKey)                 {                     InitializeBuffer(2' ref firstBuffer' ilGenerator' pks);                     //firstBuffer.ActualFieldIdx == number of processed PK's                     for (var pkIdx = firstBuffer.ActualFieldIdx; pkIdx < skf.Index; pkIdx++)                     {                         //all PK parts are contained in SK                         int skFieldIdxForPk' tmp;                         FindPosition(pkIdx' skFieldIds' 0' out tmp' out skFieldIdxForPk);                         StoreIntoLocal(ilGenerator' pks[pkIdx].Handler' firstBuffer' outOfOrderSkParts' skFieldIdxForPk' skFields[skFieldIdxForPk].Handler);                     }                     CopyToOutput(ilGenerator' pks[(int)skf.Index].Handler' writerCtxLocal' pushWriter' skFields[skFieldIdx].Handler' firstBuffer);                     firstBuffer.ActualFieldIdx = (int)skf.Index + 1;                 }                 else                 {                     InitializeBuffer(3' ref secondBuffer' ilGenerator' valueFields);                      var valueFieldIdx = valueFields.FindIndex(tfi => tfi.Name == skFields[skFieldIdx].Name);                     if (valueFieldIdx >= 0)                     {                         for (var valueIdx = secondBuffer.ActualFieldIdx; valueIdx < valueFieldIdx; valueIdx++)                         {                             var valueField = valueFields[valueIdx];                             var storeForSkIndex = skFields.FindIndex(skFieldIdx' fi => fi.Name == valueField.Name);                             if (storeForSkIndex == -1)                                 valueField.Handler.Skip(ilGenerator' valueField.Handler.NeedsCtx() ? secondBuffer.PushCtx : secondBuffer.PushReader);                             else                                 StoreIntoLocal(ilGenerator' valueField.Handler' secondBuffer' outOfOrderSkParts' storeForSkIndex' skFields[storeForSkIndex].Handler);                         }                         CopyToOutput(ilGenerator' valueFields[valueFieldIdx].Handler' writerCtxLocal' pushWriter' skFields[skFieldIdx].Handler' secondBuffer);                         secondBuffer.ActualFieldIdx = valueFieldIdx + 1;                     }                     else                     { //older version of value does not contain sk field - store field from default value (can be initialized in constructor)                         if (defaultObjectLoc == null)                         {                             defaultObjectLoc = ilGenerator.DeclareLocal(ClientType);                             ilGenerator.Ldarg(4)                                 .Castclass(ClientType)                                 .Stloc(defaultObjectLoc);                          }                         var loc = defaultObjectLoc;                         CreateSaverIl(ilGenerator' new[] { ClientRelationVersionInfo.GetSecondaryKeyField(skFieldIdx) }'                             il => il.Ldloc(loc)' null' pushWriter' il => il.Ldarg(0));                     }                 }             }
Magic Number,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateBytesToSKSaver,The following statement contains a magic number: for (var skFieldIdx = 0; skFieldIdx < skFieldIds.Count; skFieldIdx++)             {                 LocalAndHandler saveLocalInfo;                 if (outOfOrderSkParts.TryGetValue(skFieldIdx' out saveLocalInfo))                 {                     var writerOrCtx = WriterOrContextForHandler(saveLocalInfo.Handler' writerCtxLocal' pushWriter);                     saveLocalInfo.Handler.Save(ilGenerator' writerOrCtx' il => il.Ldloc(saveLocalInfo.Local));                     continue;                 }                 var skf = skFieldIds[skFieldIdx];                 if (skf.IsFromPrimaryKey)                 {                     InitializeBuffer(2' ref firstBuffer' ilGenerator' pks);                     //firstBuffer.ActualFieldIdx == number of processed PK's                     for (var pkIdx = firstBuffer.ActualFieldIdx; pkIdx < skf.Index; pkIdx++)                     {                         //all PK parts are contained in SK                         int skFieldIdxForPk' tmp;                         FindPosition(pkIdx' skFieldIds' 0' out tmp' out skFieldIdxForPk);                         StoreIntoLocal(ilGenerator' pks[pkIdx].Handler' firstBuffer' outOfOrderSkParts' skFieldIdxForPk' skFields[skFieldIdxForPk].Handler);                     }                     CopyToOutput(ilGenerator' pks[(int)skf.Index].Handler' writerCtxLocal' pushWriter' skFields[skFieldIdx].Handler' firstBuffer);                     firstBuffer.ActualFieldIdx = (int)skf.Index + 1;                 }                 else                 {                     InitializeBuffer(3' ref secondBuffer' ilGenerator' valueFields);                      var valueFieldIdx = valueFields.FindIndex(tfi => tfi.Name == skFields[skFieldIdx].Name);                     if (valueFieldIdx >= 0)                     {                         for (var valueIdx = secondBuffer.ActualFieldIdx; valueIdx < valueFieldIdx; valueIdx++)                         {                             var valueField = valueFields[valueIdx];                             var storeForSkIndex = skFields.FindIndex(skFieldIdx' fi => fi.Name == valueField.Name);                             if (storeForSkIndex == -1)                                 valueField.Handler.Skip(ilGenerator' valueField.Handler.NeedsCtx() ? secondBuffer.PushCtx : secondBuffer.PushReader);                             else                                 StoreIntoLocal(ilGenerator' valueField.Handler' secondBuffer' outOfOrderSkParts' storeForSkIndex' skFields[storeForSkIndex].Handler);                         }                         CopyToOutput(ilGenerator' valueFields[valueFieldIdx].Handler' writerCtxLocal' pushWriter' skFields[skFieldIdx].Handler' secondBuffer);                         secondBuffer.ActualFieldIdx = valueFieldIdx + 1;                     }                     else                     { //older version of value does not contain sk field - store field from default value (can be initialized in constructor)                         if (defaultObjectLoc == null)                         {                             defaultObjectLoc = ilGenerator.DeclareLocal(ClientType);                             ilGenerator.Ldarg(4)                                 .Castclass(ClientType)                                 .Stloc(defaultObjectLoc);                          }                         var loc = defaultObjectLoc;                         CreateSaverIl(ilGenerator' new[] { ClientRelationVersionInfo.GetSecondaryKeyField(skFieldIdx) }'                             il => il.Ldloc(loc)' null' pushWriter' il => il.Ldarg(0));                     }                 }             }
Magic Number,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateSaverWithApartFields,The following statement contains a magic number: StoreNthArgumentOfTypeIntoLoc(ilGenerator' 2' ClientType' 0);
Magic Number,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateSaverWithApartFields,The following statement contains a magic number: if (hasApartFields)             {                 ilGenerator.DeclareLocal(_interfaceType);                 StoreNthArgumentOfTypeIntoLoc(ilGenerator' 3' _interfaceType' 1);             }
Magic Number,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateSaver,The following statement contains a magic number: StoreNthArgumentOfTypeIntoLoc(ilGenerator' 2' ClientType' 0);
Magic Number,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,FindApartFields,The following statement contains a magic number: foreach (var method in methods)             {                 if (!method.Name.StartsWith("get_"))                     continue;                 var name = method.Name.Substring(4);                 TableFieldInfo tfi;                 if (!pks.TryGetValue(name' out tfi))                     throw new BTDBException($"Property {name} is not part of primary key.");                 if (method.ReturnType != tfi.Handler.HandledType())                     throw new BTDBException($"Property {name} has different return type then member of primary key with the same name.");                 result.Add(name' method);             }
Magic Number,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreatePrimaryKeyFromSKDataMerger,The following statement contains a magic number: Action<IILGen> pushWriter = il => il.Ldarg(2);
Magic Number,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateLoader,The following statement contains a magic number: ilGenerator                 .Ldarg(2)                 .Castclass(ClientType)                 .Stloc(0);
Magic Number,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateIDictFinder,The following statement contains a magic number: if (anyNeedsCtx)             {                 ilGenerator.DeclareLocal(typeof(IReaderCtx)); //loc 0                 ilGenerator                     .Ldarg(0)                     .Ldarg(1)                     .Ldarg(2)                     .Ldarg(3)                     .Newobj(() => new DBReaderWithFreeInfoCtx(null' null' null' null))                     .Stloc(0);             }
Magic Number,BTDB.ODBLayer,RelationInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateIDictFinder,The following statement contains a magic number: if (anyNeedsCtx)             {                 ilGenerator.DeclareLocal(typeof(IReaderCtx)); //loc 0                 ilGenerator                     .Ldarg(0)                     .Ldarg(1)                     .Ldarg(2)                     .Ldarg(3)                     .Newobj(() => new DBReaderWithFreeInfoCtx(null' null' null' null))                     .Stloc(0);             }
Magic Number,BTDB.ODBLayer,ObjectDBTransaction,C:\repos\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,AddToObjCache,The following statement contains a magic number: if (_objSmallCache == null)             {                 _objSmallCache = new Dictionary<ulong' object>();                 _objSmallMetadata = new Dictionary<object' DBObjectMetadata>(ReferenceEqualityComparer<object>.Instance);             }             else if (_objSmallCache.Count > 30)             {                 _objBigCache = new Dictionary<ulong' WeakReference>();                 _objBigMetadata = new ConditionalWeakTable<object' DBObjectMetadata>();                 foreach (var pair in _objSmallCache)                 {                     _objBigCache.Add(pair.Key' new WeakReference(pair.Value));                 }                 _objSmallCache = null;                 foreach (var pair in _objSmallMetadata)                 {                     _objBigMetadata.Add(pair.Key' pair.Value);                 }                 _objSmallMetadata = null;                 _objBigCache.Add(oid' new WeakReference(obj));                 _objBigMetadata.Add(obj' metadata);                 return;             }
Magic Number,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateInitializer,The following statement contains a magic number: if (tableVersionInfo.NeedsInit())             {                 ilGenerator.DeclareLocal(ClientType);                 ilGenerator                     .Ldarg(2)                     .Castclass(ClientType)                     .Stloc(0);                 var anyNeedsCtx = tableVersionInfo.NeedsCtx();                 if (anyNeedsCtx)                 {                     ilGenerator.DeclareLocal(typeof(IReaderCtx));                     ilGenerator                         .Ldarg(0)                         .Newobj(() => new DBReaderCtx(null))                         .Stloc(1);                 }                 var props = _clientType.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);                 for (int fi = 0; fi < tableVersionInfo.FieldCount; fi++)                 {                     var srcFieldInfo = tableVersionInfo[fi];                     var iFieldHandlerWithInit = srcFieldInfo.Handler as IFieldHandlerWithInit;                     if (iFieldHandlerWithInit == null) continue;                     Action<IILGen> readerOrCtx;                     if (srcFieldInfo.Handler.NeedsCtx())                         readerOrCtx = il => il.Ldloc(1);                     else                         readerOrCtx = il => il.Ldnull();                     var specializedSrcHandler = srcFieldInfo.Handler;                     var willLoad = specializedSrcHandler.HandledType();                     var setterMethod = props.First(p => GetPersistantName(p) == srcFieldInfo.Name).GetSetMethod(true);                     var converterGenerator = _tableInfoResolver.TypeConvertorGenerator.GenerateConversion(willLoad' setterMethod.GetParameters()[0].ParameterType);                     if (converterGenerator == null) continue;                     if (!iFieldHandlerWithInit.NeedInit()) continue;                     ilGenerator.Ldloc(0);                     iFieldHandlerWithInit.Init(ilGenerator' readerOrCtx);                     converterGenerator(ilGenerator);                     ilGenerator.Call(setterMethod);                 }             }
Magic Number,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateSaver,The following statement contains a magic number: ilGenerator                 .Ldarg(3)                 .Castclass(ClientType)                 .Stloc(0);
Magic Number,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateSaver,The following statement contains a magic number: if (anyNeedsCtx)             {                 ilGenerator.DeclareLocal(typeof(IWriterCtx));                 ilGenerator                     .Ldarg(0)                     .Ldarg(2)                     .Newobj(() => new DBWriterCtx(null' null))                     .Stloc(1);             }
Magic Number,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateSaver,The following statement contains a magic number: for (int i = 0; i < ClientTableVersionInfo.FieldCount; i++)             {                 var field = ClientTableVersionInfo[i];                 var getter = props.First(p => GetPersistantName(p) == field.Name).GetGetMethod(true);                 Action<IILGen> writerOrCtx;                 var handler = field.Handler.SpecializeSaveForType(getter.ReturnType);                 if (handler.NeedsCtx())                     writerOrCtx = il => il.Ldloc(1);                 else                     writerOrCtx = il => il.Ldarg(2);                 handler.Save(ilGenerator' writerOrCtx' il =>                     {                         il.Ldloc(0).Callvirt(getter);                         _tableInfoResolver.TypeConvertorGenerator.GenerateConversion(getter.ReturnType'                                                                                      handler.HandledType())(il);                     });             }
Magic Number,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,The following statement contains a magic number: ilGenerator                 .Ldarg(3)                 .Castclass(ClientType)                 .Stloc(0);
Magic Number,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,The following statement contains a magic number: if (anyNeedsCtx)             {                 ilGenerator.DeclareLocal(typeof(IReaderCtx));                 ilGenerator                     .Ldarg(0)                     .Ldarg(2)                     .Newobj(() => new DBReaderCtx(null' null))                     .Stloc(1);             }
Magic Number,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,The following statement contains a magic number: for (int fi = 0; fi < tableVersionInfo.FieldCount; fi++)             {                 var srcFieldInfo = tableVersionInfo[fi];                 Action<IILGen> readerOrCtx;                 if (srcFieldInfo.Handler.NeedsCtx())                     readerOrCtx = il => il.Ldloc(1);                 else                     readerOrCtx = il => il.Ldarg(2);                 var destFieldInfo = clientTableVersionInfo[srcFieldInfo.Name];                 if (destFieldInfo != null)                 {                      var fieldInfo = props.First(p => GetPersistantName(p) == destFieldInfo.Name).GetSetMethod(true);                     var fieldType = fieldInfo.GetParameters()[0].ParameterType;                     var specializedSrcHandler = srcFieldInfo.Handler.SpecializeLoadForType(fieldType' destFieldInfo.Handler);                     var willLoad = specializedSrcHandler.HandledType();                     var converterGenerator = _tableInfoResolver.TypeConvertorGenerator.GenerateConversion(willLoad' fieldType);                     if (converterGenerator != null)                     {                         ilGenerator.Ldloc(0);                         specializedSrcHandler.Load(ilGenerator' readerOrCtx);                         converterGenerator(ilGenerator);                         ilGenerator.Call(fieldInfo);                         continue;                     }                 }                 srcFieldInfo.Handler.Skip(ilGenerator' readerOrCtx);             }
Magic Number,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateFreeContent,The following statement contains a magic number: if (anyNeedsCtx)             {                 ilGenerator.DeclareLocal(typeof(IReaderCtx));                 ilGenerator                     .Ldarg(0)                     .Ldarg(2)                     .Ldarg(3)                     .Ldarg(4)                     .Newobj(() => new DBReaderWithFreeInfoCtx(null' null' null' null))                     .Stloc(0);             }
Magic Number,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateFreeContent,The following statement contains a magic number: if (anyNeedsCtx)             {                 ilGenerator.DeclareLocal(typeof(IReaderCtx));                 ilGenerator                     .Ldarg(0)                     .Ldarg(2)                     .Ldarg(3)                     .Ldarg(4)                     .Newobj(() => new DBReaderWithFreeInfoCtx(null' null' null' null))                     .Stloc(0);             }
Magic Number,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateFreeContent,The following statement contains a magic number: if (anyNeedsCtx)             {                 ilGenerator.DeclareLocal(typeof(IReaderCtx));                 ilGenerator                     .Ldarg(0)                     .Ldarg(2)                     .Ldarg(3)                     .Ldarg(4)                     .Newobj(() => new DBReaderWithFreeInfoCtx(null' null' null' null))                     .Stloc(0);             }
Magic Number,BTDB.ODBLayer,TableInfo,C:\repos\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateFreeContent,The following statement contains a magic number: for (int fi = 0; fi < tableVersionInfo.FieldCount; fi++)             {                 var srcFieldInfo = tableVersionInfo[fi];                 Action<IILGen> readerOrCtx;                 if (srcFieldInfo.Handler.NeedsCtx())                     readerOrCtx = il => il.Ldloc(0);                 else                     readerOrCtx = il => il.Ldarg(2);                 var needsFree = srcFieldInfo.Handler.FreeContent(ilGenerator' readerOrCtx);                 needsFreeContent |= needsFree;             }
Magic Number,BTDB.Reactive,FastSubject<T>,C:\repos\Bobris_BTDB\BTDB\Reactive\FastSubject.cs,Unsubscribe,The following statement contains a magic number: do             {                 original = _current;                 if (original is IStoppedSubjectMarker) return;                 if (original is FastSubjectHelpers<T>.MultiSubject)                 {                     var originalArray = ((FastSubjectHelpers<T>.MultiSubject)original).Array;                     var indexOf = Array.IndexOf(originalArray' observer);                     if (indexOf < 0) return;                     if (originalArray.Length == 2)                     {                         nextState = originalArray[1 - indexOf];                     }                     else                     {                         var newArray = new IObserver<T>[originalArray.Length - 1];                         Array.Copy(originalArray' newArray' indexOf);                         Array.Copy(originalArray' indexOf + 1' newArray' indexOf' newArray.Length - indexOf);                         nextState = new FastSubjectHelpers<T>.MultiSubject(newArray);                     }                 }                 else                 {                     if (original != observer) return;                     nextState = FastSubjectHelpers<T>.EmptySubjectMarker;                 }             } while (Interlocked.CompareExchange(ref _current' nextState' original) != original);
Magic Number,BTDB.Reactive,FastBehaviourSubject<T>,C:\repos\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,Unsubscribe,The following statement contains a magic number: do             {                 original = _current;                 if (original is IStoppedSubjectMarker) return;                 if (original is FastSubjectHelpers<T>.MultiSubject)                 {                     var originalArray = ((FastSubjectHelpers<T>.MultiSubject)original).Array;                     var indexOf = Array.IndexOf(originalArray' observer);                     if (indexOf < 0) return;                     if (originalArray.Length == 2)                     {                         nextState = originalArray[1 - indexOf];                     }                     else                     {                         var newArray = new IObserver<T>[originalArray.Length - 1];                         Array.Copy(originalArray' newArray' indexOf);                         Array.Copy(originalArray' indexOf + 1' newArray' indexOf' newArray.Length - indexOf);                         nextState = new FastSubjectHelpers<T>.MultiSubject(newArray);                     }                 }                 else if (original is FastSubjectHelpers<T>.MultiSubjectWithValue)                 {                     var o = (FastSubjectHelpers<T>.MultiSubjectWithValue) original;                     var originalArray = o.Array;                     var indexOf = Array.IndexOf(originalArray' observer);                     if (indexOf < 0) return;                     if (originalArray.Length == 2)                     {                         nextState = new FastSubjectHelpers<T>.SingleSubjectWithValue(originalArray[1 - indexOf]'o.Value);                     }                     else                     {                         var newArray = new IObserver<T>[originalArray.Length - 1];                         Array.Copy(originalArray' newArray' indexOf);                         Array.Copy(originalArray' indexOf + 1' newArray' indexOf' newArray.Length - indexOf);                         nextState = new FastSubjectHelpers<T>.MultiSubjectWithValue(newArray'o.Value);                     }                 }                 else if (original is FastSubjectHelpers<T>.SingleSubjectWithValue)                 {                     var o = (FastSubjectHelpers<T>.SingleSubjectWithValue)original;                     if (o.Observer != observer) return;                     nextState = new FastSubjectHelpers<T>.EmptySubjectWithValue(o.Value);                 }                 else                 {                     if (original != observer) return;                     nextState = FastSubjectHelpers<T>.EmptySubjectMarker;                 }             } while (Interlocked.CompareExchange(ref _current' nextState' original) != original);
Magic Number,BTDB.Reactive,FastBehaviourSubject<T>,C:\repos\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,Unsubscribe,The following statement contains a magic number: do             {                 original = _current;                 if (original is IStoppedSubjectMarker) return;                 if (original is FastSubjectHelpers<T>.MultiSubject)                 {                     var originalArray = ((FastSubjectHelpers<T>.MultiSubject)original).Array;                     var indexOf = Array.IndexOf(originalArray' observer);                     if (indexOf < 0) return;                     if (originalArray.Length == 2)                     {                         nextState = originalArray[1 - indexOf];                     }                     else                     {                         var newArray = new IObserver<T>[originalArray.Length - 1];                         Array.Copy(originalArray' newArray' indexOf);                         Array.Copy(originalArray' indexOf + 1' newArray' indexOf' newArray.Length - indexOf);                         nextState = new FastSubjectHelpers<T>.MultiSubject(newArray);                     }                 }                 else if (original is FastSubjectHelpers<T>.MultiSubjectWithValue)                 {                     var o = (FastSubjectHelpers<T>.MultiSubjectWithValue) original;                     var originalArray = o.Array;                     var indexOf = Array.IndexOf(originalArray' observer);                     if (indexOf < 0) return;                     if (originalArray.Length == 2)                     {                         nextState = new FastSubjectHelpers<T>.SingleSubjectWithValue(originalArray[1 - indexOf]'o.Value);                     }                     else                     {                         var newArray = new IObserver<T>[originalArray.Length - 1];                         Array.Copy(originalArray' newArray' indexOf);                         Array.Copy(originalArray' indexOf + 1' newArray' indexOf' newArray.Length - indexOf);                         nextState = new FastSubjectHelpers<T>.MultiSubjectWithValue(newArray'o.Value);                     }                 }                 else if (original is FastSubjectHelpers<T>.SingleSubjectWithValue)                 {                     var o = (FastSubjectHelpers<T>.SingleSubjectWithValue)original;                     if (o.Observer != observer) return;                     nextState = new FastSubjectHelpers<T>.EmptySubjectWithValue(o.Value);                 }                 else                 {                     if (original != observer) return;                     nextState = FastSubjectHelpers<T>.EmptySubjectMarker;                 }             } while (Interlocked.CompareExchange(ref _current' nextState' original) != original);
Magic Number,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (needsCtx)             {                 localReaderCtx = ilGenerator.DeclareLocal(typeof(IReaderCtx)' "readerCtx");                 ilGenerator                     .Ldarg(2)                     .Ldarg(1)                     .Newobj(() => new ServiceReaderCtx((IServiceInternalServer)null' null))                     .Castclass(typeof(IReaderCtx))                     .Stloc(localReaderCtx);             }
Magic Number,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (binding.OneWay)             {                 if (originalReturnType != typeof(void)) ilGenerator.Pop();             }             else             {                 if (localResult == null)                 {                     if (isAsync)                     {                         ilGenerator                             .Ldarg(2)                             .Ldloc(localResultId)                             .Newobj(CreateTaskContinuationWithResultMarshaling(methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler))                             .Pop();                     }                     else                     {                         if (methodInf.MethodInfo.ReturnType != typeof(void)) ilGenerator.Pop();                         ilGenerator                             .Ldarg(2)                             .Ldloc(localResultId)                             .Callvirt(() => default(IServiceInternalServer).VoidResultMarshaling(0u));                     }                 }                 else                 {                     _typeConvertorGenerator.GenerateConversion(returnType' localResult.LocalType)(ilGenerator);                     ilGenerator                         .Stloc(localResult)                         .Ldarg(2)                         .Ldloc(localResultId)                         .Callvirt(() => default(IServiceInternalServer).StartResultMarshaling(0u))                         .Stloc(localWriter);                     IILLocal localWriterCtx = null;                     if (resultFieldHandler.NeedsCtx())                     {                         localWriterCtx = ilGenerator.DeclareLocal(typeof(IWriterCtx)' "writerCtx");                         ilGenerator                             .Ldarg(2)                             .Ldloc(localWriter)                             .Newobj(() => new ServiceWriterCtx((IServiceInternalServer)null' null))                             .Castclass(typeof(IWriterCtx))                             .Stloc(localWriterCtx);                      }                     resultFieldHandler.Save(ilGenerator' il => il.Ldloc(resultFieldHandler.NeedsCtx() ? localWriterCtx : localWriter)' il => il.Ldloc(localResult));                     ilGenerator                         .Ldarg(2)                         .Ldloc(localWriter)                         .Callvirt(() => default(IServiceInternalServer).FinishResultMarshaling(null));                 }                 ilGenerator                     .Catch(typeof(Exception))                     .Stloc(localException)                     .Ldarg(2)                     .Ldloc(localResultId)                     .Ldloc(localException)                     .Callvirt(() => default(IServiceInternalServer).ExceptionMarshaling(0u' null))                     .EndTry();             }
Magic Number,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (binding.OneWay)             {                 if (originalReturnType != typeof(void)) ilGenerator.Pop();             }             else             {                 if (localResult == null)                 {                     if (isAsync)                     {                         ilGenerator                             .Ldarg(2)                             .Ldloc(localResultId)                             .Newobj(CreateTaskContinuationWithResultMarshaling(methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler))                             .Pop();                     }                     else                     {                         if (methodInf.MethodInfo.ReturnType != typeof(void)) ilGenerator.Pop();                         ilGenerator                             .Ldarg(2)                             .Ldloc(localResultId)                             .Callvirt(() => default(IServiceInternalServer).VoidResultMarshaling(0u));                     }                 }                 else                 {                     _typeConvertorGenerator.GenerateConversion(returnType' localResult.LocalType)(ilGenerator);                     ilGenerator                         .Stloc(localResult)                         .Ldarg(2)                         .Ldloc(localResultId)                         .Callvirt(() => default(IServiceInternalServer).StartResultMarshaling(0u))                         .Stloc(localWriter);                     IILLocal localWriterCtx = null;                     if (resultFieldHandler.NeedsCtx())                     {                         localWriterCtx = ilGenerator.DeclareLocal(typeof(IWriterCtx)' "writerCtx");                         ilGenerator                             .Ldarg(2)                             .Ldloc(localWriter)                             .Newobj(() => new ServiceWriterCtx((IServiceInternalServer)null' null))                             .Castclass(typeof(IWriterCtx))                             .Stloc(localWriterCtx);                      }                     resultFieldHandler.Save(ilGenerator' il => il.Ldloc(resultFieldHandler.NeedsCtx() ? localWriterCtx : localWriter)' il => il.Ldloc(localResult));                     ilGenerator                         .Ldarg(2)                         .Ldloc(localWriter)                         .Callvirt(() => default(IServiceInternalServer).FinishResultMarshaling(null));                 }                 ilGenerator                     .Catch(typeof(Exception))                     .Stloc(localException)                     .Ldarg(2)                     .Ldloc(localResultId)                     .Ldloc(localException)                     .Callvirt(() => default(IServiceInternalServer).ExceptionMarshaling(0u' null))                     .EndTry();             }
Magic Number,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (binding.OneWay)             {                 if (originalReturnType != typeof(void)) ilGenerator.Pop();             }             else             {                 if (localResult == null)                 {                     if (isAsync)                     {                         ilGenerator                             .Ldarg(2)                             .Ldloc(localResultId)                             .Newobj(CreateTaskContinuationWithResultMarshaling(methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler))                             .Pop();                     }                     else                     {                         if (methodInf.MethodInfo.ReturnType != typeof(void)) ilGenerator.Pop();                         ilGenerator                             .Ldarg(2)                             .Ldloc(localResultId)                             .Callvirt(() => default(IServiceInternalServer).VoidResultMarshaling(0u));                     }                 }                 else                 {                     _typeConvertorGenerator.GenerateConversion(returnType' localResult.LocalType)(ilGenerator);                     ilGenerator                         .Stloc(localResult)                         .Ldarg(2)                         .Ldloc(localResultId)                         .Callvirt(() => default(IServiceInternalServer).StartResultMarshaling(0u))                         .Stloc(localWriter);                     IILLocal localWriterCtx = null;                     if (resultFieldHandler.NeedsCtx())                     {                         localWriterCtx = ilGenerator.DeclareLocal(typeof(IWriterCtx)' "writerCtx");                         ilGenerator                             .Ldarg(2)                             .Ldloc(localWriter)                             .Newobj(() => new ServiceWriterCtx((IServiceInternalServer)null' null))                             .Castclass(typeof(IWriterCtx))                             .Stloc(localWriterCtx);                      }                     resultFieldHandler.Save(ilGenerator' il => il.Ldloc(resultFieldHandler.NeedsCtx() ? localWriterCtx : localWriter)' il => il.Ldloc(localResult));                     ilGenerator                         .Ldarg(2)                         .Ldloc(localWriter)                         .Callvirt(() => default(IServiceInternalServer).FinishResultMarshaling(null));                 }                 ilGenerator                     .Catch(typeof(Exception))                     .Stloc(localException)                     .Ldarg(2)                     .Ldloc(localResultId)                     .Ldloc(localException)                     .Callvirt(() => default(IServiceInternalServer).ExceptionMarshaling(0u' null))                     .EndTry();             }
Magic Number,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (binding.OneWay)             {                 if (originalReturnType != typeof(void)) ilGenerator.Pop();             }             else             {                 if (localResult == null)                 {                     if (isAsync)                     {                         ilGenerator                             .Ldarg(2)                             .Ldloc(localResultId)                             .Newobj(CreateTaskContinuationWithResultMarshaling(methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler))                             .Pop();                     }                     else                     {                         if (methodInf.MethodInfo.ReturnType != typeof(void)) ilGenerator.Pop();                         ilGenerator                             .Ldarg(2)                             .Ldloc(localResultId)                             .Callvirt(() => default(IServiceInternalServer).VoidResultMarshaling(0u));                     }                 }                 else                 {                     _typeConvertorGenerator.GenerateConversion(returnType' localResult.LocalType)(ilGenerator);                     ilGenerator                         .Stloc(localResult)                         .Ldarg(2)                         .Ldloc(localResultId)                         .Callvirt(() => default(IServiceInternalServer).StartResultMarshaling(0u))                         .Stloc(localWriter);                     IILLocal localWriterCtx = null;                     if (resultFieldHandler.NeedsCtx())                     {                         localWriterCtx = ilGenerator.DeclareLocal(typeof(IWriterCtx)' "writerCtx");                         ilGenerator                             .Ldarg(2)                             .Ldloc(localWriter)                             .Newobj(() => new ServiceWriterCtx((IServiceInternalServer)null' null))                             .Castclass(typeof(IWriterCtx))                             .Stloc(localWriterCtx);                      }                     resultFieldHandler.Save(ilGenerator' il => il.Ldloc(resultFieldHandler.NeedsCtx() ? localWriterCtx : localWriter)' il => il.Ldloc(localResult));                     ilGenerator                         .Ldarg(2)                         .Ldloc(localWriter)                         .Callvirt(() => default(IServiceInternalServer).FinishResultMarshaling(null));                 }                 ilGenerator                     .Catch(typeof(Exception))                     .Stloc(localException)                     .Ldarg(2)                     .Ldloc(localResultId)                     .Ldloc(localException)                     .Callvirt(() => default(IServiceInternalServer).ExceptionMarshaling(0u' null))                     .EndTry();             }
Magic Number,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (binding.OneWay)             {                 if (originalReturnType != typeof(void)) ilGenerator.Pop();             }             else             {                 if (localResult == null)                 {                     if (isAsync)                     {                         ilGenerator                             .Ldarg(2)                             .Ldloc(localResultId)                             .Newobj(CreateTaskContinuationWithResultMarshaling(methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler))                             .Pop();                     }                     else                     {                         if (methodInf.MethodInfo.ReturnType != typeof(void)) ilGenerator.Pop();                         ilGenerator                             .Ldarg(2)                             .Ldloc(localResultId)                             .Callvirt(() => default(IServiceInternalServer).VoidResultMarshaling(0u));                     }                 }                 else                 {                     _typeConvertorGenerator.GenerateConversion(returnType' localResult.LocalType)(ilGenerator);                     ilGenerator                         .Stloc(localResult)                         .Ldarg(2)                         .Ldloc(localResultId)                         .Callvirt(() => default(IServiceInternalServer).StartResultMarshaling(0u))                         .Stloc(localWriter);                     IILLocal localWriterCtx = null;                     if (resultFieldHandler.NeedsCtx())                     {                         localWriterCtx = ilGenerator.DeclareLocal(typeof(IWriterCtx)' "writerCtx");                         ilGenerator                             .Ldarg(2)                             .Ldloc(localWriter)                             .Newobj(() => new ServiceWriterCtx((IServiceInternalServer)null' null))                             .Castclass(typeof(IWriterCtx))                             .Stloc(localWriterCtx);                      }                     resultFieldHandler.Save(ilGenerator' il => il.Ldloc(resultFieldHandler.NeedsCtx() ? localWriterCtx : localWriter)' il => il.Ldloc(localResult));                     ilGenerator                         .Ldarg(2)                         .Ldloc(localWriter)                         .Callvirt(() => default(IServiceInternalServer).FinishResultMarshaling(null));                 }                 ilGenerator                     .Catch(typeof(Exception))                     .Stloc(localException)                     .Ldarg(2)                     .Ldloc(localResultId)                     .Ldloc(localException)                     .Callvirt(() => default(IServiceInternalServer).ExceptionMarshaling(0u' null))                     .EndTry();             }
Magic Number,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (binding.OneWay)             {                 if (originalReturnType != typeof(void)) ilGenerator.Pop();             }             else             {                 if (localResult == null)                 {                     if (isAsync)                     {                         ilGenerator                             .Ldarg(2)                             .Ldloc(localResultId)                             .Newobj(CreateTaskContinuationWithResultMarshaling(methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler))                             .Pop();                     }                     else                     {                         if (methodInf.MethodInfo.ReturnType != typeof(void)) ilGenerator.Pop();                         ilGenerator                             .Ldarg(2)                             .Ldloc(localResultId)                             .Callvirt(() => default(IServiceInternalServer).VoidResultMarshaling(0u));                     }                 }                 else                 {                     _typeConvertorGenerator.GenerateConversion(returnType' localResult.LocalType)(ilGenerator);                     ilGenerator                         .Stloc(localResult)                         .Ldarg(2)                         .Ldloc(localResultId)                         .Callvirt(() => default(IServiceInternalServer).StartResultMarshaling(0u))                         .Stloc(localWriter);                     IILLocal localWriterCtx = null;                     if (resultFieldHandler.NeedsCtx())                     {                         localWriterCtx = ilGenerator.DeclareLocal(typeof(IWriterCtx)' "writerCtx");                         ilGenerator                             .Ldarg(2)                             .Ldloc(localWriter)                             .Newobj(() => new ServiceWriterCtx((IServiceInternalServer)null' null))                             .Castclass(typeof(IWriterCtx))                             .Stloc(localWriterCtx);                      }                     resultFieldHandler.Save(ilGenerator' il => il.Ldloc(resultFieldHandler.NeedsCtx() ? localWriterCtx : localWriter)' il => il.Ldloc(localResult));                     ilGenerator                         .Ldarg(2)                         .Ldloc(localWriter)                         .Callvirt(() => default(IServiceInternalServer).FinishResultMarshaling(null));                 }                 ilGenerator                     .Catch(typeof(Exception))                     .Stloc(localException)                     .Ldarg(2)                     .Ldloc(localResultId)                     .Ldloc(localException)                     .Callvirt(() => default(IServiceInternalServer).ExceptionMarshaling(0u' null))                     .EndTry();             }
Magic Number,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,CreateTaskContinuationWithResultMarshaling,The following statement contains a magic number: ilGenerator                 .Ldarg(0)                 .Call(() => new object())                 .Ldarg(0)                 .Ldarg(2)                 .Stfld(ownerField)                 .Ldarg(0)                 .Ldarg(3)                 .Stfld(resultIdField)                 .Ldarg(1)                 .Ldarg(0)                 .Ldftn(methodBuilder)                 .Newobj(actionOfTaskType.GetConstructor(new[] { typeof(object)' typeof(IntPtr) }))                 .Callvirt(taskType.GetMethod("ContinueWith"' new[] { actionOfTaskType }))                 .Pop()                 .Ret();
Magic Number,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,CreateTaskContinuationWithResultMarshaling,The following statement contains a magic number: ilGenerator                 .Ldarg(0)                 .Call(() => new object())                 .Ldarg(0)                 .Ldarg(2)                 .Stfld(ownerField)                 .Ldarg(0)                 .Ldarg(3)                 .Stfld(resultIdField)                 .Ldarg(1)                 .Ldarg(0)                 .Ldftn(methodBuilder)                 .Newobj(actionOfTaskType.GetConstructor(new[] { typeof(object)' typeof(IntPtr) }))                 .Callvirt(taskType.GetMethod("ContinueWith"' new[] { actionOfTaskType }))                 .Pop()                 .Ret();
Magic Number,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: for (int sourceMethodIndex = 0; sourceMethodIndex < typeInf.MethodInfs.Length; sourceMethodIndex++)             {                 var methodInf = typeInf.MethodInfs[sourceMethodIndex];                 var methodInfo = methodInf.MethodInfo;                 var bindingField = tb.DefineField($"_b{bindings.Count}"' typeof(ClientBindInf)' FieldAttributes.Private);                 bindingFields.Add(bindingField);                 var parameterTypes = methodInfo.GetParameters().Select(pi => pi.ParameterType).ToArray();                 var returnType = methodInfo.ReturnType.UnwrapTask();                 var isAsync = returnType != methodInfo.ReturnType;                 var methodBuilder = tb.DefineMethod(methodInfo.Name' methodInfo.ReturnType' parameterTypes' MethodAttributes.Public | MethodAttributes.Virtual);                 ilGenerator = methodBuilder.Generator;                 var targetMethodInf = bestServiceTypeInf.MethodInfs[mapping[sourceMethodIndex][0]];                 var targetMethodIndex = Array.IndexOf(bestServiceTypeInf.MethodInfs' targetMethodInf);                 var bindingId = _clientBindNumbers.Allocate();                 Type resultAsTask;                 Type resultAsTcs;                 if (returnType != typeof(void))                 {                     resultAsTask = typeof(Task<>).MakeGenericType(returnType);                     resultAsTcs = typeof(TaskCompletionSource<>).MakeGenericType(returnType);                 }                 else                 {                     resultAsTask = typeof(Task);                     resultAsTcs = typeof(TaskCompletionSource<bool>);                 }                  var bindingInf = new ClientBindInf                     {                         BindingId = bindingId'                         ServiceId = bestServiceId'                         MethodId = (uint)targetMethodIndex'                         OneWay = !isAsync && returnType == typeof(void)                     };                 _clientBindings.TryAdd(bindingId' bindingInf);                 bindings.Add(bindingInf);                 var writer = new ByteBufferWriter();                 writer.WriteVUInt32((uint)Command.Subcommand);                 writer.WriteVUInt32((uint)Subcommand.Bind);                 bindingInf.Store(writer);                 _channel.Send(writer.Data);                 IILLocal resultTaskLocal = null;                 if (!bindingInf.OneWay)                 {                     resultTaskLocal = ilGenerator.DeclareLocal(typeof(Task)' "resultTask");                 }                 var writerLocal = ilGenerator.DeclareLocal(typeof(AbstractBufferedWriter));                 ilGenerator                     .Ldarg(0)                     .Ldfld(ownerField)                     .Ldarg(0)                     .Ldfld(bindingField);                 if (bindingInf.OneWay)                 {                     ilGenerator                         .Callvirt(() => default(IServiceInternalClient).StartOneWayMarshaling(null));                 }                 else                 {                     Task placebo;                     ilGenerator                         .Ldloca(resultTaskLocal)                         .Callvirt(() => default(IServiceInternalClient).StartTwoWayMarshaling(null' out placebo));                 }                 ilGenerator.Stloc(writerLocal);                 var needsCtx = targetMethodInf.Parameters.Any(p => p.FieldHandler.NeedsCtx());                 IILLocal writerCtxLocal = null;                 if (needsCtx)                 {                     writerCtxLocal = ilGenerator.DeclareLocal(typeof(IWriterCtx));                     ilGenerator                         .Ldarg(0)                         .Ldfld(ownerField)                         .Ldloc(writerLocal)                         .Newobj(() => new ServiceWriterCtx((IServiceInternalClient)null' null))                         .Castclass(typeof(IWriterCtx))                         .Stloc(writerCtxLocal);                 }                 for (int paramOrder = 0; paramOrder < targetMethodInf.Parameters.Length; paramOrder++)                 {                     var parameterInf = targetMethodInf.Parameters[paramOrder];                     var sourceParamIndex = mapping[sourceMethodIndex][paramOrder + 1];                     Type inputType;                     Action<IILGen> loadInput;                     if (sourceParamIndex != uint.MaxValue)                     {                         inputType = parameterTypes[sourceParamIndex];                         loadInput = il => il.Ldarg((ushort)(sourceParamIndex + 1));                     }                     else                     {                         inputType = null;                         loadInput = null;                     }                     Action<IILGen> pushWriterOrCtx;                     var fieldHandler = parameterInf.FieldHandler;                     if (fieldHandler.NeedsCtx()) pushWriterOrCtx = il => il.Ldloc(writerCtxLocal);                     else pushWriterOrCtx = il => il.Ldloc(writerLocal);                     GenerateOneFieldHandlerSave(loadInput' fieldHandler' inputType' ilGenerator' pushWriterOrCtx);                 }                 ilGenerator                     .Ldarg(0)                     .Ldfld(ownerField)                     .Ldloc(writerLocal);                 if (bindingInf.OneWay)                     ilGenerator.Callvirt(() => default(IServiceInternalClient).FinishOneWayMarshaling(null));                 else                 {                     ilGenerator                         .Callvirt(() => default(IServiceInternalClient).FinishTwoWayMarshaling(null))                         .Ldloc(resultTaskLocal)                         .Castclass(resultAsTask);                     if (!isAsync)                         ilGenerator.Callvirt(resultAsTask.GetMethod("get_Result"));                 }                 ilGenerator.Ret();                 if (!isDelegate)                     tb.DefineMethodOverride(methodBuilder' methodInfo);                 if (bindingInf.OneWay)                 {                     bindingResultTypes.Add("");                     continue;                 }                 if (bindingResultTypes.Contains(returnType.FullName))                 {                     bindingResultTypes.Add(returnType.FullName);                     continue;                 }                 bindingResultTypes.Add(returnType.FullName);                 methodBuilder = tb.DefineMethod("HandleResult_" + returnType.FullName' typeof(void)'                                                 new[] { typeof(object)' typeof(AbstractBufferedReader)' typeof(IServiceInternalClient) }' MethodAttributes.Public | MethodAttributes.Static);                 ilGenerator = methodBuilder.Generator;                 var localException = ilGenerator.DeclareLocal(typeof(Exception)' "ex");                 ilGenerator                     .Try()                     .Ldarg(0)                     .Castclass(resultAsTcs);                 if (targetMethodInf.ResultFieldHandler == null && returnType == typeof(void))                 {                     ilGenerator.Ldnull();                 }                 else                 {                     var specializedLoad = targetMethodInf.ResultFieldHandler.SpecializeLoadForType(returnType' null);                     if (specializedLoad.NeedsCtx())                     {                         var readerCtxLocal = ilGenerator.DeclareLocal(typeof(IReaderCtx));                         ilGenerator                             .Ldarg(2)                             .Ldarg(1)                             .Newobj(() => new ServiceReaderCtx((IServiceInternalClient)null' null))                             .Castclass(typeof(IReaderCtx))                             .Stloc(readerCtxLocal);                         specializedLoad.Load(ilGenerator' il => il.Ldloc(readerCtxLocal));                     }                     else                     {                         specializedLoad.Load(ilGenerator' il => il.Ldarg(1));                     }                     _typeConvertorGenerator.GenerateConversion(specializedLoad.HandledType()' returnType)(ilGenerator);                  }                 ilGenerator                     .Callvirt(resultAsTcs.GetMethod("TrySetResult"))                     .Pop()                     .Catch(typeof(Exception))                     .Stloc(localException)                     .Ldarg(0)                     .Castclass(resultAsTcs)                     .Ldloc(localException)                     .Callvirt(resultAsTcs.GetMethod("TrySetException"' new[] { typeof(Exception) }))                     .EndTry()                     .Ret();                  methodBuilder = tb.DefineMethod("HandleException_" + returnType.FullName' typeof(void)'                     new[] { typeof(object)' typeof(Exception) }' MethodAttributes.Public | MethodAttributes.Static);                 methodBuilder.ExpectedLength(16);                 ilGenerator = methodBuilder.Generator;                 ilGenerator                     .Ldarg(0)                     .Castclass(resultAsTcs)                     .Ldarg(1)                     .Callvirt(resultAsTcs.GetMethod("TrySetException"' new[] { typeof(Exception) }))                     .Pop()                     .Ret();                  methodBuilder = tb.DefineMethod("HandleCancellation_" + returnType.FullName' typeof(void)'                     new[] { typeof(object) }' MethodAttributes.Public | MethodAttributes.Static);                 methodBuilder.ExpectedLength(16);                 ilGenerator = methodBuilder.Generator;                 ilGenerator                     .Ldarg(0)                     .Castclass(resultAsTcs)                     .Callvirt(resultAsTcs.GetMethod("TrySetCanceled"' Type.EmptyTypes))                     .Pop()                     .Ret();                  methodBuilder = tb.DefineMethod("TaskWithSourceCreator_" + returnType.FullName' typeof(TaskWithSource)'                     Type.EmptyTypes' MethodAttributes.Public | MethodAttributes.Static);                 methodBuilder.ExpectedLength(32);                 ilGenerator = methodBuilder.Generator;                 ilGenerator.DeclareLocal(resultAsTcs);                 ilGenerator                     .Newobj(resultAsTcs.GetConstructor(Type.EmptyTypes))                     .Stloc(0)                     .Ldloc(0)                     .Ldloc(0)                     .Callvirt(resultAsTcs.GetMethod("get_Task"))                     .Newobj(() => new TaskWithSource(null' null))                     .Ret();             }
Magic Number,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: for (int sourceMethodIndex = 0; sourceMethodIndex < typeInf.MethodInfs.Length; sourceMethodIndex++)             {                 var methodInf = typeInf.MethodInfs[sourceMethodIndex];                 var methodInfo = methodInf.MethodInfo;                 var bindingField = tb.DefineField($"_b{bindings.Count}"' typeof(ClientBindInf)' FieldAttributes.Private);                 bindingFields.Add(bindingField);                 var parameterTypes = methodInfo.GetParameters().Select(pi => pi.ParameterType).ToArray();                 var returnType = methodInfo.ReturnType.UnwrapTask();                 var isAsync = returnType != methodInfo.ReturnType;                 var methodBuilder = tb.DefineMethod(methodInfo.Name' methodInfo.ReturnType' parameterTypes' MethodAttributes.Public | MethodAttributes.Virtual);                 ilGenerator = methodBuilder.Generator;                 var targetMethodInf = bestServiceTypeInf.MethodInfs[mapping[sourceMethodIndex][0]];                 var targetMethodIndex = Array.IndexOf(bestServiceTypeInf.MethodInfs' targetMethodInf);                 var bindingId = _clientBindNumbers.Allocate();                 Type resultAsTask;                 Type resultAsTcs;                 if (returnType != typeof(void))                 {                     resultAsTask = typeof(Task<>).MakeGenericType(returnType);                     resultAsTcs = typeof(TaskCompletionSource<>).MakeGenericType(returnType);                 }                 else                 {                     resultAsTask = typeof(Task);                     resultAsTcs = typeof(TaskCompletionSource<bool>);                 }                  var bindingInf = new ClientBindInf                     {                         BindingId = bindingId'                         ServiceId = bestServiceId'                         MethodId = (uint)targetMethodIndex'                         OneWay = !isAsync && returnType == typeof(void)                     };                 _clientBindings.TryAdd(bindingId' bindingInf);                 bindings.Add(bindingInf);                 var writer = new ByteBufferWriter();                 writer.WriteVUInt32((uint)Command.Subcommand);                 writer.WriteVUInt32((uint)Subcommand.Bind);                 bindingInf.Store(writer);                 _channel.Send(writer.Data);                 IILLocal resultTaskLocal = null;                 if (!bindingInf.OneWay)                 {                     resultTaskLocal = ilGenerator.DeclareLocal(typeof(Task)' "resultTask");                 }                 var writerLocal = ilGenerator.DeclareLocal(typeof(AbstractBufferedWriter));                 ilGenerator                     .Ldarg(0)                     .Ldfld(ownerField)                     .Ldarg(0)                     .Ldfld(bindingField);                 if (bindingInf.OneWay)                 {                     ilGenerator                         .Callvirt(() => default(IServiceInternalClient).StartOneWayMarshaling(null));                 }                 else                 {                     Task placebo;                     ilGenerator                         .Ldloca(resultTaskLocal)                         .Callvirt(() => default(IServiceInternalClient).StartTwoWayMarshaling(null' out placebo));                 }                 ilGenerator.Stloc(writerLocal);                 var needsCtx = targetMethodInf.Parameters.Any(p => p.FieldHandler.NeedsCtx());                 IILLocal writerCtxLocal = null;                 if (needsCtx)                 {                     writerCtxLocal = ilGenerator.DeclareLocal(typeof(IWriterCtx));                     ilGenerator                         .Ldarg(0)                         .Ldfld(ownerField)                         .Ldloc(writerLocal)                         .Newobj(() => new ServiceWriterCtx((IServiceInternalClient)null' null))                         .Castclass(typeof(IWriterCtx))                         .Stloc(writerCtxLocal);                 }                 for (int paramOrder = 0; paramOrder < targetMethodInf.Parameters.Length; paramOrder++)                 {                     var parameterInf = targetMethodInf.Parameters[paramOrder];                     var sourceParamIndex = mapping[sourceMethodIndex][paramOrder + 1];                     Type inputType;                     Action<IILGen> loadInput;                     if (sourceParamIndex != uint.MaxValue)                     {                         inputType = parameterTypes[sourceParamIndex];                         loadInput = il => il.Ldarg((ushort)(sourceParamIndex + 1));                     }                     else                     {                         inputType = null;                         loadInput = null;                     }                     Action<IILGen> pushWriterOrCtx;                     var fieldHandler = parameterInf.FieldHandler;                     if (fieldHandler.NeedsCtx()) pushWriterOrCtx = il => il.Ldloc(writerCtxLocal);                     else pushWriterOrCtx = il => il.Ldloc(writerLocal);                     GenerateOneFieldHandlerSave(loadInput' fieldHandler' inputType' ilGenerator' pushWriterOrCtx);                 }                 ilGenerator                     .Ldarg(0)                     .Ldfld(ownerField)                     .Ldloc(writerLocal);                 if (bindingInf.OneWay)                     ilGenerator.Callvirt(() => default(IServiceInternalClient).FinishOneWayMarshaling(null));                 else                 {                     ilGenerator                         .Callvirt(() => default(IServiceInternalClient).FinishTwoWayMarshaling(null))                         .Ldloc(resultTaskLocal)                         .Castclass(resultAsTask);                     if (!isAsync)                         ilGenerator.Callvirt(resultAsTask.GetMethod("get_Result"));                 }                 ilGenerator.Ret();                 if (!isDelegate)                     tb.DefineMethodOverride(methodBuilder' methodInfo);                 if (bindingInf.OneWay)                 {                     bindingResultTypes.Add("");                     continue;                 }                 if (bindingResultTypes.Contains(returnType.FullName))                 {                     bindingResultTypes.Add(returnType.FullName);                     continue;                 }                 bindingResultTypes.Add(returnType.FullName);                 methodBuilder = tb.DefineMethod("HandleResult_" + returnType.FullName' typeof(void)'                                                 new[] { typeof(object)' typeof(AbstractBufferedReader)' typeof(IServiceInternalClient) }' MethodAttributes.Public | MethodAttributes.Static);                 ilGenerator = methodBuilder.Generator;                 var localException = ilGenerator.DeclareLocal(typeof(Exception)' "ex");                 ilGenerator                     .Try()                     .Ldarg(0)                     .Castclass(resultAsTcs);                 if (targetMethodInf.ResultFieldHandler == null && returnType == typeof(void))                 {                     ilGenerator.Ldnull();                 }                 else                 {                     var specializedLoad = targetMethodInf.ResultFieldHandler.SpecializeLoadForType(returnType' null);                     if (specializedLoad.NeedsCtx())                     {                         var readerCtxLocal = ilGenerator.DeclareLocal(typeof(IReaderCtx));                         ilGenerator                             .Ldarg(2)                             .Ldarg(1)                             .Newobj(() => new ServiceReaderCtx((IServiceInternalClient)null' null))                             .Castclass(typeof(IReaderCtx))                             .Stloc(readerCtxLocal);                         specializedLoad.Load(ilGenerator' il => il.Ldloc(readerCtxLocal));                     }                     else                     {                         specializedLoad.Load(ilGenerator' il => il.Ldarg(1));                     }                     _typeConvertorGenerator.GenerateConversion(specializedLoad.HandledType()' returnType)(ilGenerator);                  }                 ilGenerator                     .Callvirt(resultAsTcs.GetMethod("TrySetResult"))                     .Pop()                     .Catch(typeof(Exception))                     .Stloc(localException)                     .Ldarg(0)                     .Castclass(resultAsTcs)                     .Ldloc(localException)                     .Callvirt(resultAsTcs.GetMethod("TrySetException"' new[] { typeof(Exception) }))                     .EndTry()                     .Ret();                  methodBuilder = tb.DefineMethod("HandleException_" + returnType.FullName' typeof(void)'                     new[] { typeof(object)' typeof(Exception) }' MethodAttributes.Public | MethodAttributes.Static);                 methodBuilder.ExpectedLength(16);                 ilGenerator = methodBuilder.Generator;                 ilGenerator                     .Ldarg(0)                     .Castclass(resultAsTcs)                     .Ldarg(1)                     .Callvirt(resultAsTcs.GetMethod("TrySetException"' new[] { typeof(Exception) }))                     .Pop()                     .Ret();                  methodBuilder = tb.DefineMethod("HandleCancellation_" + returnType.FullName' typeof(void)'                     new[] { typeof(object) }' MethodAttributes.Public | MethodAttributes.Static);                 methodBuilder.ExpectedLength(16);                 ilGenerator = methodBuilder.Generator;                 ilGenerator                     .Ldarg(0)                     .Castclass(resultAsTcs)                     .Callvirt(resultAsTcs.GetMethod("TrySetCanceled"' Type.EmptyTypes))                     .Pop()                     .Ret();                  methodBuilder = tb.DefineMethod("TaskWithSourceCreator_" + returnType.FullName' typeof(TaskWithSource)'                     Type.EmptyTypes' MethodAttributes.Public | MethodAttributes.Static);                 methodBuilder.ExpectedLength(32);                 ilGenerator = methodBuilder.Generator;                 ilGenerator.DeclareLocal(resultAsTcs);                 ilGenerator                     .Newobj(resultAsTcs.GetConstructor(Type.EmptyTypes))                     .Stloc(0)                     .Ldloc(0)                     .Ldloc(0)                     .Callvirt(resultAsTcs.GetMethod("get_Task"))                     .Newobj(() => new TaskWithSource(null' null))                     .Ret();             }
Magic Number,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: for (int sourceMethodIndex = 0; sourceMethodIndex < typeInf.MethodInfs.Length; sourceMethodIndex++)             {                 var methodInf = typeInf.MethodInfs[sourceMethodIndex];                 var methodInfo = methodInf.MethodInfo;                 var bindingField = tb.DefineField($"_b{bindings.Count}"' typeof(ClientBindInf)' FieldAttributes.Private);                 bindingFields.Add(bindingField);                 var parameterTypes = methodInfo.GetParameters().Select(pi => pi.ParameterType).ToArray();                 var returnType = methodInfo.ReturnType.UnwrapTask();                 var isAsync = returnType != methodInfo.ReturnType;                 var methodBuilder = tb.DefineMethod(methodInfo.Name' methodInfo.ReturnType' parameterTypes' MethodAttributes.Public | MethodAttributes.Virtual);                 ilGenerator = methodBuilder.Generator;                 var targetMethodInf = bestServiceTypeInf.MethodInfs[mapping[sourceMethodIndex][0]];                 var targetMethodIndex = Array.IndexOf(bestServiceTypeInf.MethodInfs' targetMethodInf);                 var bindingId = _clientBindNumbers.Allocate();                 Type resultAsTask;                 Type resultAsTcs;                 if (returnType != typeof(void))                 {                     resultAsTask = typeof(Task<>).MakeGenericType(returnType);                     resultAsTcs = typeof(TaskCompletionSource<>).MakeGenericType(returnType);                 }                 else                 {                     resultAsTask = typeof(Task);                     resultAsTcs = typeof(TaskCompletionSource<bool>);                 }                  var bindingInf = new ClientBindInf                     {                         BindingId = bindingId'                         ServiceId = bestServiceId'                         MethodId = (uint)targetMethodIndex'                         OneWay = !isAsync && returnType == typeof(void)                     };                 _clientBindings.TryAdd(bindingId' bindingInf);                 bindings.Add(bindingInf);                 var writer = new ByteBufferWriter();                 writer.WriteVUInt32((uint)Command.Subcommand);                 writer.WriteVUInt32((uint)Subcommand.Bind);                 bindingInf.Store(writer);                 _channel.Send(writer.Data);                 IILLocal resultTaskLocal = null;                 if (!bindingInf.OneWay)                 {                     resultTaskLocal = ilGenerator.DeclareLocal(typeof(Task)' "resultTask");                 }                 var writerLocal = ilGenerator.DeclareLocal(typeof(AbstractBufferedWriter));                 ilGenerator                     .Ldarg(0)                     .Ldfld(ownerField)                     .Ldarg(0)                     .Ldfld(bindingField);                 if (bindingInf.OneWay)                 {                     ilGenerator                         .Callvirt(() => default(IServiceInternalClient).StartOneWayMarshaling(null));                 }                 else                 {                     Task placebo;                     ilGenerator                         .Ldloca(resultTaskLocal)                         .Callvirt(() => default(IServiceInternalClient).StartTwoWayMarshaling(null' out placebo));                 }                 ilGenerator.Stloc(writerLocal);                 var needsCtx = targetMethodInf.Parameters.Any(p => p.FieldHandler.NeedsCtx());                 IILLocal writerCtxLocal = null;                 if (needsCtx)                 {                     writerCtxLocal = ilGenerator.DeclareLocal(typeof(IWriterCtx));                     ilGenerator                         .Ldarg(0)                         .Ldfld(ownerField)                         .Ldloc(writerLocal)                         .Newobj(() => new ServiceWriterCtx((IServiceInternalClient)null' null))                         .Castclass(typeof(IWriterCtx))                         .Stloc(writerCtxLocal);                 }                 for (int paramOrder = 0; paramOrder < targetMethodInf.Parameters.Length; paramOrder++)                 {                     var parameterInf = targetMethodInf.Parameters[paramOrder];                     var sourceParamIndex = mapping[sourceMethodIndex][paramOrder + 1];                     Type inputType;                     Action<IILGen> loadInput;                     if (sourceParamIndex != uint.MaxValue)                     {                         inputType = parameterTypes[sourceParamIndex];                         loadInput = il => il.Ldarg((ushort)(sourceParamIndex + 1));                     }                     else                     {                         inputType = null;                         loadInput = null;                     }                     Action<IILGen> pushWriterOrCtx;                     var fieldHandler = parameterInf.FieldHandler;                     if (fieldHandler.NeedsCtx()) pushWriterOrCtx = il => il.Ldloc(writerCtxLocal);                     else pushWriterOrCtx = il => il.Ldloc(writerLocal);                     GenerateOneFieldHandlerSave(loadInput' fieldHandler' inputType' ilGenerator' pushWriterOrCtx);                 }                 ilGenerator                     .Ldarg(0)                     .Ldfld(ownerField)                     .Ldloc(writerLocal);                 if (bindingInf.OneWay)                     ilGenerator.Callvirt(() => default(IServiceInternalClient).FinishOneWayMarshaling(null));                 else                 {                     ilGenerator                         .Callvirt(() => default(IServiceInternalClient).FinishTwoWayMarshaling(null))                         .Ldloc(resultTaskLocal)                         .Castclass(resultAsTask);                     if (!isAsync)                         ilGenerator.Callvirt(resultAsTask.GetMethod("get_Result"));                 }                 ilGenerator.Ret();                 if (!isDelegate)                     tb.DefineMethodOverride(methodBuilder' methodInfo);                 if (bindingInf.OneWay)                 {                     bindingResultTypes.Add("");                     continue;                 }                 if (bindingResultTypes.Contains(returnType.FullName))                 {                     bindingResultTypes.Add(returnType.FullName);                     continue;                 }                 bindingResultTypes.Add(returnType.FullName);                 methodBuilder = tb.DefineMethod("HandleResult_" + returnType.FullName' typeof(void)'                                                 new[] { typeof(object)' typeof(AbstractBufferedReader)' typeof(IServiceInternalClient) }' MethodAttributes.Public | MethodAttributes.Static);                 ilGenerator = methodBuilder.Generator;                 var localException = ilGenerator.DeclareLocal(typeof(Exception)' "ex");                 ilGenerator                     .Try()                     .Ldarg(0)                     .Castclass(resultAsTcs);                 if (targetMethodInf.ResultFieldHandler == null && returnType == typeof(void))                 {                     ilGenerator.Ldnull();                 }                 else                 {                     var specializedLoad = targetMethodInf.ResultFieldHandler.SpecializeLoadForType(returnType' null);                     if (specializedLoad.NeedsCtx())                     {                         var readerCtxLocal = ilGenerator.DeclareLocal(typeof(IReaderCtx));                         ilGenerator                             .Ldarg(2)                             .Ldarg(1)                             .Newobj(() => new ServiceReaderCtx((IServiceInternalClient)null' null))                             .Castclass(typeof(IReaderCtx))                             .Stloc(readerCtxLocal);                         specializedLoad.Load(ilGenerator' il => il.Ldloc(readerCtxLocal));                     }                     else                     {                         specializedLoad.Load(ilGenerator' il => il.Ldarg(1));                     }                     _typeConvertorGenerator.GenerateConversion(specializedLoad.HandledType()' returnType)(ilGenerator);                  }                 ilGenerator                     .Callvirt(resultAsTcs.GetMethod("TrySetResult"))                     .Pop()                     .Catch(typeof(Exception))                     .Stloc(localException)                     .Ldarg(0)                     .Castclass(resultAsTcs)                     .Ldloc(localException)                     .Callvirt(resultAsTcs.GetMethod("TrySetException"' new[] { typeof(Exception) }))                     .EndTry()                     .Ret();                  methodBuilder = tb.DefineMethod("HandleException_" + returnType.FullName' typeof(void)'                     new[] { typeof(object)' typeof(Exception) }' MethodAttributes.Public | MethodAttributes.Static);                 methodBuilder.ExpectedLength(16);                 ilGenerator = methodBuilder.Generator;                 ilGenerator                     .Ldarg(0)                     .Castclass(resultAsTcs)                     .Ldarg(1)                     .Callvirt(resultAsTcs.GetMethod("TrySetException"' new[] { typeof(Exception) }))                     .Pop()                     .Ret();                  methodBuilder = tb.DefineMethod("HandleCancellation_" + returnType.FullName' typeof(void)'                     new[] { typeof(object) }' MethodAttributes.Public | MethodAttributes.Static);                 methodBuilder.ExpectedLength(16);                 ilGenerator = methodBuilder.Generator;                 ilGenerator                     .Ldarg(0)                     .Castclass(resultAsTcs)                     .Callvirt(resultAsTcs.GetMethod("TrySetCanceled"' Type.EmptyTypes))                     .Pop()                     .Ret();                  methodBuilder = tb.DefineMethod("TaskWithSourceCreator_" + returnType.FullName' typeof(TaskWithSource)'                     Type.EmptyTypes' MethodAttributes.Public | MethodAttributes.Static);                 methodBuilder.ExpectedLength(32);                 ilGenerator = methodBuilder.Generator;                 ilGenerator.DeclareLocal(resultAsTcs);                 ilGenerator                     .Newobj(resultAsTcs.GetConstructor(Type.EmptyTypes))                     .Stloc(0)                     .Ldloc(0)                     .Ldloc(0)                     .Callvirt(resultAsTcs.GetMethod("get_Task"))                     .Newobj(() => new TaskWithSource(null' null))                     .Ret();             }
Magic Number,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: for (int sourceMethodIndex = 0; sourceMethodIndex < typeInf.MethodInfs.Length; sourceMethodIndex++)             {                 var methodInf = typeInf.MethodInfs[sourceMethodIndex];                 var methodInfo = methodInf.MethodInfo;                 var bindingField = tb.DefineField($"_b{bindings.Count}"' typeof(ClientBindInf)' FieldAttributes.Private);                 bindingFields.Add(bindingField);                 var parameterTypes = methodInfo.GetParameters().Select(pi => pi.ParameterType).ToArray();                 var returnType = methodInfo.ReturnType.UnwrapTask();                 var isAsync = returnType != methodInfo.ReturnType;                 var methodBuilder = tb.DefineMethod(methodInfo.Name' methodInfo.ReturnType' parameterTypes' MethodAttributes.Public | MethodAttributes.Virtual);                 ilGenerator = methodBuilder.Generator;                 var targetMethodInf = bestServiceTypeInf.MethodInfs[mapping[sourceMethodIndex][0]];                 var targetMethodIndex = Array.IndexOf(bestServiceTypeInf.MethodInfs' targetMethodInf);                 var bindingId = _clientBindNumbers.Allocate();                 Type resultAsTask;                 Type resultAsTcs;                 if (returnType != typeof(void))                 {                     resultAsTask = typeof(Task<>).MakeGenericType(returnType);                     resultAsTcs = typeof(TaskCompletionSource<>).MakeGenericType(returnType);                 }                 else                 {                     resultAsTask = typeof(Task);                     resultAsTcs = typeof(TaskCompletionSource<bool>);                 }                  var bindingInf = new ClientBindInf                     {                         BindingId = bindingId'                         ServiceId = bestServiceId'                         MethodId = (uint)targetMethodIndex'                         OneWay = !isAsync && returnType == typeof(void)                     };                 _clientBindings.TryAdd(bindingId' bindingInf);                 bindings.Add(bindingInf);                 var writer = new ByteBufferWriter();                 writer.WriteVUInt32((uint)Command.Subcommand);                 writer.WriteVUInt32((uint)Subcommand.Bind);                 bindingInf.Store(writer);                 _channel.Send(writer.Data);                 IILLocal resultTaskLocal = null;                 if (!bindingInf.OneWay)                 {                     resultTaskLocal = ilGenerator.DeclareLocal(typeof(Task)' "resultTask");                 }                 var writerLocal = ilGenerator.DeclareLocal(typeof(AbstractBufferedWriter));                 ilGenerator                     .Ldarg(0)                     .Ldfld(ownerField)                     .Ldarg(0)                     .Ldfld(bindingField);                 if (bindingInf.OneWay)                 {                     ilGenerator                         .Callvirt(() => default(IServiceInternalClient).StartOneWayMarshaling(null));                 }                 else                 {                     Task placebo;                     ilGenerator                         .Ldloca(resultTaskLocal)                         .Callvirt(() => default(IServiceInternalClient).StartTwoWayMarshaling(null' out placebo));                 }                 ilGenerator.Stloc(writerLocal);                 var needsCtx = targetMethodInf.Parameters.Any(p => p.FieldHandler.NeedsCtx());                 IILLocal writerCtxLocal = null;                 if (needsCtx)                 {                     writerCtxLocal = ilGenerator.DeclareLocal(typeof(IWriterCtx));                     ilGenerator                         .Ldarg(0)                         .Ldfld(ownerField)                         .Ldloc(writerLocal)                         .Newobj(() => new ServiceWriterCtx((IServiceInternalClient)null' null))                         .Castclass(typeof(IWriterCtx))                         .Stloc(writerCtxLocal);                 }                 for (int paramOrder = 0; paramOrder < targetMethodInf.Parameters.Length; paramOrder++)                 {                     var parameterInf = targetMethodInf.Parameters[paramOrder];                     var sourceParamIndex = mapping[sourceMethodIndex][paramOrder + 1];                     Type inputType;                     Action<IILGen> loadInput;                     if (sourceParamIndex != uint.MaxValue)                     {                         inputType = parameterTypes[sourceParamIndex];                         loadInput = il => il.Ldarg((ushort)(sourceParamIndex + 1));                     }                     else                     {                         inputType = null;                         loadInput = null;                     }                     Action<IILGen> pushWriterOrCtx;                     var fieldHandler = parameterInf.FieldHandler;                     if (fieldHandler.NeedsCtx()) pushWriterOrCtx = il => il.Ldloc(writerCtxLocal);                     else pushWriterOrCtx = il => il.Ldloc(writerLocal);                     GenerateOneFieldHandlerSave(loadInput' fieldHandler' inputType' ilGenerator' pushWriterOrCtx);                 }                 ilGenerator                     .Ldarg(0)                     .Ldfld(ownerField)                     .Ldloc(writerLocal);                 if (bindingInf.OneWay)                     ilGenerator.Callvirt(() => default(IServiceInternalClient).FinishOneWayMarshaling(null));                 else                 {                     ilGenerator                         .Callvirt(() => default(IServiceInternalClient).FinishTwoWayMarshaling(null))                         .Ldloc(resultTaskLocal)                         .Castclass(resultAsTask);                     if (!isAsync)                         ilGenerator.Callvirt(resultAsTask.GetMethod("get_Result"));                 }                 ilGenerator.Ret();                 if (!isDelegate)                     tb.DefineMethodOverride(methodBuilder' methodInfo);                 if (bindingInf.OneWay)                 {                     bindingResultTypes.Add("");                     continue;                 }                 if (bindingResultTypes.Contains(returnType.FullName))                 {                     bindingResultTypes.Add(returnType.FullName);                     continue;                 }                 bindingResultTypes.Add(returnType.FullName);                 methodBuilder = tb.DefineMethod("HandleResult_" + returnType.FullName' typeof(void)'                                                 new[] { typeof(object)' typeof(AbstractBufferedReader)' typeof(IServiceInternalClient) }' MethodAttributes.Public | MethodAttributes.Static);                 ilGenerator = methodBuilder.Generator;                 var localException = ilGenerator.DeclareLocal(typeof(Exception)' "ex");                 ilGenerator                     .Try()                     .Ldarg(0)                     .Castclass(resultAsTcs);                 if (targetMethodInf.ResultFieldHandler == null && returnType == typeof(void))                 {                     ilGenerator.Ldnull();                 }                 else                 {                     var specializedLoad = targetMethodInf.ResultFieldHandler.SpecializeLoadForType(returnType' null);                     if (specializedLoad.NeedsCtx())                     {                         var readerCtxLocal = ilGenerator.DeclareLocal(typeof(IReaderCtx));                         ilGenerator                             .Ldarg(2)                             .Ldarg(1)                             .Newobj(() => new ServiceReaderCtx((IServiceInternalClient)null' null))                             .Castclass(typeof(IReaderCtx))                             .Stloc(readerCtxLocal);                         specializedLoad.Load(ilGenerator' il => il.Ldloc(readerCtxLocal));                     }                     else                     {                         specializedLoad.Load(ilGenerator' il => il.Ldarg(1));                     }                     _typeConvertorGenerator.GenerateConversion(specializedLoad.HandledType()' returnType)(ilGenerator);                  }                 ilGenerator                     .Callvirt(resultAsTcs.GetMethod("TrySetResult"))                     .Pop()                     .Catch(typeof(Exception))                     .Stloc(localException)                     .Ldarg(0)                     .Castclass(resultAsTcs)                     .Ldloc(localException)                     .Callvirt(resultAsTcs.GetMethod("TrySetException"' new[] { typeof(Exception) }))                     .EndTry()                     .Ret();                  methodBuilder = tb.DefineMethod("HandleException_" + returnType.FullName' typeof(void)'                     new[] { typeof(object)' typeof(Exception) }' MethodAttributes.Public | MethodAttributes.Static);                 methodBuilder.ExpectedLength(16);                 ilGenerator = methodBuilder.Generator;                 ilGenerator                     .Ldarg(0)                     .Castclass(resultAsTcs)                     .Ldarg(1)                     .Callvirt(resultAsTcs.GetMethod("TrySetException"' new[] { typeof(Exception) }))                     .Pop()                     .Ret();                  methodBuilder = tb.DefineMethod("HandleCancellation_" + returnType.FullName' typeof(void)'                     new[] { typeof(object) }' MethodAttributes.Public | MethodAttributes.Static);                 methodBuilder.ExpectedLength(16);                 ilGenerator = methodBuilder.Generator;                 ilGenerator                     .Ldarg(0)                     .Castclass(resultAsTcs)                     .Callvirt(resultAsTcs.GetMethod("TrySetCanceled"' Type.EmptyTypes))                     .Pop()                     .Ret();                  methodBuilder = tb.DefineMethod("TaskWithSourceCreator_" + returnType.FullName' typeof(TaskWithSource)'                     Type.EmptyTypes' MethodAttributes.Public | MethodAttributes.Static);                 methodBuilder.ExpectedLength(32);                 ilGenerator = methodBuilder.Generator;                 ilGenerator.DeclareLocal(resultAsTcs);                 ilGenerator                     .Newobj(resultAsTcs.GetConstructor(Type.EmptyTypes))                     .Stloc(0)                     .Ldloc(0)                     .Ldloc(0)                     .Callvirt(resultAsTcs.GetMethod("get_Task"))                     .Newobj(() => new TaskWithSource(null' null))                     .Ret();             }
Magic Number,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: for (int i = 0; i < bindingFields.Count; i++)             {                 ilGenerator                     .Ldarg(0)                     .Ldarg(2)                     .LdcI4(i)                     .LdelemRef()                     .Stfld(bindingFields[i]);             }
Magic Number,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibility,The following statement contains a magic number: if (from.MethodInfs.Length == 1 && to.MethodInfs.Length == 1)             {                 uint[] parameterMapping = null;                 if (mapping != null)                 {                     parameterMapping = new uint[1 + to.MethodInfs[0].Parameters.Length];                     mapping[0] = parameterMapping;                 }                 result = EvaluateCompatibilityIgnoringName(from.MethodInfs[0]' to.MethodInfs[0]' parameterMapping);                 if (result == int.MinValue) return result;                 if (from.Name == to.Name) result += 5;                 return result;             }
Magic Number,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibility,The following statement contains a magic number: if (from.Name == to.Name && (from.Configuration == to.Configuration || from.Configuration.SequenceEqual(to.Configuration))) return 10;
Magic Number,BTDB.Service,Service,C:\repos\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibility,The following statement contains a magic number: if (_typeConvertorGenerator.GenerateConversion(typeFrom' typeTo) != null) return 5;
Magic Number,BTDB.Service,Client,C:\repos\Bobris_BTDB\BTDB\Service\TcpipServer.cs,ReceiveBody,The following statement contains a magic number: try                 {                     _connector.OnNext(true);                     var buf = new byte[9];                     while (!_disconnected)                     {                         if (!Receive(buf' 0' 1)) return;                         var packLen = PackUnpack.LengthVUInt(buf' 0);                         if (packLen > 1) if (!Receive(buf' 1' packLen - 1)) return;                         int o = 0;                         var len = PackUnpack.UnpackVUInt(buf' ref o);                         if (len > int.MaxValue) throw new InvalidDataException();                         var result = new byte[len];                         if (len != 0) if (!Receive(result' 0' (int)len)) return;                         _receiver.OnNext(ByteBuffer.NewAsync(result));                     }                 }                 catch (Exception)                 {                     SignalDisconnected();                 }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Equal4,The following statement contains a magic number: return buf[o1] == buf[o2] &&                    buf[o1 + 1] == buf[o2 + 1] &&                    buf[o1 + 2] == buf[o2 + 2] &&                    buf[o1 + 3] == buf[o2 + 3];
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Equal4,The following statement contains a magic number: return buf[o1] == buf[o2] &&                    buf[o1 + 1] == buf[o2 + 1] &&                    buf[o1 + 2] == buf[o2 + 2] &&                    buf[o1 + 3] == buf[o2 + 3];
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Equal4,The following statement contains a magic number: return buf[o1] == buf[o2] &&                    buf[o1 + 1] == buf[o2 + 1] &&                    buf[o1 + 2] == buf[o2 + 2] &&                    buf[o1 + 3] == buf[o2 + 3];
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Equal4,The following statement contains a magic number: return buf[o1] == buf[o2] &&                    buf[o1 + 1] == buf[o2 + 1] &&                    buf[o1 + 2] == buf[o2 + 2] &&                    buf[o1 + 3] == buf[o2 + 3];
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61)             {                 if (sL + 1 > dL) return false;                 dst[d] = (byte)((sL - 1) << 2);                 d++;                 dL--;             }             else if (sL <= 0x100)             {                 if (sL + 2 > dL) return false;                 dst[d] = 60 << 2;                 dst[d + 1] = (byte)(sL - 1);                 d += 2;                 dL -= 2;             }             else if (sL <= 0x10000)             {                 if (sL + 3 > dL) return false;                 dst[d] = 61 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 d += 3;                 dL -= 3;             }             else if (sL <= 0x1000000)             {                 if (sL + 4 > dL) return false;                 dst[d] = 62 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 d += 4;                 dL -= 4;             }             else             {                 if (sL + 5 > dL) return false;                 dst[d] = 63 << 2;                 dst[d + 1] = (byte)(sL - 1);                 dst[d + 2] = (byte)((sL - 1) >> 8);                 dst[d + 3] = (byte)((sL - 1) >> 16);                 dst[d + 4] = (byte)((sL - 1) >> 24);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0)             {                 var x = length - 4;                 if (0 <= x && x < 8 && offset < 1 << 11)                 {                     if (dL < 2) return false;                     dst[d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);                     dst[d + 1] = (byte)offset;                     d += 2;                     dL -= 2;                     break;                 }                 x = length;                 if (x > 1 << 6)                 {                     x = 1 << 6;                 }                 if (dL < 3) return false;                 dst[d] = (byte)((x - 1) << 2 | 2);                 dst[d + 1] = (byte)offset;                 dst[d + 2] = (byte)(offset >> 8);                 d += 3;                 dL -= 3;                 length -= x;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0)             {                 var x = length - 4;                 if (0 <= x && x < 8 && offset < 1 << 11)                 {                     if (dL < 2) return false;                     dst[d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);                     dst[d + 1] = (byte)offset;                     d += 2;                     dL -= 2;                     break;                 }                 x = length;                 if (x > 1 << 6)                 {                     x = 1 << 6;                 }                 if (dL < 3) return false;                 dst[d] = (byte)((x - 1) << 2 | 2);                 dst[d + 1] = (byte)offset;                 dst[d + 2] = (byte)(offset >> 8);                 d += 3;                 dL -= 3;                 length -= x;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0)             {                 var x = length - 4;                 if (0 <= x && x < 8 && offset < 1 << 11)                 {                     if (dL < 2) return false;                     dst[d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);                     dst[d + 1] = (byte)offset;                     d += 2;                     dL -= 2;                     break;                 }                 x = length;                 if (x > 1 << 6)                 {                     x = 1 << 6;                 }                 if (dL < 3) return false;                 dst[d] = (byte)((x - 1) << 2 | 2);                 dst[d + 1] = (byte)offset;                 dst[d + 2] = (byte)(offset >> 8);                 d += 3;                 dL -= 3;                 length -= x;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0)             {                 var x = length - 4;                 if (0 <= x && x < 8 && offset < 1 << 11)                 {                     if (dL < 2) return false;                     dst[d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);                     dst[d + 1] = (byte)offset;                     d += 2;                     dL -= 2;                     break;                 }                 x = length;                 if (x > 1 << 6)                 {                     x = 1 << 6;                 }                 if (dL < 3) return false;                 dst[d] = (byte)((x - 1) << 2 | 2);                 dst[d + 1] = (byte)offset;                 dst[d + 2] = (byte)(offset >> 8);                 d += 3;                 dL -= 3;                 length -= x;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0)             {                 var x = length - 4;                 if (0 <= x && x < 8 && offset < 1 << 11)                 {                     if (dL < 2) return false;                     dst[d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);                     dst[d + 1] = (byte)offset;                     d += 2;                     dL -= 2;                     break;                 }                 x = length;                 if (x > 1 << 6)                 {                     x = 1 << 6;                 }                 if (dL < 3) return false;                 dst[d] = (byte)((x - 1) << 2 | 2);                 dst[d + 1] = (byte)offset;                 dst[d + 2] = (byte)(offset >> 8);                 d += 3;                 dL -= 3;                 length -= x;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0)             {                 var x = length - 4;                 if (0 <= x && x < 8 && offset < 1 << 11)                 {                     if (dL < 2) return false;                     dst[d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);                     dst[d + 1] = (byte)offset;                     d += 2;                     dL -= 2;                     break;                 }                 x = length;                 if (x > 1 << 6)                 {                     x = 1 << 6;                 }                 if (dL < 3) return false;                 dst[d] = (byte)((x - 1) << 2 | 2);                 dst[d + 1] = (byte)offset;                 dst[d + 2] = (byte)(offset >> 8);                 d += 3;                 dL -= 3;                 length -= x;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0)             {                 var x = length - 4;                 if (0 <= x && x < 8 && offset < 1 << 11)                 {                     if (dL < 2) return false;                     dst[d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);                     dst[d + 1] = (byte)offset;                     d += 2;                     dL -= 2;                     break;                 }                 x = length;                 if (x > 1 << 6)                 {                     x = 1 << 6;                 }                 if (dL < 3) return false;                 dst[d] = (byte)((x - 1) << 2 | 2);                 dst[d + 1] = (byte)offset;                 dst[d + 2] = (byte)(offset >> 8);                 d += 3;                 dL -= 3;                 length -= x;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0)             {                 var x = length - 4;                 if (0 <= x && x < 8 && offset < 1 << 11)                 {                     if (dL < 2) return false;                     dst[d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);                     dst[d + 1] = (byte)offset;                     d += 2;                     dL -= 2;                     break;                 }                 x = length;                 if (x > 1 << 6)                 {                     x = 1 << 6;                 }                 if (dL < 3) return false;                 dst[d] = (byte)((x - 1) << 2 | 2);                 dst[d + 1] = (byte)offset;                 dst[d + 2] = (byte)(offset >> 8);                 d += 3;                 dL -= 3;                 length -= x;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0)             {                 var x = length - 4;                 if (0 <= x && x < 8 && offset < 1 << 11)                 {                     if (dL < 2) return false;                     dst[d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);                     dst[d + 1] = (byte)offset;                     d += 2;                     dL -= 2;                     break;                 }                 x = length;                 if (x > 1 << 6)                 {                     x = 1 << 6;                 }                 if (dL < 3) return false;                 dst[d] = (byte)((x - 1) << 2 | 2);                 dst[d + 1] = (byte)offset;                 dst[d + 2] = (byte)(offset >> 8);                 d += 3;                 dL -= 3;                 length -= x;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0)             {                 var x = length - 4;                 if (0 <= x && x < 8 && offset < 1 << 11)                 {                     if (dL < 2) return false;                     dst[d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);                     dst[d + 1] = (byte)offset;                     d += 2;                     dL -= 2;                     break;                 }                 x = length;                 if (x > 1 << 6)                 {                     x = 1 << 6;                 }                 if (dL < 3) return false;                 dst[d] = (byte)((x - 1) << 2 | 2);                 dst[d + 1] = (byte)offset;                 dst[d + 2] = (byte)(offset >> 8);                 d += 3;                 dL -= 3;                 length -= x;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0)             {                 var x = length - 4;                 if (0 <= x && x < 8 && offset < 1 << 11)                 {                     if (dL < 2) return false;                     dst[d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);                     dst[d + 1] = (byte)offset;                     d += 2;                     dL -= 2;                     break;                 }                 x = length;                 if (x > 1 << 6)                 {                     x = 1 << 6;                 }                 if (dL < 3) return false;                 dst[d] = (byte)((x - 1) << 2 | 2);                 dst[d + 1] = (byte)offset;                 dst[d + 2] = (byte)(offset >> 8);                 d += 3;                 dL -= 3;                 length -= x;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0)             {                 var x = length - 4;                 if (0 <= x && x < 8 && offset < 1 << 11)                 {                     if (dL < 2) return false;                     dst[d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);                     dst[d + 1] = (byte)offset;                     d += 2;                     dL -= 2;                     break;                 }                 x = length;                 if (x > 1 << 6)                 {                     x = 1 << 6;                 }                 if (dL < 3) return false;                 dst[d] = (byte)((x - 1) << 2 | 2);                 dst[d + 1] = (byte)offset;                 dst[d + 2] = (byte)(offset >> 8);                 d += 3;                 dL -= 3;                 length -= x;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0)             {                 var x = length - 4;                 if (0 <= x && x < 8 && offset < 1 << 11)                 {                     if (dL < 2) return false;                     dst[d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);                     dst[d + 1] = (byte)offset;                     d += 2;                     dL -= 2;                     break;                 }                 x = length;                 if (x > 1 << 6)                 {                     x = 1 << 6;                 }                 if (dL < 3) return false;                 dst[d] = (byte)((x - 1) << 2 | 2);                 dst[d + 1] = (byte)offset;                 dst[d + 2] = (byte)(offset >> 8);                 d += 3;                 dL -= 3;                 length -= x;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0)             {                 var x = length - 4;                 if (0 <= x && x < 8 && offset < 1 << 11)                 {                     if (dL < 2) return false;                     dst[d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);                     dst[d + 1] = (byte)offset;                     d += 2;                     dL -= 2;                     break;                 }                 x = length;                 if (x > 1 << 6)                 {                     x = 1 << 6;                 }                 if (dL < 3) return false;                 dst[d] = (byte)((x - 1) << 2 | 2);                 dst[d + 1] = (byte)offset;                 dst[d + 2] = (byte)(offset >> 8);                 d += 3;                 dL -= 3;                 length -= x;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0)             {                 var x = length - 4;                 if (0 <= x && x < 8 && offset < 1 << 11)                 {                     if (dL < 2) return false;                     dst[d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);                     dst[d + 1] = (byte)offset;                     d += 2;                     dL -= 2;                     break;                 }                 x = length;                 if (x > 1 << 6)                 {                     x = 1 << 6;                 }                 if (dL < 3) return false;                 dst[d] = (byte)((x - 1) << 2 | 2);                 dst[d + 1] = (byte)offset;                 dst[d + 2] = (byte)(offset >> 8);                 d += 3;                 dL -= 3;                 length -= x;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0)             {                 var x = length - 4;                 if (0 <= x && x < 8 && offset < 1 << 11)                 {                     if (dL < 2) return false;                     dst[d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);                     dst[d + 1] = (byte)offset;                     d += 2;                     dL -= 2;                     break;                 }                 x = length;                 if (x > 1 << 6)                 {                     x = 1 << 6;                 }                 if (dL < 3) return false;                 dst[d] = (byte)((x - 1) << 2 | 2);                 dst[d + 1] = (byte)offset;                 dst[d + 2] = (byte)(offset >> 8);                 d += 3;                 dL -= 3;                 length -= x;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0)             {                 var x = length - 4;                 if (0 <= x && x < 8 && offset < 1 << 11)                 {                     if (dL < 2) return false;                     dst[d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);                     dst[d + 1] = (byte)offset;                     d += 2;                     dL -= 2;                     break;                 }                 x = length;                 if (x > 1 << 6)                 {                     x = 1 << 6;                 }                 if (dL < 3) return false;                 dst[d] = (byte)((x - 1) << 2 | 2);                 dst[d + 1] = (byte)offset;                 dst[d + 2] = (byte)(offset >> 8);                 d += 3;                 dL -= 3;                 length -= x;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80)             {                 dst[d] = (byte)length;                 d++;                 dL--;             }             else if (length < 0x4000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)(length >> 7);                 d += 2;                 dL -= 2;             }             else if (length < 0x200000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)(length >> 14);                 d += 3;                 dL -= 3;             }             else if (length < 0x10000000)             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)(length >> 21);                 d += 4;                 dL -= 4;             }             else             {                 dst[d] = (byte)(length | 128);                 dst[d + 1] = (byte)((length >> 7) | 128);                 dst[d + 2] = (byte)((length >> 14) | 128);                 dst[d + 3] = (byte)((length >> 21) | 128);                 dst[d + 4] = (byte)(length >> 28);                 d += 5;                 dL -= 5;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: if (dL < 5) return -1;
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: if (sL <= 4)             {                 if (!EmitLiteral(dst' ref d' ref dL' src' s' sL)) return -1;                 return d - dstBuf.Offset;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: var shift = 32 - 8;
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: var shift = 32 - 8;
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: var tableSize = 1 << 8;
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (tableSize < 1 << 14 && tableSize < sL)             {                 shift--;                 tableSize *= 2;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (tableSize < 1 << 14 && tableSize < sL)             {                 shift--;                 tableSize *= 2;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3)             {                 var v = src[s] | ((uint)src[s + 1]) << 8 | ((uint)src[s + 2]) << 16 | ((uint)src[s + 3]) << 24;             nextfast:                 var h = (v * 0x1e35a7bd) >> shift;                 var t = table[h];                 table[h] = s;                 if (t < 0 || s - t >= MaxOffset || !Equal4(src' t' s))                 {                     s++;                     sL--;                     if (sL>3)                     {                         v = (v >> 8) | ((uint)src[s + 3]) << 24;                         goto nextfast;                     }                     break;                 }                 if (lit != s)                 {                     if (!EmitLiteral(dst' ref d' ref dL' src' lit' s - lit)) return -1;                 }                 var s0 = s;                 s += 4;                 sL -= 4;                 t += 4;                 while (sL > 0 && src[s] == src[t])                 {                     s++;                     sL--;                     t++;                 }                 if (!EmitCopy(dst' ref d' ref dL' s - t' s - s0)) return -1;                 lit = s;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3)             {                 var v = src[s] | ((uint)src[s + 1]) << 8 | ((uint)src[s + 2]) << 16 | ((uint)src[s + 3]) << 24;             nextfast:                 var h = (v * 0x1e35a7bd) >> shift;                 var t = table[h];                 table[h] = s;                 if (t < 0 || s - t >= MaxOffset || !Equal4(src' t' s))                 {                     s++;                     sL--;                     if (sL>3)                     {                         v = (v >> 8) | ((uint)src[s + 3]) << 24;                         goto nextfast;                     }                     break;                 }                 if (lit != s)                 {                     if (!EmitLiteral(dst' ref d' ref dL' src' lit' s - lit)) return -1;                 }                 var s0 = s;                 s += 4;                 sL -= 4;                 t += 4;                 while (sL > 0 && src[s] == src[t])                 {                     s++;                     sL--;                     t++;                 }                 if (!EmitCopy(dst' ref d' ref dL' s - t' s - s0)) return -1;                 lit = s;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3)             {                 var v = src[s] | ((uint)src[s + 1]) << 8 | ((uint)src[s + 2]) << 16 | ((uint)src[s + 3]) << 24;             nextfast:                 var h = (v * 0x1e35a7bd) >> shift;                 var t = table[h];                 table[h] = s;                 if (t < 0 || s - t >= MaxOffset || !Equal4(src' t' s))                 {                     s++;                     sL--;                     if (sL>3)                     {                         v = (v >> 8) | ((uint)src[s + 3]) << 24;                         goto nextfast;                     }                     break;                 }                 if (lit != s)                 {                     if (!EmitLiteral(dst' ref d' ref dL' src' lit' s - lit)) return -1;                 }                 var s0 = s;                 s += 4;                 sL -= 4;                 t += 4;                 while (sL > 0 && src[s] == src[t])                 {                     s++;                     sL--;                     t++;                 }                 if (!EmitCopy(dst' ref d' ref dL' s - t' s - s0)) return -1;                 lit = s;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3)             {                 var v = src[s] | ((uint)src[s + 1]) << 8 | ((uint)src[s + 2]) << 16 | ((uint)src[s + 3]) << 24;             nextfast:                 var h = (v * 0x1e35a7bd) >> shift;                 var t = table[h];                 table[h] = s;                 if (t < 0 || s - t >= MaxOffset || !Equal4(src' t' s))                 {                     s++;                     sL--;                     if (sL>3)                     {                         v = (v >> 8) | ((uint)src[s + 3]) << 24;                         goto nextfast;                     }                     break;                 }                 if (lit != s)                 {                     if (!EmitLiteral(dst' ref d' ref dL' src' lit' s - lit)) return -1;                 }                 var s0 = s;                 s += 4;                 sL -= 4;                 t += 4;                 while (sL > 0 && src[s] == src[t])                 {                     s++;                     sL--;                     t++;                 }                 if (!EmitCopy(dst' ref d' ref dL' s - t' s - s0)) return -1;                 lit = s;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3)             {                 var v = src[s] | ((uint)src[s + 1]) << 8 | ((uint)src[s + 2]) << 16 | ((uint)src[s + 3]) << 24;             nextfast:                 var h = (v * 0x1e35a7bd) >> shift;                 var t = table[h];                 table[h] = s;                 if (t < 0 || s - t >= MaxOffset || !Equal4(src' t' s))                 {                     s++;                     sL--;                     if (sL>3)                     {                         v = (v >> 8) | ((uint)src[s + 3]) << 24;                         goto nextfast;                     }                     break;                 }                 if (lit != s)                 {                     if (!EmitLiteral(dst' ref d' ref dL' src' lit' s - lit)) return -1;                 }                 var s0 = s;                 s += 4;                 sL -= 4;                 t += 4;                 while (sL > 0 && src[s] == src[t])                 {                     s++;                     sL--;                     t++;                 }                 if (!EmitCopy(dst' ref d' ref dL' s - t' s - s0)) return -1;                 lit = s;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3)             {                 var v = src[s] | ((uint)src[s + 1]) << 8 | ((uint)src[s + 2]) << 16 | ((uint)src[s + 3]) << 24;             nextfast:                 var h = (v * 0x1e35a7bd) >> shift;                 var t = table[h];                 table[h] = s;                 if (t < 0 || s - t >= MaxOffset || !Equal4(src' t' s))                 {                     s++;                     sL--;                     if (sL>3)                     {                         v = (v >> 8) | ((uint)src[s + 3]) << 24;                         goto nextfast;                     }                     break;                 }                 if (lit != s)                 {                     if (!EmitLiteral(dst' ref d' ref dL' src' lit' s - lit)) return -1;                 }                 var s0 = s;                 s += 4;                 sL -= 4;                 t += 4;                 while (sL > 0 && src[s] == src[t])                 {                     s++;                     sL--;                     t++;                 }                 if (!EmitCopy(dst' ref d' ref dL' s - t' s - s0)) return -1;                 lit = s;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3)             {                 var v = src[s] | ((uint)src[s + 1]) << 8 | ((uint)src[s + 2]) << 16 | ((uint)src[s + 3]) << 24;             nextfast:                 var h = (v * 0x1e35a7bd) >> shift;                 var t = table[h];                 table[h] = s;                 if (t < 0 || s - t >= MaxOffset || !Equal4(src' t' s))                 {                     s++;                     sL--;                     if (sL>3)                     {                         v = (v >> 8) | ((uint)src[s + 3]) << 24;                         goto nextfast;                     }                     break;                 }                 if (lit != s)                 {                     if (!EmitLiteral(dst' ref d' ref dL' src' lit' s - lit)) return -1;                 }                 var s0 = s;                 s += 4;                 sL -= 4;                 t += 4;                 while (sL > 0 && src[s] == src[t])                 {                     s++;                     sL--;                     t++;                 }                 if (!EmitCopy(dst' ref d' ref dL' s - t' s - s0)) return -1;                 lit = s;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3)             {                 var v = src[s] | ((uint)src[s + 1]) << 8 | ((uint)src[s + 2]) << 16 | ((uint)src[s + 3]) << 24;             nextfast:                 var h = (v * 0x1e35a7bd) >> shift;                 var t = table[h];                 table[h] = s;                 if (t < 0 || s - t >= MaxOffset || !Equal4(src' t' s))                 {                     s++;                     sL--;                     if (sL>3)                     {                         v = (v >> 8) | ((uint)src[s + 3]) << 24;                         goto nextfast;                     }                     break;                 }                 if (lit != s)                 {                     if (!EmitLiteral(dst' ref d' ref dL' src' lit' s - lit)) return -1;                 }                 var s0 = s;                 s += 4;                 sL -= 4;                 t += 4;                 while (sL > 0 && src[s] == src[t])                 {                     s++;                     sL--;                     t++;                 }                 if (!EmitCopy(dst' ref d' ref dL' s - t' s - s0)) return -1;                 lit = s;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3)             {                 var v = src[s] | ((uint)src[s + 1]) << 8 | ((uint)src[s + 2]) << 16 | ((uint)src[s + 3]) << 24;             nextfast:                 var h = (v * 0x1e35a7bd) >> shift;                 var t = table[h];                 table[h] = s;                 if (t < 0 || s - t >= MaxOffset || !Equal4(src' t' s))                 {                     s++;                     sL--;                     if (sL>3)                     {                         v = (v >> 8) | ((uint)src[s + 3]) << 24;                         goto nextfast;                     }                     break;                 }                 if (lit != s)                 {                     if (!EmitLiteral(dst' ref d' ref dL' src' lit' s - lit)) return -1;                 }                 var s0 = s;                 s += 4;                 sL -= 4;                 t += 4;                 while (sL > 0 && src[s] == src[t])                 {                     s++;                     sL--;                     t++;                 }                 if (!EmitCopy(dst' ref d' ref dL' s - t' s - s0)) return -1;                 lit = s;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3)             {                 var v = src[s] | ((uint)src[s + 1]) << 8 | ((uint)src[s + 2]) << 16 | ((uint)src[s + 3]) << 24;             nextfast:                 var h = (v * 0x1e35a7bd) >> shift;                 var t = table[h];                 table[h] = s;                 if (t < 0 || s - t >= MaxOffset || !Equal4(src' t' s))                 {                     s++;                     sL--;                     if (sL>3)                     {                         v = (v >> 8) | ((uint)src[s + 3]) << 24;                         goto nextfast;                     }                     break;                 }                 if (lit != s)                 {                     if (!EmitLiteral(dst' ref d' ref dL' src' lit' s - lit)) return -1;                 }                 var s0 = s;                 s += 4;                 sL -= 4;                 t += 4;                 while (sL > 0 && src[s] == src[t])                 {                     s++;                     sL--;                     t++;                 }                 if (!EmitCopy(dst' ref d' ref dL' s - t' s - s0)) return -1;                 lit = s;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3)             {                 var v = src[s] | ((uint)src[s + 1]) << 8 | ((uint)src[s + 2]) << 16 | ((uint)src[s + 3]) << 24;             nextfast:                 var h = (v * 0x1e35a7bd) >> shift;                 var t = table[h];                 table[h] = s;                 if (t < 0 || s - t >= MaxOffset || !Equal4(src' t' s))                 {                     s++;                     sL--;                     if (sL>3)                     {                         v = (v >> 8) | ((uint)src[s + 3]) << 24;                         goto nextfast;                     }                     break;                 }                 if (lit != s)                 {                     if (!EmitLiteral(dst' ref d' ref dL' src' lit' s - lit)) return -1;                 }                 var s0 = s;                 s += 4;                 sL -= 4;                 t += 4;                 while (sL > 0 && src[s] == src[t])                 {                     s++;                     sL--;                     t++;                 }                 if (!EmitCopy(dst' ref d' ref dL' s - t' s - s0)) return -1;                 lit = s;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3)             {                 var v = src[s] | ((uint)src[s + 1]) << 8 | ((uint)src[s + 2]) << 16 | ((uint)src[s + 3]) << 24;             nextfast:                 var h = (v * 0x1e35a7bd) >> shift;                 var t = table[h];                 table[h] = s;                 if (t < 0 || s - t >= MaxOffset || !Equal4(src' t' s))                 {                     s++;                     sL--;                     if (sL>3)                     {                         v = (v >> 8) | ((uint)src[s + 3]) << 24;                         goto nextfast;                     }                     break;                 }                 if (lit != s)                 {                     if (!EmitLiteral(dst' ref d' ref dL' src' lit' s - lit)) return -1;                 }                 var s0 = s;                 s += 4;                 sL -= 4;                 t += 4;                 while (sL > 0 && src[s] == src[t])                 {                     s++;                     sL--;                     t++;                 }                 if (!EmitCopy(dst' ref d' ref dL' s - t' s - s0)) return -1;                 lit = s;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3)             {                 var v = src[s] | ((uint)src[s + 1]) << 8 | ((uint)src[s + 2]) << 16 | ((uint)src[s + 3]) << 24;             nextfast:                 var h = (v * 0x1e35a7bd) >> shift;                 var t = table[h];                 table[h] = s;                 if (t < 0 || s - t >= MaxOffset || !Equal4(src' t' s))                 {                     s++;                     sL--;                     if (sL>3)                     {                         v = (v >> 8) | ((uint)src[s + 3]) << 24;                         goto nextfast;                     }                     break;                 }                 if (lit != s)                 {                     if (!EmitLiteral(dst' ref d' ref dL' src' lit' s - lit)) return -1;                 }                 var s0 = s;                 s += 4;                 sL -= 4;                 t += 4;                 while (sL > 0 && src[s] == src[t])                 {                     s++;                     sL--;                     t++;                 }                 if (!EmitCopy(dst' ref d' ref dL' s - t' s - s0)) return -1;                 lit = s;             }
Magic Number,BTDB.SnappyCompression,SnappyCompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,TryCompress,The following statement contains a magic number: var compressed = ByteBuffer.NewAsync(new byte[data.Length * (long)maxSizeInPercent / 100]);
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: var result = (uint)(b & 127);
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: if (b < 128) goto done;
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint)(b & 127) << 7);
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint)(b & 127) << 7);
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: if (b < 128) goto done;
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint)(b & 127) << 14);
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint)(b & 127) << 14);
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: if (b < 128) goto done;
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint)(b & 127) << 21);
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint)(b & 127) << 21);
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: if (b < 128) goto done;
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint)(b & 127) << 28);
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint)(b & 127) << 28);
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: if (b >= 16) goto error;
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0)             {                 var b = src[s];                 s++;                 sL--;                 switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }                 var end = d + len;                 if (o > d || len > dL)                     return false;                 for (; d < end; d++)                 {                     dst[d] = dst[d - o];                 }                 dL -= len;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt8Ordered,The following statement contains a magic number: return (sbyte)(Buf[Pos++] - 128);
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadVInt64,The following statement contains a magic number: if (Pos + l <= End)             {                 res = PackUnpack.UnpackVInt(Buf' ref Pos);             }             else             {                 res = (Buf[Pos] >= 0x80) ? 0 : -1;                 if (l < 8) res <<= 8 - l;                 res += Buf[Pos] & (0xff >> l);                 do                 {                     Pos++;                     res <<= 8;                     NeedOneByteInBuffer();                     res += Buf[Pos];                     l--;                 } while (l > 1);                 Pos++;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadVInt64,The following statement contains a magic number: if (Pos + l <= End)             {                 res = PackUnpack.UnpackVInt(Buf' ref Pos);             }             else             {                 res = (Buf[Pos] >= 0x80) ? 0 : -1;                 if (l < 8) res <<= 8 - l;                 res += Buf[Pos] & (0xff >> l);                 do                 {                     Pos++;                     res <<= 8;                     NeedOneByteInBuffer();                     res += Buf[Pos];                     l--;                 } while (l > 1);                 Pos++;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadVInt64,The following statement contains a magic number: if (Pos + l <= End)             {                 res = PackUnpack.UnpackVInt(Buf' ref Pos);             }             else             {                 res = (Buf[Pos] >= 0x80) ? 0 : -1;                 if (l < 8) res <<= 8 - l;                 res += Buf[Pos] & (0xff >> l);                 do                 {                     Pos++;                     res <<= 8;                     NeedOneByteInBuffer();                     res += Buf[Pos];                     l--;                 } while (l > 1);                 Pos++;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadVUInt64,The following statement contains a magic number: if (Pos + l <= End)             {                 res = PackUnpack.UnpackVUInt(Buf' ref Pos);             }             else             {                 res = (ulong)(Buf[Pos] & (0xff >> l));                 do                 {                     Pos++;                     res <<= 8;                     NeedOneByteInBuffer();                     res += Buf[Pos];                     l--;                 } while (l > 1);                 Pos++;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt64,The following statement contains a magic number: if (Pos + 8 <= End)             {                 res = PackUnpack.UnpackInt64BE(Buf' Pos);                 Pos += 8;             }             else             {                 for (int i = 0; i < 8; i++)                 {                     NeedOneByteInBuffer();                     res <<= 8;                     res += Buf[Pos];                     Pos++;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt64,The following statement contains a magic number: if (Pos + 8 <= End)             {                 res = PackUnpack.UnpackInt64BE(Buf' Pos);                 Pos += 8;             }             else             {                 for (int i = 0; i < 8; i++)                 {                     NeedOneByteInBuffer();                     res <<= 8;                     res += Buf[Pos];                     Pos++;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt64,The following statement contains a magic number: if (Pos + 8 <= End)             {                 res = PackUnpack.UnpackInt64BE(Buf' Pos);                 Pos += 8;             }             else             {                 for (int i = 0; i < 8; i++)                 {                     NeedOneByteInBuffer();                     res <<= 8;                     res += Buf[Pos];                     Pos++;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt64,The following statement contains a magic number: if (Pos + 8 <= End)             {                 res = PackUnpack.UnpackInt64BE(Buf' Pos);                 Pos += 8;             }             else             {                 for (int i = 0; i < 8; i++)                 {                     NeedOneByteInBuffer();                     res <<= 8;                     res += Buf[Pos];                     Pos++;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipInt64,The following statement contains a magic number: if (Pos + 8 <= End)             {                 Pos += 8;             }             else             {                 for (int i = 0; i < 8; i++)                 {                     NeedOneByteInBuffer();                     Pos++;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipInt64,The following statement contains a magic number: if (Pos + 8 <= End)             {                 Pos += 8;             }             else             {                 for (int i = 0; i < 8; i++)                 {                     NeedOneByteInBuffer();                     Pos++;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipInt64,The following statement contains a magic number: if (Pos + 8 <= End)             {                 Pos += 8;             }             else             {                 for (int i = 0; i < 8; i++)                 {                     NeedOneByteInBuffer();                     Pos++;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32,The following statement contains a magic number: if (Pos + 4 <= End)             {                 res = PackUnpack.UnpackInt32BE(Buf' Pos);                 Pos += 4;             }             else             {                 for (var i = 0; i < 4; i++)                 {                     NeedOneByteInBuffer();                     res <<= 8;                     res += Buf[Pos];                     Pos++;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32,The following statement contains a magic number: if (Pos + 4 <= End)             {                 res = PackUnpack.UnpackInt32BE(Buf' Pos);                 Pos += 4;             }             else             {                 for (var i = 0; i < 4; i++)                 {                     NeedOneByteInBuffer();                     res <<= 8;                     res += Buf[Pos];                     Pos++;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32,The following statement contains a magic number: if (Pos + 4 <= End)             {                 res = PackUnpack.UnpackInt32BE(Buf' Pos);                 Pos += 4;             }             else             {                 for (var i = 0; i < 4; i++)                 {                     NeedOneByteInBuffer();                     res <<= 8;                     res += Buf[Pos];                     Pos++;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32,The following statement contains a magic number: if (Pos + 4 <= End)             {                 res = PackUnpack.UnpackInt32BE(Buf' Pos);                 Pos += 4;             }             else             {                 for (var i = 0; i < 4; i++)                 {                     NeedOneByteInBuffer();                     res <<= 8;                     res += Buf[Pos];                     Pos++;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32LE,The following statement contains a magic number: if (Pos + 4 <= End)             {                 res = PackUnpack.UnpackInt32LE(Buf' Pos);                 Pos += 4;             }             else             {                 for (var rot = 0; rot < 32; rot += 8)                 {                     NeedOneByteInBuffer();                     res += Buf[Pos] << rot;                     Pos++;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32LE,The following statement contains a magic number: if (Pos + 4 <= End)             {                 res = PackUnpack.UnpackInt32LE(Buf' Pos);                 Pos += 4;             }             else             {                 for (var rot = 0; rot < 32; rot += 8)                 {                     NeedOneByteInBuffer();                     res += Buf[Pos] << rot;                     Pos++;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32LE,The following statement contains a magic number: if (Pos + 4 <= End)             {                 res = PackUnpack.UnpackInt32LE(Buf' Pos);                 Pos += 4;             }             else             {                 for (var rot = 0; rot < 32; rot += 8)                 {                     NeedOneByteInBuffer();                     res += Buf[Pos] << rot;                     Pos++;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32LE,The following statement contains a magic number: if (Pos + 4 <= End)             {                 res = PackUnpack.UnpackInt32LE(Buf' Pos);                 Pos += 4;             }             else             {                 for (var rot = 0; rot < 32; rot += 8)                 {                     NeedOneByteInBuffer();                     res += Buf[Pos] << rot;                     Pos++;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipInt32,The following statement contains a magic number: if (Pos + 4 <= End)             {                 Pos += 4;             }             else             {                 for (int i = 0; i < 4; i++)                 {                     NeedOneByteInBuffer();                     Pos++;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipInt32,The following statement contains a magic number: if (Pos + 4 <= End)             {                 Pos += 4;             }             else             {                 for (int i = 0; i < 4; i++)                 {                     NeedOneByteInBuffer();                     Pos++;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipInt32,The following statement contains a magic number: if (Pos + 4 <= End)             {                 Pos += 4;             }             else             {                 for (int i = 0; i < 4; i++)                 {                     NeedOneByteInBuffer();                     Pos++;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReserveCharBuf,The following statement contains a magic number: if (CharBuf == null)             {                 CharBuf = new char[size];             }             else             {                 if (size <= CharBuf.Length) return;                 var newLen = Math.Max((int)Math.Min((long)CharBuf.Length * 2' 2147483591 / 2)' size);                 Array.Resize(ref CharBuf' newLen);             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReserveCharBuf,The following statement contains a magic number: if (CharBuf == null)             {                 CharBuf = new char[size];             }             else             {                 if (size <= CharBuf.Length) return;                 var newLen = Math.Max((int)Math.Min((long)CharBuf.Length * 2' 2147483591 / 2)' size);                 Array.Resize(ref CharBuf' newLen);             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReserveCharBuf,The following statement contains a magic number: if (CharBuf == null)             {                 CharBuf = new char[size];             }             else             {                 if (size <= CharBuf.Length) return;                 var newLen = Math.Max((int)Math.Min((long)CharBuf.Length * 2' 2147483591 / 2)' size);                 Array.Resize(ref CharBuf' newLen);             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadString,The following statement contains a magic number: while (i < l)             {                 if (Pos != End)                 {                     var b = Buf[Pos];                     if (b < 0x80)                     {                         res[i] = (char)b;                         i++;                         Pos++;                         continue;                     }                 }                 var c = ReadVUInt64();                 if (c > 0xffff)                 {                     if (c > 0x10ffff) throw new InvalidDataException($"Reading String unicode value overflowed with {c}");                     c -= 0x10000;                     res[i] = (char)((c >> 10) + 0xD800);                     i++;                     res[i] = (char)((c & 0x3FF) + 0xDC00);                     i++;                 }                 else                 {                     res[i] = (char)c;                     i++;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadStringOrdered,The following statement contains a magic number: while (true)             {                 var c = ReadVUInt32();                 if (c == 0) break;                 c--;                 if (c > 0xffff)                 {                     if (c > 0x10ffff)                     {                         if (len == 0 && c == 0x110000) return null;                         throw new InvalidDataException($"Reading String unicode value overflowed with {c}");                     }                     c -= 0x10000;                     ReserveCharBuf(len + 2);                     CharBuf[len++] = (char)((c >> 10) + 0xD800);                     CharBuf[len++] = (char)((c & 0x3FF) + 0xDC00);                 }                 else                 {                     ReserveCharBuf(len + 1);                     CharBuf[len++] = (char)c;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadStringOrdered,The following statement contains a magic number: while (true)             {                 var c = ReadVUInt32();                 if (c == 0) break;                 c--;                 if (c > 0xffff)                 {                     if (c > 0x10ffff)                     {                         if (len == 0 && c == 0x110000) return null;                         throw new InvalidDataException($"Reading String unicode value overflowed with {c}");                     }                     c -= 0x10000;                     ReserveCharBuf(len + 2);                     CharBuf[len++] = (char)((c >> 10) + 0xD800);                     CharBuf[len++] = (char)((c & 0x3FF) + 0xDC00);                 }                 else                 {                     ReserveCharBuf(len + 1);                     CharBuf[len++] = (char)c;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipString,The following statement contains a magic number: while (i < l)             {                 var c = ReadVUInt64();                 if (c > 0xffff)                 {                     if (c > 0x10ffff) throw new InvalidDataException(                         $"Skipping String unicode value overflowed with {c}");                     i += 2;                 }                 else                 {                     i++;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,Get16Bytes,The following statement contains a magic number: return Bytes16 ?? (Bytes16 = new byte[16]);
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadGuid,The following statement contains a magic number: ReadBlock(res' 0' 16);
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipGuid,The following statement contains a magic number: SkipBlock(16);
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following statement contains a magic number: switch (header >> 5 & 3)             {                 case 0:                     break;                 case 1:                     first = ReadVUInt64();                     break;                 case 2:                     second = ReadVUInt32();                     first = (ulong)ReadInt64();                     break;                 case 3:                     second = (uint)ReadInt32();                     first = (ulong)ReadInt64();                     break;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following statement contains a magic number: switch (header >> 5 & 3)             {                 case 0:                     break;                 case 1:                     first = ReadVUInt64();                     break;                 case 2:                     second = ReadVUInt32();                     first = (ulong)ReadInt64();                     break;                 case 3:                     second = (uint)ReadInt32();                     first = (ulong)ReadInt64();                     break;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following statement contains a magic number: switch (header >> 5 & 3)             {                 case 0:                     break;                 case 1:                     first = ReadVUInt64();                     break;                 case 2:                     second = ReadVUInt32();                     first = (ulong)ReadInt64();                     break;                 case 3:                     second = (uint)ReadInt32();                     first = (ulong)ReadInt64();                     break;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following statement contains a magic number: switch (header >> 5 & 3)             {                 case 0:                     break;                 case 1:                     first = ReadVUInt64();                     break;                 case 2:                     second = ReadVUInt32();                     first = (ulong)ReadInt64();                     break;                 case 3:                     second = (uint)ReadInt32();                     first = (ulong)ReadInt64();                     break;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following statement contains a magic number: var res = new decimal((int)first' (int)(first >> 32)' (int)second' (header & 128) != 0' (byte)(header & 31));
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following statement contains a magic number: var res = new decimal((int)first' (int)(first >> 32)' (int)second' (header & 128) != 0' (byte)(header & 31));
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following statement contains a magic number: var res = new decimal((int)first' (int)(first >> 32)' (int)second' (header & 128) != 0' (byte)(header & 31));
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipDecimal,The following statement contains a magic number: switch (header >> 5 & 3)             {                 case 0:                     break;                 case 1:                     SkipVUInt64();                     break;                 case 2:                     SkipVUInt32();                     SkipInt64();                     break;                 case 3:                     SkipInt32();                     SkipInt64();                     break;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipDecimal,The following statement contains a magic number: switch (header >> 5 & 3)             {                 case 0:                     break;                 case 1:                     SkipVUInt64();                     break;                 case 2:                     SkipVUInt32();                     SkipInt64();                     break;                 case 3:                     SkipInt32();                     SkipInt64();                     break;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipDecimal,The following statement contains a magic number: switch (header >> 5 & 3)             {                 case 0:                     break;                 case 1:                     SkipVUInt64();                     break;                 case 2:                     SkipVUInt32();                     SkipInt64();                     break;                 case 3:                     SkipInt32();                     SkipInt64();                     break;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipDecimal,The following statement contains a magic number: switch (header >> 5 & 3)             {                 case 0:                     break;                 case 1:                     SkipVUInt64();                     break;                 case 2:                     SkipVUInt32();                     SkipInt64();                     break;                 case 3:                     SkipInt32();                     SkipInt64();                     break;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadIPAddress,The following statement contains a magic number: switch (ReadUInt8())             {                 case 0:                     return new IPAddress((uint)ReadInt32LE());                 case 1:                     {                         var ip6Bytes = Get16Bytes();                         ReadBlock(ip6Bytes);                         return new IPAddress(ip6Bytes);                     }                 case 2:                     {                         var ip6Bytes = Get16Bytes();                         ReadBlock(ip6Bytes);                         var scopeid = (long)ReadVUInt64();                         return new IPAddress(ip6Bytes' scopeid);                     }                 default: throw new InvalidDataException("Unknown type of IPAddress");             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipIPAddress,The following statement contains a magic number: switch (ReadUInt8())             {                 case 0:                     SkipInt32();                     return;                 case 1:                     SkipBlock(16);                     return;                 case 2:                     SkipBlock(16);                     SkipVUInt64();                     return;                 default: throw new InvalidDataException("Unknown type of IPAddress");             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipIPAddress,The following statement contains a magic number: switch (ReadUInt8())             {                 case 0:                     SkipInt32();                     return;                 case 1:                     SkipBlock(16);                     return;                 case 2:                     SkipBlock(16);                     SkipVUInt64();                     return;                 default: throw new InvalidDataException("Unknown type of IPAddress");             }
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipIPAddress,The following statement contains a magic number: switch (ReadUInt8())             {                 case 0:                     SkipInt32();                     return;                 case 1:                     SkipBlock(16);                     return;                 case 2:                     SkipBlock(16);                     SkipVUInt64();                     return;                 default: throw new InvalidDataException("Unknown type of IPAddress");             }
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt8Ordered,The following statement contains a magic number: Buf[Pos++] = (byte)(value + 128);
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt64,The following statement contains a magic number: if (Pos + 8 > End)             {                 FlushBuffer();                 if (Pos + 8 > End)                 {                     var b = new byte[8];                     PackUnpack.PackInt64BE(b' 0' value);                     WriteBlock(b);                     return;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt64,The following statement contains a magic number: if (Pos + 8 > End)             {                 FlushBuffer();                 if (Pos + 8 > End)                 {                     var b = new byte[8];                     PackUnpack.PackInt64BE(b' 0' value);                     WriteBlock(b);                     return;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt64,The following statement contains a magic number: if (Pos + 8 > End)             {                 FlushBuffer();                 if (Pos + 8 > End)                 {                     var b = new byte[8];                     PackUnpack.PackInt64BE(b' 0' value);                     WriteBlock(b);                     return;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt64,The following statement contains a magic number: Pos += 8;
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32,The following statement contains a magic number: if (Pos + 4 > End)             {                 FlushBuffer();                 if (Pos + 4 > End)                 {                     var b = new byte[4];                     PackUnpack.PackInt32BE(b' 0' value);                     WriteBlock(b);                     return;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32,The following statement contains a magic number: if (Pos + 4 > End)             {                 FlushBuffer();                 if (Pos + 4 > End)                 {                     var b = new byte[4];                     PackUnpack.PackInt32BE(b' 0' value);                     WriteBlock(b);                     return;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32,The following statement contains a magic number: if (Pos + 4 > End)             {                 FlushBuffer();                 if (Pos + 4 > End)                 {                     var b = new byte[4];                     PackUnpack.PackInt32BE(b' 0' value);                     WriteBlock(b);                     return;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32,The following statement contains a magic number: Pos += 4;
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32LE,The following statement contains a magic number: if (Pos + 4 > End)             {                 FlushBuffer();                 if (Pos + 4 > End)                 {                     var b = new byte[4];                     PackUnpack.PackInt32LE(b' 0' value);                     WriteBlock(b);                     return;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32LE,The following statement contains a magic number: if (Pos + 4 > End)             {                 FlushBuffer();                 if (Pos + 4 > End)                 {                     var b = new byte[4];                     PackUnpack.PackInt32LE(b' 0' value);                     WriteBlock(b);                     return;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32LE,The following statement contains a magic number: if (Pos + 4 > End)             {                 FlushBuffer();                 if (Pos + 4 > End)                 {                     var b = new byte[4];                     PackUnpack.PackInt32LE(b' 0' value);                     WriteBlock(b);                     return;                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32LE,The following statement contains a magic number: Pos += 4;
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteStringOrdered,The following statement contains a magic number: while (i < l)             {                 var c = value[i];                 if (char.IsHighSurrogate(c) && i + 1 < l)                 {                     var c2 = value[i + 1];                     if (char.IsLowSurrogate(c2))                     {                         WriteVUInt32((uint)((c - 0xD800) * 0x400 + (c2 - 0xDC00) + 0x10000) + 1);                         i += 2;                         continue;                     }                 }                 WriteVUInt32((uint)c + 1);                 i++;             }
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteGuid,The following statement contains a magic number: WriteBlock(ptr' 16);
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: var header = (byte)((ints[3] >> 16) & 31);
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: var header = (byte)((ints[3] >> 16) & 31);
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: var header = (byte)((ints[3] >> 16) & 31);
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (ints[3] < 0) header |= 128;
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (ints[3] < 0) header |= 128;
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: var first = (uint)ints[0] + ((ulong)ints[1] << 32);
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (ints[2] == 0)             {                 if (first == 0)                 {                     WriteUInt8(header);                 }                 else                 {                     header |= 32;                     WriteUInt8(header);                     WriteVUInt64(first);                 }             }             else             {                 if ((uint)ints[2] < 0x10000000)                 {                     header |= 64;                     WriteUInt8(header);                     WriteVUInt32((uint)ints[2]);                     WriteInt64((long)first);                 }                 else                 {                     header |= 64 | 32;                     WriteUInt8(header);                     WriteInt32(ints[2]);                     WriteInt64((long)first);                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (ints[2] == 0)             {                 if (first == 0)                 {                     WriteUInt8(header);                 }                 else                 {                     header |= 32;                     WriteUInt8(header);                     WriteVUInt64(first);                 }             }             else             {                 if ((uint)ints[2] < 0x10000000)                 {                     header |= 64;                     WriteUInt8(header);                     WriteVUInt32((uint)ints[2]);                     WriteInt64((long)first);                 }                 else                 {                     header |= 64 | 32;                     WriteUInt8(header);                     WriteInt32(ints[2]);                     WriteInt64((long)first);                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (ints[2] == 0)             {                 if (first == 0)                 {                     WriteUInt8(header);                 }                 else                 {                     header |= 32;                     WriteUInt8(header);                     WriteVUInt64(first);                 }             }             else             {                 if ((uint)ints[2] < 0x10000000)                 {                     header |= 64;                     WriteUInt8(header);                     WriteVUInt32((uint)ints[2]);                     WriteInt64((long)first);                 }                 else                 {                     header |= 64 | 32;                     WriteUInt8(header);                     WriteInt32(ints[2]);                     WriteInt64((long)first);                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (ints[2] == 0)             {                 if (first == 0)                 {                     WriteUInt8(header);                 }                 else                 {                     header |= 32;                     WriteUInt8(header);                     WriteVUInt64(first);                 }             }             else             {                 if ((uint)ints[2] < 0x10000000)                 {                     header |= 64;                     WriteUInt8(header);                     WriteVUInt32((uint)ints[2]);                     WriteInt64((long)first);                 }                 else                 {                     header |= 64 | 32;                     WriteUInt8(header);                     WriteInt32(ints[2]);                     WriteInt64((long)first);                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (ints[2] == 0)             {                 if (first == 0)                 {                     WriteUInt8(header);                 }                 else                 {                     header |= 32;                     WriteUInt8(header);                     WriteVUInt64(first);                 }             }             else             {                 if ((uint)ints[2] < 0x10000000)                 {                     header |= 64;                     WriteUInt8(header);                     WriteVUInt32((uint)ints[2]);                     WriteInt64((long)first);                 }                 else                 {                     header |= 64 | 32;                     WriteUInt8(header);                     WriteInt32(ints[2]);                     WriteInt64((long)first);                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (ints[2] == 0)             {                 if (first == 0)                 {                     WriteUInt8(header);                 }                 else                 {                     header |= 32;                     WriteUInt8(header);                     WriteVUInt64(first);                 }             }             else             {                 if ((uint)ints[2] < 0x10000000)                 {                     header |= 64;                     WriteUInt8(header);                     WriteVUInt32((uint)ints[2]);                     WriteInt64((long)first);                 }                 else                 {                     header |= 64 | 32;                     WriteUInt8(header);                     WriteInt32(ints[2]);                     WriteInt64((long)first);                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (ints[2] == 0)             {                 if (first == 0)                 {                     WriteUInt8(header);                 }                 else                 {                     header |= 32;                     WriteUInt8(header);                     WriteVUInt64(first);                 }             }             else             {                 if ((uint)ints[2] < 0x10000000)                 {                     header |= 64;                     WriteUInt8(header);                     WriteVUInt32((uint)ints[2]);                     WriteInt64((long)first);                 }                 else                 {                     header |= 64 | 32;                     WriteUInt8(header);                     WriteInt32(ints[2]);                     WriteInt64((long)first);                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (ints[2] == 0)             {                 if (first == 0)                 {                     WriteUInt8(header);                 }                 else                 {                     header |= 32;                     WriteUInt8(header);                     WriteVUInt64(first);                 }             }             else             {                 if ((uint)ints[2] < 0x10000000)                 {                     header |= 64;                     WriteUInt8(header);                     WriteVUInt32((uint)ints[2]);                     WriteInt64((long)first);                 }                 else                 {                     header |= 64 | 32;                     WriteUInt8(header);                     WriteInt32(ints[2]);                     WriteInt64((long)first);                 }             }
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteIPAddress,The following statement contains a magic number: if (value.AddressFamily == AddressFamily.InterNetworkV6)             {                 if (value.ScopeId != 0)                 {                     WriteUInt8(2);                     WriteBlock(value.GetAddressBytes());                     WriteVUInt64((ulong)value.ScopeId);                 }                 else                 {                     WriteUInt8(1);                     WriteBlock(value.GetAddressBytes());                 }             }             else             {                 WriteUInt8(0); #pragma warning disable 612'618                 WriteInt32LE((int)value.Address); #pragma warning restore 612'618             }
Magic Number,BTDB.StreamLayer,ByteBufferWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\ByteBufferWriter.cs,ByteBufferWriter,The following statement contains a magic number: Buf = new byte[32];
Magic Number,BTDB.StreamLayer,ByteBufferWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\ByteBufferWriter.cs,Reset,The following statement contains a magic number: Buf = new byte[32];
Magic Number,BTDB.StreamLayer,ByteBufferWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\ByteBufferWriter.cs,FlushBuffer,The following statement contains a magic number: var newLen = Math.Max((int)Math.Min((long)End * 2' 2147483591)' 128);
Magic Number,BTDB.StreamLayer,ByteBufferWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\ByteBufferWriter.cs,FlushBuffer,The following statement contains a magic number: var newLen = Math.Max((int)Math.Min((long)End * 2' 2147483591)' 128);
Magic Number,BTDB.StreamLayer,ByteBufferWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\ByteBufferWriter.cs,FlushBuffer,The following statement contains a magic number: var newLen = Math.Max((int)Math.Min((long)End * 2' 2147483591)' 128);
Magic Number,BTDB.StreamLayer,PositionLessStreamWriter,C:\repos\Bobris_BTDB\BTDB\StreamLayer\PositionLessStreamWriter.cs,PositionLessStreamWriter,The following statement contains a magic number: Buf = new byte[8192];
Magic Number,BTDB.StreamLayer,LoggingPositionLessStream,C:\repos\Bobris_BTDB\BTDB\StreamLayer\LoggingPositionLessStream.cs,Read,The following statement contains a magic number: var sb = new StringBuilder(8 + 16 * 3);
Magic Number,BTDB.StreamLayer,LoggingPositionLessStream,C:\repos\Bobris_BTDB\BTDB\StreamLayer\LoggingPositionLessStream.cs,Read,The following statement contains a magic number: var sb = new StringBuilder(8 + 16 * 3);
Magic Number,BTDB.StreamLayer,LoggingPositionLessStream,C:\repos\Bobris_BTDB\BTDB\StreamLayer\LoggingPositionLessStream.cs,Read,The following statement contains a magic number: var sb = new StringBuilder(8 + 16 * 3);
Magic Number,BTDB.StreamLayer,LoggingPositionLessStream,C:\repos\Bobris_BTDB\BTDB\StreamLayer\LoggingPositionLessStream.cs,Read,The following statement contains a magic number: while (i < res)             {                 if (j == 16)                 {                     Log(sb.ToString());                     sb.Length = 0;                     j = 0;                 }                 if (j == 0)                 {                     sb.AppendFormat("{0:X8}"' pos + (uint) i);                 }                 sb.AppendFormat(" {0:X2}"' data[offset + i]);                 j++;                 i++;             }
Magic Number,BTDB.StreamLayer,LoggingPositionLessStream,C:\repos\Bobris_BTDB\BTDB\StreamLayer\LoggingPositionLessStream.cs,Write,The following statement contains a magic number: var sb = new StringBuilder(8 + 16 * 3);
Magic Number,BTDB.StreamLayer,LoggingPositionLessStream,C:\repos\Bobris_BTDB\BTDB\StreamLayer\LoggingPositionLessStream.cs,Write,The following statement contains a magic number: var sb = new StringBuilder(8 + 16 * 3);
Magic Number,BTDB.StreamLayer,LoggingPositionLessStream,C:\repos\Bobris_BTDB\BTDB\StreamLayer\LoggingPositionLessStream.cs,Write,The following statement contains a magic number: var sb = new StringBuilder(8 + 16 * 3);
Magic Number,BTDB.StreamLayer,LoggingPositionLessStream,C:\repos\Bobris_BTDB\BTDB\StreamLayer\LoggingPositionLessStream.cs,Write,The following statement contains a magic number: while (i < size)             {                 if (j == 16)                 {                     Log(sb.ToString());                     sb.Length = 0;                     j = 0;                 }                 if (j == 0)                 {                     sb.AppendFormat("{0:X8}"' pos + (uint) i);                 }                 sb.AppendFormat(" {0:X2}"' data[offset + i]);                 j++;                 i++;             }
Magic Number,BTDB.StreamLayer,PositionLessStreamProxy,C:\repos\Bobris_BTDB\BTDB\StreamLayer\PositionLessStreamProxy.cs,PositionLessStreamProxy,The following statement contains a magic number: _writeBufSize = 32768;
Duplicate Code,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,IncrementInt64LE,The method contains a code clone-set at the following line numbers (starting from the method definition): ((3' 25)' (7' 29))
Duplicate Code,BTDB.Buffer,PackUnpack,C:\repos\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,IncrementInt64LE,The method contains a code clone-set at the following line numbers (starting from the method definition): ((3' 22)' (11' 30))
Missing Default,BTDB.SnappyCompression,SnappyDecompress,C:\repos\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following switch statement is missing a default case: switch (b & 3)                 {                     case 0:                         len = b >> 2;                         if (len < 60)                         {                             len++;                         }                         else if (len == 60)                         {                             if (sL < 1) return false;                             len = src[s] + 1;                             s++;                             sL--;                         }                         else if (len == 61)                         {                             if (sL < 2) return false;                             len = src[s] + 0x100 * src[s + 1] + 1;                             s += 2;                             sL -= 2;                         }                         else if (len == 62)                         {                             if (sL < 3) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 1;                             s += 3;                             sL -= 3;                         }                         else                         {                             if (sL < 4) return false;                             len = src[s] + 0x100 * src[s + 1] + 0x10000 * src[s + 2] + 0x1000000 * src[s + 3] + 1;                             s += 3;                             sL -= 3;                         }                         if (len <= 0) return false;                         if (len > dL || len > sL) return false;                         Array.Copy(src' s' dst' d' len);                         s += len;                         d += len;                         sL -= len;                         dL -= len;                         continue;                     case 1:                         if (sL < 1) return false;                         len = 4 + ((b >> 2) & 7);                         o = (b & 0xe0) << 3 | src[s];                         s++;                         sL--;                         break;                     case 2:                         if (sL < 2) return false;                         len = 1 + (b >> 2);                         o = src[s] + src[s + 1] * 0x100;                         s += 2;                         sL -= 2;                         break;                     case 3:                         return false;                 }
Missing Default,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following switch statement is missing a default case: switch (header >> 5 & 3)             {                 case 0:                     break;                 case 1:                     first = ReadVUInt64();                     break;                 case 2:                     second = ReadVUInt32();                     first = (ulong)ReadInt64();                     break;                 case 3:                     second = (uint)ReadInt32();                     first = (ulong)ReadInt64();                     break;             }
Missing Default,BTDB.StreamLayer,AbstractBufferedReader,C:\repos\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipDecimal,The following switch statement is missing a default case: switch (header >> 5 & 3)             {                 case 0:                     break;                 case 1:                     SkipVUInt64();                     break;                 case 2:                     SkipVUInt32();                     SkipInt64();                     break;                 case 3:                     SkipInt32();                     SkipInt64();                     break;             }
