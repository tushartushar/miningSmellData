Implementation smell,Namespace,Class,File,Method,Description
Long Method,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The method has 123 lines of code.
Long Method,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The method has 127 lines of code.
Long Method,BTDB.KVDBLayer.BTree,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,CreateOrUpdate,The method has 113 lines of code.
Long Method,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,CreateOrUpdate,The method has 138 lines of code.
Long Method,BTDB.KVDBLayer.BTreeMem,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,CreateOrUpdate,The method has 113 lines of code.
Long Method,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,The method has 128 lines of code.
Long Method,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadTransactionLog,The method has 136 lines of code.
Long Method,BTDB.ODBLayer,ODBIterator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,IterateHandler,The method has 107 lines of code.
Long Method,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The method has 141 lines of code.
Long Method,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The method has 194 lines of code.
Complex Method,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,Cyclomatic complexity of the method is 27
Complex Method,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,Cyclomatic complexity of the method is 9
Complex Method,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,Cyclomatic complexity of the method is 8
Complex Method,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,Cyclomatic complexity of the method is 15
Complex Method,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,Cyclomatic complexity of the method is 14
Complex Method,BTDB.ChunkCache,DiskChunkCache,F:\newReposMay17\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,LoadContent,Cyclomatic complexity of the method is 14
Complex Method,BTDB.ChunkCache,DiskChunkCache,F:\newReposMay17\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,CompactionCore,Cyclomatic complexity of the method is 11
Complex Method,BTDB.EventStore2Layer,EventDeserializer,F:\newReposMay17\Bobris_BTDB\BTDB\EventStore2Layer\EventDeserializer.cs,ProcessMetadataLog,Cyclomatic complexity of the method is 27
Complex Method,BTDB.EventStore2Layer,EventSerializer,F:\newReposMay17\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,ProcessMetadataLog,Cyclomatic complexity of the method is 27
Complex Method,BTDB.EventStore2Layer,EventSerializer,F:\newReposMay17\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,Create,Cyclomatic complexity of the method is 11
Complex Method,BTDB.EventStore2Layer,EventSerializer,F:\newReposMay17\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,MergeTypesByShapeAndStoreNew,Cyclomatic complexity of the method is 11
Complex Method,BTDB.EventStore2Layer,EventSerializer,F:\newReposMay17\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,StoreObject,Cyclomatic complexity of the method is 8
Complex Method,BTDB.EventStoreLayer,AppendingEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,SerializeIntoBuffer,Cyclomatic complexity of the method is 12
Complex Method,BTDB.EventStoreLayer,EnumTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,EnumTypeDescriptor,Cyclomatic complexity of the method is 8
Complex Method,BTDB.EventStoreLayer,EnumTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,UlongValueToStringFlags,Cyclomatic complexity of the method is 8
Complex Method,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,Cyclomatic complexity of the method is 29
Complex Method,BTDB.EventStoreLayer,TypeSerializersMapping,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializersMapping.cs,LoadTypeDescriptors,Cyclomatic complexity of the method is 24
Complex Method,BTDB.EventStoreLayer,TypeSerializersMapping,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializersMapping.cs,StoreNewDescriptors,Cyclomatic complexity of the method is 10
Complex Method,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,Cyclomatic complexity of the method is 34
Complex Method,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldarg,Cyclomatic complexity of the method is 16
Complex Method,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Stloc,Cyclomatic complexity of the method is 18
Complex Method,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldloc,Cyclomatic complexity of the method is 18
Complex Method,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldelem,Cyclomatic complexity of the method is 11
Complex Method,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Stelem,Cyclomatic complexity of the method is 8
Complex Method,BTDB.IL,SourceCodeWriter,F:\newReposMay17\Bobris_BTDB\BTDB\IL\SourceCodeWriter.cs,StartMethod,Cyclomatic complexity of the method is 17
Complex Method,BTDB.IOC,BuildContext,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\BuildContext.cs,ResolveNeedBy,Cyclomatic complexity of the method is 11
Complex Method,BTDB.IOC,GenerationContext,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\GenerationContext.cs,PushToILStack,Cyclomatic complexity of the method is 9
Complex Method,BTDB.IOC,GenerationContext,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\GenerationContext.cs,GatherNeeds,Cyclomatic complexity of the method is 9
Complex Method,BTDB.IOC,MultiRegistration,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\MultiRegistration.cs,Register,Cyclomatic complexity of the method is 9
Complex Method,BTDB.IOC,SingleRegistration,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\SingleRegistration.cs,Register,Cyclomatic complexity of the method is 10
Complex Method,BTDB.KVDBLayer.BTree,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,CreateOrUpdate,Cyclomatic complexity of the method is 12
Complex Method,BTDB.KVDBLayer.BTree,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,EraseRange,Cyclomatic complexity of the method is 16
Complex Method,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,CreateOrUpdate,Cyclomatic complexity of the method is 8
Complex Method,BTDB.KVDBLayer.BTreeMem,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,CreateOrUpdate,Cyclomatic complexity of the method is 12
Complex Method,BTDB.KVDBLayer.BTreeMem,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,EraseRange,Cyclomatic complexity of the method is 16
Complex Method,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,Cyclomatic complexity of the method is 8
Complex Method,BTDB.KVDBLayer,FileCollectionWithFileInfos,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\FileCollectionWithFileInfos.cs,LoadInfoAboutFiles,Cyclomatic complexity of the method is 31
Complex Method,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadInfoAboutFiles,Cyclomatic complexity of the method is 10
Complex Method,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadTransactionLog,Cyclomatic complexity of the method is 46
Complex Method,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,Cyclomatic complexity of the method is 34
Complex Method,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,WriteCreateOrUpdateCommand,Cyclomatic complexity of the method is 8
Complex Method,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,Cyclomatic complexity of the method is 26
Complex Method,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,Cyclomatic complexity of the method is 17
Complex Method,BTDB.KVDBLayer,PtrLenList,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryExclude,Cyclomatic complexity of the method is 14
Complex Method,BTDB.KVDBLayer,PtrLenList,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryInclude,Cyclomatic complexity of the method is 13
Complex Method,BTDB.ODBLayer,ODBDictionary,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,FreeContent,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ODBLayer,ODBDictionary,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,GetEnumerator,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ODBLayer,ODBDictionary,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,GetReverseEnumerator,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ODBLayer,ODBDictionary,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,GetIncreasingEnumerator,Cyclomatic complexity of the method is 19
Complex Method,BTDB.ODBLayer,ODBDictionary,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,GetDecreasingEnumerator,Cyclomatic complexity of the method is 19
Complex Method,BTDB.ODBLayer,ODBDictionary,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,QuerySizeEnumerator,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ODBLayer,ODBIterator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,Iterate,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ODBLayer,ODBIterator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,IterateRelation,Cyclomatic complexity of the method is 11
Complex Method,BTDB.ODBLayer,ODBIterator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,IterateDict,Cyclomatic complexity of the method is 11
Complex Method,BTDB.ODBLayer,ODBIterator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,IterateHandler,Cyclomatic complexity of the method is 32
Complex Method,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,Cyclomatic complexity of the method is 18
Complex Method,BTDB.ODBLayer,RelationDBManipulator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,CompareAndRelease,Cyclomatic complexity of the method is 11
Complex Method,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateVersionInfoByReflection,Cyclomatic complexity of the method is 11
Complex Method,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateLoader,Cyclomatic complexity of the method is 13
Complex Method,BTDB.ODBLayer,RelationAdvancedEnumerator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,RelationAdvancedEnumerator,Cyclomatic complexity of the method is 33
Complex Method,BTDB.ODBLayer,RelationAdvancedOrderedEnumerator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,RelationAdvancedOrderedEnumerator,Cyclomatic complexity of the method is 35
Complex Method,BTDB.ODBLayer,RelationVersionInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationVersionInfo.cs,CreateSecondaryKeyInfo,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ODBLayer,ObjectDBTransaction,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,Enumerate,Cyclomatic complexity of the method is 17
Complex Method,BTDB.ODBLayer,ObjectDBTransaction,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,Store,Cyclomatic complexity of the method is 10
Complex Method,BTDB.ODBLayer,ObjectDBTransaction,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,StoreAndFlush,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ODBLayer,ObjectDBTransaction,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,StoreIfNotInlined,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ODBLayer,ObjectDBTransaction,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,Delete,Cyclomatic complexity of the method is 9
Complex Method,BTDB.ODBLayer,ObjectDBTransaction,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,Delete,Cyclomatic complexity of the method is 10
Complex Method,BTDB.ODBLayer,ObjectDBTransaction,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,PersistTableInfo,Cyclomatic complexity of the method is 10
Complex Method,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateInitializer,Cyclomatic complexity of the method is 8
Complex Method,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,Cyclomatic complexity of the method is 13
Complex Method,BTDB.Reactive,FastSubject,F:\newReposMay17\Bobris_BTDB\BTDB\Reactive\FastSubject.cs,Subscribe,Cyclomatic complexity of the method is 8
Complex Method,BTDB.Reactive,FastBehaviourSubject,F:\newReposMay17\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,Subscribe,Cyclomatic complexity of the method is 11
Complex Method,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnReceive,Cyclomatic complexity of the method is 21
Complex Method,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnSubcommand,Cyclomatic complexity of the method is 17
Complex Method,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,Cyclomatic complexity of the method is 14
Complex Method,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,Cyclomatic complexity of the method is 21
Complex Method,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibility,Cyclomatic complexity of the method is 10
Complex Method,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibilityIgnoringName,Cyclomatic complexity of the method is 19
Complex Method,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,WriteObjectForServer,Cyclomatic complexity of the method is 8
Complex Method,BTDB.Service,TypeInf,F:\newReposMay17\Bobris_BTDB\BTDB\Service\TypeInf.cs,TypeInf,Cyclomatic complexity of the method is 15
Complex Method,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,Cyclomatic complexity of the method is 10
Complex Method,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,Cyclomatic complexity of the method is 11
Complex Method,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,Cyclomatic complexity of the method is 32
Complex Method,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,Cyclomatic complexity of the method is 13
Complex Method,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipDecimal,Cyclomatic complexity of the method is 13
Complex Method,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipIPAddress,Cyclomatic complexity of the method is 9
Long Parameter List,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,CompareByteArray,The method has 6 parameters.
Long Parameter List,BTDB.EventStore2Layer,PlaceHolderDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStore2Layer\PlaceHolderDescriptor.cs,GenerateLoad,The method has 5 parameters.
Long Parameter List,BTDB.EventStore2Layer,PlaceHolderDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStore2Layer\PlaceHolderDescriptor.cs,GenerateSave,The method has 5 parameters.
Long Parameter List,BTDB.EventStoreLayer,AppendingEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,SerializeIntoBuffer,The method has 7 parameters.
Long Parameter List,BTDB.EventStoreLayer,ByteArrayTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ByteArrayTypeDescriptor.cs,GenerateLoad,The method has 5 parameters.
Long Parameter List,BTDB.EventStoreLayer,ByteArrayTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ByteArrayTypeDescriptor.cs,GenerateSave,The method has 5 parameters.
Long Parameter List,BTDB.EventStoreLayer,DictionaryTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateLoad,The method has 5 parameters.
Long Parameter List,BTDB.EventStoreLayer,DictionaryTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateSave,The method has 5 parameters.
Long Parameter List,BTDB.EventStoreLayer,EnumTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,EnumTypeDescriptor,The method has 6 parameters.
Long Parameter List,BTDB.EventStoreLayer,EnumTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,GenerateLoad,The method has 5 parameters.
Long Parameter List,BTDB.EventStoreLayer,EnumTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,GenerateSave,The method has 5 parameters.
Long Parameter List,BTDB.EventStoreLayer,ListTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateLoad,The method has 5 parameters.
Long Parameter List,BTDB.EventStoreLayer,ListTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateSave,The method has 5 parameters.
Long Parameter List,BTDB.EventStoreLayer,TypeDescriptorExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeDescriptorExtensions.cs,GenerateSaveEx,The method has 6 parameters.
Long Parameter List,BTDB.EventStoreLayer,TypeDescriptorExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeDescriptorExtensions.cs,GenerateLoadEx,The method has 7 parameters.
Long Parameter List,BTDB.EventStoreLayer,ITypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ITypeDescriptor.cs,GenerateLoad,The method has 5 parameters.
Long Parameter List,BTDB.EventStoreLayer,ITypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ITypeDescriptor.cs,GenerateSave,The method has 5 parameters.
Long Parameter List,BTDB.EventStoreLayer,ObjectTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,GenerateLoad,The method has 5 parameters.
Long Parameter List,BTDB.EventStoreLayer,ObjectTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,GenerateSave,The method has 5 parameters.
Long Parameter List,BTDB.EventStoreLayer,SimpleTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\SimpleTypeDescriptor.cs,GenerateLoad,The method has 5 parameters.
Long Parameter List,BTDB.EventStoreLayer,SimpleTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\SimpleTypeDescriptor.cs,GenerateSave,The method has 5 parameters.
Long Parameter List,BTDB.EventStoreLayer,TypeSerializersMapping,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializersMapping.cs,StoreObjectCore,The method has 5 parameters.
Long Parameter List,BTDB.FieldHandler,BasicSerializersFactory,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\BasicSerializersFactory.cs,AddJustOrderable,The method has 5 parameters.
Long Parameter List,BTDB.FieldHandler,BasicSerializersFactory,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\BasicSerializersFactory.cs,AddDescriptor,The method has 5 parameters.
Long Parameter List,BTDB.FieldHandler,BasicSerializersFactory,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\BasicSerializersFactory.cs,Add,The method has 6 parameters.
Long Parameter List,BTDB.FieldHandler,DictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,DictionaryFieldHandler,The method has 5 parameters.
Long Parameter List,BTDB.FieldHandler,Extensions,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\Extensions.cs,GenerateLoad,The method has 5 parameters.
Long Parameter List,BTDB.IL,ILMethodDebugImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILMethodDebugImpl.cs,ILMethodDebugImpl,The method has 6 parameters.
Long Parameter List,BTDB.IL,EmitHelpers,F:\newReposMay17\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateJumpIfEqual,The method has 5 parameters.
Long Parameter List,BTDB.IOC.CRegs,EnumerableImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\CRegs\EnumerableImpl.cs,EnumerableImpl,The method has 5 parameters.
Long Parameter List,BTDB.KVDBLayer,FileKeyIndex,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\FileKeyIndex.cs,FileKeyIndex,The method has 7 parameters.
Long Parameter List,BTDB.KVDBLayer,IFileCollectionFile,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Interface\IFileCollectionFile.cs,RandomRead,The method has 5 parameters.
Long Parameter List,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,WriteCreateOrUpdateCommand,The method has 6 parameters.
Long Parameter List,BTDB.ODBLayer,AdvancedEnumeratorParam,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\IOrderedDictionary.cs,AdvancedEnumeratorParam,The method has 5 parameters.
Long Parameter List,BTDB.ODBLayer,ODBDictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionaryFieldHandler.cs,ODBDictionaryFieldHandler,The method has 5 parameters.
Long Parameter List,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,SaveKeyBytesAndCallMethod,The method has 6 parameters.
Long Parameter List,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodFindById,The method has 8 parameters.
Long Parameter List,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodRemoveById,The method has 8 parameters.
Long Parameter List,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodFindBy,The method has 8 parameters.
Long Parameter List,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodListById,The method has 7 parameters.
Long Parameter List,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodContains,The method has 6 parameters.
Long Parameter List,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,RelationInfo,The method has 6 parameters.
Long Parameter List,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateSaverIl,The method has 6 parameters.
Long Parameter List,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CopyFromBuffer,The method has 10 parameters.
Long Parameter List,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,FindPosition,The method has 5 parameters.
Long Parameter List,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,SkipWithMemorizing,The method has 5 parameters.
Long Parameter List,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CopyFromMemorizedPosition,The method has 5 parameters.
Long Parameter List,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,GenerateCopyFieldFromByteBufferToWriterIl,The method has 6 parameters.
Long Parameter List,BTDB.ODBLayer,RelationSecondaryKeyEnumerator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,RelationSecondaryKeyEnumerator,The method has 6 parameters.
Long Parameter List,BTDB.ODBLayer,RelationAdvancedEnumerator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,RelationAdvancedEnumerator,The method has 8 parameters.
Long Parameter List,BTDB.ODBLayer,RelationAdvancedSecondaryKeyEnumerator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,RelationAdvancedSecondaryKeyEnumerator,The method has 9 parameters.
Long Parameter List,BTDB.ODBLayer,RelationAdvancedOrderedEnumerator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,RelationAdvancedOrderedEnumerator,The method has 9 parameters.
Long Parameter List,BTDB.ODBLayer,RelationAdvancedOrderedSecondaryKeyEnumerator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,RelationAdvancedOrderedSecondaryKeyEnumerator,The method has 9 parameters.
Long Parameter List,BTDB.ODBLayer,RelationVersionInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationVersionInfo.cs,RelationVersionInfo,The method has 5 parameters.
Long Parameter List,BTDB.ODBLayer,RelationVersionInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationVersionInfo.cs,RelationVersionInfo,The method has 5 parameters.
Long Parameter List,BTDB.ODBLayer,UnresolvedTableFieldInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableFieldInfo.cs,UnresolvedTableFieldInfo,The method has 5 parameters.
Long Parameter List,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,GenerateOneFieldHandlerSave,The method has 5 parameters.
Long Parameter List,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The method has 6 parameters.
Long Parameter List,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The method has 5 parameters.
Long Identifier,BTDB.IL,EmitHelpers,F:\newReposMay17\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateAddRemoveEvent,The length of the parameter typePropertyChangedEventHandler is 31.
Long Identifier,BTDB.KVDBLayer,FileTransactionLog,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\FileTransactionLog.cs,FileTransactionLog,The length of the parameter fileIdWithPreviousTransactionLog is 32.
Long Identifier,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,RevertWrittingTransaction,The length of the parameter nothingWrittenToTransactionLog is 30.
Long Identifier,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,RegisterLocalTypeInternalUnlocked,The length of the parameter iFieldHandlerWithNestedFieldHandlers is 36.
Long Statement,BTDB.Buffer,ByteBuffer,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\ByteBuffer.cs,SubBuffer,The length of the statement  "	return AsyncSafe ? NewAsync (Buffer' Offset + offset' Length - offset) : NewSync (Buffer' Offset + offset' Length - offset); " is 124.
Long Statement,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The length of the statement  "	return data [offset] | ((ulong)data [offset + 1] << 8) | ((ulong)data [offset + 2] << 16) | ((ulong)data [offset + 3] << 24) | ((ulong)data [offset + 4] << 32) | ((ulong)data [offset + 5] << 40) | ((ulong)data [offset + 6] << 48) | ((ulong)data [offset + 7] << 56); " is 265.
Long Statement,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The length of the statement  "	return data [offset] | ((long)data [offset + 1] << 8) | ((long)data [offset + 2] << 16) | ((long)data [offset + 3] << 24) | ((long)data [offset + 4] << 32) | ((long)data [offset + 5] << 40) | ((long)data [offset + 6] << 48) | ((long)data [offset + 7] << 56); " is 258.
Long Statement,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The length of the statement  "	return data [offset + 7] | ((long)data [offset + 6] << 8) | ((long)data [offset + 5] << 16) | ((long)data [offset + 4] << 24) | ((long)data [offset + 3] << 32) | ((long)data [offset + 2] << 40) | ((long)data [offset + 1] << 48) | ((long)data [offset] << 56); " is 258.
Long Statement,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The length of the statement  "		result = ((ulong)(first & 0x07u) << 32) + ((uint)data [ofs] << 24) + ((uint)data [ofs + 1] << 16) + ((uint)data [ofs + 2] << 8) + data [ofs + 3]; " is 145.
Long Statement,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The length of the statement  "		result = ((ulong)(first & 0x03u) << 40) + ((ulong)data [ofs] << 32) + ((uint)data [ofs + 1] << 24) + ((uint)data [ofs + 2] << 16) + ((uint)data [ofs + 3] << 8) + data [ofs + 4]; " is 177.
Long Statement,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The length of the statement  "		result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5]; " is 209.
Long Statement,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The length of the statement  "		result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6]; " is 208.
Long Statement,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The length of the statement  "	result = ((ulong)data [ofs] << 56) + ((ulong)data [ofs + 1] << 48) + ((ulong)data [ofs + 2] << 40) + ((ulong)data [ofs + 3] << 32) + ((uint)data [ofs + 4] << 24) + ((uint)data [ofs + 5] << 16) + ((uint)data [ofs + 6] << 8) + data [ofs + 7]; " is 240.
Long Statement,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "			result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3]; " is 131.
Long Statement,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "			result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4]; " is 162.
Long Statement,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "			result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5]; " is 162.
Long Statement,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "		result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7]; " is 224.
Long Statement,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "		result = ((long)(first - 0x08) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3]; " is 131.
Long Statement,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "		result = ((long)(first - 0x04) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4]; " is 162.
Long Statement,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "		result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5]; " is 176.
Long Statement,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The length of the statement  "	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7]; " is 224.
Long Statement,BTDB.ChunkCache,DiskChunkCache,F:\newReposMay17\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,LoadContent,The length of the statement  "	var hashFilePair = _fileInfos.Where (f => f.Value.FileType == DiskChunkFileType.HashIndex).OrderByDescending (f => f.Value.Generation).FirstOrDefault (); " is 153.
Long Statement,BTDB.ChunkCache,DiskChunkCache,F:\newReposMay17\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,StartNewValueFile,The length of the statement  "		_compactionTask = Task.Factory.StartNew (CompactionCore' _compactionCts.Token' TaskCreationOptions.LongRunning' TaskScheduler.Default); " is 135.
Long Statement,BTDB.ChunkCache,DiskChunkCache,F:\newReposMay17\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,PreserveJustMostOftenUsed,The length of the statement  "				_fileCollection.GetFile (cacheValue.FileId).RandomRead (content' 0' (int)cacheValue.ContentLength' cacheValue.FileOfs' true); " is 125.
Long Statement,BTDB.ChunkCache,DiskChunkCache,F:\newReposMay17\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,Get,The length of the statement  "			_fileCollection.GetFile (cacheValue.FileId).RandomRead (result' 0' (int)cacheValue.ContentLength' cacheValue.FileOfs' false); " is 125.
Long Statement,BTDB.ChunkCache,DiskChunkCache,F:\newReposMay17\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,CalcStats,The length of the statement  "	res.AppendFormat ("Files {0} FileInfos {1} FileGeneration {2} Cached items {3}{4}"' _fileCollection.GetCount ()' _fileInfos.Count' _fileGeneration' _cache.Count' Environment.NewLine); " is 183.
Long Statement,BTDB.ChunkCache,DiskChunkCache,F:\newReposMay17\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,CalcStats,The length of the statement  "			res.AppendFormat ("{0} Size: {1} Type: {2} {3}"' fileCollectionFile.Index' size' fileInfo.FileType' Environment.NewLine); " is 121.
Long Statement,BTDB.ChunkCache,DiskChunkCache,F:\newReposMay17\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,CalcStats,The length of the statement  "	res.AppendFormat ("TotalSize {0} TotalControledSize {1} Limit {2}{3}"' totalSize' totalControledSize' _cacheCapacity' Environment.NewLine); " is 139.
Long Statement,BTDB.EventStore2Layer,EventDeserializer,F:\newReposMay17\Bobris_BTDB\BTDB\EventStore2Layer\EventDeserializer.cs,LoaderFactory,The length of the statement  "	var methodBuilder = ILBuilder.Instance.NewMethod<Func<AbstractBufferedReader' ITypeBinaryDeserializerContext' ITypeDescriptor' object>> ("DeserializerFor" + descriptor.Name); " is 174.
Long Statement,BTDB.EventStore2Layer,EventSerializer,F:\newReposMay17\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,BuildComplexSaver,The length of the statement  "	var method = ILBuilder.Instance.NewMethod<Action<AbstractBufferedWriter' ITypeBinarySerializerContext' object>> (descriptor.Name + "Saver"); " is 140.
Long Statement,BTDB.EventStore2Layer,EventSerializer,F:\newReposMay17\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,BuildNestedObjGatherer,The length of the statement  "		var method = ILBuilder.Instance.NewMethod<Action<object' IDescriptorSerializerLiteContext>> ("GatherAllObjectsForTypeExtraction_" + descriptor.Name); " is 149.
Long Statement,BTDB.EventStoreLayer,AppendingEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,Store,The length of the statement  "	SerializeIntoBuffer (metadata' events' out startOffset' out serializerContext' out blockType' out lenWithoutEndPadding' out block); " is 131.
Long Statement,BTDB.EventStoreLayer,AppendingEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,Store,The length of the statement  "		SerializeIntoBuffer (metadata' events' out startOffset' out serializerContext' out blockType' out lenWithoutEndPadding' out block); " is 131.
Long Statement,BTDB.EventStoreLayer,AppendingEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,KnownAppendablePosition,The length of the statement  "		throw new InvalidOperationException ("IsKnownAsAppendable needs to return true before calling this method. Use ReadToEnd(new SkippingEventObserver()).Wait() to initialize."); " is 174.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,AnyOpNeedsCtx,The length of the statement  "	return !_keyDescriptor.StoredInline || !_valueDescriptor.StoredInline || _keyDescriptor.AnyOpNeedsCtx () || _valueDescriptor.AnyOpNeedsCtx (); " is 142.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateLoad,The length of the statement  "	ilGenerator.Do (pushReader).Callvirt (() => default(AbstractBufferedReader).ReadVUInt32 ()).ConvI4 ().Dup ().LdcI4 (1).Sub ().Stloc (localCount).Brfalse (loadFinished).Ldloc (localCount).Do (pushDescriptor).Newobj (dictionaryType.GetConstructor (new[] { " is 253.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateLoad,The length of the statement  "	})).Stloc (localDict).Mark (next).Ldloc (localCount).Brfalse (loadFinished).Ldloc (localCount).LdcI4 (1).Sub ().Stloc (localCount).Ldloc (localDict); " is 149.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateLoad,The length of the statement  "	_keyDescriptor.GenerateLoadEx (ilGenerator' pushReader' pushCtx' il => il.Do (pushDescriptor).LdcI4 (0).Callvirt (() => default(ITypeDescriptor).NestedType (0))' keyType' _convertorGenerator); " is 192.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateLoad,The length of the statement  "	_valueDescriptor.GenerateLoadEx (ilGenerator' pushReader' pushCtx' il => il.Do (pushDescriptor).LdcI4 (1).Callvirt (() => default(ITypeDescriptor).NestedType (0))' valueType' _convertorGenerator); " is 196.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateLoad,The length of the statement  "	ilGenerator.Callvirt (dictionaryType.GetMethod ("Add")).Br (next).Mark (loadFinished).Ldloc (localDict).Castclass (targetType); " is 127.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateSave,The length of the statement  "	ilGenerator.Do (pushValue).Castclass (typeAsIDictionary).Stloc (localDict).Ldloc (localDict).Brtrue (notnull).Do (pushWriter).Callvirt (() => default(AbstractBufferedWriter).WriteByteZero ()).Br (completeFinish).Mark (notnull).Do (pushWriter).Ldloc (localDict).Callvirt (typeAsICollection.GetProperty ("Count").GetGetMethod ()).LdcI4 (1).Add ().Callvirt (() => default(AbstractBufferedWriter).WriteVUInt32 (0)); " is 411.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateSave,The length of the statement  "		var getEnumeratorMethod = typeAsDictionary.GetMethods ().Single (m => m.Name == "GetEnumerator" && m.ReturnType.IsValueType && m.GetParameters ().Length == 0); " is 159.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateSave,The length of the statement  "		ilGenerator.Ldloc (localDict).Castclass (typeAsDictionary).Brfalse (notDictionary).Ldloc (localDict).Castclass (typeAsDictionary).Callvirt (getEnumeratorMethod).Stloc (localEnumerator).Try ().Mark (next).Ldloca (localEnumerator).Call (typeAsIEnumerator.GetMethod ("MoveNext")).Brfalse (finish).Ldloca (localEnumerator).Call (currentGetter).Stloc (localPair); " is 358.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateSave,The length of the statement  "		_keyDescriptor.GenerateSaveEx (ilGenerator' pushWriter' pushCtx' il => il.Ldloca (localPair).Call (typeKeyValuePair.GetProperty ("Key").GetGetMethod ())' keyType); " is 163.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateSave,The length of the statement  "		_valueDescriptor.GenerateSaveEx (ilGenerator' pushWriter' pushCtx' il => il.Ldloca (localPair).Call (typeKeyValuePair.GetProperty ("Value").GetGetMethod ())' valueType); " is 169.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateSave,The length of the statement  "		ilGenerator.Br (next).Mark (finish).Finally ().Ldloca (localEnumerator).Constrained (typeAsIEnumerator).Callvirt (() => default(IDisposable).Dispose ()).EndTry ().Br (completeFinish); " is 183.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateSave,The length of the statement  "		ilGenerator.Mark (notDictionary).Ldloc (localDict).Callvirt (getEnumeratorMethod).Stloc (localEnumerator).Try ().Mark (next).Ldloc (localEnumerator).Callvirt (() => default(IEnumerator).MoveNext ()).Brfalse (finish).Ldloc (localEnumerator).Callvirt (currentGetter).Stloc (localPair); " is 283.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateSave,The length of the statement  "		_keyDescriptor.GenerateSaveEx (ilGenerator' pushWriter' pushCtx' il => il.Ldloca (localPair).Call (typeKeyValuePair.GetProperty ("Key").GetGetMethod ())' keyType); " is 163.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateSave,The length of the statement  "		_valueDescriptor.GenerateSaveEx (ilGenerator' pushWriter' pushCtx' il => il.Ldloca (localPair).Call (typeKeyValuePair.GetProperty ("Value").GetGetMethod ())' valueType); " is 169.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateSave,The length of the statement  "		ilGenerator.Br (next).Mark (finish).Finally ().Ldloc (localEnumerator).Callvirt (() => default(IDisposable).Dispose ()).EndTry ().Mark (completeFinish); " is 152.
Long Statement,BTDB.EventStoreLayer,DictionaryTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\DictionaryTypeDescriptor.cs,GenerateSkip,The length of the statement  "	ilGenerator.Do (pushReader).Callvirt (() => default(AbstractBufferedReader).ReadVUInt32 ()).Stloc (localCount).Ldloc (localCount).Brfalse (skipFinished).Mark (next).Ldloc (localCount).LdcI4 (1).Sub ().Stloc (localCount).Ldloc (localCount).Brfalse (skipFinished); " is 262.
Long Statement,BTDB.EventStoreLayer,ListTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateLoad,The length of the statement  "		ilGenerator.LdcI4 (0).Stloc (localIndex).Do (pushReader).Callvirt (() => default(AbstractBufferedReader).ReadVUInt32 ()).ConvI4 ().Dup ().Stloc (localCount).Brfalse (loadFinished).Ldloc (localCount).LdcI4 (1).Sub ().Dup ().Stloc (localCount).Newarr (itemType).Stloc (localArray).Mark (next).Ldloc (localCount).Ldloc (localIndex).Sub ().Brfalse (loadFinished).Ldloc (localArray).Ldloc (localIndex); " is 397.
Long Statement,BTDB.EventStoreLayer,ListTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateLoad,The length of the statement  "		_itemDescriptor.GenerateLoadEx (ilGenerator' pushReader' pushCtx' il => il.Do (pushDescriptor).LdcI4 (0).Callvirt (() => default(ITypeDescriptor).NestedType (0))' itemType' _convertorGenerator); " is 194.
Long Statement,BTDB.EventStoreLayer,ListTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateLoad,The length of the statement  "		ilGenerator.Stelem (itemType).Ldloc (localIndex).LdcI4 (1).Add ().Stloc (localIndex).Br (next).Mark (loadFinished).Ldloc (localArray).Castclass (targetType); " is 157.
Long Statement,BTDB.EventStoreLayer,ListTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateLoad,The length of the statement  "		ilGenerator.Do (pushReader).Callvirt (() => default(AbstractBufferedReader).ReadVUInt32 ()).ConvI4 ().Dup ().Stloc (localCount).Brfalse (loadFinished).Ldloc (localCount).LdcI4 (1).Sub ().Dup ().Stloc (localCount).Do (pushDescriptor).Newobj (listType.GetConstructor (new[] { " is 273.
Long Statement,BTDB.EventStoreLayer,ListTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateLoad,The length of the statement  "		})).Stloc (localList).Mark (next).Ldloc (localCount).Brfalse (loadFinished).Ldloc (localCount).LdcI4 (1).Sub ().Stloc (localCount).Ldloc (localList); " is 149.
Long Statement,BTDB.EventStoreLayer,ListTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateLoad,The length of the statement  "		_itemDescriptor.GenerateLoadEx (ilGenerator' pushReader' pushCtx' il => il.Do (pushDescriptor).LdcI4 (0).Callvirt (() => default(ITypeDescriptor).NestedType (0))' itemType' _convertorGenerator); " is 194.
Long Statement,BTDB.EventStoreLayer,ListTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateLoad,The length of the statement  "		ilGenerator.Callvirt (listType.GetInterface ("ICollection`1").GetMethod ("Add")).Br (next).Mark (loadFinished).Ldloc (localList).Castclass (targetType); " is 152.
Long Statement,BTDB.EventStoreLayer,ListTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateSave,The length of the statement  "	ilGenerator.Do (pushValue).Castclass (localList.LocalType).Stloc (localList).Ldloc (localList).BrtrueS (notnull).Do (pushWriter).Callvirt (() => default(AbstractBufferedWriter).WriteByteZero ()).Br (finish).Mark (notnull).Ldloc (localList).Callvirt (localList.LocalType.GetInterface ("ICollection`1").GetProperty ("Count").GetGetMethod ()).Stloc (localCount).Do (pushWriter).Ldloc (localCount).LdcI4 (1).Add ().Callvirt (() => default(AbstractBufferedWriter).WriteVUInt32 (0)).LdcI4 (0).Stloc (localIndex).Mark (next).Ldloc (localIndex).Ldloc (localCount).BgeUn (finish); " is 571.
Long Statement,BTDB.EventStoreLayer,ListTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateSave,The length of the statement  "	_itemDescriptor.GenerateSaveEx (ilGenerator' pushWriter' pushCtx' il => il.Ldloc (localList).Ldloc (localIndex).Callvirt (localList.LocalType.GetMethod ("get_Item"))' itemType); " is 177.
Long Statement,BTDB.EventStoreLayer,ListTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GenerateSkip,The length of the statement  "	ilGenerator.Do (pushReader).Callvirt (() => default(AbstractBufferedReader).ReadVUInt32 ()).ConvI4 ().Dup ().Stloc (localCount).Brfalse (skipFinished).Ldloc (localCount).LdcI4 (1).Sub ().Stloc (localCount).Mark (next).Ldloc (localCount).Brfalse (skipFinished).Ldloc (localCount).LdcI4 (1).Sub ().Stloc (localCount); " is 315.
Long Statement,BTDB.EventStoreLayer,TypeDescriptorExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeDescriptorExtensions.cs,Describe,The length of the statement  "	descriptor.BuildHumanReadableFullName (sb' new HashSet<ITypeDescriptor> (ReferenceEqualityComparer<ITypeDescriptor>.Instance)' 0); " is 130.
Long Statement,BTDB.EventStoreLayer,TypeDescriptorExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeDescriptorExtensions.cs,GenerateLoadEx,The length of the statement  "					throw new BTDBException ("Don't know how to convert " + descriptor.Name + " from " + origType.ToSimpleName () + " to " + asType.ToSimpleName ()); " is 145.
Long Statement,BTDB.EventStoreLayer,ObjectTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,GetPersitentName,The length of the statement  "	var a = propertyInfo.GetCustomAttributes (typeof(PersistedNameAttribute)' false).Cast<PersistedNameAttribute> ().FirstOrDefault (); " is 131.
Long Statement,BTDB.EventStoreLayer,ObjectTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,GenerateLoad,The length of the statement  "		ilGenerator.Do (pushDescriptor).Castclass (typeof(ObjectTypeDescriptor)).Newobj (typeof(DynamicObject).GetConstructor (new[] { " is 126.
Long Statement,BTDB.EventStoreLayer,ObjectTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,GenerateLoad,The length of the statement  "		})).Stloc (resultLoc).Do (pushCtx).BrfalseS (labelNoCtx).Do (pushCtx).Ldloc (resultLoc).Callvirt (() => default(ITypeBinaryDeserializerContext).AddBackRef (null)).Mark (labelNoCtx); " is 181.
Long Statement,BTDB.EventStoreLayer,ObjectTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,GenerateLoad,The length of the statement  "			pair.Value.GenerateLoadEx (ilGenerator' pushReader' pushCtx' il => il.Do (pushDescriptor).LdcI4 (idxForCapture).Callvirt (() => default(ITypeDescriptor).NestedType (0))' typeof(object)' _typeSerializers.ConvertorGenerator); " is 223.
Long Statement,BTDB.EventStoreLayer,ObjectTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,GenerateLoad,The length of the statement  "		ilGenerator.Newobj (targetType.GetConstructor (Type.EmptyTypes)).Stloc (resultLoc).Do (pushCtx).BrfalseS (labelNoCtx).Do (pushCtx).Ldloc (resultLoc).Callvirt (() => default(ITypeBinaryDeserializerContext).AddBackRef (null)).Mark (labelNoCtx); " is 242.
Long Statement,BTDB.EventStoreLayer,ObjectTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,GenerateLoad,The length of the statement  "			pair.Value.GenerateLoadEx (ilGenerator' pushReader' pushCtx' il => il.Do (pushDescriptor).LdcI4 (idxForCapture).Callvirt (() => default(ITypeDescriptor).NestedType (0))' prop.PropertyType' _typeSerializers.ConvertorGenerator); " is 226.
Long Statement,BTDB.EventStoreLayer,ObjectTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,GenerateSave,The length of the statement  "		pair.Value.GenerateSaveEx (ilGenerator' pushWriter' pushCtx' il => il.Ldloc (locValue).Callvirt (methodInfo)' methodInfo.ReturnType); " is 133.
Long Statement,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The length of the statement  "			stopReadingRequested = Process (blockType' ByteBuffer.NewSync (bufferBlock' bufferReadOffset' (int)blockLen)' observer); " is 120.
Long Statement,BTDB.EventStoreLayer,TypeSerializers,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,ForgotAllTypesAndSerializers,The length of the statement  "	_type2DescriptorMap = new ConcurrentDictionary<Type' ITypeDescriptor> (EnumDefaultTypes ()' ReferenceEqualityComparer<Type>.Instance); " is 134.
Long Statement,BTDB.EventStoreLayer,TypeSerializers,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,LoaderFactory,The length of the statement  "	var methodBuilder = ILBuilder.Instance.NewMethod<Func<AbstractBufferedReader' ITypeBinaryDeserializerContext' ITypeSerializersId2LoaderMapping' ITypeDescriptor' object>> ("DeserializerFor" + descriptor.Name); " is 208.
Long Statement,BTDB.EventStoreLayer,TypeSerializers,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,LoaderFactory,The length of the statement  "		il.Ldarg (1).Dup ().Stloc (localCtx).Brtrue (haveCtx).Ldarg (0).Ldarg (2).Newobj (() => new DeserializerCtx (null' null)).Castclass (typeof(ITypeBinaryDeserializerContext)).Stloc (localCtx).Mark (haveCtx); " is 205.
Long Statement,BTDB.EventStoreLayer,TypeSerializers,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,LoaderFactory,The length of the statement  "		descriptor.GenerateLoad (il' ilGen => ilGen.Ldarg (0)' ilGen => ilGen.Ldloc (localCtx)' ilGen => ilGen.Ldarg (3)' loadAsType); " is 126.
Long Statement,BTDB.EventStoreLayer,TypeSerializers,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,NewComplexSaver,The length of the statement  "	var method = ILBuilder.Instance.NewMethod<Action<AbstractBufferedWriter' ITypeBinarySerializerContext' object>> (descriptor.Name + "ComplexSaver"); " is 147.
Long Statement,BTDB.EventStoreLayer,TypeSerializers,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,NewDescriptorSaverFactory,The length of the statement  "	var method = ILBuilder.Instance.NewMethod<Action<object' IDescriptorSerializerLiteContext>> ("GatherAllObjectsForTypeExtraction_" + descriptor.Name); " is 149.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,IsCompatibleWith,The length of the statement  "	return type.GetGenericTypeDefinition () == typeof(IDictionary<' >) || type.GetGenericTypeDefinition () == typeof(Dictionary<' >); " is 129.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,HandledType,The length of the statement  "	return _type ?? (_type = typeof(IDictionary<' >).MakeGenericType (_keysHandler.HandledType ()' _valuesHandler.HandledType ())); " is 127.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,Load,The length of the statement  "	ilGenerator.Do (pushReaderOrCtx).Ldloca (localResultOfObject).Callvirt (() => default(IReaderCtx).ReadObject (out fake)).Brfalse (loadSkipped).Do (Extensions.PushReaderFromCtx (pushReaderOrCtx)).Callvirt (() => default(AbstractBufferedReader).ReadVUInt32 ()).Stloc (localCount).Ldloc (localCount).Newobj (typeof(Dictionary<' >).MakeGenericType (genericArguments).GetConstructor (new[] { " is 386.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,Load,The length of the statement  "	})).Stloc (localResult).Do (pushReaderOrCtx).Ldloc (localResult).Castclass (typeof(object)).Callvirt (() => default(IReaderCtx).RegisterObject (null)).Mark (next).Ldloc (localCount).Brfalse (readfinish).Ldloc (localCount).LdcI4 (1).Sub ().ConvU4 ().Stloc (localCount).Ldloc (localResult).GenerateLoad (_keysHandler' genericArguments [0]' pushReaderOrCtx' _typeConvertorGenerator).GenerateLoad (_valuesHandler' genericArguments [1]' pushReaderOrCtx' _typeConvertorGenerator).Callvirt (_type.GetMethod ("Add")).Br (next).Mark (readfinish).Do (pushReaderOrCtx).Callvirt (() => default(IReaderCtx).ReadObjectDone ()).Br (finish).Mark (loadSkipped).Ldloc (localResultOfObject).Isinst (_type).Stloc (localResult).Mark (finish).Ldloc (localResult); " is 741.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,Skip,The length of the statement  "	ilGenerator.Do (pushReaderOrCtx).Callvirt (() => ((IReaderCtx)null).SkipObject ()).Brfalse (finish).Do (Extensions.PushReaderFromCtx (pushReaderOrCtx)).Callvirt (() => ((AbstractBufferedReader)null).ReadVUInt32 ()).Stloc (localCount).Mark (next).Ldloc (localCount).Brfalse (finish).Ldloc (localCount).LdcI4 (1).Sub ().ConvU4 ().Stloc (localCount).GenerateSkip (_keysHandler' pushReaderOrCtx).GenerateSkip (_valuesHandler' pushReaderOrCtx).Br (next).Mark (finish); " is 463.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,Save,The length of the statement  "	ilGenerator.Do (pushValue).Stloc (localValue).Do (pushWriterOrCtx).Ldloc (localValue).Castclass (typeof(object)).Callvirt (() => default(IWriterCtx).WriteObject (null)).Brfalse (realfinish).Do (Extensions.PushWriterFromCtx (pushWriterOrCtx)).Ldloc (localValue).Callvirt (typeAsICollection.GetProperty ("Count").GetGetMethod ()).ConvU4 ().Callvirt (() => default(AbstractBufferedWriter).WriteVUInt32 (0)).Ldloc (localValue).Callvirt (getEnumeratorMethod).Stloc (localEnumerator).Try ().Mark (next).Ldloc (localEnumerator).Callvirt (() => default(IEnumerator).MoveNext ()).Brfalse (finish).Ldloc (localEnumerator).Callvirt (typeAsIEnumerator.GetProperty ("Current").GetGetMethod ()).Stloc (localPair); " is 699.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,Save,The length of the statement  "	_keysHandler.Save (ilGenerator' Extensions.PushWriterOrCtxAsNeeded (pushWriterOrCtx' _keysHandler.NeedsCtx ())' il => il.Ldloca (localPair).Call (typeKeyValuePair.GetProperty ("Key").GetGetMethod ()).Do (_typeConvertorGenerator.GenerateConversion (_type.GetGenericArguments () [0]' _keysHandler.HandledType ()))); " is 313.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,Save,The length of the statement  "	_valuesHandler.Save (ilGenerator' Extensions.PushWriterOrCtxAsNeeded (pushWriterOrCtx' _valuesHandler.NeedsCtx ())' il => il.Ldloca (localPair).Call (typeKeyValuePair.GetProperty ("Value").GetGetMethod ()).Do (_typeConvertorGenerator.GenerateConversion (_type.GetGenericArguments () [1]' _valuesHandler.HandledType ()))); " is 321.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,Save,The length of the statement  "	ilGenerator.Br (next).Mark (finish).Finally ().Ldloc (localEnumerator).Callvirt (() => default(IDisposable).Dispose ()).EndTry ().Mark (realfinish); " is 148.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,SpecializeLoadForType,The length of the statement  "	return new DictionaryFieldHandler (_fieldHandlerFactory' _typeConvertorGenerator' type' keySpecialized' valueSpecialized); " is 122.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,SpecializeSaveForType,The length of the statement  "	return new DictionaryFieldHandler (_fieldHandlerFactory' _typeConvertorGenerator' type' keySpecialized' valueSpecialized); " is 122.
Long Statement,BTDB.FieldHandler,DictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\DictionaryFieldHandler.cs,FreeContent,The length of the statement  "	ilGenerator.Do (pushReaderOrCtx).Callvirt (() => ((IReaderCtx)null).SkipObject ()).Brfalse (finish).Do (Extensions.PushReaderFromCtx (pushReaderOrCtx)).Callvirt (() => ((AbstractBufferedReader)null).ReadVUInt32 ()).Stloc (localCount).Mark (next).Ldloc (localCount).Brfalse (finish).Ldloc (localCount).LdcI4 (1).Sub ().ConvU4 ().Stloc (localCount).GenerateFreeContent (_keysHandler' pushReaderOrCtx' ref needsFreeContent).GenerateFreeContent (_valuesHandler' pushReaderOrCtx' ref needsFreeContent).Br (next).Mark (finish); " is 521.
Long Statement,BTDB.FieldHandler,Extensions,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\Extensions.cs,GenerateFreeContent,The length of the statement  "	if (fieldHandler.FreeContent (ilGenerator' fieldHandler.NeedsCtx () ? pushReaderOrCtx : PushReaderFromCtx (pushReaderOrCtx))) " is 125.
Long Statement,BTDB.FieldHandler,EnumFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\EnumFieldHandler.cs,IsCompatibleWith,The length of the statement  "	return SignedFieldHandler.IsCompatibleWith (enumUnderlyingType) || UnsignedFieldHandler.IsCompatibleWith (enumUnderlyingType); " is 126.
Long Statement,BTDB.FieldHandler,EnumFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\EnumFieldHandler.cs,SpecializeLoadForType,The length of the statement  "		if (_signed == enumTypeHandler._signed && new EnumConfiguration (Configuration).IsSubsetOf (new EnumConfiguration (enumTypeHandler.Configuration))) { " is 149.
Long Statement,BTDB.FieldHandler,ListFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\ListFieldHandler.cs,Load,The length of the statement  "	ilGenerator.Do (pushReaderOrCtx).Ldloca (localResultOfObject).Callvirt (() => default(IReaderCtx).ReadObject (out fake)).Brfalse (loadSkipped).Do (Extensions.PushReaderFromCtx (pushReaderOrCtx)).Callvirt (() => default(AbstractBufferedReader).ReadVUInt32 ()).Stloc (localCount).Ldloc (localCount).Newobj (typeof(List<>).MakeGenericType (_type.GetGenericArguments () [0]).GetConstructor (new[] { " is 394.
Long Statement,BTDB.FieldHandler,ListFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\ListFieldHandler.cs,Load,The length of the statement  "	})).Stloc (localResult).Do (pushReaderOrCtx).Ldloc (localResult).Castclass (typeof(object)).Callvirt (() => default(IReaderCtx).RegisterObject (null)).Mark (next).Ldloc (localCount).Brfalse (loadFinished).Ldloc (localCount).LdcI4 (1).Sub ().ConvU4 ().Stloc (localCount).Ldloc (localResult).GenerateLoad (_itemsHandler' _type.GetGenericArguments () [0]' pushReaderOrCtx' _typeConvertorGenerator).Callvirt (_type.GetInterface ("ICollection`1").GetMethod ("Add")).Br (next).Mark (loadFinished).Do (pushReaderOrCtx).Callvirt (() => default(IReaderCtx).ReadObjectDone ()).Br (finish).Mark (loadSkipped).Ldloc (localResultOfObject).Isinst (_type).Stloc (localResult).Mark (finish).Ldloc (localResult); " is 695.
Long Statement,BTDB.FieldHandler,ListFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\ListFieldHandler.cs,Skip,The length of the statement  "	ilGenerator.Do (pushReaderOrCtx).Callvirt (() => default(IReaderCtx).SkipObject ()).Brfalse (finish).Do (Extensions.PushReaderFromCtx (pushReaderOrCtx)).Callvirt (() => default(AbstractBufferedReader).ReadVUInt32 ()).Stloc (localCount).Mark (next).Ldloc (localCount).Brfalse (finish).Ldloc (localCount).LdcI4 (1).Sub ().ConvU4 ().Stloc (localCount).GenerateSkip (_itemsHandler' pushReaderOrCtx).Br (next).Mark (finish); " is 419.
Long Statement,BTDB.FieldHandler,ListFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\ListFieldHandler.cs,Save,The length of the statement  "	ilGenerator.LdcI4 (0).Stloc (localIndex).Do (pushValue).Stloc (localValue).Do (pushWriterOrCtx).Ldloc (localValue).Castclass (typeof(object)).Callvirt (() => default(IWriterCtx).WriteObject (null)).Brfalse (finish).Ldloc (localValue).Callvirt (_type.GetInterface ("ICollection`1").GetProperty ("Count").GetGetMethod ()).Stloc (localCount).Do (Extensions.PushWriterFromCtx (pushWriterOrCtx)).Ldloc (localCount).ConvU4 ().Callvirt (() => default(AbstractBufferedWriter).WriteVUInt32 (0)).Mark (next).Ldloc (localIndex).Ldloc (localCount).BgeUn (finish); " is 551.
Long Statement,BTDB.FieldHandler,ListFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\ListFieldHandler.cs,Save,The length of the statement  "	_itemsHandler.Save (ilGenerator' Extensions.PushWriterOrCtxAsNeeded (pushWriterOrCtx' _itemsHandler.NeedsCtx ())' il => il.Ldloc (localValue).Ldloc (localIndex).Callvirt (_type.GetMethod ("get_Item")).Do (_typeConvertorGenerator.GenerateConversion (_type.GetGenericArguments () [0]' _itemsHandler.HandledType ()))); " is 315.
Long Statement,BTDB.FieldHandler,ListFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\ListFieldHandler.cs,FreeContent,The length of the statement  "	ilGenerator.Do (pushReaderOrCtx).Callvirt (() => default(IReaderCtx).SkipObject ()).Brfalse (finish).Do (Extensions.PushReaderFromCtx (pushReaderOrCtx)).Callvirt (() => default(AbstractBufferedReader).ReadVUInt32 ()).Stloc (localCount).Mark (next).Ldloc (localCount).Brfalse (finish).Ldloc (localCount).LdcI4 (1).Sub ().ConvU4 ().Stloc (localCount).GenerateFreeContent (_itemsHandler' pushReaderOrCtx' ref needsFreeContent).Br (next).Mark (finish); " is 448.
Long Statement,BTDB.FieldHandler,DBObjectFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\DBObjectFieldHandler.cs,Save,The length of the statement  "		ilGenerator.Do (pushWriterOrCtx).Do (pushValue).Call (typeof(DBIndirect<>).MakeGenericType (_type).GetMethod ("SaveImpl")); " is 123.
Long Statement,BTDB.FieldHandler,DBObjectFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\FieldHandler\DBObjectFieldHandler.cs,Save,The length of the statement  "	ilGenerator.Do (pushWriterOrCtx).Do (pushValue).Do (_objectDB.TypeConvertorGenerator.GenerateConversion (HandledType ()' typeof(object))).Callvirt (() => default(IWriterCtx).WriteNativeObject (null)); " is 200.
Long Statement,BTDB.IL.Caching,CachingILDynamicType,F:\newReposMay17\Bobris_BTDB\BTDB\IL\Caching\CachingILDynamicType.cs,Equals,The length of the statement  "	return _name == v._name && _baseType == v._baseType && _interfaces.SequenceEqual (v._interfaces) && _insts.SequenceEqual (v._insts' ReplayComparer.Instance); " is 157.
Long Statement,BTDB.IL,ILDynamicTypeImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILDynamicTypeImpl.cs,DefineConstructor,The length of the statement  "	return new ILConstructorImpl (_typeBuilder.DefineConstructor (MethodAttributes.Public' CallingConventions.Standard' parameters)' _forbidenInstructions); " is 152.
Long Statement,BTDB.IL,ILGenDebugImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenDebugImpl.cs,DeclareLocal,The length of the statement  "	_sourceCodeWriter.WriteLine (string.Format ("{3}{0} {1} // index {2}"' type.ToSimpleName ()' name' localBuilder.LocalIndex' pinned ? "pinned " : "")); " is 150.
Long Statement,BTDB.IL,ILGenDebugImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenDebugImpl.cs,Emit,The length of the statement  "	_sourceCodeWriter.MarkAndWriteLine (_ilGenerator' string.Format ("{0} {3} {1}({2})"' opCode' param.Name' FormatParams (param.GetParameters ())' param.ReturnType.ToSimpleName ())); " is 179.
Long Statement,BTDB.IL,ILGenDebugImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenDebugImpl.cs,Emit,The length of the statement  "	_sourceCodeWriter.MarkAndWriteLine (_ilGenerator' string.Format ("{0} {1} {3} {2}"' opCode' ilLocal.Index' ((ILLocalImpl)ilLocal).Name' ilLocal.LocalType.ToSimpleName ())); " is 172.
Long Statement,BTDB.IL,ILGenDebugImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenDebugImpl.cs,Ldftn,The length of the statement  "	_sourceCodeWriter.MarkAndWriteLine (_ilGenerator' string.Format ("{0} {2} {1}({3})"' OpCodes.Ldftn' mi.Name' meth.ReturnType.ToSimpleName ()' string.Join ("' "' meth.Parameters.Select (p => p.ToSimpleName ())))); " is 212.
Long Statement,BTDB.IL,ILDynamicMethodDebugImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILDynamicMethodDebugImpl.cs,CheckInPeVerify,The length of the statement  "	var nameInExeDirectory = Path.Combine (Path.GetDirectoryName (Path.GetDirectoryName (fullyQualifiedName))' Path.GetFileName (fullyQualifiedName)); " is 146.
Long Statement,BTDB.IL,ILDynamicMethodDebugImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILDynamicMethodDebugImpl.cs,CheckInPeVerify,The length of the statement  "	var additionalDlls = new List<string> (Assembly.ReflectionOnlyLoadFrom (nameInExeDirectory).GetReferencedAssemblies ().Select (a => a.Name + ".dll").Where (a => File.Exists (Path.Combine (DynamicILDirectoryPath.DynamicIL' a)))); " is 228.
Long Statement,BTDB.IL,SourceCodeWriter,F:\newReposMay17\Bobris_BTDB\BTDB\IL\SourceCodeWriter.cs,StartMethod,The length of the statement  "	StartMethod (name' mi.ReturnType' mi.GetParameters ().Select (p => p.ParameterType).ToArray ()' MethodAttributes.Static); " is 121.
Long Statement,BTDB.IL,SourceCodeWriter,F:\newReposMay17\Bobris_BTDB\BTDB\IL\SourceCodeWriter.cs,StartMethod,The length of the statement  "		WriteLine (String.Format ("{2}{0} {1}({3} arg{4})"' returns.ToSimpleName ()' name' before' parameters [0].ToSimpleName ()' firstArgIdx)); " is 137.
Long Statement,BTDB.IL,EmitHelpers,F:\newReposMay17\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,InheritsOrImplements,The length of the statement  "		currentChild = currentChild.BaseType != null && currentChild.BaseType.IsGenericType ? currentChild.BaseType.GetGenericTypeDefinition () : currentChild.BaseType; " is 160.
Long Statement,BTDB.IL,EmitHelpers,F:\newReposMay17\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,ToSimpleName,The length of the statement  "		return String.Format (type.Namespace == "System" ? "{1}<{2}>" : "{0}.{1}<{2}>"' type.Namespace' simpleName' String.Join ("'"' type.GetGenericArguments ().Select (p => p.ToSimpleName ()))); " is 188.
Long Statement,BTDB.IL,EmitHelpers,F:\newReposMay17\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateINotifyPropertyChangedImpl,The length of the statement  "	var fieldBuilder = typeBuilder.DefineField ("_propertyChanged"' typeof(PropertyChangedEventHandler)' FieldAttributes.Private); " is 126.
Long Statement,BTDB.IL,EmitHelpers,F:\newReposMay17\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateINotifyPropertyChangedImpl,The length of the statement  "	var eventBuilder = typeBuilder.DefineEvent ("PropertyChanged"' EventAttributes.None' typeof(PropertyChangedEventHandler)); " is 122.
Long Statement,BTDB.IL,EmitHelpers,F:\newReposMay17\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateINotifyPropertyChangedImpl,The length of the statement  "	ilGenerator.Ldarg (0).Ldfld (fieldBuilder).Stloc (0).Ldloc (0).BrfalseS (labelRet).Ldloc (0).Ldarg (0).Ldarg (1).Newobj (() => new PropertyChangedEventArgs (null)).Callvirt (() => default(PropertyChangedEventHandler).Invoke (null' null)).Mark (labelRet).Ret (); " is 261.
Long Statement,BTDB.IL,EmitHelpers,F:\newReposMay17\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateAddRemoveEvent,The length of the statement  "	}' MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.SpecialName | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Final); " is 167.
Long Statement,BTDB.IL,EmitHelpers,F:\newReposMay17\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateAddRemoveEvent,The length of the statement  "	ilGenerator.Ldarg (0).Ldfld (fieldBuilder).Stloc (0).Mark (label).Ldloc (0).Stloc (1).Ldloc (1).Ldarg (1).Call (add ? GetMethodInfo (() => Delegate.Combine (null' null)) : GetMethodInfo (() => Delegate.Remove (null' null))).Castclass (typePropertyChangedEventHandler).Stloc (2).Ldarg (0).Ldflda (fieldBuilder).Ldloc (2).Ldloc (1); " is 330.
Long Statement,BTDB.IL,EmitHelpers,F:\newReposMay17\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateAddRemoveEvent,The length of the statement  "	ilGenerator.Call (() => Interlocked.CompareExchange (ref stub' null' null)).Stloc (0).Ldloc (0).Ldloc (1).BneUnS (label).Ret (); " is 128.
Long Statement,BTDB.IL,EmitHelpers,F:\newReposMay17\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateAddRemoveEvent,The length of the statement  "	typeBuilder.DefineMethodOverride (methodBuilder' add ? eventPropertyChanged.GetAddMethod () : eventPropertyChanged.GetRemoveMethod ()); " is 135.
Long Statement,BTDB.IL,EmitHelpers,F:\newReposMay17\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateJumpIfEqual,The length of the statement  "	if (type == typeof(sbyte) || type == typeof(byte) || type == typeof(short) || type == typeof(ushort) || type == typeof(int) || type == typeof(uint) || type == typeof(long) || type == typeof(ulong) || type == typeof(float) || type == typeof(double) || type == typeof(bool) || type.IsEnum) { " is 289.
Long Statement,BTDB.IL,EmitHelpers,F:\newReposMay17\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateJumpIfEqual,The length of the statement  "			ilGenerator.Do (loadLeft).Stloc (localLeft).Do (loadRight).Stloc (localRight).Ldloca (localLeft).Call (hasValueMethod).BrtrueS (labelLeftHasValue).Ldloca (localRight).Call (hasValueMethod).BrtrueS (labelDifferent).BrS (jumpTo).Mark (labelLeftHasValue).Ldloca (localRight).Call (hasValueMethod).BrfalseS (labelDifferent); " is 320.
Long Statement,BTDB.IL,EmitHelpers,F:\newReposMay17\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateJumpIfEqual,The length of the statement  "			GenerateJumpIfEqual (ilGenerator' type.GetGenericArguments () [0]' jumpTo' g => g.Ldloca (localLeft).Call (getValueMethod)' g => g.Ldloca (localRight).Call (getValueMethod)); " is 174.
Long Statement,BTDB.IOC,ConstructorTraitImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\ConstructorTraitImpl.cs,ChooseConstructor,The length of the statement  "		return candidates.FirstOrDefault (ci => ci.GetParameters ().Select (pi => pi.ParameterType).SequenceEqual (_parameterTypes)); " is 125.
Long Statement,BTDB.IOC,ClosureOfObjBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\ClosureOfObjBuilder.cs,Build,The length of the statement  "		return Delegate.CreateDelegate (funcType' typeof(ClosureOfObj<>).MakeGenericType (methodInfo.ReturnType).GetConstructors () [0].Invoke (new[] { " is 143.
Long Statement,BTDB.IOC,ClosureOfObjBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\ClosureOfObjBuilder.cs,Build,The length of the statement  "	return Delegate.CreateDelegate (funcType' typeof(ClosureOfObj<' >).MakeGenericType (methodInfo.ReturnType' parameters [0].ParameterType).GetConstructors () [0].Invoke (new[] { " is 175.
Long Statement,BTDB.IOC,GenerationContext,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\GenerationContext.cs,PushToCycleDetector,The length of the statement  "		throw new InvalidOperationException ("Cycle detected in registrations: " + string.Join ("' "' _cycleDetectionStack.Select (t => t.Item2)) + ". Consider using Lazy<> to break cycle."); " is 183.
Long Statement,BTDB.IOC,MultiRegistration,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\MultiRegistration.cs,Register,The length of the statement  "			((IContanerRegistration)new SingleRegistration (type' _asTrait' _liveScopeTrait' _constructorTrait)).Register (context); " is 120.
Long Statement,BTDB.IOC,SingleRegistration,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\SingleRegistration.cs,Register,The length of the statement  "		reg = new SingletonImpl (_implementationType' new AlwaysNewImpl (_implementationType' bestConstructor)' context.SingletonCount); " is 128.
Long Statement,BTDB.IOC.CRegs,DelegateImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\CRegs\DelegateImpl.cs,GetNeeds,The length of the statement  "		var genCtx = new GenerationContext (context.Container' _nestedRegistration' buildContext' _type.GetMethod ("Invoke").GetParameters ()); " is 135.
Long Statement,BTDB.IOC.CRegs,FactoryImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\CRegs\FactoryImpl.cs,GenMain,The length of the statement  "	context.IL.Ldloc (localInstances).LdcI4 (_instanceIndex).LdelemRef ().Castclass (typeof(Func<object>)).Call (() => default(Func<object>).Invoke ()).Castclass (_type).Stloc (localInstance); " is 188.
Long Statement,BTDB.IOC.CRegs,FactoryWithContainerParamImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\CRegs\FactoryWithContainerParamImpl.cs,GenMain,The length of the statement  "	context.IL.Castclass (typeof(ContainerImpl)).Call (() => default(Func<ContainerImpl' object>).Invoke (null)).Castclass (_type).Stloc (localInstance); " is 149.
Long Statement,BTDB.IOC.CRegs,LazyImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\CRegs\LazyImpl.cs,GetNeeds,The length of the statement  "		_myNeed.Key = ((IObjectBuilder)typeof(ClosureOfLazy<>).MakeGenericType (resultType).GetConstructors () [0].Invoke (new object[0])).Build (() => context.Container.BuildFromRegistration (_nestedRegistration' context.BuildContext) ()); " is 232.
Long Statement,BTDB.IOC.CRegs,InstanceImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\CRegs\InstanceImpl.cs,GenMain,The length of the statement  "	context.IL.Ldloc (localInstances).LdcI4 (_instanceIndex).LdelemRef ().UnboxAny (_instance.GetType ()).Stloc (localInstance); " is 124.
Long Statement,BTDB.IOC.CRegs,SingletonImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\CRegs\SingletonImpl.cs,GenMain,The length of the statement  "	il.Ldloc (localSingletons).LdcI4 (_singletonIndex).LdelemRef ().Dup ().Castclass (safeImplementationType).Stloc (localSingleton).Brtrue (labelNull1).LdcI4 (0).Stloc (localLockTaken); " is 182.
Long Statement,BTDB.IOC.CRegs,SingletonImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\CRegs\SingletonImpl.cs,GenMain,The length of the statement  "	il.Castclass (typeof(ContainerImpl)).Ldfld (() => default(ContainerImpl).SingletonLocks).LdcI4 (_singletonIndex).LdelemRef ().Stloc (localLock).Try ().Ldloc (localLock).Ldloca (localLockTaken).Call (() => Monitor.Enter (null' ref boolPlaceholder)).Ldloc (localSingletons).LdcI4 (_singletonIndex).LdelemRef ().Dup ().Castclass (safeImplementationType).Stloc (localSingleton).Brtrue (labelNotNull2); " is 397.
Long Statement,BTDB.IOC.CRegs,SingletonImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\CRegs\SingletonImpl.cs,GenMain,The length of the statement  "	il.Stloc (localSingleton).Ldloc (localSingletons).LdcI4 (_singletonIndex).Ldloc (localSingleton).StelemRef ().Mark (labelNotNull2).Finally ().Ldloc (localLockTaken).BrfalseS (labelNotTaken).Ldloc (localLock).Call (() => Monitor.Exit (null)).Mark (labelNotTaken).EndTry ().Mark (labelNull1); " is 290.
Long Statement,BTDB.KVDBLayer.BTree,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,Find,The length of the statement  "		var result = BitArrayManipulation.CompareByteArray (prefix' prefix.Length' currentKey' Math.Min (currentKey.Length' prefix.Length)); " is 132.
Long Statement,BTDB.KVDBLayer.BTree,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,Find,The length of the statement  "			result = BitArrayManipulation.CompareByteArray (key.Buffer' key.Offset' key.Length' currentKey' prefix.Length' currentKey.Length - prefix.Length); " is 146.
Long Statement,BTDB.KVDBLayer.BTree,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,FindLastWithPrefix,The length of the statement  "		var result = BitArrayManipulation.CompareByteArray (prefix' prefix.Length' currentKey' Math.Min (currentKey.Length' prefix.Length)); " is 132.
Long Statement,BTDB.KVDBLayer.BTree,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,EraseRange,The length of the statement  "			firstPartialNode = _children [i].EraseRange (transactionId' firstKeyIndex - prevPairCount' lastKeyIndex - prevPairCount); " is 121.
Long Statement,BTDB.KVDBLayer.BTree,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,EraseRange,The length of the statement  "			firstPartialNode = _children [i].EraseRange (transactionId' firstKeyIndex - prevPairCount' nextPairCount - 1 - prevPairCount); " is 126.
Long Statement,BTDB.KVDBLayer.BTree,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,EraseRange,The length of the statement  "	var finalChildrenCount = firstRemoved - (firstPartialNode == null ? 1 : 0) + _children.Length + 1 - lastRemoved - (lastPartialNode == null ? 1 : 0) - (firstPartialNode == lastPartialNode && firstPartialNode != null ? 1 : 0); " is 224.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,Find,The length of the statement  "		var result = BitArrayManipulation.CompareByteArray (prefix' prefix.Length' currentKey' Math.Min (currentKey.Length' prefix.Length)); " is 132.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,Find,The length of the statement  "			result = BitArrayManipulation.CompareByteArray (key.Buffer' key.Offset' key.Length' currentKey' prefix.Length' currentKey.Length - prefix.Length); " is 146.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,CreateOrUpdate,The length of the statement  "		Array.Copy (_keyvalues' index' rightNode._keyvalues' index - keyCountLeft + 1' keyCountLeft + keyCountRight - 1 - index); " is 121.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,FindLastWithPrefix,The length of the statement  "		result = BitArrayManipulation.CompareByteArray (prefix' prefix.Length' currentKey' Math.Min (currentKey.Length' prefix.Length)); " is 128.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,FindLastWithPrefix,The length of the statement  "	result = BitArrayManipulation.CompareByteArray (prefix' prefix.Length' currentKey' Math.Min (currentKey.Length' prefix.Length)); " is 128.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,EraseRange,The length of the statement  "	Array.Copy (_keyvalues' (int)lastKeyIndex + 1' newKeyValues' (int)firstKeyIndex' newKeyValues.Length - (int)firstKeyIndex); " is 123.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,Find,The length of the statement  "		var result = BitArrayManipulation.CompareByteArray (prefix' 0' prefix.Length' keyBytes' currentKeyOfs' Math.Min (currentKeyLen' prefix.Length)); " is 144.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,Find,The length of the statement  "			result = BitArrayManipulation.CompareByteArray (key.Buffer' key.Offset' key.Length' keyBytes' currentKeyOfs + prefix.Length' currentKeyLen - prefix.Length); " is 156.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,CreateOrUpdate,The length of the statement  "		Array.Copy (_keyBytes' ofs + leftKeyBytesLen' newKeyBytes' ofs + newKey.Length' _keyBytes.Length - ofs - leftKeyBytesLen); " is 122.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,CreateOrUpdate,The length of the statement  "		Array.Copy (_keyvalues' index' rightNode._keyvalues' index - keyCountLeft + 1' keyCountLeft + keyCountRight - 1 - index); " is 121.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,FindLastWithPrefix,The length of the statement  "		result = BitArrayManipulation.CompareByteArray (prefix' 0' prefix.Length' keyBytes' currentKeyOfs' Math.Min (currentKeyLen' prefix.Length)); " is 140.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,FindLastWithPrefix,The length of the statement  "	result = BitArrayManipulation.CompareByteArray (prefix' 0' prefix.Length' keyBytes' currentKeyOfs' Math.Min (currentKeyLen' prefix.Length)); " is 140.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,EraseRange,The length of the statement  "	var newKeyBytes = new byte[_keyBytes.Length + _keyvalues [firstKeyIndex].KeyOffset - _keyvalues [lastKeyIndex].KeyOffset - _keyvalues [lastKeyIndex].KeyLength]; " is 160.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,EraseRange,The length of the statement  "	Array.Copy (_keyvalues' (int)lastKeyIndex + 1' newKeyValues' (int)firstKeyIndex' newKeyValues.Length - (int)firstKeyIndex); " is 123.
Long Statement,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,EraseRange,The length of the statement  "	Array.Copy (_keyBytes' _keyvalues [lastKeyIndex].KeyOffset + _keyvalues [lastKeyIndex].KeyLength' newKeyBytes' _keyvalues [firstKeyIndex].KeyOffset' newKeyBytes.Length - _keyvalues [firstKeyIndex].KeyOffset); " is 208.
Long Statement,BTDB.KVDBLayer.BTree,BTreeRoot,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeRoot.cs,CreateOrUpdate,The length of the statement  "		_rootNode = ctx.WholeKeyLen > BTreeLeafComp.MaxTotalLen ? BTreeLeaf.CreateFirst (ctx) : BTreeLeafComp.CreateFirst (ctx); " is 120.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,Find,The length of the statement  "		var result = BitArrayManipulation.CompareByteArray (prefix' prefix.Length' currentKey' Math.Min (currentKey.Length' prefix.Length)); " is 132.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,Find,The length of the statement  "			result = BitArrayManipulation.CompareByteArray (key.Buffer' key.Offset' key.Length' currentKey' prefix.Length' currentKey.Length - prefix.Length); " is 146.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,FindLastWithPrefix,The length of the statement  "		var result = BitArrayManipulation.CompareByteArray (prefix' prefix.Length' currentKey' Math.Min (currentKey.Length' prefix.Length)); " is 132.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,EraseRange,The length of the statement  "			firstPartialNode = _children [i].EraseRange (transactionId' firstKeyIndex - prevPairCount' lastKeyIndex - prevPairCount); " is 121.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,EraseRange,The length of the statement  "			firstPartialNode = _children [i].EraseRange (transactionId' firstKeyIndex - prevPairCount' nextPairCount - 1 - prevPairCount); " is 126.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,EraseRange,The length of the statement  "	var finalChildrenCount = firstRemoved - (firstPartialNode == null ? 1 : 0) + _children.Length + 1 - lastRemoved - (lastPartialNode == null ? 1 : 0) - (firstPartialNode == lastPartialNode && firstPartialNode != null ? 1 : 0); " is 224.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,Find,The length of the statement  "		var result = BitArrayManipulation.CompareByteArray (prefix' prefix.Length' currentKey' Math.Min (currentKey.Length' prefix.Length)); " is 132.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,Find,The length of the statement  "			result = BitArrayManipulation.CompareByteArray (key.Buffer' key.Offset' key.Length' currentKey' prefix.Length' currentKey.Length - prefix.Length); " is 146.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,CreateOrUpdate,The length of the statement  "		Array.Copy (_keyvalues' index' rightNode._keyvalues' index - keyCountLeft + 1' keyCountLeft + keyCountRight - 1 - index); " is 121.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,FindLastWithPrefix,The length of the statement  "		result = BitArrayManipulation.CompareByteArray (prefix' prefix.Length' currentKey' Math.Min (currentKey.Length' prefix.Length)); " is 128.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,FindLastWithPrefix,The length of the statement  "	result = BitArrayManipulation.CompareByteArray (prefix' prefix.Length' currentKey' Math.Min (currentKey.Length' prefix.Length)); " is 128.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,EraseRange,The length of the statement  "	Array.Copy (_keyvalues' (int)lastKeyIndex + 1' newKeyValues' (int)firstKeyIndex' newKeyValues.Length - (int)firstKeyIndex); " is 123.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,Find,The length of the statement  "		var result = BitArrayManipulation.CompareByteArray (prefix' 0' prefix.Length' keyBytes' currentKeyOfs' Math.Min (currentKeyLen' prefix.Length)); " is 144.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,Find,The length of the statement  "			result = BitArrayManipulation.CompareByteArray (key.Buffer' key.Offset' key.Length' keyBytes' currentKeyOfs + prefix.Length' currentKeyLen - prefix.Length); " is 156.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,The length of the statement  "		Array.Copy (_keyBytes' ofs + leftKeyBytesLen' newKeyBytes' ofs + newKey.Length' _keyBytes.Length - ofs - leftKeyBytesLen); " is 122.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,The length of the statement  "		Array.Copy (_keyvalues' index' rightNode._keyvalues' index - keyCountLeft + 1' keyCountLeft + keyCountRight - 1 - index); " is 121.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,FindLastWithPrefix,The length of the statement  "		result = BitArrayManipulation.CompareByteArray (prefix' 0' prefix.Length' keyBytes' currentKeyOfs' Math.Min (currentKeyLen' prefix.Length)); " is 140.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,FindLastWithPrefix,The length of the statement  "	result = BitArrayManipulation.CompareByteArray (prefix' 0' prefix.Length' keyBytes' currentKeyOfs' Math.Min (currentKeyLen' prefix.Length)); " is 140.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,EraseRange,The length of the statement  "	var newKeyBytes = new byte[_keyBytes.Length + _keyvalues [firstKeyIndex].KeyOffset - _keyvalues [lastKeyIndex].KeyOffset - _keyvalues [lastKeyIndex].KeyLength]; " is 160.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,EraseRange,The length of the statement  "	Array.Copy (_keyvalues' (int)lastKeyIndex + 1' newKeyValues' (int)firstKeyIndex' newKeyValues.Length - (int)firstKeyIndex); " is 123.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,EraseRange,The length of the statement  "	Array.Copy (_keyBytes' _keyvalues [lastKeyIndex].KeyOffset + _keyvalues [lastKeyIndex].KeyLength' newKeyBytes' _keyvalues [firstKeyIndex].KeyOffset' newKeyBytes.Length - _keyvalues [firstKeyIndex].KeyOffset); " is 208.
Long Statement,BTDB.KVDBLayer.BTreeMem,BTreeRoot,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeRoot.cs,CreateOrUpdate,The length of the statement  "		_rootNode = ctx.WholeKeyLen > BTreeLeafComp.MaxTotalLen ? BTreeLeaf.CreateFirst (ctx) : BTreeLeafComp.CreateFirst (ctx); " is 120.
Long Statement,BTDB.KVDBLayer,Compactor,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,Run,The length of the statement  "	var btreesCorrectInTransactionId = _keyValueDB.AtomicallyChangeBTree (root => root.RemappingIterate ((uint oldFileId' uint oldOffset' out uint newFileId' out uint newOffset) => { " is 178.
Long Statement,BTDB.KVDBLayer,FileCollectionWithFileInfos,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\FileCollectionWithFileInfos.cs,SkipHeader,The length of the statement  "	var withGuid = BitArrayManipulation.CompareByteArray (magic' magic.Length' MagicStartOfFileWithGuid' MagicStartOfFileWithGuid.Length) == 0; " is 139.
Long Statement,BTDB.KVDBLayer,FileCollectionWithFileInfos,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\FileCollectionWithFileInfos.cs,LoadInfoAboutFiles,The length of the statement  "			if (BitArrayManipulation.CompareByteArray (magic' magic.Length' MagicStartOfFileWithGuid' MagicStartOfFileWithGuid.Length) == 0) { " is 130.
Long Statement,BTDB.KVDBLayer,FileCollectionWithFileInfos,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\FileCollectionWithFileInfos.cs,LoadInfoAboutFiles,The length of the statement  "			} else if (BitArrayManipulation.CompareByteArray (magic' magic.Length' MagicStartOfFile' MagicStartOfFile.Length) != 0) { " is 121.
Long Statement,BTDB.KVDBLayer,FileCollectionWithFileInfos,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\FileCollectionWithFileInfos.cs,DeleteAllUnknownFiles,The length of the statement  "	foreach (var fileId in _fileInfos.Where (fi => fi.Value.FileType == KVFileType.Unknown).Select (fi => fi.Key).ToArray ()) { " is 123.
Long Statement,BTDB.KVDBLayer,InMemoryKeyValueDBTransaction,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\MemoryImplementation\InMemoryKeyValueDBTransaction.cs,CalcPrefixKeyStart,The length of the statement  "	if (BtreeRoot.FindKey (new List<NodeIdxPair> ()' out _prefixKeyStart' _prefix' ByteBuffer.NewEmpty ()) == FindResult.NotFound) { " is 128.
Long Statement,BTDB.KVDBLayer,InMemoryKeyValueDBTransaction,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\MemoryImplementation\InMemoryKeyValueDBTransaction.cs,GetStorageSizeOfCurrentKey,The length of the statement  "	return new KeyValuePair<uint' uint> ((uint)((IBTreeLeafNode)nodeIdxPair.Node).GetKey (nodeIdxPair.Idx).Length' (uint)((IBTreeLeafNode)nodeIdxPair.Node).GetMemberValue (nodeIdxPair.Idx).Length); " is 193.
Long Statement,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadInfoAboutFiles,The length of the statement  "	if (lastestTrLogFileId != firstTrLogId && firstTrLogId != 0 || !hasKeyIndex && _fileCollection.FileInfos.Any (p => p.Value.SubDBId == 0)) { " is 139.
Long Statement,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,CreateIndexFile,The length of the statement  "	MarkAsUnknown (_fileCollection.FileInfos.Where (p => p.Value.FileType == KVFileType.KeyIndex && p.Key != idxFileId).Select (p => p.Key)); " is 137.
Long Statement,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The length of the statement  "		valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24); " is 160.
Long Statement,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,CalcStats,The length of the statement  "	var sb = new StringBuilder ("KeyValueCount:" + LastCommited.CalcKeyCount () + Environment.NewLine + "FileCount:" + FileCollection.GetCount () + Environment.NewLine + "FileGeneration:" + FileCollection.LastFileGeneration + Environment.NewLine); " is 243.
Long Statement,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,CalcStats,The length of the statement  "		sb.AppendFormat ("{0} Size:{1} Type:{2} Gen:{3}{4}"' file.Key' FileCollection.GetSize (file.Key)' file.Value.FileType' file.Value.Generation' Environment.NewLine); " is 163.
Long Statement,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,WriteStartOfNewTransactionLogFile,The length of the statement  "	var transactionLog = new FileTransactionLog (FileCollection.NextGeneration ()' FileCollection.Guid' _fileIdWithPreviousTransactionLog); " is 135.
Long Statement,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,CreateKeyIndexFile,The length of the statement  "	var keyIndex = new FileKeyIndex (FileCollection.NextGeneration ()' FileCollection.Guid' root.TrLogFileId' root.TrLogOffset' keyCount' root.CommitUlong' KeyIndexCompression.None); " is 178.
Long Statement,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,DistanceFromLastKeyIndex,The length of the statement  "	var keyIndex = FileCollection.FileInfos.Where (p => p.Value.FileType == KVFileType.KeyIndex).Select (p => (IKeyIndex)p.Value).FirstOrDefault (); " is 144.
Long Statement,BTDB.KVDBLayer,KeyValueDBTransaction,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDBTransaction.cs,CalcPrefixKeyStart,The length of the statement  "	if (BtreeRoot.FindKey (new List<NodeIdxPair> ()' out _prefixKeyStart' _prefix' ByteBuffer.NewEmpty ()) == FindResult.NotFound) { " is 128.
Long Statement,BTDB.KVDBLayer,KeyValueDBTransaction,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDBTransaction.cs,SetValue,The length of the statement  "	_keyValueDB.WriteCreateOrUpdateCommand (BitArrayManipulation.EmptyByteArray' memberKey' value' out memberValue.ValueFileId' out memberValue.ValueOfs' out memberValue.ValueSize); " is 177.
Long Statement,BTDB.KVDBLayer,KeyValueDBTransaction,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDBTransaction.cs,GetStorageSizeOfCurrentKey,The length of the statement  "	return new KeyValuePair<uint' uint> ((uint)((IBTreeLeafNode)nodeIdxPair.Node).GetKey (nodeIdxPair.Idx).Length' _keyValueDB.CalcValueSize (leafMember.ValueFileId' leafMember.ValueOfs' leafMember.ValueSize)); " is 206.
Long Statement,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The length of the statement  "	if (tempbuf [0] != 'B' || tempbuf [1] != 'T' || tempbuf [2] != 'D' || tempbuf [3] != 'B' || tempbuf [4] != 'E' || tempbuf [5] != 'X' || tempbuf [6] != 'P' || tempbuf [7] != '2') { " is 179.
Long Statement,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The length of the statement  "		transaction.CreateOrUpdateKeyValue (ByteBuffer.NewSync (tempbuf' 0' keySize)' ByteBuffer.NewSync (tempbuf2' 0' valueSize)); " is 123.
Long Statement,BTDB.KVDBLayer,PtrLenList,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryExclude,The length of the statement  "				_list [m + 1] = new KeyValuePair<ulong' ulong> (excludePos + excludeLen' cur.Key + cur.Value - excludePos - excludeLen); " is 120.
Long Statement,BTDB.KVDBLayer,PtrLenList,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryInclude,The length of the statement  "			_list [m] = new KeyValuePair<ulong' ulong> (cur.Key' Math.Max (lastOk.Key + lastOk.Value' includePos + includeLen) - cur.Key); " is 126.
Long Statement,BTDB.KVDBLayer,PtrLenList,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryInclude,The length of the statement  "	_list [l] = new KeyValuePair<ulong' ulong> (includePos' Math.Max (cur.Key + cur.Value' includePos + includeLen) - includePos); " is 126.
Long Statement,BTDB.ODBLayer,ODBDictionary,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,FreeContent,The length of the statement  "		var method = ILBuilder.Instance.NewMethod<Action<IInternalObjectDBTransaction' AbstractBufferedReader' IList<ulong>' IList<ulong>>> (); " is 135.
Long Statement,BTDB.ODBLayer,ODBDictionary,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,FreeContent,The length of the statement  "		ilGenerator.Ldarg (0).Ldarg (1).Ldarg (2).Ldarg (3).Newobj (() => new DBReaderWithFreeInfoCtx (null' null' null' null)).Stloc (readerLoc); " is 138.
Long Statement,BTDB.ODBLayer,ODBDictionary,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,FreeContent,The length of the statement  "	var findIDictAction = (Action<IInternalObjectDBTransaction' AbstractBufferedReader' IList<ulong>' IList<ulong>>)config.FreeContent; " is 131.
Long Statement,BTDB.ODBLayer,ODBDictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionaryFieldHandler.cs,CreateWriter,The length of the statement  "	fieldHandler.Save (ilGenerator' pushWriterOrCtx' il => il.Ldarg (0).Do (_typeConvertorGenerator.GenerateConversion (realType' fieldHandler.HandledType ()))); " is 157.
Long Statement,BTDB.ODBLayer,ODBDictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionaryFieldHandler.cs,Load,The length of the statement  "	ilGenerator.Do (pushReaderOrCtx).Castclass (typeof(IDBReaderCtx)).Callvirt (() => default(IDBReaderCtx).GetTransaction ()).Do (pushReaderOrCtx).Castclass (typeof(IDBReaderCtx)).LdcI4 (_configurationId).Callvirt (() => default(IDBReaderCtx).FindInstance (0)).Castclass (typeof(ODBDictionaryConfiguration)).Do (Extensions.PushReaderFromCtx (pushReaderOrCtx)).Callvirt (() => default(AbstractBufferedReader).ReadVUInt64 ()).Newobj (constructorInfo).Castclass (_type); " is 464.
Long Statement,BTDB.ODBLayer,ODBDictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionaryFieldHandler.cs,Init,The length of the statement  "	ilGenerator.Do (pushReaderCtx).Castclass (typeof(IDBReaderCtx)).Callvirt (() => default(IDBReaderCtx).GetTransaction ()).Do (pushReaderCtx).Castclass (typeof(IDBReaderCtx)).LdcI4 (_configurationId).Callvirt (() => default(IDBReaderCtx).FindInstance (0)).Castclass (typeof(ODBDictionaryConfiguration)).Newobj (constructorInfo).Castclass (_type); " is 344.
Long Statement,BTDB.ODBLayer,ODBDictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionaryFieldHandler.cs,Skip,The length of the statement  "	ilGenerator.Do (Extensions.PushReaderFromCtx (pushReaderOrCtx)).Callvirt (() => default(AbstractBufferedReader).SkipVUInt64 ()); " is 128.
Long Statement,BTDB.ODBLayer,ODBDictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionaryFieldHandler.cs,SpecializeLoadForType,The length of the statement  "	if (wantedKeyHandler == specializedKeyHandler && (wantedValueHandler == specializedValueHandler || wantedValueHandler.HandledType () == specializedValueHandler.HandledType ())) { " is 178.
Long Statement,BTDB.ODBLayer,ODBDictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionaryFieldHandler.cs,SpecializeLoadForType,The length of the statement  "	var res = new ODBDictionaryFieldHandler (_odb' _configuration' _configurationId' specializedKeyHandler' specializedValueHandler); " is 129.
Long Statement,BTDB.ODBLayer,ODBDictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionaryFieldHandler.cs,GenerateType,The length of the statement  "		return _type = typeof(IOrderedDictionary<' >).MakeGenericType (_keysHandler.HandledType ()' _valuesHandler.HandledType ()); " is 123.
Long Statement,BTDB.ODBLayer,ODBDictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionaryFieldHandler.cs,FreeContent,The length of the statement  "		ilGenerator.Do (pushReaderOrCtx).Castclass (typeof(IDBReaderCtx)).Do (Extensions.PushReaderFromCtx (pushReaderOrCtx)).Callvirt (() => default(AbstractBufferedReader).ReadVUInt64 ()).Callvirt (() => default(IDBReaderCtx).RegisterDict (0ul)); " is 240.
Long Statement,BTDB.ODBLayer,ODBDictionaryFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionaryFieldHandler.cs,FreeContent,The length of the statement  "		ilGenerator.Do (pushReaderOrCtx).Castclass (typeof(IDBReaderCtx)).Do (Extensions.PushReaderFromCtx (pushReaderOrCtx)).Callvirt (() => default(AbstractBufferedReader).ReadVUInt64 ()).Stloc (dictId).Ldloc (dictId).Callvirt (() => default(IDBReaderCtx).RegisterDict (0ul)).Do (pushReaderOrCtx).Ldloc (dictId).LdcI4 (_configurationId).Call (instanceType.GetMethod ("DoFreeContent")); " is 379.
Long Statement,BTDB.ODBLayer,ODBIterator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,Iterate,The length of the statement  "		if (_visitor != null && !_visitor.VisitSingleton (singleton.Key' _tableId2Name.TryGetValue (singleton.Key' out name) ? name : null' singleton.Value)) " is 149.
Long Statement,BTDB.ODBLayer,ODBIterator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,IterateOid,The length of the statement  "	if (_visitor != null && !_visitor.StartObject (oid' tableId' _tableId2Name.TryGetValue (tableId' out tableName) ? tableName : null' version)) " is 141.
Long Statement,BTDB.ODBLayer,ODBIterator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,IterateHandler,The length of the statement  "			var skip = skipping || _visitor != null && !_visitor.StartInlineObject (tableId' _tableId2Name.TryGetValue (tableId' out tableName) ? tableName : null' version); " is 161.
Long Statement,BTDB.ODBLayer,ODBIterator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,LoadTableNamesDict,The length of the statement  "	_tableId2Name = ObjectDB.LoadTablesEnum (_tr.KeyValueDBTransaction).ToDictionary (pair => pair.Key' pair => pair.Value); " is 120.
Long Statement,BTDB.ODBLayer,ODBIterator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBIterator.cs,LoadRelationNamesDict,The length of the statement  "	_relationId2Name = ObjectDB.LoadRelationNamesEnum (_tr.KeyValueDBTransaction).ToDictionary (pair => pair.Key' pair => pair.Value); " is 130.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The length of the statement  "		var reqMethod = classImpl.DefineMethod ("_R_" + method.Name' method.ReturnType' method.GetParameters ().Select (pi => pi.ParameterType).ToArray ()' MethodAttributes.Virtual | MethodAttributes.Public); " is 200.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The length of the statement  "			SaveKeyBytesAndCallMethod (reqMethod.Generator' relationDBManipulatorType' method.Name' method.GetParameters ()' method.ReturnType' _relationInfo.ApartFields); " is 159.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The length of the statement  "			var field = _relationInfo.ClientRelationVersionInfo.GetPrimaryKeyFields ().Skip (_relationInfo.ApartFields.Count + prefixParamCount).First (); " is 142.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The length of the statement  "			reqMethod.Generator.LdcI4 (prefixParamCount + _relationInfo.ApartFields.Count).Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("Order")).Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("StartProposition")); " is 222.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The length of the statement  "			FillBufferWhenNotIgnoredKeyPropositionIl (advEnumParamOrder' field' emptyBufferLoc' advEnumParam.GetField ("Start")' reqMethod.Generator); " is 138.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The length of the statement  "			FillBufferWhenNotIgnoredKeyPropositionIl (advEnumParamOrder' field' emptyBufferLoc' advEnumParam.GetField ("End")' reqMethod.Generator); " is 136.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The length of the statement  "			} else if (typeof(IOrderedDictionaryEnumerator<' >).MakeGenericType (advEnumParamType' _relationInfo.ClientType).IsAssignableFrom (method.ReturnType)) { " is 152.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The length of the statement  "				var enumType = typeof(RelationAdvancedOrderedEnumerator<' >).MakeGenericType (advEnumParamType' _relationInfo.ClientType); " is 122.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The length of the statement  "		} else if (method.Name.StartsWith ("ListBy"' StringComparison.Ordinal))//ListBy{Name}(tenantId' ..' AdvancedEnumeratorParam) " is 124.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The length of the statement  "			var field = _relationInfo.ClientRelationVersionInfo.GetSecondaryKeyFields (secondaryKeyIndex).Skip (_relationInfo.ApartFields.Count + prefixParamCount).First (); " is 161.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The length of the statement  "			SaveListPrefixBytes (secondaryKeyIndex' reqMethod.Generator' method.Name' method.GetParameters ()' _relationInfo.ApartFields); " is 126.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The length of the statement  "			reqMethod.Generator.LdcI4 (prefixParamCount + _relationInfo.ApartFields.Count).Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("Order")).Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("StartProposition")); " is 222.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The length of the statement  "			FillBufferWhenNotIgnoredKeyPropositionIl (advEnumParamOrder' field' emptyBufferLoc' advEnumParam.GetField ("Start")' reqMethod.Generator); " is 138.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The length of the statement  "			FillBufferWhenNotIgnoredKeyPropositionIl (advEnumParamOrder' field' emptyBufferLoc' advEnumParam.GetField ("End")' reqMethod.Generator); " is 136.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The length of the statement  "			} else if (typeof(IOrderedDictionaryEnumerator<' >).MakeGenericType (advEnumParamType' _relationInfo.ClientType).IsAssignableFrom (method.ReturnType)) { " is 152.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The length of the statement  "				var enumType = typeof(RelationAdvancedOrderedSecondaryKeyEnumerator<' >).MakeGenericType (advEnumParamType' _relationInfo.ClientType); " is 134.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The length of the statement  "				reqMethod.Generator.Brtrue (returnedTrueLabel).Ldstr ("Trying to insert duplicate key.").Newobj (() => new BTDBException (null)).Throw ().Mark (returnedTrueLabel); " is 163.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,BuildRelationCreatorInstance,The length of the statement  "	var methodBuilder = ILBuilder.Instance.NewMethod ("RelationFactory" + relationName' typeof(Func<IObjectDBTransaction' T>)' typeof(RelationInfo)); " is 145.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,SaveKeyBytesAndCallMethod,The length of the statement  "		CreateMethodRemoveById (ilGenerator' relationDBManipulatorType' methodName' methodParameters' methodReturnType' apartFields' pushWriter' writerLoc); " is 148.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,SaveKeyBytesAndCallMethod,The length of the statement  "		CreateMethodFindById (ilGenerator' relationDBManipulatorType' methodName' methodParameters' methodReturnType' apartFields' pushWriter' writerLoc); " is 146.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,SaveKeyBytesAndCallMethod,The length of the statement  "		CreateMethodFindBy (ilGenerator' relationDBManipulatorType' methodName' methodParameters' methodReturnType' apartFields' pushWriter' writerLoc); " is 144.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,SaveKeyBytesAndCallMethod,The length of the statement  "		CreateMethodListById (ilGenerator' relationDBManipulatorType' methodName' methodParameters' apartFields' pushWriter' writerLoc); " is 128.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodFindById,The length of the statement  "	var count = SaveMethodParameters (ilGenerator' methodName' methodParameters' methodParameters.Length' apartFields' primaryKeyFields' writerLoc); " is 144.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodRemoveById,The length of the statement  "	var count = SaveMethodParameters (ilGenerator' methodName' methodParameters' methodParameters.Length' apartFields' primaryKeyFields' writerLoc); " is 144.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodFindBy,The length of the statement  "	SaveMethodParameters (ilGenerator' methodName' methodParameters' methodParameters.Length' apartFields' secondaryKeyFields' writerLoc); " is 134.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodFindBy,The length of the statement  "	//call public T FindBySecondaryKeyOrDefault(uint secondaryKeyIndex' uint prefixParametersCount' ByteBuffer secKeyBytes' bool throwWhenNotFound) " is 143.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,ReturnsEnumerableOfClientType,The length of the statement  "	return methodReturnType.IsGenericType && methodReturnType.GetGenericTypeDefinition () == typeof(IEnumerator<>) && methodReturnType.GetGenericArguments () [0] == clientType; " is 172.
Long Statement,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodListById,The length of the statement  "	var paramsCount = SaveMethodParameters (ilGenerator' methodName' methodParameters' methodParameters.Length' apartFields' primaryKeyFields' writerLoc); " is 150.
Long Statement,BTDB.ODBLayer,RelationDBManipulator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,CreateInstanceFromSK,The length of the statement  "	_relationInfo.GetSKKeyValuetoPKMerger (secondaryKeyIndex' fieldInFirstBufferCount) (firstPart.ToByteArray ()' secondPart.ToByteArray ()' pkWriter); " is 147.
Long Statement,BTDB.ODBLayer,RelationDBManipulator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,FindBySecondaryKey,The length of the statement  "	return new RelationSecondaryKeyEnumerator<T> (_transaction' _relationInfo' keyWriter.Data.ToAsyncSafe ()' secondaryKeyIndex' prefixFieldCount' this); " is 149.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CalculateSecondaryKey,The length of the statement  "	var enumerator = (IEnumerator)Activator.CreateInstance (enumeratorType' tr' this' keyWriter.GetDataAndRewind ().ToAsyncSafe ()' new SimpleModificationCounter ()); " is 162.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateSaverWithApartFields,The length of the statement  "	var method = ILBuilder.Instance.NewMethod<Action<IInternalObjectDBTransaction' AbstractBufferedWriter' object' object>> (saverName); " is 132.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateSaverWithApartFields,The length of the statement  "	CreateSaverIl (ilGenerator' fields' il => il.Ldloc (0)' hasApartFields ? il => il.Ldloc (1) : (Action<IILGen>)null' il => il.Ldarg (1)' il => il.Ldarg (0)); " is 156.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateSaver,The length of the statement  "	var method = ILBuilder.Instance.NewMethod<Action<IInternalObjectDBTransaction' AbstractBufferedWriter' object>> (saverName); " is 124.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateVersionInfoByReflection,The length of the statement  "			var fieldInfo = TableFieldInfo.Build (Name' pi' _relationInfoResolver.FieldHandlerFactory' FieldHandlerOptions.Orderable); " is 122.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateVersionInfoByReflection,The length of the statement  "					secondaryKeyFields.Add (TableFieldInfo.Build (Name' pi' _relationInfoResolver.FieldHandlerFactory' FieldHandlerOptions.Orderable)); " is 131.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateVersionInfoByReflection,The length of the statement  "	return new RelationVersionInfo (primaryKeys' secondaryKeys' secondaryKeyFields.ToArray ()' fields.ToArray ()' prevVersion); " is 123.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,GetPrimaryKeysLoader,The length of the statement  "	return _primaryKeysLoaders.GetOrAdd (version' ver => CreateLoader (ver' _relationVersions [version].GetPrimaryKeyFields ())); " is 125.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,GetSecondaryKeysKeySaver,The length of the statement  "	return _secondaryKeysSavers.GetOrAdd (secondaryKeyIndex' idx => CreateSaverWithApartFields (ClientRelationVersionInfo.GetSecondaryKeyFields (secondaryKeyIndex))); " is 162.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,GetSecondaryKeysValueSaver,The length of the statement  "	return _secondaryKeysValueSavers.GetOrAdd (secondaryKeyIndex' idx => CreateSaverWithApartFields (ClientRelationVersionInfo.GetSecondaryKeyValueKeys (secondaryKeyIndex))); " is 170.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,GetSKKeyValuetoPKMerger,The length of the statement  "	return _secondaryKeyValuetoPKLoader.GetOrAdd (h' idx => CreatePrimaryKeyFromSKDataMerger (secondaryKeyIndex' (int)paramFieldCountInFirstBuffer)); " is 145.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreatePrimaryKeyFromSKDataMerger,The length of the statement  "			CopyFromBuffer (ilGenerator' bufferIdx' skFieldIdx' ref firstBuffer' outOfOrderPKParts' pks' skFields' positionLoc' memoPositionLoc' pushWriter); " is 145.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreatePrimaryKeyFromSKDataMerger,The length of the statement  "			CopyFromBuffer (ilGenerator' bufferIdx' skFieldIdx' ref secondBuffer' outOfOrderPKParts' pks' skFields' positionLoc' memoPositionLoc' pushWriter); " is 146.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CopyFromBuffer,The length of the statement  "			outOfOrderPKParts [(int)field.Index] = SkipWithMemorizing (bufferIdx' ilGenerator' bi.PushReader' pks [(int)field.Index].Handler' positionLoc); " is 143.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CopyFromBuffer,The length of the statement  "	GenerateCopyFieldFromByteBufferToWriterIl (ilGenerator' pks [(int)skField.Index].Handler' bi.PushReader' pushWriter' positionLoc' memoPositionLoc); " is 147.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,MergerInitializeFirstBufferReader,The length of the statement  "	ilGenerator.Do (bi.PushReader).LdcI4 (ObjectDB.AllRelationsSKPrefix.Length).Callvirt (() => default(ByteArrayReader).SkipBlock (0)).Do (bi.PushReader).Call (() => default(ByteArrayReader).SkipVUInt32 ()).Do (bi.PushReader).Call (() => default(ByteArrayReader).SkipVUInt32 ()); " is 276.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,SkipWithMemorizing,The length of the statement  "	ilGenerator.Do (pushReader).Callvirt (() => default(ByteArrayReader).GetCurrentPosition ()).Ldloc (tempPosition).Sub ().ConvI4 ().Stloc (memoLen); " is 146.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CopyFromMemorizedPosition,The length of the statement  "	ilGenerator.Do (pushWriter).Do (pushReader).Ldloc (memo.Length).Ldloc (memo.Pos).Callvirt (() => default(IMemorizedPosition).Restore ()).Call (() => default(ByteArrayReader).ReadByteArrayRaw (0)).Call (() => default(AbstractBufferedWriter).WriteByteArrayRaw (null)).Ldloc (memoPositionLoc).Callvirt (() => default(IMemorizedPosition).Restore ()); " is 346.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,GenerateCopyFieldFromByteBufferToWriterIl,The length of the statement  "	ilGenerator.Do (pushWriter).Do (pushReader).Dup ().Callvirt (() => default(ByteArrayReader).GetCurrentPosition ()).Ldloc (positionLoc).Sub ().ConvI4 ().Ldloc (memoPositionLoc).Callvirt (() => default(IMemorizedPosition).Restore ()).Call (() => default(ByteArrayReader).ReadByteArrayRaw (0)).Call (() => default(AbstractBufferedWriter).WriteByteArrayRaw (null)); " is 361.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateSimpleLoader,The length of the statement  "	var delegateType = typeof(Func<' ' >).MakeGenericType (typeof(AbstractBufferedReader)' typeof(IReaderCtx)' loaderType.RealType); " is 128.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateSimpleLoader,The length of the statement  "	ilGenerator.Do (_typeConvertorGenerator.GenerateConversion (loaderType.FieldHandler.HandledType ()' loaderType.RealType)).Ret (); " is 129.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateLoader,The length of the statement  "	var method = ILBuilder.Instance.NewMethod<Action<IInternalObjectDBTransaction' AbstractBufferedReader' object>> (loaderName); " is 125.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateLoader,The length of the statement  "			var converterGenerator = _relationInfoResolver.TypeConvertorGenerator.GenerateConversion (willLoad' setterMethod.GetParameters () [0].ParameterType); " is 149.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateIDictFinder,The length of the statement  "	var method = ILBuilder.Instance.NewMethod<Action<IInternalObjectDBTransaction' AbstractBufferedReader' IList<ulong>' IList<ulong>>> (); " is 135.
Long Statement,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateIDictFinder,The length of the statement  "		ilGenerator.Ldarg (0).Ldarg (1).Ldarg (2).Ldarg (3).Newobj (() => new DBReaderWithFreeInfoCtx (null' null' null' null)).Stloc (0); " is 130.
Long Statement,BTDB.ODBLayer,RelationPrimaryKeyEnumerator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,GetKeyBytes,The length of the statement  "	keyWriter.WriteBlock (KeyBytes.Buffer' KeyBytes.Offset + ObjectDB.AllRelationsPKPrefix.Length' KeyBytes.Length - ObjectDB.AllRelationsPKPrefix.Length); " is 151.
Long Statement,BTDB.ODBLayer,RelationAdvancedEnumerator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,CreateInstance,The length of the statement  "	writer.WriteBlock (_keyBytes.Buffer' _keyBytes.Offset + _lengthOfNonDataPrefix' _keyBytes.Length - _lengthOfNonDataPrefix); " is 123.
Long Statement,BTDB.ODBLayer,RelationAdvancedOrderedEnumerator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationEnumerator.cs,CreateInstance,The length of the statement  "	writer.WriteBlock (_keyBytes.Buffer' _keyBytes.Offset + _lengthOfNonDataPrefix' _keyBytes.Length - _lengthOfNonDataPrefix); " is 123.
Long Statement,BTDB.ODBLayer,TableFieldInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableFieldInfo.cs,Build,The length of the statement  "		throw new BTDBException (string.Format ("FieldHandlerFactory did not build property {0} of type {2} in {1}"' pi.Name' tableName' pi.PropertyType.FullName)); " is 156.
Long Statement,BTDB.ODBLayer,ObjectDB,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ObjectDB.cs,StartWritingTransaction,The length of the statement  "	return _keyValueDB.StartWritingTransaction ().ContinueWith<IObjectDBTransaction> (t => new ObjectDBTransaction (this' t.Result' false)' CancellationToken.None' TaskContinuationOptions.ExecuteSynchronously' TaskScheduler.Default); " is 229.
Long Statement,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateInitializer,The length of the statement  "			var converterGenerator = _tableInfoResolver.TypeConvertorGenerator.GenerateConversion (willLoad' setterMethod.GetParameters () [0].ParameterType); " is 146.
Long Statement,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateSaver,The length of the statement  "	var method = ILBuilder.Instance.NewMethod<Action<IInternalObjectDBTransaction' DBObjectMetadata' AbstractBufferedWriter' object>> (); " is 133.
Long Statement,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,The length of the statement  "	var method = ILBuilder.Instance.NewMethod<Action<IInternalObjectDBTransaction' DBObjectMetadata' AbstractBufferedReader' object>> (); " is 133.
Long Statement,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,The length of the statement  "	var tableVersionInfo = _tableVersions.GetOrAdd (version' version1 => _tableInfoResolver.LoadTableVersionInfo (_id' version1' Name)); " is 132.
Long Statement,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,The length of the statement  "			var converterGenerator = _tableInfoResolver.TypeConvertorGenerator.GenerateConversion (willLoad' setterMethod.GetParameters () [0].ParameterType); " is 146.
Long Statement,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,IsFreeContentNeeded,The length of the statement  "	Tuple<bool' Action<IInternalObjectDBTransaction' DBObjectMetadata' AbstractBufferedReader' IList<ulong>' IList<ulong>>> freeContent; " is 132.
Long Statement,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateFreeContent,The length of the statement  "	var method = ILBuilder.Instance.NewMethod<Action<IInternalObjectDBTransaction' DBObjectMetadata' AbstractBufferedReader' IList<ulong>' IList<ulong>>> (); " is 153.
Long Statement,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateFreeContent,The length of the statement  "	var tableVersionInfo = _tableVersions.GetOrAdd (version' version1 => _tableInfoResolver.LoadTableVersionInfo (_id' version1' Name)); " is 132.
Long Statement,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateFreeContent,The length of the statement  "		ilGenerator.Ldarg (0).Ldarg (2).Ldarg (3).Ldarg (4).Newobj (() => new DBReaderWithFreeInfoCtx (null' null' null' null)).Stloc (0); " is 130.
Long Statement,BTDB.Reactive,FastSubject,F:\newReposMay17\Bobris_BTDB\BTDB\Reactive\FastSubject.cs,OnCompleted,The length of the statement  "	} while (Interlocked.CompareExchange (ref _current' FastSubjectHelpers<T>.CompletedSubjectMarker' original) != original); " is 121.
Long Statement,BTDB.Reactive,FastSubject,F:\newReposMay17\Bobris_BTDB\BTDB\Reactive\FastSubject.cs,OnError,The length of the statement  "	} while (Interlocked.CompareExchange (ref _current' new FastSubjectHelpers<T>.ExceptionedSubject (error)' original) != original); " is 129.
Long Statement,BTDB.Reactive,FastBehaviourSubject,F:\newReposMay17\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,OnCompleted,The length of the statement  "	} while (Interlocked.CompareExchange (ref _current' FastSubjectHelpers<T>.CompletedSubjectMarker' original) != original); " is 121.
Long Statement,BTDB.Reactive,FastBehaviourSubject,F:\newReposMay17\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,OnError,The length of the statement  "	} while (Interlocked.CompareExchange (ref _current' new FastSubjectHelpers<T>.ExceptionedSubject (error)' original) != original); " is 129.
Long Statement,BTDB.Reactive,FastBehaviourSubject,F:\newReposMay17\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,OnNext,The length of the statement  "			nextState = new FastSubjectHelpers<T>.SingleSubjectWithValue (((FastSubjectHelpers<T>.SingleSubjectWithValue)original).Observer' value); " is 136.
Long Statement,BTDB.Reactive,FastBehaviourSubject,F:\newReposMay17\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,OnNext,The length of the statement  "		} else if (original is FastSubjectHelpers<T>.EmptySubjectWithValue || original == FastSubjectHelpers<T>.EmptySubjectMarker) { " is 125.
Long Statement,BTDB.Reactive,FastBehaviourSubject,F:\newReposMay17\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,OnNext,The length of the statement  "			nextState = new FastSubjectHelpers<T>.MultiSubjectWithValue (((FastSubjectHelpers<T>.MultiSubjectWithValue)original).Array' value); " is 131.
Long Statement,BTDB.Reactive,FastBehaviourSubject,F:\newReposMay17\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,OnNext,The length of the statement  "			nextState = new FastSubjectHelpers<T>.MultiSubjectWithValue (((FastSubjectHelpers<T>.MultiSubject)original).Array' value); " is 122.
Long Statement,BTDB.Service,ServiceObjectFieldHandler,F:\newReposMay17\Bobris_BTDB\BTDB\Service\ServiceObjectFieldHandler.cs,Save,The length of the statement  "	ilGenerator.Do (pushWriterOrCtx).Do (pushValue).Do (_service.TypeConvertorGenerator.GenerateConversion (HandledType ()' typeof(object))).Callvirt (() => default(IWriterCtx).WriteNativeObject (null)); " is 199.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The length of the statement  "		ilGenerator.Ldarg (2).Ldarg (1).Newobj (() => new ServiceReaderCtx ((IServiceInternalServer)null' null)).Castclass (typeof(IReaderCtx)).Stloc (localReaderCtx); " is 159.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The length of the statement  "				ilGenerator.Ldarg (2).Ldloc (localResultId).Newobj (CreateTaskContinuationWithResultMarshaling (methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler)).Pop (); " is 167.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The length of the statement  "			ilGenerator.Stloc (localResult).Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).StartResultMarshaling (0u)).Stloc (localWriter); " is 160.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The length of the statement  "				ilGenerator.Ldarg (2).Ldloc (localWriter).Newobj (() => new ServiceWriterCtx ((IServiceInternalServer)null' null)).Castclass (typeof(IWriterCtx)).Stloc (localWriterCtx); " is 169.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The length of the statement  "			resultFieldHandler.Save (ilGenerator' il => il.Ldloc (resultFieldHandler.NeedsCtx () ? localWriterCtx : localWriter)' il => il.Ldloc (localResult)); " is 148.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The length of the statement  "			ilGenerator.Ldarg (2).Ldloc (localWriter).Callvirt (() => default(IServiceInternalServer).FinishResultMarshaling (null)); " is 121.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The length of the statement  "		ilGenerator.Catch (typeof(Exception)).Stloc (localException).Ldarg (2).Ldloc (localResultId).Ldloc (localException).Callvirt (() => default(IServiceInternalServer).ExceptionMarshaling (0u' null)).EndTry (); " is 206.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,CreateTaskContinuationWithResultMarshaling,The length of the statement  "	ilGenerator.Ldarg (1).Callvirt (typeof(Task).GetMethod ("get_IsFaulted")).BrfalseS (notFaultedLabel).Ldarg (0).Ldfld (ownerField).Ldarg (0).Ldfld (resultIdField).Ldarg (1).Callvirt (typeof(Task).GetMethod ("get_Exception")).Callvirt (() => default(IServiceInternalServer).ExceptionMarshaling (0u' null)).Ret ().Mark (notFaultedLabel).Ldarg (0).Ldfld (ownerField).Ldarg (0).Ldfld (resultIdField); " is 395.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,CreateTaskContinuationWithResultMarshaling,The length of the statement  "			ilGenerator.Ldarg (0).Ldfld (ownerField).Ldloc (localWriter).Newobj (() => new ServiceWriterCtx ((IServiceInternalServer)null' null)).Castclass (typeof(IWriterCtx)).Stloc (localWriterCtx); " is 188.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,CreateTaskContinuationWithResultMarshaling,The length of the statement  "		resultFieldHandler.Save (ilGenerator' il => il.Ldloc (resultFieldHandler.NeedsCtx () ? localWriterCtx : localWriter)' il => { " is 125.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,CreateTaskContinuationWithResultMarshaling,The length of the statement  "		ilGenerator.Ldarg (0).Ldfld (ownerField).Ldloc (localWriter).Callvirt (() => default(IServiceInternalServer).FinishResultMarshaling (null)); " is 140.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,CreateTaskContinuationWithResultMarshaling,The length of the statement  "	ilGenerator.Ldarg (0).Call (() => new object ()).Ldarg (0).Ldarg (2).Stfld (ownerField).Ldarg (0).Ldarg (3).Stfld (resultIdField).Ldarg (1).Ldarg (0).Ldftn (methodBuilder).Newobj (actionOfTaskType.GetConstructor (new[] { " is 220.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The length of the statement  "		var methodBuilder = tb.DefineMethod (methodInfo.Name' methodInfo.ReturnType' parameterTypes' MethodAttributes.Public | MethodAttributes.Virtual); " is 145.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The length of the statement  "			ilGenerator.Ldloca (resultTaskLocal).Callvirt (() => default(IServiceInternalClient).StartTwoWayMarshaling (null' out placebo)); " is 128.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The length of the statement  "			ilGenerator.Ldarg (0).Ldfld (ownerField).Ldloc (writerLocal).Newobj (() => new ServiceWriterCtx ((IServiceInternalClient)null' null)).Castclass (typeof(IWriterCtx)).Stloc (writerCtxLocal); " is 188.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The length of the statement  "			ilGenerator.Callvirt (() => default(IServiceInternalClient).FinishTwoWayMarshaling (null)).Ldloc (resultTaskLocal).Castclass (resultAsTask); " is 140.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The length of the statement  "				ilGenerator.Ldarg (2).Ldarg (1).Newobj (() => new ServiceReaderCtx ((IServiceInternalClient)null' null)).Castclass (typeof(IReaderCtx)).Stloc (readerCtxLocal); " is 159.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The length of the statement  "		ilGenerator.Callvirt (resultAsTcs.GetMethod ("TrySetResult")).Pop ().Catch (typeof(Exception)).Stloc (localException).Ldarg (0).Castclass (resultAsTcs).Ldloc (localException).Callvirt (resultAsTcs.GetMethod ("TrySetException"' new[] { " is 234.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The length of the statement  "		ilGenerator.Ldarg (0).Castclass (resultAsTcs).Callvirt (resultAsTcs.GetMethod ("TrySetCanceled"' Type.EmptyTypes)).Pop ().Ret (); " is 129.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The length of the statement  "		methodBuilder = tb.DefineMethod ("TaskWithSourceCreator_" + returnType.FullName' typeof(TaskWithSource)' Type.EmptyTypes' MethodAttributes.Public | MethodAttributes.Static); " is 173.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The length of the statement  "		ilGenerator.Newobj (resultAsTcs.GetConstructor (Type.EmptyTypes)).Stloc (0).Ldloc (0).Ldloc (0).Callvirt (resultAsTcs.GetMethod ("get_Task")).Newobj (() => new TaskWithSource (null' null)).Ret (); " is 196.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The length of the statement  "		bindings [i].HandleResult = finalType.GetMethod ("HandleResult_" + resultType).CreateDelegate<Action<object' AbstractBufferedReader' IServiceInternalClient>> (); " is 161.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The length of the statement  "		bindings [i].HandleException = finalType.GetMethod ("HandleException_" + resultType).CreateDelegate<Action<object' Exception>> (); " is 130.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The length of the statement  "		bindings [i].HandleCancellation = finalType.GetMethod ("HandleCancellation_" + resultType).CreateDelegate<Action<object>> (); " is 125.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The length of the statement  "		bindings [i].TaskWithSourceCreator = finalType.GetMethod ("TaskWithSourceCreator_" + resultType).CreateDelegate<Func<TaskWithSource>> (); " is 137.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibility,The length of the statement  "	if (from.Name == to.Name && (from.Configuration == to.Configuration || from.Configuration.SequenceEqual (to.Configuration))) " is 124.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,WriteObjectForServer,The length of the statement  "	ilGenerator.Ldarg (1).Callvirt (() => default(IWriterCtx).Writer ()).Dup ().Stloc (writerLocal).LdcI4 ((int)typeId).ConvU4 ().Call (() => default(AbstractBufferedWriter).WriteVUInt32 (0)); " is 188.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,LoadObjectOnServer,The length of the statement  "	ilGenerator.Ldarg (0).Callvirt (() => default(IReaderCtx).Reader ()).Stloc (readerLocal).Newobj (type.GetConstructor (Type.EmptyTypes)).Stloc (resultLocal); " is 156.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,LoadObjectOnServer,The length of the statement  "		ilGenerator.Do (_typeConvertorGenerator.GenerateConversion (fieldHandler.HandledType ()' inputType)).Callvirt (prop.GetSetMethod ()); " is 133.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,WriteObjectForClient,The length of the statement  "	ilGenerator.Ldarg (1).Callvirt (() => default(IWriterCtx).Writer ()).Dup ().Stloc (writerLocal).LdcI4 ((int)typeId).ConvU4 ().Call (() => default(AbstractBufferedWriter).WriteVUInt32 (0)); " is 188.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,LoadObjectOnClient,The length of the statement  "	ilGenerator.Ldarg (0).Callvirt (() => default(IReaderCtx).Reader ()).Stloc (readerLocal).Newobj (type.GetConstructor (Type.EmptyTypes)).Stloc (resultLocal); " is 156.
Long Statement,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,LoadObjectOnClient,The length of the statement  "		ilGenerator.Do (_typeConvertorGenerator.GenerateConversion (fieldHandler.HandledType ()' inputType)).Callvirt (prop.GetSetMethod ()); " is 133.
Long Statement,BTDB.Service,TcpipServer,F:\newReposMay17\Bobris_BTDB\BTDB\Service\TcpipServer.cs,StartListening,The length of the statement  "	_acceptClientsTask = Task.Factory.StartNew (AcceptNewClients' CancellationToken.None' TaskCreationOptions.LongRunning' TaskScheduler.Default); " is 142.
Long Statement,BTDB.Service,TypeInf,F:\newReposMay17\Bobris_BTDB\BTDB\Service\TypeInf.cs,EnumerateFieldHandlers,The length of the statement  "	return _methodInfs.SelectMany (methodInf => methodInf.EnumerateFieldHandlers ()).Concat (_propertyInfs.Select (propertyInf => propertyInf.FieldHandler)); " is 153.
Long Statement,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Equal4,The length of the statement  "	return buf [o1] == buf [o2] && buf [o1 + 1] == buf [o2 + 1] && buf [o1 + 2] == buf [o2 + 2] && buf [o1 + 3] == buf [o2 + 3]; " is 124.
Long Statement,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,Decompress,The length of the statement  "	if (!DecompressRaw (dstBuf' ByteBuffer.NewSync (compressedBytes.Buffer' compressedBytes.Offset + ofs' compressedBytes.Length - ofs))) " is 133.
Long Statement,BTDB.StreamLayer,PositionLessStreamProxy,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\PositionLessStreamProxy.cs,Write,The length of the statement  "				if (pos >= _writeBufStart && pos <= _writeBufStart + (ulong)_writeBufUsed && pos + (ulong)size <= _writeBufStart + (ulong)_writeBufSize) { " is 138.
Complex Conditional,BTDB.IL,EmitHelpers,F:\newReposMay17\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateJumpIfEqual,The conditional expression  "type == typeof(sbyte) || type == typeof(byte) || type == typeof(short) || type == typeof(ushort) || type == typeof(int) || type == typeof(uint) || type == typeof(long) || type == typeof(ulong) || type == typeof(float) || type == typeof(double) || type == typeof(bool) || type.IsEnum"  is complex.
Complex Conditional,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,LoadInfoAboutFiles,The conditional expression  "lastestTrLogFileId != firstTrLogId && firstTrLogId != 0 || !hasKeyIndex && _fileCollection.FileInfos.Any (p => p.Value.SubDBId == 0)"  is complex.
Complex Conditional,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The conditional expression  "tempbuf [0] != 'B' || tempbuf [1] != 'T' || tempbuf [2] != 'D' || tempbuf [3] != 'B' || tempbuf [4] != 'E' || tempbuf [5] != 'X' || tempbuf [6] != 'P' || tempbuf [7] != '2'"  is complex.
Empty Catch Block,BTDB.ChunkCache,DiskChunkCache,F:\newReposMay17\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,QuickFinishCompaction,The method has an empty catch block.
Empty Catch Block,BTDB.ChunkCache,DiskChunkCache,F:\newReposMay17\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,Get,The method has an empty catch block.
Empty Catch Block,BTDB.ODBLayer,ObjectDBTransaction,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,EnumerateSingletonTypes,The method has an empty catch block.
Empty Catch Block,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,SendDataIgnoringExceptions,The method has an empty catch block.
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: switch (b) {  case 255:  	laststart += 8;  	break;  case 0:  	sizetill += 8;  	break;  default:  	if (FirstHoleSize [b] >= size)  		return (int)laststart;  	if (MaxHoleSize [b] >= size)  		return (int)(pos * 8 + MaxHoleOffset [b] - 8);  	sizetill = LastHoleSize [b];  	laststart += 8 - sizetill;  	break;  }  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: switch (b) {  case 255:  	laststart += 8;  	break;  case 0:  	sizetill += 8;  	break;  default:  	if (FirstHoleSize [b] >= size)  		return (int)laststart;  	if (MaxHoleSize [b] >= size)  		return (int)(pos * 8 + MaxHoleOffset [b] - 8);  	sizetill = LastHoleSize [b];  	laststart += 8 - sizetill;  	break;  }  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: switch (b) {  case 255:  	laststart += 8;  	break;  case 0:  	sizetill += 8;  	break;  default:  	if (FirstHoleSize [b] >= size)  		return (int)laststart;  	if (MaxHoleSize [b] >= size)  		return (int)(pos * 8 + MaxHoleOffset [b] - 8);  	sizetill = LastHoleSize [b];  	laststart += 8 - sizetill;  	break;  }  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: switch (b) {  case 255:  	laststart += 8;  	break;  case 0:  	sizetill += 8;  	break;  default:  	if (FirstHoleSize [b] >= size)  		return (int)laststart;  	if (MaxHoleSize [b] >= size)  		return (int)(pos * 8 + MaxHoleOffset [b] - 8);  	sizetill = LastHoleSize [b];  	laststart += 8 - sizetill;  	break;  }  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: switch (b) {  case 255:  	laststart += 8;  	break;  case 0:  	sizetill += 8;  	break;  default:  	if (FirstHoleSize [b] >= size)  		return (int)laststart;  	if (MaxHoleSize [b] >= size)  		return (int)(pos * 8 + MaxHoleOffset [b] - 8);  	sizetill = LastHoleSize [b];  	laststart += 8 - sizetill;  	break;  }  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: switch (b) {  case 255:  	laststart += 8;  	break;  case 0:  	sizetill += 8;  	break;  default:  	if (FirstHoleSize [b] >= size)  		return (int)laststart;  	if (MaxHoleSize [b] >= size)  		return (int)(pos * 8 + MaxHoleOffset [b] - 8);  	sizetill = LastHoleSize [b];  	laststart += 8 - sizetill;  	break;  }  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: laststart += 8;  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: sizetill += 8;  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: if (MaxHoleSize [b] >= size)  	return (int)(pos * 8 + MaxHoleOffset [b] - 8);  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: if (MaxHoleSize [b] >= size)  	return (int)(pos * 8 + MaxHoleOffset [b] - 8);  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: return (int)(pos * 8 + MaxHoleOffset [b] - 8);  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: return (int)(pos * 8 + MaxHoleOffset [b] - 8);  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: laststart += 8 - sizetill;  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: while (pos < len) {  	b = data [pos];  	pos++;  	switch (b) {  	case 255:  		if (sizetill >= size)  			return (int)laststart;  		sizetill = 0;  		laststart = pos * 8;  		break;  	case 0:  		sizetill += 8;  		break;  	default:  		sizetill += FirstHoleSize [b];  		if (sizetill >= size)  			return (int)laststart;  		if (MaxHoleSize [b] >= size)  			return (int)(pos * 8 + MaxHoleOffset [b] - 8);  		sizetill = LastHoleSize [b];  		laststart = pos * 8 - sizetill;  		break;  	}  }  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: while (pos < len) {  	b = data [pos];  	pos++;  	switch (b) {  	case 255:  		if (sizetill >= size)  			return (int)laststart;  		sizetill = 0;  		laststart = pos * 8;  		break;  	case 0:  		sizetill += 8;  		break;  	default:  		sizetill += FirstHoleSize [b];  		if (sizetill >= size)  			return (int)laststart;  		if (MaxHoleSize [b] >= size)  			return (int)(pos * 8 + MaxHoleOffset [b] - 8);  		sizetill = LastHoleSize [b];  		laststart = pos * 8 - sizetill;  		break;  	}  }  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: while (pos < len) {  	b = data [pos];  	pos++;  	switch (b) {  	case 255:  		if (sizetill >= size)  			return (int)laststart;  		sizetill = 0;  		laststart = pos * 8;  		break;  	case 0:  		sizetill += 8;  		break;  	default:  		sizetill += FirstHoleSize [b];  		if (sizetill >= size)  			return (int)laststart;  		if (MaxHoleSize [b] >= size)  			return (int)(pos * 8 + MaxHoleOffset [b] - 8);  		sizetill = LastHoleSize [b];  		laststart = pos * 8 - sizetill;  		break;  	}  }  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: while (pos < len) {  	b = data [pos];  	pos++;  	switch (b) {  	case 255:  		if (sizetill >= size)  			return (int)laststart;  		sizetill = 0;  		laststart = pos * 8;  		break;  	case 0:  		sizetill += 8;  		break;  	default:  		sizetill += FirstHoleSize [b];  		if (sizetill >= size)  			return (int)laststart;  		if (MaxHoleSize [b] >= size)  			return (int)(pos * 8 + MaxHoleOffset [b] - 8);  		sizetill = LastHoleSize [b];  		laststart = pos * 8 - sizetill;  		break;  	}  }  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: while (pos < len) {  	b = data [pos];  	pos++;  	switch (b) {  	case 255:  		if (sizetill >= size)  			return (int)laststart;  		sizetill = 0;  		laststart = pos * 8;  		break;  	case 0:  		sizetill += 8;  		break;  	default:  		sizetill += FirstHoleSize [b];  		if (sizetill >= size)  			return (int)laststart;  		if (MaxHoleSize [b] >= size)  			return (int)(pos * 8 + MaxHoleOffset [b] - 8);  		sizetill = LastHoleSize [b];  		laststart = pos * 8 - sizetill;  		break;  	}  }  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: while (pos < len) {  	b = data [pos];  	pos++;  	switch (b) {  	case 255:  		if (sizetill >= size)  			return (int)laststart;  		sizetill = 0;  		laststart = pos * 8;  		break;  	case 0:  		sizetill += 8;  		break;  	default:  		sizetill += FirstHoleSize [b];  		if (sizetill >= size)  			return (int)laststart;  		if (MaxHoleSize [b] >= size)  			return (int)(pos * 8 + MaxHoleOffset [b] - 8);  		sizetill = LastHoleSize [b];  		laststart = pos * 8 - sizetill;  		break;  	}  }  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: switch (b) {  case 255:  	if (sizetill >= size)  		return (int)laststart;  	sizetill = 0;  	laststart = pos * 8;  	break;  case 0:  	sizetill += 8;  	break;  default:  	sizetill += FirstHoleSize [b];  	if (sizetill >= size)  		return (int)laststart;  	if (MaxHoleSize [b] >= size)  		return (int)(pos * 8 + MaxHoleOffset [b] - 8);  	sizetill = LastHoleSize [b];  	laststart = pos * 8 - sizetill;  	break;  }  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: switch (b) {  case 255:  	if (sizetill >= size)  		return (int)laststart;  	sizetill = 0;  	laststart = pos * 8;  	break;  case 0:  	sizetill += 8;  	break;  default:  	sizetill += FirstHoleSize [b];  	if (sizetill >= size)  		return (int)laststart;  	if (MaxHoleSize [b] >= size)  		return (int)(pos * 8 + MaxHoleOffset [b] - 8);  	sizetill = LastHoleSize [b];  	laststart = pos * 8 - sizetill;  	break;  }  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: switch (b) {  case 255:  	if (sizetill >= size)  		return (int)laststart;  	sizetill = 0;  	laststart = pos * 8;  	break;  case 0:  	sizetill += 8;  	break;  default:  	sizetill += FirstHoleSize [b];  	if (sizetill >= size)  		return (int)laststart;  	if (MaxHoleSize [b] >= size)  		return (int)(pos * 8 + MaxHoleOffset [b] - 8);  	sizetill = LastHoleSize [b];  	laststart = pos * 8 - sizetill;  	break;  }  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: switch (b) {  case 255:  	if (sizetill >= size)  		return (int)laststart;  	sizetill = 0;  	laststart = pos * 8;  	break;  case 0:  	sizetill += 8;  	break;  default:  	sizetill += FirstHoleSize [b];  	if (sizetill >= size)  		return (int)laststart;  	if (MaxHoleSize [b] >= size)  		return (int)(pos * 8 + MaxHoleOffset [b] - 8);  	sizetill = LastHoleSize [b];  	laststart = pos * 8 - sizetill;  	break;  }  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: switch (b) {  case 255:  	if (sizetill >= size)  		return (int)laststart;  	sizetill = 0;  	laststart = pos * 8;  	break;  case 0:  	sizetill += 8;  	break;  default:  	sizetill += FirstHoleSize [b];  	if (sizetill >= size)  		return (int)laststart;  	if (MaxHoleSize [b] >= size)  		return (int)(pos * 8 + MaxHoleOffset [b] - 8);  	sizetill = LastHoleSize [b];  	laststart = pos * 8 - sizetill;  	break;  }  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: switch (b) {  case 255:  	if (sizetill >= size)  		return (int)laststart;  	sizetill = 0;  	laststart = pos * 8;  	break;  case 0:  	sizetill += 8;  	break;  default:  	sizetill += FirstHoleSize [b];  	if (sizetill >= size)  		return (int)laststart;  	if (MaxHoleSize [b] >= size)  		return (int)(pos * 8 + MaxHoleOffset [b] - 8);  	sizetill = LastHoleSize [b];  	laststart = pos * 8 - sizetill;  	break;  }  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: laststart = pos * 8;  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: sizetill += 8;  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: if (MaxHoleSize [b] >= size)  	return (int)(pos * 8 + MaxHoleOffset [b] - 8);  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: if (MaxHoleSize [b] >= size)  	return (int)(pos * 8 + MaxHoleOffset [b] - 8);  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: return (int)(pos * 8 + MaxHoleOffset [b] - 8);  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: return (int)(pos * 8 + MaxHoleOffset [b] - 8);  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,IndexOfFirstHole,The following statement contains a magic number: laststart = pos * 8 - sizetill;  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,SetBits,The following statement contains a magic number: Debug.Assert (position >= 0 && size > 0 && position + size <= data.Length * 8);  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,SetBits,The following statement contains a magic number: if (startBytePos == endBytePos) {  	data [startBytePos] |= (byte)(startMask & endMask);  } else {  	data [startBytePos] |= startMask;  	startBytePos++;  	while (startBytePos < endBytePos) {  		data [startBytePos] = 255;  		startBytePos++;  	}  	data [endBytePos] |= endMask;  }  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,SetBits,The following statement contains a magic number: while (startBytePos < endBytePos) {  	data [startBytePos] = 255;  	startBytePos++;  }  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,SetBits,The following statement contains a magic number: data [startBytePos] = 255;  
Magic Number,BTDB.Buffer,BitArrayManipulation,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\BitArrayManipulation.cs,UnsetBits,The following statement contains a magic number: Debug.Assert (position >= 0 && size > 0 && position + size <= data.Length * 8);  
Magic Number,BTDB.Buffer,Checksum,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: while (length > 0) {  	uint tlen = length > 360 ? 360 : length;  	length -= tlen;  	do {  		sum1 += (uint)(data [position] + data [position + 1] * 256);  		position += 2;  		sum2 += sum1;  	} while (--tlen > 0);  	sum1 = (sum1 & 0xffff) + (sum1 >> 16);  	sum2 = (sum2 & 0xffff) + (sum2 >> 16);  }  
Magic Number,BTDB.Buffer,Checksum,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: while (length > 0) {  	uint tlen = length > 360 ? 360 : length;  	length -= tlen;  	do {  		sum1 += (uint)(data [position] + data [position + 1] * 256);  		position += 2;  		sum2 += sum1;  	} while (--tlen > 0);  	sum1 = (sum1 & 0xffff) + (sum1 >> 16);  	sum2 = (sum2 & 0xffff) + (sum2 >> 16);  }  
Magic Number,BTDB.Buffer,Checksum,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: while (length > 0) {  	uint tlen = length > 360 ? 360 : length;  	length -= tlen;  	do {  		sum1 += (uint)(data [position] + data [position + 1] * 256);  		position += 2;  		sum2 += sum1;  	} while (--tlen > 0);  	sum1 = (sum1 & 0xffff) + (sum1 >> 16);  	sum2 = (sum2 & 0xffff) + (sum2 >> 16);  }  
Magic Number,BTDB.Buffer,Checksum,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: while (length > 0) {  	uint tlen = length > 360 ? 360 : length;  	length -= tlen;  	do {  		sum1 += (uint)(data [position] + data [position + 1] * 256);  		position += 2;  		sum2 += sum1;  	} while (--tlen > 0);  	sum1 = (sum1 & 0xffff) + (sum1 >> 16);  	sum2 = (sum2 & 0xffff) + (sum2 >> 16);  }  
Magic Number,BTDB.Buffer,Checksum,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: while (length > 0) {  	uint tlen = length > 360 ? 360 : length;  	length -= tlen;  	do {  		sum1 += (uint)(data [position] + data [position + 1] * 256);  		position += 2;  		sum2 += sum1;  	} while (--tlen > 0);  	sum1 = (sum1 & 0xffff) + (sum1 >> 16);  	sum2 = (sum2 & 0xffff) + (sum2 >> 16);  }  
Magic Number,BTDB.Buffer,Checksum,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: while (length > 0) {  	uint tlen = length > 360 ? 360 : length;  	length -= tlen;  	do {  		sum1 += (uint)(data [position] + data [position + 1] * 256);  		position += 2;  		sum2 += sum1;  	} while (--tlen > 0);  	sum1 = (sum1 & 0xffff) + (sum1 >> 16);  	sum2 = (sum2 & 0xffff) + (sum2 >> 16);  }  
Magic Number,BTDB.Buffer,Checksum,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: do {  	sum1 += (uint)(data [position] + data [position + 1] * 256);  	position += 2;  	sum2 += sum1;  } while (--tlen > 0);  
Magic Number,BTDB.Buffer,Checksum,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: do {  	sum1 += (uint)(data [position] + data [position + 1] * 256);  	position += 2;  	sum2 += sum1;  } while (--tlen > 0);  
Magic Number,BTDB.Buffer,Checksum,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: sum1 += (uint)(data [position] + data [position + 1] * 256);  
Magic Number,BTDB.Buffer,Checksum,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: position += 2;  
Magic Number,BTDB.Buffer,Checksum,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: sum1 = (sum1 & 0xffff) + (sum1 >> 16);  
Magic Number,BTDB.Buffer,Checksum,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: sum2 = (sum2 & 0xffff) + (sum2 >> 16);  
Magic Number,BTDB.Buffer,Checksum,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: if (odd) {  	sum1 += data [position];  	sum2 += sum1;  	sum1 = (sum1 & 0xffff) + (sum1 >> 16);  	sum2 = (sum2 & 0xffff) + (sum2 >> 16);  }  
Magic Number,BTDB.Buffer,Checksum,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: if (odd) {  	sum1 += data [position];  	sum2 += sum1;  	sum1 = (sum1 & 0xffff) + (sum1 >> 16);  	sum2 = (sum2 & 0xffff) + (sum2 >> 16);  }  
Magic Number,BTDB.Buffer,Checksum,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: sum1 = (sum1 & 0xffff) + (sum1 >> 16);  
Magic Number,BTDB.Buffer,Checksum,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: sum2 = (sum2 & 0xffff) + (sum2 >> 16);  
Magic Number,BTDB.Buffer,Checksum,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: sum1 = (sum1 & 0xffff) + (sum1 >> 16);  
Magic Number,BTDB.Buffer,Checksum,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: sum2 = (sum2 & 0xffff) + (sum2 >> 16);  
Magic Number,BTDB.Buffer,Checksum,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\Checksum.cs,CalcFletcher32,The following statement contains a magic number: return sum2 << 16 | sum1;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt16LE,The following statement contains a magic number: data [offset + 1] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt16LE,The following statement contains a magic number: return (ushort)(data [offset] | (data [offset + 1] << 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt16LE,The following statement contains a magic number: data [offset + 1] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt16LE,The following statement contains a magic number: return (short)(data [offset] | (data [offset + 1] << 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt32LE,The following statement contains a magic number: data [offset + 1] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt32LE,The following statement contains a magic number: data [offset + 2] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt32LE,The following statement contains a magic number: data [offset + 2] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt32LE,The following statement contains a magic number: data [offset + 3] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt32LE,The following statement contains a magic number: data [offset + 3] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt32LE,The following statement contains a magic number: return (uint)(data [offset] | (data [offset + 1] << 8) | (data [offset + 2] << 16) | (data [offset + 3] << 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt32LE,The following statement contains a magic number: return (uint)(data [offset] | (data [offset + 1] << 8) | (data [offset + 2] << 16) | (data [offset + 3] << 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt32LE,The following statement contains a magic number: return (uint)(data [offset] | (data [offset + 1] << 8) | (data [offset + 2] << 16) | (data [offset + 3] << 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt32LE,The following statement contains a magic number: return (uint)(data [offset] | (data [offset + 1] << 8) | (data [offset + 2] << 16) | (data [offset + 3] << 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt32LE,The following statement contains a magic number: return (uint)(data [offset] | (data [offset + 1] << 8) | (data [offset + 2] << 16) | (data [offset + 3] << 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32LE,The following statement contains a magic number: data [offset + 1] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32LE,The following statement contains a magic number: data [offset + 2] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32LE,The following statement contains a magic number: data [offset + 2] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32LE,The following statement contains a magic number: data [offset + 3] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32LE,The following statement contains a magic number: data [offset + 3] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32BE,The following statement contains a magic number: data [offset + 3] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32BE,The following statement contains a magic number: data [offset + 2] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32BE,The following statement contains a magic number: data [offset + 2] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32BE,The following statement contains a magic number: data [offset + 1] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt32BE,The following statement contains a magic number: data [offset] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32LE,The following statement contains a magic number: return data [offset] | (data [offset + 1] << 8) | (data [offset + 2] << 16) | (data [offset + 3] << 24);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32LE,The following statement contains a magic number: return data [offset] | (data [offset + 1] << 8) | (data [offset + 2] << 16) | (data [offset + 3] << 24);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32LE,The following statement contains a magic number: return data [offset] | (data [offset + 1] << 8) | (data [offset + 2] << 16) | (data [offset + 3] << 24);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32LE,The following statement contains a magic number: return data [offset] | (data [offset + 1] << 8) | (data [offset + 2] << 16) | (data [offset + 3] << 24);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32LE,The following statement contains a magic number: return data [offset] | (data [offset + 1] << 8) | (data [offset + 2] << 16) | (data [offset + 3] << 24);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32BE,The following statement contains a magic number: return data [offset + 3] | (data [offset + 2] << 8) | (data [offset + 1] << 16) | (data [offset] << 24);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32BE,The following statement contains a magic number: return data [offset + 3] | (data [offset + 2] << 8) | (data [offset + 1] << 16) | (data [offset] << 24);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32BE,The following statement contains a magic number: return data [offset + 3] | (data [offset + 2] << 8) | (data [offset + 1] << 16) | (data [offset] << 24);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32BE,The following statement contains a magic number: return data [offset + 3] | (data [offset + 2] << 8) | (data [offset + 1] << 16) | (data [offset] << 24);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt32BE,The following statement contains a magic number: return data [offset + 3] | (data [offset + 2] << 8) | (data [offset + 1] << 16) | (data [offset] << 24);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data [offset + 1] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data [offset + 2] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data [offset + 2] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data [offset + 3] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data [offset + 3] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data [offset + 4] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data [offset + 4] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data [offset + 5] = unchecked((byte)(value >> 40));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data [offset + 5] = unchecked((byte)(value >> 40));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data [offset + 6] = unchecked((byte)(value >> 48));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data [offset + 6] = unchecked((byte)(value >> 48));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data [offset + 7] = unchecked((byte)(value >> 56));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackUInt64LE,The following statement contains a magic number: data [offset + 7] = unchecked((byte)(value >> 56));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data [offset] | ((ulong)data [offset + 1] << 8) | ((ulong)data [offset + 2] << 16) | ((ulong)data [offset + 3] << 24) | ((ulong)data [offset + 4] << 32) | ((ulong)data [offset + 5] << 40) | ((ulong)data [offset + 6] << 48) | ((ulong)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data [offset] | ((ulong)data [offset + 1] << 8) | ((ulong)data [offset + 2] << 16) | ((ulong)data [offset + 3] << 24) | ((ulong)data [offset + 4] << 32) | ((ulong)data [offset + 5] << 40) | ((ulong)data [offset + 6] << 48) | ((ulong)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data [offset] | ((ulong)data [offset + 1] << 8) | ((ulong)data [offset + 2] << 16) | ((ulong)data [offset + 3] << 24) | ((ulong)data [offset + 4] << 32) | ((ulong)data [offset + 5] << 40) | ((ulong)data [offset + 6] << 48) | ((ulong)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data [offset] | ((ulong)data [offset + 1] << 8) | ((ulong)data [offset + 2] << 16) | ((ulong)data [offset + 3] << 24) | ((ulong)data [offset + 4] << 32) | ((ulong)data [offset + 5] << 40) | ((ulong)data [offset + 6] << 48) | ((ulong)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data [offset] | ((ulong)data [offset + 1] << 8) | ((ulong)data [offset + 2] << 16) | ((ulong)data [offset + 3] << 24) | ((ulong)data [offset + 4] << 32) | ((ulong)data [offset + 5] << 40) | ((ulong)data [offset + 6] << 48) | ((ulong)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data [offset] | ((ulong)data [offset + 1] << 8) | ((ulong)data [offset + 2] << 16) | ((ulong)data [offset + 3] << 24) | ((ulong)data [offset + 4] << 32) | ((ulong)data [offset + 5] << 40) | ((ulong)data [offset + 6] << 48) | ((ulong)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data [offset] | ((ulong)data [offset + 1] << 8) | ((ulong)data [offset + 2] << 16) | ((ulong)data [offset + 3] << 24) | ((ulong)data [offset + 4] << 32) | ((ulong)data [offset + 5] << 40) | ((ulong)data [offset + 6] << 48) | ((ulong)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data [offset] | ((ulong)data [offset + 1] << 8) | ((ulong)data [offset + 2] << 16) | ((ulong)data [offset + 3] << 24) | ((ulong)data [offset + 4] << 32) | ((ulong)data [offset + 5] << 40) | ((ulong)data [offset + 6] << 48) | ((ulong)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data [offset] | ((ulong)data [offset + 1] << 8) | ((ulong)data [offset + 2] << 16) | ((ulong)data [offset + 3] << 24) | ((ulong)data [offset + 4] << 32) | ((ulong)data [offset + 5] << 40) | ((ulong)data [offset + 6] << 48) | ((ulong)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data [offset] | ((ulong)data [offset + 1] << 8) | ((ulong)data [offset + 2] << 16) | ((ulong)data [offset + 3] << 24) | ((ulong)data [offset + 4] << 32) | ((ulong)data [offset + 5] << 40) | ((ulong)data [offset + 6] << 48) | ((ulong)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data [offset] | ((ulong)data [offset + 1] << 8) | ((ulong)data [offset + 2] << 16) | ((ulong)data [offset + 3] << 24) | ((ulong)data [offset + 4] << 32) | ((ulong)data [offset + 5] << 40) | ((ulong)data [offset + 6] << 48) | ((ulong)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data [offset] | ((ulong)data [offset + 1] << 8) | ((ulong)data [offset + 2] << 16) | ((ulong)data [offset + 3] << 24) | ((ulong)data [offset + 4] << 32) | ((ulong)data [offset + 5] << 40) | ((ulong)data [offset + 6] << 48) | ((ulong)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackUInt64LE,The following statement contains a magic number: return data [offset] | ((ulong)data [offset + 1] << 8) | ((ulong)data [offset + 2] << 16) | ((ulong)data [offset + 3] << 24) | ((ulong)data [offset + 4] << 32) | ((ulong)data [offset + 5] << 40) | ((ulong)data [offset + 6] << 48) | ((ulong)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data [offset + 1] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data [offset + 2] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data [offset + 2] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data [offset + 3] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data [offset + 3] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data [offset + 4] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data [offset + 4] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data [offset + 5] = unchecked((byte)(value >> 40));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data [offset + 5] = unchecked((byte)(value >> 40));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data [offset + 6] = unchecked((byte)(value >> 48));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data [offset + 6] = unchecked((byte)(value >> 48));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data [offset + 7] = unchecked((byte)(value >> 56));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64LE,The following statement contains a magic number: data [offset + 7] = unchecked((byte)(value >> 56));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data [offset + 7] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data [offset + 6] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data [offset + 6] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data [offset + 5] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data [offset + 5] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data [offset + 4] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data [offset + 4] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data [offset + 3] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data [offset + 3] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data [offset + 2] = unchecked((byte)(value >> 40));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data [offset + 2] = unchecked((byte)(value >> 40));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data [offset + 1] = unchecked((byte)(value >> 48));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackInt64BE,The following statement contains a magic number: data [offset] = unchecked((byte)(value >> 56));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data [offset] | ((long)data [offset + 1] << 8) | ((long)data [offset + 2] << 16) | ((long)data [offset + 3] << 24) | ((long)data [offset + 4] << 32) | ((long)data [offset + 5] << 40) | ((long)data [offset + 6] << 48) | ((long)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data [offset] | ((long)data [offset + 1] << 8) | ((long)data [offset + 2] << 16) | ((long)data [offset + 3] << 24) | ((long)data [offset + 4] << 32) | ((long)data [offset + 5] << 40) | ((long)data [offset + 6] << 48) | ((long)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data [offset] | ((long)data [offset + 1] << 8) | ((long)data [offset + 2] << 16) | ((long)data [offset + 3] << 24) | ((long)data [offset + 4] << 32) | ((long)data [offset + 5] << 40) | ((long)data [offset + 6] << 48) | ((long)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data [offset] | ((long)data [offset + 1] << 8) | ((long)data [offset + 2] << 16) | ((long)data [offset + 3] << 24) | ((long)data [offset + 4] << 32) | ((long)data [offset + 5] << 40) | ((long)data [offset + 6] << 48) | ((long)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data [offset] | ((long)data [offset + 1] << 8) | ((long)data [offset + 2] << 16) | ((long)data [offset + 3] << 24) | ((long)data [offset + 4] << 32) | ((long)data [offset + 5] << 40) | ((long)data [offset + 6] << 48) | ((long)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data [offset] | ((long)data [offset + 1] << 8) | ((long)data [offset + 2] << 16) | ((long)data [offset + 3] << 24) | ((long)data [offset + 4] << 32) | ((long)data [offset + 5] << 40) | ((long)data [offset + 6] << 48) | ((long)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data [offset] | ((long)data [offset + 1] << 8) | ((long)data [offset + 2] << 16) | ((long)data [offset + 3] << 24) | ((long)data [offset + 4] << 32) | ((long)data [offset + 5] << 40) | ((long)data [offset + 6] << 48) | ((long)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data [offset] | ((long)data [offset + 1] << 8) | ((long)data [offset + 2] << 16) | ((long)data [offset + 3] << 24) | ((long)data [offset + 4] << 32) | ((long)data [offset + 5] << 40) | ((long)data [offset + 6] << 48) | ((long)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data [offset] | ((long)data [offset + 1] << 8) | ((long)data [offset + 2] << 16) | ((long)data [offset + 3] << 24) | ((long)data [offset + 4] << 32) | ((long)data [offset + 5] << 40) | ((long)data [offset + 6] << 48) | ((long)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data [offset] | ((long)data [offset + 1] << 8) | ((long)data [offset + 2] << 16) | ((long)data [offset + 3] << 24) | ((long)data [offset + 4] << 32) | ((long)data [offset + 5] << 40) | ((long)data [offset + 6] << 48) | ((long)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data [offset] | ((long)data [offset + 1] << 8) | ((long)data [offset + 2] << 16) | ((long)data [offset + 3] << 24) | ((long)data [offset + 4] << 32) | ((long)data [offset + 5] << 40) | ((long)data [offset + 6] << 48) | ((long)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data [offset] | ((long)data [offset + 1] << 8) | ((long)data [offset + 2] << 16) | ((long)data [offset + 3] << 24) | ((long)data [offset + 4] << 32) | ((long)data [offset + 5] << 40) | ((long)data [offset + 6] << 48) | ((long)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64LE,The following statement contains a magic number: return data [offset] | ((long)data [offset + 1] << 8) | ((long)data [offset + 2] << 16) | ((long)data [offset + 3] << 24) | ((long)data [offset + 4] << 32) | ((long)data [offset + 5] << 40) | ((long)data [offset + 6] << 48) | ((long)data [offset + 7] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data [offset + 7] | ((long)data [offset + 6] << 8) | ((long)data [offset + 5] << 16) | ((long)data [offset + 4] << 24) | ((long)data [offset + 3] << 32) | ((long)data [offset + 2] << 40) | ((long)data [offset + 1] << 48) | ((long)data [offset] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data [offset + 7] | ((long)data [offset + 6] << 8) | ((long)data [offset + 5] << 16) | ((long)data [offset + 4] << 24) | ((long)data [offset + 3] << 32) | ((long)data [offset + 2] << 40) | ((long)data [offset + 1] << 48) | ((long)data [offset] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data [offset + 7] | ((long)data [offset + 6] << 8) | ((long)data [offset + 5] << 16) | ((long)data [offset + 4] << 24) | ((long)data [offset + 3] << 32) | ((long)data [offset + 2] << 40) | ((long)data [offset + 1] << 48) | ((long)data [offset] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data [offset + 7] | ((long)data [offset + 6] << 8) | ((long)data [offset + 5] << 16) | ((long)data [offset + 4] << 24) | ((long)data [offset + 3] << 32) | ((long)data [offset + 2] << 40) | ((long)data [offset + 1] << 48) | ((long)data [offset] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data [offset + 7] | ((long)data [offset + 6] << 8) | ((long)data [offset + 5] << 16) | ((long)data [offset + 4] << 24) | ((long)data [offset + 3] << 32) | ((long)data [offset + 2] << 40) | ((long)data [offset + 1] << 48) | ((long)data [offset] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data [offset + 7] | ((long)data [offset + 6] << 8) | ((long)data [offset + 5] << 16) | ((long)data [offset + 4] << 24) | ((long)data [offset + 3] << 32) | ((long)data [offset + 2] << 40) | ((long)data [offset + 1] << 48) | ((long)data [offset] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data [offset + 7] | ((long)data [offset + 6] << 8) | ((long)data [offset + 5] << 16) | ((long)data [offset + 4] << 24) | ((long)data [offset + 3] << 32) | ((long)data [offset + 2] << 40) | ((long)data [offset + 1] << 48) | ((long)data [offset] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data [offset + 7] | ((long)data [offset + 6] << 8) | ((long)data [offset + 5] << 16) | ((long)data [offset + 4] << 24) | ((long)data [offset + 3] << 32) | ((long)data [offset + 2] << 40) | ((long)data [offset + 1] << 48) | ((long)data [offset] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data [offset + 7] | ((long)data [offset + 6] << 8) | ((long)data [offset + 5] << 16) | ((long)data [offset + 4] << 24) | ((long)data [offset + 3] << 32) | ((long)data [offset + 2] << 40) | ((long)data [offset + 1] << 48) | ((long)data [offset] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data [offset + 7] | ((long)data [offset + 6] << 8) | ((long)data [offset + 5] << 16) | ((long)data [offset + 4] << 24) | ((long)data [offset + 3] << 32) | ((long)data [offset + 2] << 40) | ((long)data [offset + 1] << 48) | ((long)data [offset] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data [offset + 7] | ((long)data [offset + 6] << 8) | ((long)data [offset + 5] << 16) | ((long)data [offset + 4] << 24) | ((long)data [offset + 3] << 32) | ((long)data [offset + 2] << 40) | ((long)data [offset + 1] << 48) | ((long)data [offset] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data [offset + 7] | ((long)data [offset + 6] << 8) | ((long)data [offset + 5] << 16) | ((long)data [offset + 4] << 24) | ((long)data [offset + 3] << 32) | ((long)data [offset + 2] << 40) | ((long)data [offset + 1] << 48) | ((long)data [offset] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackInt64BE,The following statement contains a magic number: return data [offset + 7] | ((long)data [offset + 6] << 8) | ((long)data [offset + 5] << 16) | ((long)data [offset + 4] << 24) | ((long)data [offset + 3] << 32) | ((long)data [offset + 2] << 40) | ((long)data [offset + 1] << 48) | ((long)data [offset] << 56);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (value < 0x4000)  	return 2;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 2;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (value < 0x200000)  	return 3;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 3;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (value < 0x10000000)  	return 4;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 4;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 5;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (value < 0x4000)  	return 2;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 2;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (value < 0x200000)  	return 3;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 3;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (value < 0x10000000)  	return 4;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 4;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (value < 0x0800000000)  	return 5;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 5;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (value < 0x040000000000)  	return 6;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 6;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (value < 0x02000000000000)  	return 7;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 7;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (value < 0x0100000000000000)  	return 8;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 8;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 9;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (first < 0xC0)  	return 2;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 2;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (first < 0xE0)  	return 3;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 3;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (first < 0xF0)  	return 4;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 4;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (first < 0xF8)  	return 5;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 5;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (first < 0xFC)  	return 6;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 6;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: if (first < 0xFE)  	return 7;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return 7;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return first == 0xFE ? 8 : 9;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVUInt,The following statement contains a magic number: return first == 0xFE ? 8 : 9;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x4000) {  	data [ofs] = (byte)(0x80 + (value >> 8));  	data [ofs + 1] = unchecked((byte)value);  	ofs += 2;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x4000) {  	data [ofs] = (byte)(0x80 + (value >> 8));  	data [ofs + 1] = unchecked((byte)value);  	ofs += 2;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs] = (byte)(0x80 + (value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 2;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x200000) {  	data [ofs] = (byte)(0xC0 + (value >> 16));  	data [ofs + 1] = unchecked((byte)(value >> 8));  	data [ofs + 2] = unchecked((byte)value);  	ofs += 3;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x200000) {  	data [ofs] = (byte)(0xC0 + (value >> 16));  	data [ofs + 1] = unchecked((byte)(value >> 8));  	data [ofs + 2] = unchecked((byte)value);  	ofs += 3;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x200000) {  	data [ofs] = (byte)(0xC0 + (value >> 16));  	data [ofs + 1] = unchecked((byte)(value >> 8));  	data [ofs + 2] = unchecked((byte)value);  	ofs += 3;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x200000) {  	data [ofs] = (byte)(0xC0 + (value >> 16));  	data [ofs + 1] = unchecked((byte)(value >> 8));  	data [ofs + 2] = unchecked((byte)value);  	ofs += 3;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs] = (byte)(0xC0 + (value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 3;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000) {  	data [ofs] = (byte)(0xE0 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000) {  	data [ofs] = (byte)(0xE0 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000) {  	data [ofs] = (byte)(0xE0 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000) {  	data [ofs] = (byte)(0xE0 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000) {  	data [ofs] = (byte)(0xE0 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000) {  	data [ofs] = (byte)(0xE0 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs] = (byte)(0xE0 + (value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 4;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 5;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x4000) {  	data [ofs] = (byte)(0x80 + (value >> 8));  	data [ofs + 1] = unchecked((byte)value);  	ofs += 2;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x4000) {  	data [ofs] = (byte)(0x80 + (value >> 8));  	data [ofs + 1] = unchecked((byte)value);  	ofs += 2;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs] = (byte)(0x80 + (value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 2;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x200000) {  	data [ofs] = (byte)(0xC0 + (value >> 16));  	data [ofs + 1] = unchecked((byte)(value >> 8));  	data [ofs + 2] = unchecked((byte)value);  	ofs += 3;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x200000) {  	data [ofs] = (byte)(0xC0 + (value >> 16));  	data [ofs + 1] = unchecked((byte)(value >> 8));  	data [ofs + 2] = unchecked((byte)value);  	ofs += 3;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x200000) {  	data [ofs] = (byte)(0xC0 + (value >> 16));  	data [ofs + 1] = unchecked((byte)(value >> 8));  	data [ofs + 2] = unchecked((byte)value);  	ofs += 3;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x200000) {  	data [ofs] = (byte)(0xC0 + (value >> 16));  	data [ofs + 1] = unchecked((byte)(value >> 8));  	data [ofs + 2] = unchecked((byte)value);  	ofs += 3;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs] = (byte)(0xC0 + (value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 3;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000) {  	data [ofs] = (byte)(0xE0 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000) {  	data [ofs] = (byte)(0xE0 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000) {  	data [ofs] = (byte)(0xE0 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000) {  	data [ofs] = (byte)(0xE0 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000) {  	data [ofs] = (byte)(0xE0 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x10000000) {  	data [ofs] = (byte)(0xE0 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs] = (byte)(0xE0 + (value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 4;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0800000000) {  	data [ofs] = (byte)(0xF0 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0800000000) {  	data [ofs] = (byte)(0xF0 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0800000000) {  	data [ofs] = (byte)(0xF0 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0800000000) {  	data [ofs] = (byte)(0xF0 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0800000000) {  	data [ofs] = (byte)(0xF0 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0800000000) {  	data [ofs] = (byte)(0xF0 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0800000000) {  	data [ofs] = (byte)(0xF0 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0800000000) {  	data [ofs] = (byte)(0xF0 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs] = (byte)(0xF0 + (value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 5;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x040000000000) {  	data [ofs] = (byte)(0xF8 + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x040000000000) {  	data [ofs] = (byte)(0xF8 + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x040000000000) {  	data [ofs] = (byte)(0xF8 + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x040000000000) {  	data [ofs] = (byte)(0xF8 + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x040000000000) {  	data [ofs] = (byte)(0xF8 + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x040000000000) {  	data [ofs] = (byte)(0xF8 + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x040000000000) {  	data [ofs] = (byte)(0xF8 + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x040000000000) {  	data [ofs] = (byte)(0xF8 + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x040000000000) {  	data [ofs] = (byte)(0xF8 + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x040000000000) {  	data [ofs] = (byte)(0xF8 + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs] = (byte)(0xF8 + (value >> 40));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 5] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 6;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000) {  	data [ofs] = (byte)(0xFC + (value >> 48));  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000) {  	data [ofs] = (byte)(0xFC + (value >> 48));  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000) {  	data [ofs] = (byte)(0xFC + (value >> 48));  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000) {  	data [ofs] = (byte)(0xFC + (value >> 48));  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000) {  	data [ofs] = (byte)(0xFC + (value >> 48));  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000) {  	data [ofs] = (byte)(0xFC + (value >> 48));  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000) {  	data [ofs] = (byte)(0xFC + (value >> 48));  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000) {  	data [ofs] = (byte)(0xFC + (value >> 48));  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000) {  	data [ofs] = (byte)(0xFC + (value >> 48));  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000) {  	data [ofs] = (byte)(0xFC + (value >> 48));  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000) {  	data [ofs] = (byte)(0xFC + (value >> 48));  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x02000000000000) {  	data [ofs] = (byte)(0xFC + (value >> 48));  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs] = (byte)(0xFC + (value >> 48));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 40));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 5] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 5] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 6] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 7;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000) {  	data [ofs] = (byte)(0xFE + (value >> 56));  	data [ofs + 1] = unchecked((byte)(value >> 48));  	data [ofs + 2] = unchecked((byte)(value >> 40));  	data [ofs + 3] = unchecked((byte)(value >> 32));  	data [ofs + 4] = unchecked((byte)(value >> 24));  	data [ofs + 5] = unchecked((byte)(value >> 16));  	data [ofs + 6] = unchecked((byte)(value >> 8));  	data [ofs + 7] = unchecked((byte)value);  	ofs += 8;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000) {  	data [ofs] = (byte)(0xFE + (value >> 56));  	data [ofs + 1] = unchecked((byte)(value >> 48));  	data [ofs + 2] = unchecked((byte)(value >> 40));  	data [ofs + 3] = unchecked((byte)(value >> 32));  	data [ofs + 4] = unchecked((byte)(value >> 24));  	data [ofs + 5] = unchecked((byte)(value >> 16));  	data [ofs + 6] = unchecked((byte)(value >> 8));  	data [ofs + 7] = unchecked((byte)value);  	ofs += 8;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000) {  	data [ofs] = (byte)(0xFE + (value >> 56));  	data [ofs + 1] = unchecked((byte)(value >> 48));  	data [ofs + 2] = unchecked((byte)(value >> 40));  	data [ofs + 3] = unchecked((byte)(value >> 32));  	data [ofs + 4] = unchecked((byte)(value >> 24));  	data [ofs + 5] = unchecked((byte)(value >> 16));  	data [ofs + 6] = unchecked((byte)(value >> 8));  	data [ofs + 7] = unchecked((byte)value);  	ofs += 8;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000) {  	data [ofs] = (byte)(0xFE + (value >> 56));  	data [ofs + 1] = unchecked((byte)(value >> 48));  	data [ofs + 2] = unchecked((byte)(value >> 40));  	data [ofs + 3] = unchecked((byte)(value >> 32));  	data [ofs + 4] = unchecked((byte)(value >> 24));  	data [ofs + 5] = unchecked((byte)(value >> 16));  	data [ofs + 6] = unchecked((byte)(value >> 8));  	data [ofs + 7] = unchecked((byte)value);  	ofs += 8;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000) {  	data [ofs] = (byte)(0xFE + (value >> 56));  	data [ofs + 1] = unchecked((byte)(value >> 48));  	data [ofs + 2] = unchecked((byte)(value >> 40));  	data [ofs + 3] = unchecked((byte)(value >> 32));  	data [ofs + 4] = unchecked((byte)(value >> 24));  	data [ofs + 5] = unchecked((byte)(value >> 16));  	data [ofs + 6] = unchecked((byte)(value >> 8));  	data [ofs + 7] = unchecked((byte)value);  	ofs += 8;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000) {  	data [ofs] = (byte)(0xFE + (value >> 56));  	data [ofs + 1] = unchecked((byte)(value >> 48));  	data [ofs + 2] = unchecked((byte)(value >> 40));  	data [ofs + 3] = unchecked((byte)(value >> 32));  	data [ofs + 4] = unchecked((byte)(value >> 24));  	data [ofs + 5] = unchecked((byte)(value >> 16));  	data [ofs + 6] = unchecked((byte)(value >> 8));  	data [ofs + 7] = unchecked((byte)value);  	ofs += 8;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000) {  	data [ofs] = (byte)(0xFE + (value >> 56));  	data [ofs + 1] = unchecked((byte)(value >> 48));  	data [ofs + 2] = unchecked((byte)(value >> 40));  	data [ofs + 3] = unchecked((byte)(value >> 32));  	data [ofs + 4] = unchecked((byte)(value >> 24));  	data [ofs + 5] = unchecked((byte)(value >> 16));  	data [ofs + 6] = unchecked((byte)(value >> 8));  	data [ofs + 7] = unchecked((byte)value);  	ofs += 8;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000) {  	data [ofs] = (byte)(0xFE + (value >> 56));  	data [ofs + 1] = unchecked((byte)(value >> 48));  	data [ofs + 2] = unchecked((byte)(value >> 40));  	data [ofs + 3] = unchecked((byte)(value >> 32));  	data [ofs + 4] = unchecked((byte)(value >> 24));  	data [ofs + 5] = unchecked((byte)(value >> 16));  	data [ofs + 6] = unchecked((byte)(value >> 8));  	data [ofs + 7] = unchecked((byte)value);  	ofs += 8;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000) {  	data [ofs] = (byte)(0xFE + (value >> 56));  	data [ofs + 1] = unchecked((byte)(value >> 48));  	data [ofs + 2] = unchecked((byte)(value >> 40));  	data [ofs + 3] = unchecked((byte)(value >> 32));  	data [ofs + 4] = unchecked((byte)(value >> 24));  	data [ofs + 5] = unchecked((byte)(value >> 16));  	data [ofs + 6] = unchecked((byte)(value >> 8));  	data [ofs + 7] = unchecked((byte)value);  	ofs += 8;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000) {  	data [ofs] = (byte)(0xFE + (value >> 56));  	data [ofs + 1] = unchecked((byte)(value >> 48));  	data [ofs + 2] = unchecked((byte)(value >> 40));  	data [ofs + 3] = unchecked((byte)(value >> 32));  	data [ofs + 4] = unchecked((byte)(value >> 24));  	data [ofs + 5] = unchecked((byte)(value >> 16));  	data [ofs + 6] = unchecked((byte)(value >> 8));  	data [ofs + 7] = unchecked((byte)value);  	ofs += 8;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000) {  	data [ofs] = (byte)(0xFE + (value >> 56));  	data [ofs + 1] = unchecked((byte)(value >> 48));  	data [ofs + 2] = unchecked((byte)(value >> 40));  	data [ofs + 3] = unchecked((byte)(value >> 32));  	data [ofs + 4] = unchecked((byte)(value >> 24));  	data [ofs + 5] = unchecked((byte)(value >> 16));  	data [ofs + 6] = unchecked((byte)(value >> 8));  	data [ofs + 7] = unchecked((byte)value);  	ofs += 8;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000) {  	data [ofs] = (byte)(0xFE + (value >> 56));  	data [ofs + 1] = unchecked((byte)(value >> 48));  	data [ofs + 2] = unchecked((byte)(value >> 40));  	data [ofs + 3] = unchecked((byte)(value >> 32));  	data [ofs + 4] = unchecked((byte)(value >> 24));  	data [ofs + 5] = unchecked((byte)(value >> 16));  	data [ofs + 6] = unchecked((byte)(value >> 8));  	data [ofs + 7] = unchecked((byte)value);  	ofs += 8;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000) {  	data [ofs] = (byte)(0xFE + (value >> 56));  	data [ofs + 1] = unchecked((byte)(value >> 48));  	data [ofs + 2] = unchecked((byte)(value >> 40));  	data [ofs + 3] = unchecked((byte)(value >> 32));  	data [ofs + 4] = unchecked((byte)(value >> 24));  	data [ofs + 5] = unchecked((byte)(value >> 16));  	data [ofs + 6] = unchecked((byte)(value >> 8));  	data [ofs + 7] = unchecked((byte)value);  	ofs += 8;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: if (value < 0x0100000000000000) {  	data [ofs] = (byte)(0xFE + (value >> 56));  	data [ofs + 1] = unchecked((byte)(value >> 48));  	data [ofs + 2] = unchecked((byte)(value >> 40));  	data [ofs + 3] = unchecked((byte)(value >> 32));  	data [ofs + 4] = unchecked((byte)(value >> 24));  	data [ofs + 5] = unchecked((byte)(value >> 16));  	data [ofs + 6] = unchecked((byte)(value >> 8));  	data [ofs + 7] = unchecked((byte)value);  	ofs += 8;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs] = (byte)(0xFE + (value >> 56));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 48));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 40));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 40));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 5] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 5] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 6] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 6] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 7] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 8;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 56));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 48));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 48));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 40));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 40));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 5] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 5] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 6] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 6] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 7] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 7] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: data [ofs + 8] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVUInt,The following statement contains a magic number: ofs += 9;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xC0) {  	result = ((first & 0x3F) << 8) + data [ofs];  	ofs++;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((first & 0x3F) << 8) + data [ofs];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xE0) {  	result = ((first & 0x1Fu) << 16) + ((uint)data [ofs] << 8) + data [ofs + 1];  	ofs += 2;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xE0) {  	result = ((first & 0x1Fu) << 16) + ((uint)data [ofs] << 8) + data [ofs + 1];  	ofs += 2;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xE0) {  	result = ((first & 0x1Fu) << 16) + ((uint)data [ofs] << 8) + data [ofs + 1];  	ofs += 2;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((first & 0x1Fu) << 16) + ((uint)data [ofs] << 8) + data [ofs + 1];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((first & 0x1Fu) << 16) + ((uint)data [ofs] << 8) + data [ofs + 1];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: ofs += 2;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF0) {  	result = ((first & 0x0Fu) << 24) + ((uint)data [ofs] << 16) + ((uint)data [ofs + 1] << 8) + data [ofs + 2];  	ofs += 3;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF0) {  	result = ((first & 0x0Fu) << 24) + ((uint)data [ofs] << 16) + ((uint)data [ofs + 1] << 8) + data [ofs + 2];  	ofs += 3;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF0) {  	result = ((first & 0x0Fu) << 24) + ((uint)data [ofs] << 16) + ((uint)data [ofs + 1] << 8) + data [ofs + 2];  	ofs += 3;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF0) {  	result = ((first & 0x0Fu) << 24) + ((uint)data [ofs] << 16) + ((uint)data [ofs + 1] << 8) + data [ofs + 2];  	ofs += 3;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF0) {  	result = ((first & 0x0Fu) << 24) + ((uint)data [ofs] << 16) + ((uint)data [ofs + 1] << 8) + data [ofs + 2];  	ofs += 3;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((first & 0x0Fu) << 24) + ((uint)data [ofs] << 16) + ((uint)data [ofs + 1] << 8) + data [ofs + 2];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((first & 0x0Fu) << 24) + ((uint)data [ofs] << 16) + ((uint)data [ofs + 1] << 8) + data [ofs + 2];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((first & 0x0Fu) << 24) + ((uint)data [ofs] << 16) + ((uint)data [ofs + 1] << 8) + data [ofs + 2];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((first & 0x0Fu) << 24) + ((uint)data [ofs] << 16) + ((uint)data [ofs + 1] << 8) + data [ofs + 2];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: ofs += 3;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF8) {  	result = ((ulong)(first & 0x07u) << 32) + ((uint)data [ofs] << 24) + ((uint)data [ofs + 1] << 16) + ((uint)data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF8) {  	result = ((ulong)(first & 0x07u) << 32) + ((uint)data [ofs] << 24) + ((uint)data [ofs + 1] << 16) + ((uint)data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF8) {  	result = ((ulong)(first & 0x07u) << 32) + ((uint)data [ofs] << 24) + ((uint)data [ofs + 1] << 16) + ((uint)data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF8) {  	result = ((ulong)(first & 0x07u) << 32) + ((uint)data [ofs] << 24) + ((uint)data [ofs + 1] << 16) + ((uint)data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF8) {  	result = ((ulong)(first & 0x07u) << 32) + ((uint)data [ofs] << 24) + ((uint)data [ofs + 1] << 16) + ((uint)data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF8) {  	result = ((ulong)(first & 0x07u) << 32) + ((uint)data [ofs] << 24) + ((uint)data [ofs + 1] << 16) + ((uint)data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xF8) {  	result = ((ulong)(first & 0x07u) << 32) + ((uint)data [ofs] << 24) + ((uint)data [ofs + 1] << 16) + ((uint)data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x07u) << 32) + ((uint)data [ofs] << 24) + ((uint)data [ofs + 1] << 16) + ((uint)data [ofs + 2] << 8) + data [ofs + 3];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x07u) << 32) + ((uint)data [ofs] << 24) + ((uint)data [ofs + 1] << 16) + ((uint)data [ofs + 2] << 8) + data [ofs + 3];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x07u) << 32) + ((uint)data [ofs] << 24) + ((uint)data [ofs + 1] << 16) + ((uint)data [ofs + 2] << 8) + data [ofs + 3];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x07u) << 32) + ((uint)data [ofs] << 24) + ((uint)data [ofs + 1] << 16) + ((uint)data [ofs + 2] << 8) + data [ofs + 3];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x07u) << 32) + ((uint)data [ofs] << 24) + ((uint)data [ofs + 1] << 16) + ((uint)data [ofs + 2] << 8) + data [ofs + 3];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x07u) << 32) + ((uint)data [ofs] << 24) + ((uint)data [ofs + 1] << 16) + ((uint)data [ofs + 2] << 8) + data [ofs + 3];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: ofs += 4;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFC) {  	result = ((ulong)(first & 0x03u) << 40) + ((ulong)data [ofs] << 32) + ((uint)data [ofs + 1] << 24) + ((uint)data [ofs + 2] << 16) + ((uint)data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFC) {  	result = ((ulong)(first & 0x03u) << 40) + ((ulong)data [ofs] << 32) + ((uint)data [ofs + 1] << 24) + ((uint)data [ofs + 2] << 16) + ((uint)data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFC) {  	result = ((ulong)(first & 0x03u) << 40) + ((ulong)data [ofs] << 32) + ((uint)data [ofs + 1] << 24) + ((uint)data [ofs + 2] << 16) + ((uint)data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFC) {  	result = ((ulong)(first & 0x03u) << 40) + ((ulong)data [ofs] << 32) + ((uint)data [ofs + 1] << 24) + ((uint)data [ofs + 2] << 16) + ((uint)data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFC) {  	result = ((ulong)(first & 0x03u) << 40) + ((ulong)data [ofs] << 32) + ((uint)data [ofs + 1] << 24) + ((uint)data [ofs + 2] << 16) + ((uint)data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFC) {  	result = ((ulong)(first & 0x03u) << 40) + ((ulong)data [ofs] << 32) + ((uint)data [ofs + 1] << 24) + ((uint)data [ofs + 2] << 16) + ((uint)data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFC) {  	result = ((ulong)(first & 0x03u) << 40) + ((ulong)data [ofs] << 32) + ((uint)data [ofs + 1] << 24) + ((uint)data [ofs + 2] << 16) + ((uint)data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFC) {  	result = ((ulong)(first & 0x03u) << 40) + ((ulong)data [ofs] << 32) + ((uint)data [ofs + 1] << 24) + ((uint)data [ofs + 2] << 16) + ((uint)data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFC) {  	result = ((ulong)(first & 0x03u) << 40) + ((ulong)data [ofs] << 32) + ((uint)data [ofs + 1] << 24) + ((uint)data [ofs + 2] << 16) + ((uint)data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x03u) << 40) + ((ulong)data [ofs] << 32) + ((uint)data [ofs + 1] << 24) + ((uint)data [ofs + 2] << 16) + ((uint)data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x03u) << 40) + ((ulong)data [ofs] << 32) + ((uint)data [ofs + 1] << 24) + ((uint)data [ofs + 2] << 16) + ((uint)data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x03u) << 40) + ((ulong)data [ofs] << 32) + ((uint)data [ofs + 1] << 24) + ((uint)data [ofs + 2] << 16) + ((uint)data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x03u) << 40) + ((ulong)data [ofs] << 32) + ((uint)data [ofs + 1] << 24) + ((uint)data [ofs + 2] << 16) + ((uint)data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x03u) << 40) + ((ulong)data [ofs] << 32) + ((uint)data [ofs + 1] << 24) + ((uint)data [ofs + 2] << 16) + ((uint)data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x03u) << 40) + ((ulong)data [ofs] << 32) + ((uint)data [ofs + 1] << 24) + ((uint)data [ofs + 2] << 16) + ((uint)data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x03u) << 40) + ((ulong)data [ofs] << 32) + ((uint)data [ofs + 1] << 24) + ((uint)data [ofs + 2] << 16) + ((uint)data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x03u) << 40) + ((ulong)data [ofs] << 32) + ((uint)data [ofs + 1] << 24) + ((uint)data [ofs + 2] << 16) + ((uint)data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: ofs += 5;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE) {  	result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE) {  	result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE) {  	result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE) {  	result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE) {  	result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE) {  	result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE) {  	result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE) {  	result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE) {  	result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE) {  	result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first < 0xFE) {  	result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)(first & 0x01u) << 48) + ((ulong)data [ofs] << 40) + ((ulong)data [ofs + 1] << 32) + ((uint)data [ofs + 2] << 24) + ((uint)data [ofs + 3] << 16) + ((uint)data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: ofs += 6;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE) {  	result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  	ofs += 7;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE) {  	result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  	ofs += 7;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE) {  	result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  	ofs += 7;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE) {  	result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  	ofs += 7;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE) {  	result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  	ofs += 7;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE) {  	result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  	ofs += 7;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE) {  	result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  	ofs += 7;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE) {  	result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  	ofs += 7;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE) {  	result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  	ofs += 7;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE) {  	result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  	ofs += 7;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE) {  	result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  	ofs += 7;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: if (first == 0xFE) {  	result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  	ofs += 7;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 48) + ((ulong)data [ofs + 1] << 40) + ((ulong)data [ofs + 2] << 32) + ((uint)data [ofs + 3] << 24) + ((uint)data [ofs + 4] << 16) + ((uint)data [ofs + 5] << 8) + data [ofs + 6];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: ofs += 7;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 56) + ((ulong)data [ofs + 1] << 48) + ((ulong)data [ofs + 2] << 40) + ((ulong)data [ofs + 3] << 32) + ((uint)data [ofs + 4] << 24) + ((uint)data [ofs + 5] << 16) + ((uint)data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 56) + ((ulong)data [ofs + 1] << 48) + ((ulong)data [ofs + 2] << 40) + ((ulong)data [ofs + 3] << 32) + ((uint)data [ofs + 4] << 24) + ((uint)data [ofs + 5] << 16) + ((uint)data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 56) + ((ulong)data [ofs + 1] << 48) + ((ulong)data [ofs + 2] << 40) + ((ulong)data [ofs + 3] << 32) + ((uint)data [ofs + 4] << 24) + ((uint)data [ofs + 5] << 16) + ((uint)data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 56) + ((ulong)data [ofs + 1] << 48) + ((ulong)data [ofs + 2] << 40) + ((ulong)data [ofs + 3] << 32) + ((uint)data [ofs + 4] << 24) + ((uint)data [ofs + 5] << 16) + ((uint)data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 56) + ((ulong)data [ofs + 1] << 48) + ((ulong)data [ofs + 2] << 40) + ((ulong)data [ofs + 3] << 32) + ((uint)data [ofs + 4] << 24) + ((uint)data [ofs + 5] << 16) + ((uint)data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 56) + ((ulong)data [ofs + 1] << 48) + ((ulong)data [ofs + 2] << 40) + ((ulong)data [ofs + 3] << 32) + ((uint)data [ofs + 4] << 24) + ((uint)data [ofs + 5] << 16) + ((uint)data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 56) + ((ulong)data [ofs + 1] << 48) + ((ulong)data [ofs + 2] << 40) + ((ulong)data [ofs + 3] << 32) + ((uint)data [ofs + 4] << 24) + ((uint)data [ofs + 5] << 16) + ((uint)data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 56) + ((ulong)data [ofs + 1] << 48) + ((ulong)data [ofs + 2] << 40) + ((ulong)data [ofs + 3] << 32) + ((uint)data [ofs + 4] << 24) + ((uint)data [ofs + 5] << 16) + ((uint)data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 56) + ((ulong)data [ofs + 1] << 48) + ((ulong)data [ofs + 2] << 40) + ((ulong)data [ofs + 3] << 32) + ((uint)data [ofs + 4] << 24) + ((uint)data [ofs + 5] << 16) + ((uint)data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 56) + ((ulong)data [ofs + 1] << 48) + ((ulong)data [ofs + 2] << 40) + ((ulong)data [ofs + 3] << 32) + ((uint)data [ofs + 4] << 24) + ((uint)data [ofs + 5] << 16) + ((uint)data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 56) + ((ulong)data [ofs + 1] << 48) + ((ulong)data [ofs + 2] << 40) + ((ulong)data [ofs + 3] << 32) + ((uint)data [ofs + 4] << 24) + ((uint)data [ofs + 5] << 16) + ((uint)data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 56) + ((ulong)data [ofs + 1] << 48) + ((ulong)data [ofs + 2] << 40) + ((ulong)data [ofs + 3] << 32) + ((uint)data [ofs + 4] << 24) + ((uint)data [ofs + 5] << 16) + ((uint)data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: result = ((ulong)data [ofs] << 56) + ((ulong)data [ofs + 1] << 48) + ((ulong)data [ofs + 2] << 40) + ((ulong)data [ofs + 3] << 32) + ((uint)data [ofs + 4] << 24) + ((uint)data [ofs + 5] << 16) + ((uint)data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVUInt,The following statement contains a magic number: ofs += 8;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (-0x2000 <= value && value < 0x2000)  	return 2;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 2;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (-0x100000 <= value && value < 0x100000)  	return 3;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 3;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (-0x08000000 <= value && value < 0x08000000)  	return 4;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 4;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 5;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (-0x2000 <= value && value < 0x2000)  	return 2;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 2;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (-0x100000 <= value && value < 0x100000)  	return 3;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 3;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (-0x08000000 <= value && value < 0x08000000)  	return 4;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 4;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (-0x0400000000 <= value && value < 0x0400000000)  	return 5;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 5;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (-0x020000000000 <= value && value < 0x020000000000)  	return 6;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 6;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (-0x01000000000000 <= value && value < 0x01000000000000)  	return 7;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 7;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 9;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (0x20 <= first && first < 0xE0)  	return 2;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 2;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (0x10 <= first && first < 0xF0)  	return 3;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 3;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (0x08 <= first && first < 0xF8)  	return 4;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 4;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (0x04 <= first && first < 0xFC)  	return 5;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 5;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (0x02 <= first && first < 0xFE)  	return 6;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 6;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: if (0x01 <= first && first < 0xFF)  	return 7;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 7;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,LengthVInt,The following statement contains a magic number: return 9;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= 0) {  	if (value < 0x2000) {  		data [ofs] = (byte)(0xC0 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value < 0x100000) {  		data [ofs] = (byte)(0xE0 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value < 0x08000000) {  		data [ofs] = (byte)(0xF0 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value < 0x0400000000) {  		data [ofs] = (byte)(0xF8 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value < 0x020000000000) {  		data [ofs] = (byte)(0xFC + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value < 0x01000000000000) {  		data [ofs] = 0xFE;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0xFF;  } else {  	if (value >= -0x2000) {  		data [ofs] = (byte)(0x40 + (value >> 8));  		data [ofs + 1] = unchecked((byte)value);  		ofs += 2;  		return;  	}  	if (value >= -0x100000) {  		data [ofs] = (byte)(0x20 + (value >> 16));  		data [ofs + 1] = unchecked((byte)(value >> 8));  		data [ofs + 2] = unchecked((byte)value);  		ofs += 3;  		return;  	}  	if (value >= -0x08000000) {  		data [ofs] = (byte)(0x10 + (value >> 24));  		data [ofs + 1] = unchecked((byte)(value >> 16));  		data [ofs + 2] = unchecked((byte)(value >> 8));  		data [ofs + 3] = unchecked((byte)value);  		ofs += 4;  		return;  	}  	if (value >= -0x0400000000) {  		data [ofs] = (byte)(0x08 + (value >> 32));  		data [ofs + 1] = unchecked((byte)(value >> 24));  		data [ofs + 2] = unchecked((byte)(value >> 16));  		data [ofs + 3] = unchecked((byte)(value >> 8));  		data [ofs + 4] = unchecked((byte)value);  		ofs += 5;  		return;  	}  	if (value >= -0x020000000000) {  		data [ofs] = (byte)(0x04 + (value >> 40));  		data [ofs + 1] = unchecked((byte)(value >> 32));  		data [ofs + 2] = unchecked((byte)(value >> 24));  		data [ofs + 3] = unchecked((byte)(value >> 16));  		data [ofs + 4] = unchecked((byte)(value >> 8));  		data [ofs + 5] = unchecked((byte)value);  		ofs += 6;  		return;  	}  	if (value >= -0x01000000000000) {  		data [ofs] = 0x01;  		data [ofs + 1] = unchecked((byte)(value >> 40));  		data [ofs + 2] = unchecked((byte)(value >> 32));  		data [ofs + 3] = unchecked((byte)(value >> 24));  		data [ofs + 4] = unchecked((byte)(value >> 16));  		data [ofs + 5] = unchecked((byte)(value >> 8));  		data [ofs + 6] = unchecked((byte)value);  		ofs += 7;  		return;  	}  	data [ofs] = 0;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x2000) {  	data [ofs] = (byte)(0xC0 + (value >> 8));  	data [ofs + 1] = unchecked((byte)value);  	ofs += 2;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x2000) {  	data [ofs] = (byte)(0xC0 + (value >> 8));  	data [ofs + 1] = unchecked((byte)value);  	ofs += 2;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs] = (byte)(0xC0 + (value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 2;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x100000) {  	data [ofs] = (byte)(0xE0 + (value >> 16));  	data [ofs + 1] = unchecked((byte)(value >> 8));  	data [ofs + 2] = unchecked((byte)value);  	ofs += 3;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x100000) {  	data [ofs] = (byte)(0xE0 + (value >> 16));  	data [ofs + 1] = unchecked((byte)(value >> 8));  	data [ofs + 2] = unchecked((byte)value);  	ofs += 3;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x100000) {  	data [ofs] = (byte)(0xE0 + (value >> 16));  	data [ofs + 1] = unchecked((byte)(value >> 8));  	data [ofs + 2] = unchecked((byte)value);  	ofs += 3;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x100000) {  	data [ofs] = (byte)(0xE0 + (value >> 16));  	data [ofs + 1] = unchecked((byte)(value >> 8));  	data [ofs + 2] = unchecked((byte)value);  	ofs += 3;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs] = (byte)(0xE0 + (value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 3;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x08000000) {  	data [ofs] = (byte)(0xF0 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x08000000) {  	data [ofs] = (byte)(0xF0 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x08000000) {  	data [ofs] = (byte)(0xF0 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x08000000) {  	data [ofs] = (byte)(0xF0 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x08000000) {  	data [ofs] = (byte)(0xF0 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x08000000) {  	data [ofs] = (byte)(0xF0 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs] = (byte)(0xF0 + (value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 4;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x0400000000) {  	data [ofs] = (byte)(0xF8 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x0400000000) {  	data [ofs] = (byte)(0xF8 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x0400000000) {  	data [ofs] = (byte)(0xF8 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x0400000000) {  	data [ofs] = (byte)(0xF8 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x0400000000) {  	data [ofs] = (byte)(0xF8 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x0400000000) {  	data [ofs] = (byte)(0xF8 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x0400000000) {  	data [ofs] = (byte)(0xF8 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x0400000000) {  	data [ofs] = (byte)(0xF8 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs] = (byte)(0xF8 + (value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 5;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x020000000000) {  	data [ofs] = (byte)(0xFC + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x020000000000) {  	data [ofs] = (byte)(0xFC + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x020000000000) {  	data [ofs] = (byte)(0xFC + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x020000000000) {  	data [ofs] = (byte)(0xFC + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x020000000000) {  	data [ofs] = (byte)(0xFC + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x020000000000) {  	data [ofs] = (byte)(0xFC + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x020000000000) {  	data [ofs] = (byte)(0xFC + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x020000000000) {  	data [ofs] = (byte)(0xFC + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x020000000000) {  	data [ofs] = (byte)(0xFC + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x020000000000) {  	data [ofs] = (byte)(0xFC + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs] = (byte)(0xFC + (value >> 40));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 5] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 6;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x01000000000000) {  	data [ofs] = 0xFE;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x01000000000000) {  	data [ofs] = 0xFE;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x01000000000000) {  	data [ofs] = 0xFE;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x01000000000000) {  	data [ofs] = 0xFE;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x01000000000000) {  	data [ofs] = 0xFE;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x01000000000000) {  	data [ofs] = 0xFE;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x01000000000000) {  	data [ofs] = 0xFE;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x01000000000000) {  	data [ofs] = 0xFE;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x01000000000000) {  	data [ofs] = 0xFE;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x01000000000000) {  	data [ofs] = 0xFE;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value < 0x01000000000000) {  	data [ofs] = 0xFE;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 40));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 5] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 5] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 6] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 7;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x2000) {  	data [ofs] = (byte)(0x40 + (value >> 8));  	data [ofs + 1] = unchecked((byte)value);  	ofs += 2;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x2000) {  	data [ofs] = (byte)(0x40 + (value >> 8));  	data [ofs + 1] = unchecked((byte)value);  	ofs += 2;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs] = (byte)(0x40 + (value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 2;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x100000) {  	data [ofs] = (byte)(0x20 + (value >> 16));  	data [ofs + 1] = unchecked((byte)(value >> 8));  	data [ofs + 2] = unchecked((byte)value);  	ofs += 3;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x100000) {  	data [ofs] = (byte)(0x20 + (value >> 16));  	data [ofs + 1] = unchecked((byte)(value >> 8));  	data [ofs + 2] = unchecked((byte)value);  	ofs += 3;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x100000) {  	data [ofs] = (byte)(0x20 + (value >> 16));  	data [ofs + 1] = unchecked((byte)(value >> 8));  	data [ofs + 2] = unchecked((byte)value);  	ofs += 3;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x100000) {  	data [ofs] = (byte)(0x20 + (value >> 16));  	data [ofs + 1] = unchecked((byte)(value >> 8));  	data [ofs + 2] = unchecked((byte)value);  	ofs += 3;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs] = (byte)(0x20 + (value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 3;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x08000000) {  	data [ofs] = (byte)(0x10 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x08000000) {  	data [ofs] = (byte)(0x10 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x08000000) {  	data [ofs] = (byte)(0x10 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x08000000) {  	data [ofs] = (byte)(0x10 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x08000000) {  	data [ofs] = (byte)(0x10 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x08000000) {  	data [ofs] = (byte)(0x10 + (value >> 24));  	data [ofs + 1] = unchecked((byte)(value >> 16));  	data [ofs + 2] = unchecked((byte)(value >> 8));  	data [ofs + 3] = unchecked((byte)value);  	ofs += 4;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs] = (byte)(0x10 + (value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 4;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x0400000000) {  	data [ofs] = (byte)(0x08 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x0400000000) {  	data [ofs] = (byte)(0x08 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x0400000000) {  	data [ofs] = (byte)(0x08 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x0400000000) {  	data [ofs] = (byte)(0x08 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x0400000000) {  	data [ofs] = (byte)(0x08 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x0400000000) {  	data [ofs] = (byte)(0x08 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x0400000000) {  	data [ofs] = (byte)(0x08 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x0400000000) {  	data [ofs] = (byte)(0x08 + (value >> 32));  	data [ofs + 1] = unchecked((byte)(value >> 24));  	data [ofs + 2] = unchecked((byte)(value >> 16));  	data [ofs + 3] = unchecked((byte)(value >> 8));  	data [ofs + 4] = unchecked((byte)value);  	ofs += 5;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs] = (byte)(0x08 + (value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 5;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x020000000000) {  	data [ofs] = (byte)(0x04 + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x020000000000) {  	data [ofs] = (byte)(0x04 + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x020000000000) {  	data [ofs] = (byte)(0x04 + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x020000000000) {  	data [ofs] = (byte)(0x04 + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x020000000000) {  	data [ofs] = (byte)(0x04 + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x020000000000) {  	data [ofs] = (byte)(0x04 + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x020000000000) {  	data [ofs] = (byte)(0x04 + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x020000000000) {  	data [ofs] = (byte)(0x04 + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x020000000000) {  	data [ofs] = (byte)(0x04 + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x020000000000) {  	data [ofs] = (byte)(0x04 + (value >> 40));  	data [ofs + 1] = unchecked((byte)(value >> 32));  	data [ofs + 2] = unchecked((byte)(value >> 24));  	data [ofs + 3] = unchecked((byte)(value >> 16));  	data [ofs + 4] = unchecked((byte)(value >> 8));  	data [ofs + 5] = unchecked((byte)value);  	ofs += 6;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs] = (byte)(0x04 + (value >> 40));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 5] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 6;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x01000000000000) {  	data [ofs] = 0x01;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x01000000000000) {  	data [ofs] = 0x01;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x01000000000000) {  	data [ofs] = 0x01;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x01000000000000) {  	data [ofs] = 0x01;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x01000000000000) {  	data [ofs] = 0x01;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x01000000000000) {  	data [ofs] = 0x01;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x01000000000000) {  	data [ofs] = 0x01;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x01000000000000) {  	data [ofs] = 0x01;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x01000000000000) {  	data [ofs] = 0x01;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x01000000000000) {  	data [ofs] = 0x01;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: if (value >= -0x01000000000000) {  	data [ofs] = 0x01;  	data [ofs + 1] = unchecked((byte)(value >> 40));  	data [ofs + 2] = unchecked((byte)(value >> 32));  	data [ofs + 3] = unchecked((byte)(value >> 24));  	data [ofs + 4] = unchecked((byte)(value >> 16));  	data [ofs + 5] = unchecked((byte)(value >> 8));  	data [ofs + 6] = unchecked((byte)value);  	ofs += 7;  	return;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 40));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 5] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 5] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 6] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 7;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 1] = unchecked((byte)(value >> 56));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 48));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 2] = unchecked((byte)(value >> 48));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 40));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 3] = unchecked((byte)(value >> 40));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 4] = unchecked((byte)(value >> 32));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 5] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 5] = unchecked((byte)(value >> 24));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 6] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 6] = unchecked((byte)(value >> 16));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 7] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 7] = unchecked((byte)(value >> 8));  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: data [ofs + 8] = unchecked((byte)value);  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,PackVInt,The following statement contains a magic number: ofs += 9;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x80) {  	if (first < 0xE0) {  		result = ((first & 0x1F) << 8) + data [ofs];  		ofs++;  		return result;  	}  	if (first < 0xF0) {  		result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  		ofs += 2;  		return result;  	}  	if (first < 0xF8) {  		result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  		ofs += 3;  		return result;  	}  	if (first < 0xFC) {  		result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  		ofs += 4;  		return result;  	}  	if (first < 0xFE) {  		result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  		ofs += 5;  		return result;  	}  	if (first < 0xFF) {  		result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  		ofs += 6;  		return result;  	}  	result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  	ofs += 8;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xE0) {  	result = ((first & 0x1F) << 8) + data [ofs];  	ofs++;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((first & 0x1F) << 8) + data [ofs];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xF0) {  	result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  	ofs += 2;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xF0) {  	result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  	ofs += 2;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xF0) {  	result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  	ofs += 2;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((first & 0x0F) << 16) + (data [ofs] << 8) + data [ofs + 1];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 2;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xF8) {  	result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  	ofs += 3;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xF8) {  	result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  	ofs += 3;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xF8) {  	result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  	ofs += 3;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xF8) {  	result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  	ofs += 3;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xF8) {  	result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  	ofs += 3;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((first & 0x07) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 3;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFC) {  	result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFC) {  	result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFC) {  	result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFC) {  	result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFC) {  	result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFC) {  	result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFC) {  	result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x03) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 4;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFE) {  	result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFE) {  	result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFE) {  	result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFE) {  	result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFE) {  	result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFE) {  	result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFE) {  	result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFE) {  	result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFE) {  	result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first & 0x01) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 5;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFF) {  	result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFF) {  	result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFF) {  	result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFF) {  	result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFF) {  	result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFF) {  	result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFF) {  	result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFF) {  	result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFF) {  	result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first < 0xFF) {  	result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 6;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 8;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x20) {  	result = ((int)(first - 0x40) << 8) + data [ofs];  	ofs++;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((int)(first - 0x40) << 8) + data [ofs];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x10) {  	result = ((int)(first - 0x20) << 16) + (data [ofs] << 8) + data [ofs + 1];  	ofs += 2;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x10) {  	result = ((int)(first - 0x20) << 16) + (data [ofs] << 8) + data [ofs + 1];  	ofs += 2;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x10) {  	result = ((int)(first - 0x20) << 16) + (data [ofs] << 8) + data [ofs + 1];  	ofs += 2;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((int)(first - 0x20) << 16) + (data [ofs] << 8) + data [ofs + 1];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((int)(first - 0x20) << 16) + (data [ofs] << 8) + data [ofs + 1];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 2;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x08) {  	result = ((int)(first - 0x10) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  	ofs += 3;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x08) {  	result = ((int)(first - 0x10) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  	ofs += 3;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x08) {  	result = ((int)(first - 0x10) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  	ofs += 3;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x08) {  	result = ((int)(first - 0x10) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  	ofs += 3;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x08) {  	result = ((int)(first - 0x10) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  	ofs += 3;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((int)(first - 0x10) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((int)(first - 0x10) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((int)(first - 0x10) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((int)(first - 0x10) << 24) + (data [ofs] << 16) + (data [ofs + 1] << 8) + data [ofs + 2];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 3;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x04) {  	result = ((long)(first - 0x08) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x04) {  	result = ((long)(first - 0x08) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x04) {  	result = ((long)(first - 0x08) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x04) {  	result = ((long)(first - 0x08) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x04) {  	result = ((long)(first - 0x08) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x04) {  	result = ((long)(first - 0x08) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x04) {  	result = ((long)(first - 0x08) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  	ofs += 4;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x08) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x08) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x08) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x08) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x08) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x08) << 32) + ((long)data [ofs] << 24) + (data [ofs + 1] << 16) + (data [ofs + 2] << 8) + data [ofs + 3];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 4;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x02) {  	result = ((long)(first - 0x04) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x02) {  	result = ((long)(first - 0x04) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x02) {  	result = ((long)(first - 0x04) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x02) {  	result = ((long)(first - 0x04) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x02) {  	result = ((long)(first - 0x04) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x02) {  	result = ((long)(first - 0x04) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x02) {  	result = ((long)(first - 0x04) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x02) {  	result = ((long)(first - 0x04) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x02) {  	result = ((long)(first - 0x04) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  	ofs += 5;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x04) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x04) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x04) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x04) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x04) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x04) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x04) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)(first - 0x04) << 40) + ((long)data [ofs] << 32) + ((long)data [ofs + 1] << 24) + (data [ofs + 2] << 16) + (data [ofs + 3] << 8) + data [ofs + 4];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 5;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01) {  	result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01) {  	result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01) {  	result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01) {  	result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01) {  	result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01) {  	result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01) {  	result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01) {  	result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01) {  	result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01) {  	result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: if (first >= 0x01) {  	result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  	ofs += 6;  	return result;  }  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = (-1L << 48) + ((long)data [ofs] << 40) + ((long)data [ofs + 1] << 32) + ((long)data [ofs + 2] << 24) + (data [ofs + 3] << 16) + (data [ofs + 4] << 8) + data [ofs + 5];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 6;  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: result = ((long)data [ofs] << 56) + ((long)data [ofs + 1] << 48) + ((long)data [ofs + 2] << 40) + ((long)data [ofs + 3] << 32) + ((long)data [ofs + 4] << 24) + (data [ofs + 5] << 16) + (data [ofs + 6] << 8) + data [ofs + 7];  
Magic Number,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,UnpackVInt,The following statement contains a magic number: ofs += 8;  
Magic Number,BTDB.ChunkCache,DiskChunkCache,F:\newReposMay17\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: if (keySize != 20)  	throw new NotSupportedException ("Only keySize of 20 (Usefull for SHA1) is supported for now");  
Magic Number,BTDB.ChunkCache,DiskChunkCache,F:\newReposMay17\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: if (cacheCapacity < 1000)  	throw new ArgumentOutOfRangeException (nameof (cacheCapacity)' "Minimum for cache capacity is 1kB");  
Magic Number,BTDB.ChunkCache,DiskChunkCache,F:\newReposMay17\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: cacheCapacity = cacheCapacity / 1000 * (980 - keySize);  
Magic Number,BTDB.ChunkCache,DiskChunkCache,F:\newReposMay17\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: cacheCapacity = cacheCapacity / 1000 * (980 - keySize);  
Magic Number,BTDB.ChunkCache,DiskChunkCache,F:\newReposMay17\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: if (cacheCapacity / 8 > int.MaxValue) {  	_maxValueFileCount = checked((int)(cacheCapacity / int.MaxValue));  	_sizeLimitOfOneValueFile = int.MaxValue;  } else {  	_maxValueFileCount = 8;  	_sizeLimitOfOneValueFile = (int)(cacheCapacity / 8);  }  
Magic Number,BTDB.ChunkCache,DiskChunkCache,F:\newReposMay17\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: if (cacheCapacity / 8 > int.MaxValue) {  	_maxValueFileCount = checked((int)(cacheCapacity / int.MaxValue));  	_sizeLimitOfOneValueFile = int.MaxValue;  } else {  	_maxValueFileCount = 8;  	_sizeLimitOfOneValueFile = (int)(cacheCapacity / 8);  }  
Magic Number,BTDB.ChunkCache,DiskChunkCache,F:\newReposMay17\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: if (cacheCapacity / 8 > int.MaxValue) {  	_maxValueFileCount = checked((int)(cacheCapacity / int.MaxValue));  	_sizeLimitOfOneValueFile = int.MaxValue;  } else {  	_maxValueFileCount = 8;  	_sizeLimitOfOneValueFile = (int)(cacheCapacity / 8);  }  
Magic Number,BTDB.ChunkCache,DiskChunkCache,F:\newReposMay17\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: _maxValueFileCount = 8;  
Magic Number,BTDB.ChunkCache,DiskChunkCache,F:\newReposMay17\Bobris_BTDB\BTDB\ChunkCache\DiskChunkCache.cs,DiskChunkCache,The following statement contains a magic number: _sizeLimitOfOneValueFile = (int)(cacheCapacity / 8);  
Magic Number,BTDB.DtoChannel,DtoChannel,F:\newReposMay17\Bobris_BTDB\BTDB\DtoChannel\DtoChannel.cs,Send,The following statement contains a magic number: lock (_sendLocker) {  	IDescriptorSerializerContext serializerContext = _sendingMapping;  	var writer = new ByteBufferWriter ();  	writer.WriteUInt8 (100);  	serializerContext = serializerContext.StoreNewDescriptors (writer' dto);  	serializerContext.FinishNewDescriptors (writer);  	serializerContext.StoreObject (writer' dto);  	var block = writer.Data;  	if (serializerContext.SomeTypeStored) {  		block [0] = 99;  	}  	_channel.Send (block);  	serializerContext.CommitNewDescriptors ();  }  
Magic Number,BTDB.DtoChannel,DtoChannel,F:\newReposMay17\Bobris_BTDB\BTDB\DtoChannel\DtoChannel.cs,Send,The following statement contains a magic number: lock (_sendLocker) {  	IDescriptorSerializerContext serializerContext = _sendingMapping;  	var writer = new ByteBufferWriter ();  	writer.WriteUInt8 (100);  	serializerContext = serializerContext.StoreNewDescriptors (writer' dto);  	serializerContext.FinishNewDescriptors (writer);  	serializerContext.StoreObject (writer' dto);  	var block = writer.Data;  	if (serializerContext.SomeTypeStored) {  		block [0] = 99;  	}  	_channel.Send (block);  	serializerContext.CommitNewDescriptors ();  }  
Magic Number,BTDB.DtoChannel,DtoChannel,F:\newReposMay17\Bobris_BTDB\BTDB\DtoChannel\DtoChannel.cs,Send,The following statement contains a magic number: writer.WriteUInt8 (100);  
Magic Number,BTDB.DtoChannel,DtoChannel,F:\newReposMay17\Bobris_BTDB\BTDB\DtoChannel\DtoChannel.cs,Send,The following statement contains a magic number: if (serializerContext.SomeTypeStored) {  	block [0] = 99;  }  
Magic Number,BTDB.DtoChannel,DtoChannel,F:\newReposMay17\Bobris_BTDB\BTDB\DtoChannel\DtoChannel.cs,Send,The following statement contains a magic number: block [0] = 99;  
Magic Number,BTDB.EventStore2Layer,EventDeserializer,F:\newReposMay17\Bobris_BTDB\BTDB\EventStore2Layer\EventDeserializer.cs,LoaderFactory,The following statement contains a magic number: descriptor.GenerateLoad (il' ilGen => ilGen.Ldarg (0)' ilGen => ilGen.Ldarg (1)' ilGen => ilGen.Ldarg (2)' loadAsType);  
Magic Number,BTDB.EventStore2Layer,EventSerializer,F:\newReposMay17\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,BuildComplexSaver,The following statement contains a magic number: descriptor.GenerateSave (il' ilgen => ilgen.Ldarg (0)' ilgen => ilgen.Ldarg (1)' ilgen => {  	ilgen.Ldarg (2);  	var type = descriptor.GetPreferedType ();  	if (type != typeof(object)) {  		ilgen.UnboxAny (type);  	}  }' descriptor.GetPreferedType ());  
Magic Number,BTDB.EventStore2Layer,EventSerializer,F:\newReposMay17\Bobris_BTDB\BTDB\EventStore2Layer\EventSerializer.cs,BuildComplexSaver,The following statement contains a magic number: ilgen.Ldarg (2);  
Magic Number,BTDB.EventStoreLayer,AppendingEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,FinalizeStore,The following statement contains a magic number: if (EndBufferPosition + (ulong)startOffset <= File.MaxFileSize) {  	WriteOneBlock (ByteBuffer.NewSync (new byte[SectorSize * 2]' startOffset' 0)' BlockType.LastBlock);  }  
Magic Number,BTDB.EventStoreLayer,AppendingEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,FinalizeStore,The following statement contains a magic number: WriteOneBlock (ByteBuffer.NewSync (new byte[SectorSize * 2]' startOffset' 0)' BlockType.LastBlock);  
Magic Number,BTDB.EventStoreLayer,AppendingEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,WriteOneBlock,The following statement contains a magic number: PackUnpack.PackUInt32LE (block.Buffer' o' (blockLen << 8) + (uint)blockType);  
Magic Number,BTDB.EventStoreLayer,AppendingEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\AppendingEventStore.cs,WriteOneBlock,The following statement contains a magic number: o -= 4;  
Magic Number,BTDB.EventStoreLayer,EnumTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,EnumTypeDescriptor,The following statement contains a magic number: _flags = (header & 2) != 0;  
Magic Number,BTDB.EventStoreLayer,EnumTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\EnumTypeDescriptor.cs,AppendIndent,The following statement contains a magic number: text.Append (' '' (int)(indent * 4));  
Magic Number,BTDB.EventStoreLayer,ListTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ListTypeDescriptor.cs,GetHashCode,The following statement contains a magic number: return 33 * _itemDescriptor.GetHashCode ();  
Magic Number,BTDB.EventStoreLayer,SnappyCompressionStrategy,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\SnappyCompressionStrategy.cs,ShouldTryToCompress,The following statement contains a magic number: return length > 512;  
Magic Number,BTDB.EventStoreLayer,SnappyCompressionStrategy,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\SnappyCompressionStrategy.cs,Compress,The following statement contains a magic number: return SnappyCompress.TryCompress (ref data' 80);  
Magic Number,BTDB.EventStoreLayer,StreamEventFileStorage,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\StreamEventFileStorage.cs,StreamEventFileStorage,The following statement contains a magic number: MaxBlockSize = 4 * 1024 * 1024;  
Magic Number,BTDB.EventStoreLayer,StreamEventFileStorage,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\StreamEventFileStorage.cs,StreamEventFileStorage,The following statement contains a magic number: MaxBlockSize = 4 * 1024 * 1024;  
Magic Number,BTDB.EventStoreLayer,StreamEventFileStorage,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\StreamEventFileStorage.cs,StreamEventFileStorage,The following statement contains a magic number: MaxBlockSize = 4 * 1024 * 1024;  
Magic Number,BTDB.EventStoreLayer,ObjectTypeDescriptor,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ObjectTypeDescriptor.cs,AppendIndent,The following statement contains a magic number: text.Append (' '' (int)(indent * 4));  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: while (true) {  	if (bufferStartPosition + (ulong)bufferReadOffset + HeaderSize > File.MaxFileSize) {  		KnownAsFinished = true;  		return;  	}  	if (bufferReadOffset == bufferFullLength) {  		break;  	}  	if (bufferReadOffset + HeaderSize > bufferFullLength) {  		for (var i = bufferReadOffset; i < bufferFullLength; i++) {  			if (bufferBlock [i] != 0) {  				SetCorrupted ();  				return;  			}  		}  		break;  	}  	var blockCheckSum = PackUnpack.UnpackUInt32LE (bufferBlock' bufferReadOffset);  	bufferReadOffset += 4;  	var blockLen = PackUnpack.UnpackUInt32LE (bufferBlock' bufferReadOffset);  	if (blockCheckSum == 0 && blockLen == 0) {  		bufferReadOffset -= 4;  		break;  	}  	var blockType = (BlockType)(blockLen & 0xff);  	blockLen >>= 8;  	if (blockType == BlockType.LastBlock && blockLen == 0) {  		if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum) {  			SetCorrupted ();  			return;  		}  		KnownAsFinished = true;  		return;  	}  	if (blockLen == 0 && blockType != (BlockType.FirstBlock | BlockType.LastBlock)) {  		SetCorrupted ();  		return;  	}  	if (blockLen + HeaderSize > MaxBlockSize) {  		SetCorrupted ();  		return;  	}  	bufferReadOffset += 4;  	var bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + FirstReadAhead) & SectorMaskUInt;  	if (bufferLenToFill > bufferBlock.Length)  		bufferLenToFill = (uint)bufferBlock.Length;  	buf = ByteBuffer.NewSync (bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));  	if (buf.Length > 0) {  		bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + currentReadAhead) & SectorMaskUInt;  		if (bufferLenToFill > bufferBlock.Length)  			bufferLenToFill = (uint)bufferBlock.Length;  		if (bufferStartPosition + bufferLenToFill > File.MaxFileSize) {  			bufferLenToFill = (uint)(File.MaxFileSize - bufferStartPosition);  		}  		buf = ByteBuffer.NewSync (bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));  		if (buf.Length > 0) {  			if (currentReadAhead * 4 < MaxBlockSize) {  				currentReadAhead = currentReadAhead * 2;  			}  			bufReadLength = (int)File.Read (buf' bufferStartPosition + (ulong)bufferFullLength);  			bufferFullLength += bufReadLength;  		}  	}  	if (bufferReadOffset + (int)blockLen > bufferFullLength) {  		SetCorrupted ();  		return;  	}  	if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum) {  		SetCorrupted ();  		return;  	}  	var blockTypeBlock = blockType & (BlockType.FirstBlock | BlockType.MiddleBlock | BlockType.LastBlock);  	var stopReadingRequested = false;  	if (blockTypeBlock == (BlockType.FirstBlock | BlockType.LastBlock)) {  		stopReadingRequested = Process (blockType' ByteBuffer.NewSync (bufferBlock' bufferReadOffset' (int)blockLen)' observer);  	} else {  		if (blockTypeBlock == BlockType.FirstBlock) {  			overflowWriter = new ByteBufferWriter ();  		} else if (blockTypeBlock == BlockType.MiddleBlock || blockTypeBlock == BlockType.LastBlock) {  			if (overflowWriter == null) {  				SetCorrupted ();  				return;  			}  		} else {  			SetCorrupted ();  			return;  		}  		overflowWriter.WriteBlock (ByteBuffer.NewSync (bufferBlock' bufferReadOffset' (int)blockLen));  		if (blockTypeBlock == BlockType.LastBlock) {  			stopReadingRequested = Process (blockType' overflowWriter.Data' observer);  			overflowWriter = null;  		}  	}  	bufferReadOffset += (int)blockLen;  	if (overflowWriter == null)  		NextReadPosition = bufferStartPosition + (ulong)bufferReadOffset;  	if (stopReadingRequested) {  		return;  	}  	var nextBufferStartPosition = (bufferStartPosition + (ulong)bufferReadOffset) & SectorMask;  	var bufferMoveDistance = (int)(nextBufferStartPosition - bufferStartPosition);  	if (bufferMoveDistance <= 0)  		continue;  	Array.Copy (bufferBlock' bufferMoveDistance' bufferBlock' 0' bufferFullLength - bufferMoveDistance);  	bufferStartPosition = nextBufferStartPosition;  	bufferFullLength -= bufferMoveDistance;  	bufferReadOffset -= bufferMoveDistance;  }  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: while (true) {  	if (bufferStartPosition + (ulong)bufferReadOffset + HeaderSize > File.MaxFileSize) {  		KnownAsFinished = true;  		return;  	}  	if (bufferReadOffset == bufferFullLength) {  		break;  	}  	if (bufferReadOffset + HeaderSize > bufferFullLength) {  		for (var i = bufferReadOffset; i < bufferFullLength; i++) {  			if (bufferBlock [i] != 0) {  				SetCorrupted ();  				return;  			}  		}  		break;  	}  	var blockCheckSum = PackUnpack.UnpackUInt32LE (bufferBlock' bufferReadOffset);  	bufferReadOffset += 4;  	var blockLen = PackUnpack.UnpackUInt32LE (bufferBlock' bufferReadOffset);  	if (blockCheckSum == 0 && blockLen == 0) {  		bufferReadOffset -= 4;  		break;  	}  	var blockType = (BlockType)(blockLen & 0xff);  	blockLen >>= 8;  	if (blockType == BlockType.LastBlock && blockLen == 0) {  		if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum) {  			SetCorrupted ();  			return;  		}  		KnownAsFinished = true;  		return;  	}  	if (blockLen == 0 && blockType != (BlockType.FirstBlock | BlockType.LastBlock)) {  		SetCorrupted ();  		return;  	}  	if (blockLen + HeaderSize > MaxBlockSize) {  		SetCorrupted ();  		return;  	}  	bufferReadOffset += 4;  	var bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + FirstReadAhead) & SectorMaskUInt;  	if (bufferLenToFill > bufferBlock.Length)  		bufferLenToFill = (uint)bufferBlock.Length;  	buf = ByteBuffer.NewSync (bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));  	if (buf.Length > 0) {  		bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + currentReadAhead) & SectorMaskUInt;  		if (bufferLenToFill > bufferBlock.Length)  			bufferLenToFill = (uint)bufferBlock.Length;  		if (bufferStartPosition + bufferLenToFill > File.MaxFileSize) {  			bufferLenToFill = (uint)(File.MaxFileSize - bufferStartPosition);  		}  		buf = ByteBuffer.NewSync (bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));  		if (buf.Length > 0) {  			if (currentReadAhead * 4 < MaxBlockSize) {  				currentReadAhead = currentReadAhead * 2;  			}  			bufReadLength = (int)File.Read (buf' bufferStartPosition + (ulong)bufferFullLength);  			bufferFullLength += bufReadLength;  		}  	}  	if (bufferReadOffset + (int)blockLen > bufferFullLength) {  		SetCorrupted ();  		return;  	}  	if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum) {  		SetCorrupted ();  		return;  	}  	var blockTypeBlock = blockType & (BlockType.FirstBlock | BlockType.MiddleBlock | BlockType.LastBlock);  	var stopReadingRequested = false;  	if (blockTypeBlock == (BlockType.FirstBlock | BlockType.LastBlock)) {  		stopReadingRequested = Process (blockType' ByteBuffer.NewSync (bufferBlock' bufferReadOffset' (int)blockLen)' observer);  	} else {  		if (blockTypeBlock == BlockType.FirstBlock) {  			overflowWriter = new ByteBufferWriter ();  		} else if (blockTypeBlock == BlockType.MiddleBlock || blockTypeBlock == BlockType.LastBlock) {  			if (overflowWriter == null) {  				SetCorrupted ();  				return;  			}  		} else {  			SetCorrupted ();  			return;  		}  		overflowWriter.WriteBlock (ByteBuffer.NewSync (bufferBlock' bufferReadOffset' (int)blockLen));  		if (blockTypeBlock == BlockType.LastBlock) {  			stopReadingRequested = Process (blockType' overflowWriter.Data' observer);  			overflowWriter = null;  		}  	}  	bufferReadOffset += (int)blockLen;  	if (overflowWriter == null)  		NextReadPosition = bufferStartPosition + (ulong)bufferReadOffset;  	if (stopReadingRequested) {  		return;  	}  	var nextBufferStartPosition = (bufferStartPosition + (ulong)bufferReadOffset) & SectorMask;  	var bufferMoveDistance = (int)(nextBufferStartPosition - bufferStartPosition);  	if (bufferMoveDistance <= 0)  		continue;  	Array.Copy (bufferBlock' bufferMoveDistance' bufferBlock' 0' bufferFullLength - bufferMoveDistance);  	bufferStartPosition = nextBufferStartPosition;  	bufferFullLength -= bufferMoveDistance;  	bufferReadOffset -= bufferMoveDistance;  }  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: while (true) {  	if (bufferStartPosition + (ulong)bufferReadOffset + HeaderSize > File.MaxFileSize) {  		KnownAsFinished = true;  		return;  	}  	if (bufferReadOffset == bufferFullLength) {  		break;  	}  	if (bufferReadOffset + HeaderSize > bufferFullLength) {  		for (var i = bufferReadOffset; i < bufferFullLength; i++) {  			if (bufferBlock [i] != 0) {  				SetCorrupted ();  				return;  			}  		}  		break;  	}  	var blockCheckSum = PackUnpack.UnpackUInt32LE (bufferBlock' bufferReadOffset);  	bufferReadOffset += 4;  	var blockLen = PackUnpack.UnpackUInt32LE (bufferBlock' bufferReadOffset);  	if (blockCheckSum == 0 && blockLen == 0) {  		bufferReadOffset -= 4;  		break;  	}  	var blockType = (BlockType)(blockLen & 0xff);  	blockLen >>= 8;  	if (blockType == BlockType.LastBlock && blockLen == 0) {  		if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum) {  			SetCorrupted ();  			return;  		}  		KnownAsFinished = true;  		return;  	}  	if (blockLen == 0 && blockType != (BlockType.FirstBlock | BlockType.LastBlock)) {  		SetCorrupted ();  		return;  	}  	if (blockLen + HeaderSize > MaxBlockSize) {  		SetCorrupted ();  		return;  	}  	bufferReadOffset += 4;  	var bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + FirstReadAhead) & SectorMaskUInt;  	if (bufferLenToFill > bufferBlock.Length)  		bufferLenToFill = (uint)bufferBlock.Length;  	buf = ByteBuffer.NewSync (bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));  	if (buf.Length > 0) {  		bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + currentReadAhead) & SectorMaskUInt;  		if (bufferLenToFill > bufferBlock.Length)  			bufferLenToFill = (uint)bufferBlock.Length;  		if (bufferStartPosition + bufferLenToFill > File.MaxFileSize) {  			bufferLenToFill = (uint)(File.MaxFileSize - bufferStartPosition);  		}  		buf = ByteBuffer.NewSync (bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));  		if (buf.Length > 0) {  			if (currentReadAhead * 4 < MaxBlockSize) {  				currentReadAhead = currentReadAhead * 2;  			}  			bufReadLength = (int)File.Read (buf' bufferStartPosition + (ulong)bufferFullLength);  			bufferFullLength += bufReadLength;  		}  	}  	if (bufferReadOffset + (int)blockLen > bufferFullLength) {  		SetCorrupted ();  		return;  	}  	if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum) {  		SetCorrupted ();  		return;  	}  	var blockTypeBlock = blockType & (BlockType.FirstBlock | BlockType.MiddleBlock | BlockType.LastBlock);  	var stopReadingRequested = false;  	if (blockTypeBlock == (BlockType.FirstBlock | BlockType.LastBlock)) {  		stopReadingRequested = Process (blockType' ByteBuffer.NewSync (bufferBlock' bufferReadOffset' (int)blockLen)' observer);  	} else {  		if (blockTypeBlock == BlockType.FirstBlock) {  			overflowWriter = new ByteBufferWriter ();  		} else if (blockTypeBlock == BlockType.MiddleBlock || blockTypeBlock == BlockType.LastBlock) {  			if (overflowWriter == null) {  				SetCorrupted ();  				return;  			}  		} else {  			SetCorrupted ();  			return;  		}  		overflowWriter.WriteBlock (ByteBuffer.NewSync (bufferBlock' bufferReadOffset' (int)blockLen));  		if (blockTypeBlock == BlockType.LastBlock) {  			stopReadingRequested = Process (blockType' overflowWriter.Data' observer);  			overflowWriter = null;  		}  	}  	bufferReadOffset += (int)blockLen;  	if (overflowWriter == null)  		NextReadPosition = bufferStartPosition + (ulong)bufferReadOffset;  	if (stopReadingRequested) {  		return;  	}  	var nextBufferStartPosition = (bufferStartPosition + (ulong)bufferReadOffset) & SectorMask;  	var bufferMoveDistance = (int)(nextBufferStartPosition - bufferStartPosition);  	if (bufferMoveDistance <= 0)  		continue;  	Array.Copy (bufferBlock' bufferMoveDistance' bufferBlock' 0' bufferFullLength - bufferMoveDistance);  	bufferStartPosition = nextBufferStartPosition;  	bufferFullLength -= bufferMoveDistance;  	bufferReadOffset -= bufferMoveDistance;  }  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: while (true) {  	if (bufferStartPosition + (ulong)bufferReadOffset + HeaderSize > File.MaxFileSize) {  		KnownAsFinished = true;  		return;  	}  	if (bufferReadOffset == bufferFullLength) {  		break;  	}  	if (bufferReadOffset + HeaderSize > bufferFullLength) {  		for (var i = bufferReadOffset; i < bufferFullLength; i++) {  			if (bufferBlock [i] != 0) {  				SetCorrupted ();  				return;  			}  		}  		break;  	}  	var blockCheckSum = PackUnpack.UnpackUInt32LE (bufferBlock' bufferReadOffset);  	bufferReadOffset += 4;  	var blockLen = PackUnpack.UnpackUInt32LE (bufferBlock' bufferReadOffset);  	if (blockCheckSum == 0 && blockLen == 0) {  		bufferReadOffset -= 4;  		break;  	}  	var blockType = (BlockType)(blockLen & 0xff);  	blockLen >>= 8;  	if (blockType == BlockType.LastBlock && blockLen == 0) {  		if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum) {  			SetCorrupted ();  			return;  		}  		KnownAsFinished = true;  		return;  	}  	if (blockLen == 0 && blockType != (BlockType.FirstBlock | BlockType.LastBlock)) {  		SetCorrupted ();  		return;  	}  	if (blockLen + HeaderSize > MaxBlockSize) {  		SetCorrupted ();  		return;  	}  	bufferReadOffset += 4;  	var bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + FirstReadAhead) & SectorMaskUInt;  	if (bufferLenToFill > bufferBlock.Length)  		bufferLenToFill = (uint)bufferBlock.Length;  	buf = ByteBuffer.NewSync (bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));  	if (buf.Length > 0) {  		bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + currentReadAhead) & SectorMaskUInt;  		if (bufferLenToFill > bufferBlock.Length)  			bufferLenToFill = (uint)bufferBlock.Length;  		if (bufferStartPosition + bufferLenToFill > File.MaxFileSize) {  			bufferLenToFill = (uint)(File.MaxFileSize - bufferStartPosition);  		}  		buf = ByteBuffer.NewSync (bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));  		if (buf.Length > 0) {  			if (currentReadAhead * 4 < MaxBlockSize) {  				currentReadAhead = currentReadAhead * 2;  			}  			bufReadLength = (int)File.Read (buf' bufferStartPosition + (ulong)bufferFullLength);  			bufferFullLength += bufReadLength;  		}  	}  	if (bufferReadOffset + (int)blockLen > bufferFullLength) {  		SetCorrupted ();  		return;  	}  	if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum) {  		SetCorrupted ();  		return;  	}  	var blockTypeBlock = blockType & (BlockType.FirstBlock | BlockType.MiddleBlock | BlockType.LastBlock);  	var stopReadingRequested = false;  	if (blockTypeBlock == (BlockType.FirstBlock | BlockType.LastBlock)) {  		stopReadingRequested = Process (blockType' ByteBuffer.NewSync (bufferBlock' bufferReadOffset' (int)blockLen)' observer);  	} else {  		if (blockTypeBlock == BlockType.FirstBlock) {  			overflowWriter = new ByteBufferWriter ();  		} else if (blockTypeBlock == BlockType.MiddleBlock || blockTypeBlock == BlockType.LastBlock) {  			if (overflowWriter == null) {  				SetCorrupted ();  				return;  			}  		} else {  			SetCorrupted ();  			return;  		}  		overflowWriter.WriteBlock (ByteBuffer.NewSync (bufferBlock' bufferReadOffset' (int)blockLen));  		if (blockTypeBlock == BlockType.LastBlock) {  			stopReadingRequested = Process (blockType' overflowWriter.Data' observer);  			overflowWriter = null;  		}  	}  	bufferReadOffset += (int)blockLen;  	if (overflowWriter == null)  		NextReadPosition = bufferStartPosition + (ulong)bufferReadOffset;  	if (stopReadingRequested) {  		return;  	}  	var nextBufferStartPosition = (bufferStartPosition + (ulong)bufferReadOffset) & SectorMask;  	var bufferMoveDistance = (int)(nextBufferStartPosition - bufferStartPosition);  	if (bufferMoveDistance <= 0)  		continue;  	Array.Copy (bufferBlock' bufferMoveDistance' bufferBlock' 0' bufferFullLength - bufferMoveDistance);  	bufferStartPosition = nextBufferStartPosition;  	bufferFullLength -= bufferMoveDistance;  	bufferReadOffset -= bufferMoveDistance;  }  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: while (true) {  	if (bufferStartPosition + (ulong)bufferReadOffset + HeaderSize > File.MaxFileSize) {  		KnownAsFinished = true;  		return;  	}  	if (bufferReadOffset == bufferFullLength) {  		break;  	}  	if (bufferReadOffset + HeaderSize > bufferFullLength) {  		for (var i = bufferReadOffset; i < bufferFullLength; i++) {  			if (bufferBlock [i] != 0) {  				SetCorrupted ();  				return;  			}  		}  		break;  	}  	var blockCheckSum = PackUnpack.UnpackUInt32LE (bufferBlock' bufferReadOffset);  	bufferReadOffset += 4;  	var blockLen = PackUnpack.UnpackUInt32LE (bufferBlock' bufferReadOffset);  	if (blockCheckSum == 0 && blockLen == 0) {  		bufferReadOffset -= 4;  		break;  	}  	var blockType = (BlockType)(blockLen & 0xff);  	blockLen >>= 8;  	if (blockType == BlockType.LastBlock && blockLen == 0) {  		if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum) {  			SetCorrupted ();  			return;  		}  		KnownAsFinished = true;  		return;  	}  	if (blockLen == 0 && blockType != (BlockType.FirstBlock | BlockType.LastBlock)) {  		SetCorrupted ();  		return;  	}  	if (blockLen + HeaderSize > MaxBlockSize) {  		SetCorrupted ();  		return;  	}  	bufferReadOffset += 4;  	var bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + FirstReadAhead) & SectorMaskUInt;  	if (bufferLenToFill > bufferBlock.Length)  		bufferLenToFill = (uint)bufferBlock.Length;  	buf = ByteBuffer.NewSync (bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));  	if (buf.Length > 0) {  		bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + currentReadAhead) & SectorMaskUInt;  		if (bufferLenToFill > bufferBlock.Length)  			bufferLenToFill = (uint)bufferBlock.Length;  		if (bufferStartPosition + bufferLenToFill > File.MaxFileSize) {  			bufferLenToFill = (uint)(File.MaxFileSize - bufferStartPosition);  		}  		buf = ByteBuffer.NewSync (bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));  		if (buf.Length > 0) {  			if (currentReadAhead * 4 < MaxBlockSize) {  				currentReadAhead = currentReadAhead * 2;  			}  			bufReadLength = (int)File.Read (buf' bufferStartPosition + (ulong)bufferFullLength);  			bufferFullLength += bufReadLength;  		}  	}  	if (bufferReadOffset + (int)blockLen > bufferFullLength) {  		SetCorrupted ();  		return;  	}  	if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum) {  		SetCorrupted ();  		return;  	}  	var blockTypeBlock = blockType & (BlockType.FirstBlock | BlockType.MiddleBlock | BlockType.LastBlock);  	var stopReadingRequested = false;  	if (blockTypeBlock == (BlockType.FirstBlock | BlockType.LastBlock)) {  		stopReadingRequested = Process (blockType' ByteBuffer.NewSync (bufferBlock' bufferReadOffset' (int)blockLen)' observer);  	} else {  		if (blockTypeBlock == BlockType.FirstBlock) {  			overflowWriter = new ByteBufferWriter ();  		} else if (blockTypeBlock == BlockType.MiddleBlock || blockTypeBlock == BlockType.LastBlock) {  			if (overflowWriter == null) {  				SetCorrupted ();  				return;  			}  		} else {  			SetCorrupted ();  			return;  		}  		overflowWriter.WriteBlock (ByteBuffer.NewSync (bufferBlock' bufferReadOffset' (int)blockLen));  		if (blockTypeBlock == BlockType.LastBlock) {  			stopReadingRequested = Process (blockType' overflowWriter.Data' observer);  			overflowWriter = null;  		}  	}  	bufferReadOffset += (int)blockLen;  	if (overflowWriter == null)  		NextReadPosition = bufferStartPosition + (ulong)bufferReadOffset;  	if (stopReadingRequested) {  		return;  	}  	var nextBufferStartPosition = (bufferStartPosition + (ulong)bufferReadOffset) & SectorMask;  	var bufferMoveDistance = (int)(nextBufferStartPosition - bufferStartPosition);  	if (bufferMoveDistance <= 0)  		continue;  	Array.Copy (bufferBlock' bufferMoveDistance' bufferBlock' 0' bufferFullLength - bufferMoveDistance);  	bufferStartPosition = nextBufferStartPosition;  	bufferFullLength -= bufferMoveDistance;  	bufferReadOffset -= bufferMoveDistance;  }  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: while (true) {  	if (bufferStartPosition + (ulong)bufferReadOffset + HeaderSize > File.MaxFileSize) {  		KnownAsFinished = true;  		return;  	}  	if (bufferReadOffset == bufferFullLength) {  		break;  	}  	if (bufferReadOffset + HeaderSize > bufferFullLength) {  		for (var i = bufferReadOffset; i < bufferFullLength; i++) {  			if (bufferBlock [i] != 0) {  				SetCorrupted ();  				return;  			}  		}  		break;  	}  	var blockCheckSum = PackUnpack.UnpackUInt32LE (bufferBlock' bufferReadOffset);  	bufferReadOffset += 4;  	var blockLen = PackUnpack.UnpackUInt32LE (bufferBlock' bufferReadOffset);  	if (blockCheckSum == 0 && blockLen == 0) {  		bufferReadOffset -= 4;  		break;  	}  	var blockType = (BlockType)(blockLen & 0xff);  	blockLen >>= 8;  	if (blockType == BlockType.LastBlock && blockLen == 0) {  		if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum) {  			SetCorrupted ();  			return;  		}  		KnownAsFinished = true;  		return;  	}  	if (blockLen == 0 && blockType != (BlockType.FirstBlock | BlockType.LastBlock)) {  		SetCorrupted ();  		return;  	}  	if (blockLen + HeaderSize > MaxBlockSize) {  		SetCorrupted ();  		return;  	}  	bufferReadOffset += 4;  	var bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + FirstReadAhead) & SectorMaskUInt;  	if (bufferLenToFill > bufferBlock.Length)  		bufferLenToFill = (uint)bufferBlock.Length;  	buf = ByteBuffer.NewSync (bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));  	if (buf.Length > 0) {  		bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + currentReadAhead) & SectorMaskUInt;  		if (bufferLenToFill > bufferBlock.Length)  			bufferLenToFill = (uint)bufferBlock.Length;  		if (bufferStartPosition + bufferLenToFill > File.MaxFileSize) {  			bufferLenToFill = (uint)(File.MaxFileSize - bufferStartPosition);  		}  		buf = ByteBuffer.NewSync (bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));  		if (buf.Length > 0) {  			if (currentReadAhead * 4 < MaxBlockSize) {  				currentReadAhead = currentReadAhead * 2;  			}  			bufReadLength = (int)File.Read (buf' bufferStartPosition + (ulong)bufferFullLength);  			bufferFullLength += bufReadLength;  		}  	}  	if (bufferReadOffset + (int)blockLen > bufferFullLength) {  		SetCorrupted ();  		return;  	}  	if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum) {  		SetCorrupted ();  		return;  	}  	var blockTypeBlock = blockType & (BlockType.FirstBlock | BlockType.MiddleBlock | BlockType.LastBlock);  	var stopReadingRequested = false;  	if (blockTypeBlock == (BlockType.FirstBlock | BlockType.LastBlock)) {  		stopReadingRequested = Process (blockType' ByteBuffer.NewSync (bufferBlock' bufferReadOffset' (int)blockLen)' observer);  	} else {  		if (blockTypeBlock == BlockType.FirstBlock) {  			overflowWriter = new ByteBufferWriter ();  		} else if (blockTypeBlock == BlockType.MiddleBlock || blockTypeBlock == BlockType.LastBlock) {  			if (overflowWriter == null) {  				SetCorrupted ();  				return;  			}  		} else {  			SetCorrupted ();  			return;  		}  		overflowWriter.WriteBlock (ByteBuffer.NewSync (bufferBlock' bufferReadOffset' (int)blockLen));  		if (blockTypeBlock == BlockType.LastBlock) {  			stopReadingRequested = Process (blockType' overflowWriter.Data' observer);  			overflowWriter = null;  		}  	}  	bufferReadOffset += (int)blockLen;  	if (overflowWriter == null)  		NextReadPosition = bufferStartPosition + (ulong)bufferReadOffset;  	if (stopReadingRequested) {  		return;  	}  	var nextBufferStartPosition = (bufferStartPosition + (ulong)bufferReadOffset) & SectorMask;  	var bufferMoveDistance = (int)(nextBufferStartPosition - bufferStartPosition);  	if (bufferMoveDistance <= 0)  		continue;  	Array.Copy (bufferBlock' bufferMoveDistance' bufferBlock' 0' bufferFullLength - bufferMoveDistance);  	bufferStartPosition = nextBufferStartPosition;  	bufferFullLength -= bufferMoveDistance;  	bufferReadOffset -= bufferMoveDistance;  }  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: while (true) {  	if (bufferStartPosition + (ulong)bufferReadOffset + HeaderSize > File.MaxFileSize) {  		KnownAsFinished = true;  		return;  	}  	if (bufferReadOffset == bufferFullLength) {  		break;  	}  	if (bufferReadOffset + HeaderSize > bufferFullLength) {  		for (var i = bufferReadOffset; i < bufferFullLength; i++) {  			if (bufferBlock [i] != 0) {  				SetCorrupted ();  				return;  			}  		}  		break;  	}  	var blockCheckSum = PackUnpack.UnpackUInt32LE (bufferBlock' bufferReadOffset);  	bufferReadOffset += 4;  	var blockLen = PackUnpack.UnpackUInt32LE (bufferBlock' bufferReadOffset);  	if (blockCheckSum == 0 && blockLen == 0) {  		bufferReadOffset -= 4;  		break;  	}  	var blockType = (BlockType)(blockLen & 0xff);  	blockLen >>= 8;  	if (blockType == BlockType.LastBlock && blockLen == 0) {  		if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum) {  			SetCorrupted ();  			return;  		}  		KnownAsFinished = true;  		return;  	}  	if (blockLen == 0 && blockType != (BlockType.FirstBlock | BlockType.LastBlock)) {  		SetCorrupted ();  		return;  	}  	if (blockLen + HeaderSize > MaxBlockSize) {  		SetCorrupted ();  		return;  	}  	bufferReadOffset += 4;  	var bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + FirstReadAhead) & SectorMaskUInt;  	if (bufferLenToFill > bufferBlock.Length)  		bufferLenToFill = (uint)bufferBlock.Length;  	buf = ByteBuffer.NewSync (bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));  	if (buf.Length > 0) {  		bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + currentReadAhead) & SectorMaskUInt;  		if (bufferLenToFill > bufferBlock.Length)  			bufferLenToFill = (uint)bufferBlock.Length;  		if (bufferStartPosition + bufferLenToFill > File.MaxFileSize) {  			bufferLenToFill = (uint)(File.MaxFileSize - bufferStartPosition);  		}  		buf = ByteBuffer.NewSync (bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));  		if (buf.Length > 0) {  			if (currentReadAhead * 4 < MaxBlockSize) {  				currentReadAhead = currentReadAhead * 2;  			}  			bufReadLength = (int)File.Read (buf' bufferStartPosition + (ulong)bufferFullLength);  			bufferFullLength += bufReadLength;  		}  	}  	if (bufferReadOffset + (int)blockLen > bufferFullLength) {  		SetCorrupted ();  		return;  	}  	if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum) {  		SetCorrupted ();  		return;  	}  	var blockTypeBlock = blockType & (BlockType.FirstBlock | BlockType.MiddleBlock | BlockType.LastBlock);  	var stopReadingRequested = false;  	if (blockTypeBlock == (BlockType.FirstBlock | BlockType.LastBlock)) {  		stopReadingRequested = Process (blockType' ByteBuffer.NewSync (bufferBlock' bufferReadOffset' (int)blockLen)' observer);  	} else {  		if (blockTypeBlock == BlockType.FirstBlock) {  			overflowWriter = new ByteBufferWriter ();  		} else if (blockTypeBlock == BlockType.MiddleBlock || blockTypeBlock == BlockType.LastBlock) {  			if (overflowWriter == null) {  				SetCorrupted ();  				return;  			}  		} else {  			SetCorrupted ();  			return;  		}  		overflowWriter.WriteBlock (ByteBuffer.NewSync (bufferBlock' bufferReadOffset' (int)blockLen));  		if (blockTypeBlock == BlockType.LastBlock) {  			stopReadingRequested = Process (blockType' overflowWriter.Data' observer);  			overflowWriter = null;  		}  	}  	bufferReadOffset += (int)blockLen;  	if (overflowWriter == null)  		NextReadPosition = bufferStartPosition + (ulong)bufferReadOffset;  	if (stopReadingRequested) {  		return;  	}  	var nextBufferStartPosition = (bufferStartPosition + (ulong)bufferReadOffset) & SectorMask;  	var bufferMoveDistance = (int)(nextBufferStartPosition - bufferStartPosition);  	if (bufferMoveDistance <= 0)  		continue;  	Array.Copy (bufferBlock' bufferMoveDistance' bufferBlock' 0' bufferFullLength - bufferMoveDistance);  	bufferStartPosition = nextBufferStartPosition;  	bufferFullLength -= bufferMoveDistance;  	bufferReadOffset -= bufferMoveDistance;  }  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: while (true) {  	if (bufferStartPosition + (ulong)bufferReadOffset + HeaderSize > File.MaxFileSize) {  		KnownAsFinished = true;  		return;  	}  	if (bufferReadOffset == bufferFullLength) {  		break;  	}  	if (bufferReadOffset + HeaderSize > bufferFullLength) {  		for (var i = bufferReadOffset; i < bufferFullLength; i++) {  			if (bufferBlock [i] != 0) {  				SetCorrupted ();  				return;  			}  		}  		break;  	}  	var blockCheckSum = PackUnpack.UnpackUInt32LE (bufferBlock' bufferReadOffset);  	bufferReadOffset += 4;  	var blockLen = PackUnpack.UnpackUInt32LE (bufferBlock' bufferReadOffset);  	if (blockCheckSum == 0 && blockLen == 0) {  		bufferReadOffset -= 4;  		break;  	}  	var blockType = (BlockType)(blockLen & 0xff);  	blockLen >>= 8;  	if (blockType == BlockType.LastBlock && blockLen == 0) {  		if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum) {  			SetCorrupted ();  			return;  		}  		KnownAsFinished = true;  		return;  	}  	if (blockLen == 0 && blockType != (BlockType.FirstBlock | BlockType.LastBlock)) {  		SetCorrupted ();  		return;  	}  	if (blockLen + HeaderSize > MaxBlockSize) {  		SetCorrupted ();  		return;  	}  	bufferReadOffset += 4;  	var bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + FirstReadAhead) & SectorMaskUInt;  	if (bufferLenToFill > bufferBlock.Length)  		bufferLenToFill = (uint)bufferBlock.Length;  	buf = ByteBuffer.NewSync (bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));  	if (buf.Length > 0) {  		bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + currentReadAhead) & SectorMaskUInt;  		if (bufferLenToFill > bufferBlock.Length)  			bufferLenToFill = (uint)bufferBlock.Length;  		if (bufferStartPosition + bufferLenToFill > File.MaxFileSize) {  			bufferLenToFill = (uint)(File.MaxFileSize - bufferStartPosition);  		}  		buf = ByteBuffer.NewSync (bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));  		if (buf.Length > 0) {  			if (currentReadAhead * 4 < MaxBlockSize) {  				currentReadAhead = currentReadAhead * 2;  			}  			bufReadLength = (int)File.Read (buf' bufferStartPosition + (ulong)bufferFullLength);  			bufferFullLength += bufReadLength;  		}  	}  	if (bufferReadOffset + (int)blockLen > bufferFullLength) {  		SetCorrupted ();  		return;  	}  	if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum) {  		SetCorrupted ();  		return;  	}  	var blockTypeBlock = blockType & (BlockType.FirstBlock | BlockType.MiddleBlock | BlockType.LastBlock);  	var stopReadingRequested = false;  	if (blockTypeBlock == (BlockType.FirstBlock | BlockType.LastBlock)) {  		stopReadingRequested = Process (blockType' ByteBuffer.NewSync (bufferBlock' bufferReadOffset' (int)blockLen)' observer);  	} else {  		if (blockTypeBlock == BlockType.FirstBlock) {  			overflowWriter = new ByteBufferWriter ();  		} else if (blockTypeBlock == BlockType.MiddleBlock || blockTypeBlock == BlockType.LastBlock) {  			if (overflowWriter == null) {  				SetCorrupted ();  				return;  			}  		} else {  			SetCorrupted ();  			return;  		}  		overflowWriter.WriteBlock (ByteBuffer.NewSync (bufferBlock' bufferReadOffset' (int)blockLen));  		if (blockTypeBlock == BlockType.LastBlock) {  			stopReadingRequested = Process (blockType' overflowWriter.Data' observer);  			overflowWriter = null;  		}  	}  	bufferReadOffset += (int)blockLen;  	if (overflowWriter == null)  		NextReadPosition = bufferStartPosition + (ulong)bufferReadOffset;  	if (stopReadingRequested) {  		return;  	}  	var nextBufferStartPosition = (bufferStartPosition + (ulong)bufferReadOffset) & SectorMask;  	var bufferMoveDistance = (int)(nextBufferStartPosition - bufferStartPosition);  	if (bufferMoveDistance <= 0)  		continue;  	Array.Copy (bufferBlock' bufferMoveDistance' bufferBlock' 0' bufferFullLength - bufferMoveDistance);  	bufferStartPosition = nextBufferStartPosition;  	bufferFullLength -= bufferMoveDistance;  	bufferReadOffset -= bufferMoveDistance;  }  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: while (true) {  	if (bufferStartPosition + (ulong)bufferReadOffset + HeaderSize > File.MaxFileSize) {  		KnownAsFinished = true;  		return;  	}  	if (bufferReadOffset == bufferFullLength) {  		break;  	}  	if (bufferReadOffset + HeaderSize > bufferFullLength) {  		for (var i = bufferReadOffset; i < bufferFullLength; i++) {  			if (bufferBlock [i] != 0) {  				SetCorrupted ();  				return;  			}  		}  		break;  	}  	var blockCheckSum = PackUnpack.UnpackUInt32LE (bufferBlock' bufferReadOffset);  	bufferReadOffset += 4;  	var blockLen = PackUnpack.UnpackUInt32LE (bufferBlock' bufferReadOffset);  	if (blockCheckSum == 0 && blockLen == 0) {  		bufferReadOffset -= 4;  		break;  	}  	var blockType = (BlockType)(blockLen & 0xff);  	blockLen >>= 8;  	if (blockType == BlockType.LastBlock && blockLen == 0) {  		if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum) {  			SetCorrupted ();  			return;  		}  		KnownAsFinished = true;  		return;  	}  	if (blockLen == 0 && blockType != (BlockType.FirstBlock | BlockType.LastBlock)) {  		SetCorrupted ();  		return;  	}  	if (blockLen + HeaderSize > MaxBlockSize) {  		SetCorrupted ();  		return;  	}  	bufferReadOffset += 4;  	var bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + FirstReadAhead) & SectorMaskUInt;  	if (bufferLenToFill > bufferBlock.Length)  		bufferLenToFill = (uint)bufferBlock.Length;  	buf = ByteBuffer.NewSync (bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));  	if (buf.Length > 0) {  		bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + currentReadAhead) & SectorMaskUInt;  		if (bufferLenToFill > bufferBlock.Length)  			bufferLenToFill = (uint)bufferBlock.Length;  		if (bufferStartPosition + bufferLenToFill > File.MaxFileSize) {  			bufferLenToFill = (uint)(File.MaxFileSize - bufferStartPosition);  		}  		buf = ByteBuffer.NewSync (bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));  		if (buf.Length > 0) {  			if (currentReadAhead * 4 < MaxBlockSize) {  				currentReadAhead = currentReadAhead * 2;  			}  			bufReadLength = (int)File.Read (buf' bufferStartPosition + (ulong)bufferFullLength);  			bufferFullLength += bufReadLength;  		}  	}  	if (bufferReadOffset + (int)blockLen > bufferFullLength) {  		SetCorrupted ();  		return;  	}  	if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum) {  		SetCorrupted ();  		return;  	}  	var blockTypeBlock = blockType & (BlockType.FirstBlock | BlockType.MiddleBlock | BlockType.LastBlock);  	var stopReadingRequested = false;  	if (blockTypeBlock == (BlockType.FirstBlock | BlockType.LastBlock)) {  		stopReadingRequested = Process (blockType' ByteBuffer.NewSync (bufferBlock' bufferReadOffset' (int)blockLen)' observer);  	} else {  		if (blockTypeBlock == BlockType.FirstBlock) {  			overflowWriter = new ByteBufferWriter ();  		} else if (blockTypeBlock == BlockType.MiddleBlock || blockTypeBlock == BlockType.LastBlock) {  			if (overflowWriter == null) {  				SetCorrupted ();  				return;  			}  		} else {  			SetCorrupted ();  			return;  		}  		overflowWriter.WriteBlock (ByteBuffer.NewSync (bufferBlock' bufferReadOffset' (int)blockLen));  		if (blockTypeBlock == BlockType.LastBlock) {  			stopReadingRequested = Process (blockType' overflowWriter.Data' observer);  			overflowWriter = null;  		}  	}  	bufferReadOffset += (int)blockLen;  	if (overflowWriter == null)  		NextReadPosition = bufferStartPosition + (ulong)bufferReadOffset;  	if (stopReadingRequested) {  		return;  	}  	var nextBufferStartPosition = (bufferStartPosition + (ulong)bufferReadOffset) & SectorMask;  	var bufferMoveDistance = (int)(nextBufferStartPosition - bufferStartPosition);  	if (bufferMoveDistance <= 0)  		continue;  	Array.Copy (bufferBlock' bufferMoveDistance' bufferBlock' 0' bufferFullLength - bufferMoveDistance);  	bufferStartPosition = nextBufferStartPosition;  	bufferFullLength -= bufferMoveDistance;  	bufferReadOffset -= bufferMoveDistance;  }  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: bufferReadOffset += 4;  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: if (blockCheckSum == 0 && blockLen == 0) {  	bufferReadOffset -= 4;  	break;  }  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: bufferReadOffset -= 4;  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: blockLen >>= 8;  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: if (blockType == BlockType.LastBlock && blockLen == 0) {  	if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum) {  		SetCorrupted ();  		return;  	}  	KnownAsFinished = true;  	return;  }  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset' 4) != blockCheckSum) {  	SetCorrupted ();  	return;  }  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: bufferReadOffset += 4;  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: if (buf.Length > 0) {  	bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + currentReadAhead) & SectorMaskUInt;  	if (bufferLenToFill > bufferBlock.Length)  		bufferLenToFill = (uint)bufferBlock.Length;  	if (bufferStartPosition + bufferLenToFill > File.MaxFileSize) {  		bufferLenToFill = (uint)(File.MaxFileSize - bufferStartPosition);  	}  	buf = ByteBuffer.NewSync (bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));  	if (buf.Length > 0) {  		if (currentReadAhead * 4 < MaxBlockSize) {  			currentReadAhead = currentReadAhead * 2;  		}  		bufReadLength = (int)File.Read (buf' bufferStartPosition + (ulong)bufferFullLength);  		bufferFullLength += bufReadLength;  	}  }  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: if (buf.Length > 0) {  	bufferLenToFill = (uint)(bufferReadOffset + (int)blockLen + currentReadAhead) & SectorMaskUInt;  	if (bufferLenToFill > bufferBlock.Length)  		bufferLenToFill = (uint)bufferBlock.Length;  	if (bufferStartPosition + bufferLenToFill > File.MaxFileSize) {  		bufferLenToFill = (uint)(File.MaxFileSize - bufferStartPosition);  	}  	buf = ByteBuffer.NewSync (bufferBlock' bufferFullLength' (int)(bufferLenToFill - bufferFullLength));  	if (buf.Length > 0) {  		if (currentReadAhead * 4 < MaxBlockSize) {  			currentReadAhead = currentReadAhead * 2;  		}  		bufReadLength = (int)File.Read (buf' bufferStartPosition + (ulong)bufferFullLength);  		bufferFullLength += bufReadLength;  	}  }  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: if (buf.Length > 0) {  	if (currentReadAhead * 4 < MaxBlockSize) {  		currentReadAhead = currentReadAhead * 2;  	}  	bufReadLength = (int)File.Read (buf' bufferStartPosition + (ulong)bufferFullLength);  	bufferFullLength += bufReadLength;  }  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: if (buf.Length > 0) {  	if (currentReadAhead * 4 < MaxBlockSize) {  		currentReadAhead = currentReadAhead * 2;  	}  	bufReadLength = (int)File.Read (buf' bufferStartPosition + (ulong)bufferFullLength);  	bufferFullLength += bufReadLength;  }  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: if (currentReadAhead * 4 < MaxBlockSize) {  	currentReadAhead = currentReadAhead * 2;  }  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: if (currentReadAhead * 4 < MaxBlockSize) {  	currentReadAhead = currentReadAhead * 2;  }  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: currentReadAhead = currentReadAhead * 2;  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum) {  	SetCorrupted ();  	return;  }  
Magic Number,BTDB.EventStoreLayer,ReadOnlyEventStore,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\ReadOnlyEventStore.cs,ReadToEnd,The following statement contains a magic number: if (Checksum.CalcFletcher32 (bufferBlock' (uint)bufferReadOffset - 4' blockLen + 4) != blockCheckSum) {  	SetCorrupted ();  	return;  }  
Magic Number,BTDB.EventStoreLayer,TypeSerializers,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,LoaderFactory,The following statement contains a magic number: if (descriptor.AnyOpNeedsCtx ()) {  	var localCtx = il.DeclareLocal (typeof(ITypeBinaryDeserializerContext)' "ctx");  	var haveCtx = il.DefineLabel ();  	il.Ldarg (1).Dup ().Stloc (localCtx).Brtrue (haveCtx).Ldarg (0).Ldarg (2).Newobj (() => new DeserializerCtx (null' null)).Castclass (typeof(ITypeBinaryDeserializerContext)).Stloc (localCtx).Mark (haveCtx);  	descriptor.GenerateLoad (il' ilGen => ilGen.Ldarg (0)' ilGen => ilGen.Ldloc (localCtx)' ilGen => ilGen.Ldarg (3)' loadAsType);  } else {  	descriptor.GenerateLoad (il' ilGen => ilGen.Ldarg (0)' ilGen => ilGen.Ldarg (1)' ilGen => ilGen.Ldarg (3)' loadAsType);  }  
Magic Number,BTDB.EventStoreLayer,TypeSerializers,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,LoaderFactory,The following statement contains a magic number: if (descriptor.AnyOpNeedsCtx ()) {  	var localCtx = il.DeclareLocal (typeof(ITypeBinaryDeserializerContext)' "ctx");  	var haveCtx = il.DefineLabel ();  	il.Ldarg (1).Dup ().Stloc (localCtx).Brtrue (haveCtx).Ldarg (0).Ldarg (2).Newobj (() => new DeserializerCtx (null' null)).Castclass (typeof(ITypeBinaryDeserializerContext)).Stloc (localCtx).Mark (haveCtx);  	descriptor.GenerateLoad (il' ilGen => ilGen.Ldarg (0)' ilGen => ilGen.Ldloc (localCtx)' ilGen => ilGen.Ldarg (3)' loadAsType);  } else {  	descriptor.GenerateLoad (il' ilGen => ilGen.Ldarg (0)' ilGen => ilGen.Ldarg (1)' ilGen => ilGen.Ldarg (3)' loadAsType);  }  
Magic Number,BTDB.EventStoreLayer,TypeSerializers,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,LoaderFactory,The following statement contains a magic number: if (descriptor.AnyOpNeedsCtx ()) {  	var localCtx = il.DeclareLocal (typeof(ITypeBinaryDeserializerContext)' "ctx");  	var haveCtx = il.DefineLabel ();  	il.Ldarg (1).Dup ().Stloc (localCtx).Brtrue (haveCtx).Ldarg (0).Ldarg (2).Newobj (() => new DeserializerCtx (null' null)).Castclass (typeof(ITypeBinaryDeserializerContext)).Stloc (localCtx).Mark (haveCtx);  	descriptor.GenerateLoad (il' ilGen => ilGen.Ldarg (0)' ilGen => ilGen.Ldloc (localCtx)' ilGen => ilGen.Ldarg (3)' loadAsType);  } else {  	descriptor.GenerateLoad (il' ilGen => ilGen.Ldarg (0)' ilGen => ilGen.Ldarg (1)' ilGen => ilGen.Ldarg (3)' loadAsType);  }  
Magic Number,BTDB.EventStoreLayer,TypeSerializers,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,LoaderFactory,The following statement contains a magic number: il.Ldarg (1).Dup ().Stloc (localCtx).Brtrue (haveCtx).Ldarg (0).Ldarg (2).Newobj (() => new DeserializerCtx (null' null)).Castclass (typeof(ITypeBinaryDeserializerContext)).Stloc (localCtx).Mark (haveCtx);  
Magic Number,BTDB.EventStoreLayer,TypeSerializers,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,LoaderFactory,The following statement contains a magic number: descriptor.GenerateLoad (il' ilGen => ilGen.Ldarg (0)' ilGen => ilGen.Ldloc (localCtx)' ilGen => ilGen.Ldarg (3)' loadAsType);  
Magic Number,BTDB.EventStoreLayer,TypeSerializers,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,LoaderFactory,The following statement contains a magic number: descriptor.GenerateLoad (il' ilGen => ilGen.Ldarg (0)' ilGen => ilGen.Ldarg (1)' ilGen => ilGen.Ldarg (3)' loadAsType);  
Magic Number,BTDB.EventStoreLayer,TypeSerializers,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,NewComplexSaver,The following statement contains a magic number: descriptor.GenerateSave (il' ilgen => ilgen.Ldarg (0)' ilgen => ilgen.Ldarg (1)' ilgen => {  	ilgen.Ldarg (2);  	var type = descriptor.GetPreferedType ();  	if (type != typeof(object)) {  		ilgen.UnboxAny (type);  	}  }' descriptor.GetPreferedType ());  
Magic Number,BTDB.EventStoreLayer,TypeSerializers,F:\newReposMay17\Bobris_BTDB\BTDB\EventStoreLayer\TypeSerializers.cs,NewComplexSaver,The following statement contains a magic number: ilgen.Ldarg (2);  
Magic Number,BTDB.IL.Caching,CachingILDynamicType,F:\newReposMay17\Bobris_BTDB\BTDB\IL\Caching\CachingILDynamicType.cs,GetHashCode,The following statement contains a magic number: return _name.GetHashCode () * 33 + _insts.Count;  
Magic Number,BTDB.IL,ILConstructorDebugImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILConstructorDebugImpl.cs,ILConstructorDebugImpl,The following statement contains a magic number: _expectedLength = 64;  
Magic Number,BTDB.IL,ILConstructorImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILConstructorImpl.cs,ILConstructorImpl,The following statement contains a magic number: _expectedLength = 64;  
Magic Number,BTDB.IL,ILDynamicMethodWithThisImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILDynamicMethodWithThisImpl.cs,ILDynamicMethodWithThisImpl,The following statement contains a magic number: _expectedLength = 64;  
Magic Number,BTDB.IL,ILDynamicMethodImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILDynamicMethodImpl.cs,ILDynamicMethodImpl,The following statement contains a magic number: _expectedLength = 64;  
Magic Number,BTDB.IL,ILDynamicMethodDebugImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILDynamicMethodDebugImpl.cs,ILDynamicMethodDebugImpl,The following statement contains a magic number: _expectedLength = 64;  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value) {  case 0:  	il.Emit (OpCodes.Ldc_I4_0);  	break;  case 1:  	il.Emit (OpCodes.Ldc_I4_1);  	break;  case 2:  	il.Emit (OpCodes.Ldc_I4_2);  	break;  case 3:  	il.Emit (OpCodes.Ldc_I4_3);  	break;  case 4:  	il.Emit (OpCodes.Ldc_I4_4);  	break;  case 5:  	il.Emit (OpCodes.Ldc_I4_5);  	break;  case 6:  	il.Emit (OpCodes.Ldc_I4_6);  	break;  case 7:  	il.Emit (OpCodes.Ldc_I4_7);  	break;  case 8:  	il.Emit (OpCodes.Ldc_I4_8);  	break;  case -1:  	il.Emit (OpCodes.Ldc_I4_M1);  	break;  default:  	if (value >= -128 && value <= 127)  		il.Emit (OpCodes.Ldc_I4_S' (sbyte)value);  	else  		il.Emit (OpCodes.Ldc_I4' value);  	break;  }  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value) {  case 0:  	il.Emit (OpCodes.Ldc_I4_0);  	break;  case 1:  	il.Emit (OpCodes.Ldc_I4_1);  	break;  case 2:  	il.Emit (OpCodes.Ldc_I4_2);  	break;  case 3:  	il.Emit (OpCodes.Ldc_I4_3);  	break;  case 4:  	il.Emit (OpCodes.Ldc_I4_4);  	break;  case 5:  	il.Emit (OpCodes.Ldc_I4_5);  	break;  case 6:  	il.Emit (OpCodes.Ldc_I4_6);  	break;  case 7:  	il.Emit (OpCodes.Ldc_I4_7);  	break;  case 8:  	il.Emit (OpCodes.Ldc_I4_8);  	break;  case -1:  	il.Emit (OpCodes.Ldc_I4_M1);  	break;  default:  	if (value >= -128 && value <= 127)  		il.Emit (OpCodes.Ldc_I4_S' (sbyte)value);  	else  		il.Emit (OpCodes.Ldc_I4' value);  	break;  }  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value) {  case 0:  	il.Emit (OpCodes.Ldc_I4_0);  	break;  case 1:  	il.Emit (OpCodes.Ldc_I4_1);  	break;  case 2:  	il.Emit (OpCodes.Ldc_I4_2);  	break;  case 3:  	il.Emit (OpCodes.Ldc_I4_3);  	break;  case 4:  	il.Emit (OpCodes.Ldc_I4_4);  	break;  case 5:  	il.Emit (OpCodes.Ldc_I4_5);  	break;  case 6:  	il.Emit (OpCodes.Ldc_I4_6);  	break;  case 7:  	il.Emit (OpCodes.Ldc_I4_7);  	break;  case 8:  	il.Emit (OpCodes.Ldc_I4_8);  	break;  case -1:  	il.Emit (OpCodes.Ldc_I4_M1);  	break;  default:  	if (value >= -128 && value <= 127)  		il.Emit (OpCodes.Ldc_I4_S' (sbyte)value);  	else  		il.Emit (OpCodes.Ldc_I4' value);  	break;  }  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value) {  case 0:  	il.Emit (OpCodes.Ldc_I4_0);  	break;  case 1:  	il.Emit (OpCodes.Ldc_I4_1);  	break;  case 2:  	il.Emit (OpCodes.Ldc_I4_2);  	break;  case 3:  	il.Emit (OpCodes.Ldc_I4_3);  	break;  case 4:  	il.Emit (OpCodes.Ldc_I4_4);  	break;  case 5:  	il.Emit (OpCodes.Ldc_I4_5);  	break;  case 6:  	il.Emit (OpCodes.Ldc_I4_6);  	break;  case 7:  	il.Emit (OpCodes.Ldc_I4_7);  	break;  case 8:  	il.Emit (OpCodes.Ldc_I4_8);  	break;  case -1:  	il.Emit (OpCodes.Ldc_I4_M1);  	break;  default:  	if (value >= -128 && value <= 127)  		il.Emit (OpCodes.Ldc_I4_S' (sbyte)value);  	else  		il.Emit (OpCodes.Ldc_I4' value);  	break;  }  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value) {  case 0:  	il.Emit (OpCodes.Ldc_I4_0);  	break;  case 1:  	il.Emit (OpCodes.Ldc_I4_1);  	break;  case 2:  	il.Emit (OpCodes.Ldc_I4_2);  	break;  case 3:  	il.Emit (OpCodes.Ldc_I4_3);  	break;  case 4:  	il.Emit (OpCodes.Ldc_I4_4);  	break;  case 5:  	il.Emit (OpCodes.Ldc_I4_5);  	break;  case 6:  	il.Emit (OpCodes.Ldc_I4_6);  	break;  case 7:  	il.Emit (OpCodes.Ldc_I4_7);  	break;  case 8:  	il.Emit (OpCodes.Ldc_I4_8);  	break;  case -1:  	il.Emit (OpCodes.Ldc_I4_M1);  	break;  default:  	if (value >= -128 && value <= 127)  		il.Emit (OpCodes.Ldc_I4_S' (sbyte)value);  	else  		il.Emit (OpCodes.Ldc_I4' value);  	break;  }  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value) {  case 0:  	il.Emit (OpCodes.Ldc_I4_0);  	break;  case 1:  	il.Emit (OpCodes.Ldc_I4_1);  	break;  case 2:  	il.Emit (OpCodes.Ldc_I4_2);  	break;  case 3:  	il.Emit (OpCodes.Ldc_I4_3);  	break;  case 4:  	il.Emit (OpCodes.Ldc_I4_4);  	break;  case 5:  	il.Emit (OpCodes.Ldc_I4_5);  	break;  case 6:  	il.Emit (OpCodes.Ldc_I4_6);  	break;  case 7:  	il.Emit (OpCodes.Ldc_I4_7);  	break;  case 8:  	il.Emit (OpCodes.Ldc_I4_8);  	break;  case -1:  	il.Emit (OpCodes.Ldc_I4_M1);  	break;  default:  	if (value >= -128 && value <= 127)  		il.Emit (OpCodes.Ldc_I4_S' (sbyte)value);  	else  		il.Emit (OpCodes.Ldc_I4' value);  	break;  }  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value) {  case 0:  	il.Emit (OpCodes.Ldc_I4_0);  	break;  case 1:  	il.Emit (OpCodes.Ldc_I4_1);  	break;  case 2:  	il.Emit (OpCodes.Ldc_I4_2);  	break;  case 3:  	il.Emit (OpCodes.Ldc_I4_3);  	break;  case 4:  	il.Emit (OpCodes.Ldc_I4_4);  	break;  case 5:  	il.Emit (OpCodes.Ldc_I4_5);  	break;  case 6:  	il.Emit (OpCodes.Ldc_I4_6);  	break;  case 7:  	il.Emit (OpCodes.Ldc_I4_7);  	break;  case 8:  	il.Emit (OpCodes.Ldc_I4_8);  	break;  case -1:  	il.Emit (OpCodes.Ldc_I4_M1);  	break;  default:  	if (value >= -128 && value <= 127)  		il.Emit (OpCodes.Ldc_I4_S' (sbyte)value);  	else  		il.Emit (OpCodes.Ldc_I4' value);  	break;  }  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value) {  case 0:  	il.Emit (OpCodes.Ldc_I4_0);  	break;  case 1:  	il.Emit (OpCodes.Ldc_I4_1);  	break;  case 2:  	il.Emit (OpCodes.Ldc_I4_2);  	break;  case 3:  	il.Emit (OpCodes.Ldc_I4_3);  	break;  case 4:  	il.Emit (OpCodes.Ldc_I4_4);  	break;  case 5:  	il.Emit (OpCodes.Ldc_I4_5);  	break;  case 6:  	il.Emit (OpCodes.Ldc_I4_6);  	break;  case 7:  	il.Emit (OpCodes.Ldc_I4_7);  	break;  case 8:  	il.Emit (OpCodes.Ldc_I4_8);  	break;  case -1:  	il.Emit (OpCodes.Ldc_I4_M1);  	break;  default:  	if (value >= -128 && value <= 127)  		il.Emit (OpCodes.Ldc_I4_S' (sbyte)value);  	else  		il.Emit (OpCodes.Ldc_I4' value);  	break;  }  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: switch (value) {  case 0:  	il.Emit (OpCodes.Ldc_I4_0);  	break;  case 1:  	il.Emit (OpCodes.Ldc_I4_1);  	break;  case 2:  	il.Emit (OpCodes.Ldc_I4_2);  	break;  case 3:  	il.Emit (OpCodes.Ldc_I4_3);  	break;  case 4:  	il.Emit (OpCodes.Ldc_I4_4);  	break;  case 5:  	il.Emit (OpCodes.Ldc_I4_5);  	break;  case 6:  	il.Emit (OpCodes.Ldc_I4_6);  	break;  case 7:  	il.Emit (OpCodes.Ldc_I4_7);  	break;  case 8:  	il.Emit (OpCodes.Ldc_I4_8);  	break;  case -1:  	il.Emit (OpCodes.Ldc_I4_M1);  	break;  default:  	if (value >= -128 && value <= 127)  		il.Emit (OpCodes.Ldc_I4_S' (sbyte)value);  	else  		il.Emit (OpCodes.Ldc_I4' value);  	break;  }  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: if (value >= -128 && value <= 127)  	il.Emit (OpCodes.Ldc_I4_S' (sbyte)value);  else  	il.Emit (OpCodes.Ldc_I4' value);  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,LdcI4,The following statement contains a magic number: if (value >= -128 && value <= 127)  	il.Emit (OpCodes.Ldc_I4_S' (sbyte)value);  else  	il.Emit (OpCodes.Ldc_I4' value);  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldarg,The following statement contains a magic number: switch (parameterIndex) {  case 0:  	il.Emit (OpCodes.Ldarg_0);  	break;  case 1:  	il.Emit (OpCodes.Ldarg_1);  	break;  case 2:  	il.Emit (OpCodes.Ldarg_2);  	break;  case 3:  	il.Emit (OpCodes.Ldarg_3);  	break;  default:  	if (parameterIndex <= 255)  		il.Emit (OpCodes.Ldarg_S' (byte)parameterIndex);  	else  		il.Emit (OpCodes.Ldarg' parameterIndex);  	break;  }  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldarg,The following statement contains a magic number: switch (parameterIndex) {  case 0:  	il.Emit (OpCodes.Ldarg_0);  	break;  case 1:  	il.Emit (OpCodes.Ldarg_1);  	break;  case 2:  	il.Emit (OpCodes.Ldarg_2);  	break;  case 3:  	il.Emit (OpCodes.Ldarg_3);  	break;  default:  	if (parameterIndex <= 255)  		il.Emit (OpCodes.Ldarg_S' (byte)parameterIndex);  	else  		il.Emit (OpCodes.Ldarg' parameterIndex);  	break;  }  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldarg,The following statement contains a magic number: switch (parameterIndex) {  case 0:  	il.Emit (OpCodes.Ldarg_0);  	break;  case 1:  	il.Emit (OpCodes.Ldarg_1);  	break;  case 2:  	il.Emit (OpCodes.Ldarg_2);  	break;  case 3:  	il.Emit (OpCodes.Ldarg_3);  	break;  default:  	if (parameterIndex <= 255)  		il.Emit (OpCodes.Ldarg_S' (byte)parameterIndex);  	else  		il.Emit (OpCodes.Ldarg' parameterIndex);  	break;  }  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldarg,The following statement contains a magic number: if (parameterIndex <= 255)  	il.Emit (OpCodes.Ldarg_S' (byte)parameterIndex);  else  	il.Emit (OpCodes.Ldarg' parameterIndex);  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Starg,The following statement contains a magic number: if (parameterIndex <= 255)  	il.Emit (OpCodes.Starg_S' (byte)parameterIndex);  else  	il.Emit (OpCodes.Starg' parameterIndex);  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Stloc,The following statement contains a magic number: switch (localVariableIndex) {  case 0:  	il.Emit (OpCodes.Stloc_0);  	break;  case 1:  	il.Emit (OpCodes.Stloc_1);  	break;  case 2:  	il.Emit (OpCodes.Stloc_2);  	break;  case 3:  	il.Emit (OpCodes.Stloc_3);  	break;  case 65535:  	throw new ArgumentOutOfRangeException (nameof (localVariableIndex));  default:  	if (localVariableIndex <= 255)  		il.Emit (OpCodes.Stloc_S' (byte)localVariableIndex);  	else  		il.Emit (OpCodes.Stloc' localVariableIndex);  	break;  }  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Stloc,The following statement contains a magic number: switch (localVariableIndex) {  case 0:  	il.Emit (OpCodes.Stloc_0);  	break;  case 1:  	il.Emit (OpCodes.Stloc_1);  	break;  case 2:  	il.Emit (OpCodes.Stloc_2);  	break;  case 3:  	il.Emit (OpCodes.Stloc_3);  	break;  case 65535:  	throw new ArgumentOutOfRangeException (nameof (localVariableIndex));  default:  	if (localVariableIndex <= 255)  		il.Emit (OpCodes.Stloc_S' (byte)localVariableIndex);  	else  		il.Emit (OpCodes.Stloc' localVariableIndex);  	break;  }  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Stloc,The following statement contains a magic number: switch (localVariableIndex) {  case 0:  	il.Emit (OpCodes.Stloc_0);  	break;  case 1:  	il.Emit (OpCodes.Stloc_1);  	break;  case 2:  	il.Emit (OpCodes.Stloc_2);  	break;  case 3:  	il.Emit (OpCodes.Stloc_3);  	break;  case 65535:  	throw new ArgumentOutOfRangeException (nameof (localVariableIndex));  default:  	if (localVariableIndex <= 255)  		il.Emit (OpCodes.Stloc_S' (byte)localVariableIndex);  	else  		il.Emit (OpCodes.Stloc' localVariableIndex);  	break;  }  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Stloc,The following statement contains a magic number: switch (localVariableIndex) {  case 0:  	il.Emit (OpCodes.Stloc_0);  	break;  case 1:  	il.Emit (OpCodes.Stloc_1);  	break;  case 2:  	il.Emit (OpCodes.Stloc_2);  	break;  case 3:  	il.Emit (OpCodes.Stloc_3);  	break;  case 65535:  	throw new ArgumentOutOfRangeException (nameof (localVariableIndex));  default:  	if (localVariableIndex <= 255)  		il.Emit (OpCodes.Stloc_S' (byte)localVariableIndex);  	else  		il.Emit (OpCodes.Stloc' localVariableIndex);  	break;  }  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Stloc,The following statement contains a magic number: if (localVariableIndex <= 255)  	il.Emit (OpCodes.Stloc_S' (byte)localVariableIndex);  else  	il.Emit (OpCodes.Stloc' localVariableIndex);  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldloc,The following statement contains a magic number: switch (localVariableIndex) {  case 0:  	il.Emit (OpCodes.Ldloc_0);  	break;  case 1:  	il.Emit (OpCodes.Ldloc_1);  	break;  case 2:  	il.Emit (OpCodes.Ldloc_2);  	break;  case 3:  	il.Emit (OpCodes.Ldloc_3);  	break;  case 65535:  	throw new ArgumentOutOfRangeException (nameof (localVariableIndex));  default:  	if (localVariableIndex <= 255)  		il.Emit (OpCodes.Ldloc_S' (byte)localVariableIndex);  	else  		il.Emit (OpCodes.Ldloc' localVariableIndex);  	break;  }  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldloc,The following statement contains a magic number: switch (localVariableIndex) {  case 0:  	il.Emit (OpCodes.Ldloc_0);  	break;  case 1:  	il.Emit (OpCodes.Ldloc_1);  	break;  case 2:  	il.Emit (OpCodes.Ldloc_2);  	break;  case 3:  	il.Emit (OpCodes.Ldloc_3);  	break;  case 65535:  	throw new ArgumentOutOfRangeException (nameof (localVariableIndex));  default:  	if (localVariableIndex <= 255)  		il.Emit (OpCodes.Ldloc_S' (byte)localVariableIndex);  	else  		il.Emit (OpCodes.Ldloc' localVariableIndex);  	break;  }  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldloc,The following statement contains a magic number: switch (localVariableIndex) {  case 0:  	il.Emit (OpCodes.Ldloc_0);  	break;  case 1:  	il.Emit (OpCodes.Ldloc_1);  	break;  case 2:  	il.Emit (OpCodes.Ldloc_2);  	break;  case 3:  	il.Emit (OpCodes.Ldloc_3);  	break;  case 65535:  	throw new ArgumentOutOfRangeException (nameof (localVariableIndex));  default:  	if (localVariableIndex <= 255)  		il.Emit (OpCodes.Ldloc_S' (byte)localVariableIndex);  	else  		il.Emit (OpCodes.Ldloc' localVariableIndex);  	break;  }  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldloc,The following statement contains a magic number: switch (localVariableIndex) {  case 0:  	il.Emit (OpCodes.Ldloc_0);  	break;  case 1:  	il.Emit (OpCodes.Ldloc_1);  	break;  case 2:  	il.Emit (OpCodes.Ldloc_2);  	break;  case 3:  	il.Emit (OpCodes.Ldloc_3);  	break;  case 65535:  	throw new ArgumentOutOfRangeException (nameof (localVariableIndex));  default:  	if (localVariableIndex <= 255)  		il.Emit (OpCodes.Ldloc_S' (byte)localVariableIndex);  	else  		il.Emit (OpCodes.Ldloc' localVariableIndex);  	break;  }  
Magic Number,BTDB.IL,ILGenExtensions,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILGenExtensions.cs,Ldloc,The following statement contains a magic number: if (localVariableIndex <= 255)  	il.Emit (OpCodes.Ldloc_S' (byte)localVariableIndex);  else  	il.Emit (OpCodes.Ldloc' localVariableIndex);  
Magic Number,BTDB.IL,ILMethodDebugImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILMethodDebugImpl.cs,ILMethodDebugImpl,The following statement contains a magic number: _expectedLength = 64;  
Magic Number,BTDB.IL,ILMethodImpl,F:\newReposMay17\Bobris_BTDB\BTDB\IL\ILMethodImpl.cs,ILMethodImpl,The following statement contains a magic number: _expectedLength = 64;  
Magic Number,BTDB.IL,EmitHelpers,F:\newReposMay17\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateAddRemoveEvent,The following statement contains a magic number: ilGenerator.Ldarg (0).Ldfld (fieldBuilder).Stloc (0).Mark (label).Ldloc (0).Stloc (1).Ldloc (1).Ldarg (1).Call (add ? GetMethodInfo (() => Delegate.Combine (null' null)) : GetMethodInfo (() => Delegate.Remove (null' null))).Castclass (typePropertyChangedEventHandler).Stloc (2).Ldarg (0).Ldflda (fieldBuilder).Ldloc (2).Ldloc (1);  
Magic Number,BTDB.IL,EmitHelpers,F:\newReposMay17\Bobris_BTDB\BTDB\IL\EmitHelpers.cs,GenerateAddRemoveEvent,The following statement contains a magic number: ilGenerator.Ldarg (0).Ldfld (fieldBuilder).Stloc (0).Mark (label).Ldloc (0).Stloc (1).Ldloc (1).Ldarg (1).Call (add ? GetMethodInfo (() => Delegate.Combine (null' null)) : GetMethodInfo (() => Delegate.Remove (null' null))).Castclass (typePropertyChangedEventHandler).Stloc (2).Ldarg (0).Ldflda (fieldBuilder).Ldloc (2).Ldloc (1);  
Magic Number,BTDB.IOC,KeyAndType,F:\newReposMay17\Bobris_BTDB\BTDB\IOC\KeyAndType.cs,GetHashCode,The following statement contains a magic number: return Key.GetHashCode () * 33 + Type.GetHashCode ();  
Magic Number,BTDB.KVDBLayer.BTree,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,Find,The following statement contains a magic number: while (left < right) {  	var middle = (left + right) / 2;  	var currentKey = _keys [middle];  	var result = BitArrayManipulation.CompareByteArray (prefix' prefix.Length' currentKey' Math.Min (currentKey.Length' prefix.Length));  	if (result == 0) {  		result = BitArrayManipulation.CompareByteArray (key.Buffer' key.Offset' key.Length' currentKey' prefix.Length' currentKey.Length - prefix.Length);  	}  	if (result < 0) {  		right = middle;  	} else {  		left = middle + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTree,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,CreateOrUpdate,The following statement contains a magic number: if (ctx.Split) {  	ctx.Split = false;  	var newKeys = new byte[_children.Length][];  	var newChildren = new IBTreeNode[_children.Length + 1];  	var newPairCounts = new long[_children.Length + 1];  	Array.Copy (_keys' 0' newKeys' 0' index);  	newKeys [index] = ctx.Node2.GetLeftMostKey ();  	Array.Copy (_keys' index' newKeys' index + 1' _keys.Length - index);  	Array.Copy (_children' 0' newChildren' 0' index);  	newChildren [index] = ctx.Node1;  	newChildren [index + 1] = ctx.Node2;  	Array.Copy (_children' index + 1' newChildren' index + 2' _children.Length - index - 1);  	Array.Copy (_pairCounts' newPairCounts' index);  	var previousPairCount = index > 0 ? newPairCounts [index - 1] : 0;  	for (var i = index; i < newPairCounts.Length; i++) {  		previousPairCount += newChildren [i].CalcKeyCount ();  		newPairCounts [i] = previousPairCount;  	}  	ctx.Node1 = null;  	ctx.Node2 = null;  	if (_children.Length < MaxChildren) {  		if (TransactionId != ctx.TransactionId) {  			newBranch = new BTreeBranch (ctx.TransactionId' newKeys' newChildren' newPairCounts);  			ctx.Node1 = newBranch;  			ctx.Update = true;  		} else {  			_keys = newKeys;  			_children = newChildren;  			_pairCounts = newPairCounts;  		}  		if (ctx.SplitInRight)  			index++;  		ctx.Stack [ctx.Depth] = new NodeIdxPair {  			Node = newBranch'  			Idx = index  		};  		return;  	}  	if (ctx.SplitInRight)  		index++;  	ctx.Split = true;  	var keyCountLeft = (newChildren.Length + 1) / 2;  	var keyCountRight = newChildren.Length - keyCountLeft;  	var splitKeys = new byte[keyCountLeft - 1][];  	var splitChildren = new IBTreeNode[keyCountLeft];  	var splitPairCounts = new long[keyCountLeft];  	Array.Copy (newKeys' splitKeys' splitKeys.Length);  	Array.Copy (newChildren' splitChildren' splitChildren.Length);  	Array.Copy (newPairCounts' splitPairCounts' splitPairCounts.Length);  	ctx.Node1 = new BTreeBranch (ctx.TransactionId' splitKeys' splitChildren' splitPairCounts);  	splitKeys = new byte[keyCountRight - 1][];  	splitChildren = new IBTreeNode[keyCountRight];  	splitPairCounts = new long[keyCountRight];  	Array.Copy (newKeys' keyCountLeft' splitKeys' 0' splitKeys.Length);  	Array.Copy (newChildren' keyCountLeft' splitChildren' 0' splitChildren.Length);  	for (int i = 0; i < splitPairCounts.Length; i++) {  		splitPairCounts [i] = newPairCounts [keyCountLeft + i] - newPairCounts [keyCountLeft - 1];  	}  	ctx.Node2 = new BTreeBranch (ctx.TransactionId' splitKeys' splitChildren' splitPairCounts);  	if (index < keyCountLeft) {  		ctx.Stack [ctx.Depth] = new NodeIdxPair {  			Node = ctx.Node1'  			Idx = index  		};  		ctx.SplitInRight = false;  	} else {  		ctx.Stack [ctx.Depth] = new NodeIdxPair {  			Node = ctx.Node2'  			Idx = index - keyCountLeft  		};  		ctx.SplitInRight = true;  	}  	return;  }  
Magic Number,BTDB.KVDBLayer.BTree,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,CreateOrUpdate,The following statement contains a magic number: if (ctx.Split) {  	ctx.Split = false;  	var newKeys = new byte[_children.Length][];  	var newChildren = new IBTreeNode[_children.Length + 1];  	var newPairCounts = new long[_children.Length + 1];  	Array.Copy (_keys' 0' newKeys' 0' index);  	newKeys [index] = ctx.Node2.GetLeftMostKey ();  	Array.Copy (_keys' index' newKeys' index + 1' _keys.Length - index);  	Array.Copy (_children' 0' newChildren' 0' index);  	newChildren [index] = ctx.Node1;  	newChildren [index + 1] = ctx.Node2;  	Array.Copy (_children' index + 1' newChildren' index + 2' _children.Length - index - 1);  	Array.Copy (_pairCounts' newPairCounts' index);  	var previousPairCount = index > 0 ? newPairCounts [index - 1] : 0;  	for (var i = index; i < newPairCounts.Length; i++) {  		previousPairCount += newChildren [i].CalcKeyCount ();  		newPairCounts [i] = previousPairCount;  	}  	ctx.Node1 = null;  	ctx.Node2 = null;  	if (_children.Length < MaxChildren) {  		if (TransactionId != ctx.TransactionId) {  			newBranch = new BTreeBranch (ctx.TransactionId' newKeys' newChildren' newPairCounts);  			ctx.Node1 = newBranch;  			ctx.Update = true;  		} else {  			_keys = newKeys;  			_children = newChildren;  			_pairCounts = newPairCounts;  		}  		if (ctx.SplitInRight)  			index++;  		ctx.Stack [ctx.Depth] = new NodeIdxPair {  			Node = newBranch'  			Idx = index  		};  		return;  	}  	if (ctx.SplitInRight)  		index++;  	ctx.Split = true;  	var keyCountLeft = (newChildren.Length + 1) / 2;  	var keyCountRight = newChildren.Length - keyCountLeft;  	var splitKeys = new byte[keyCountLeft - 1][];  	var splitChildren = new IBTreeNode[keyCountLeft];  	var splitPairCounts = new long[keyCountLeft];  	Array.Copy (newKeys' splitKeys' splitKeys.Length);  	Array.Copy (newChildren' splitChildren' splitChildren.Length);  	Array.Copy (newPairCounts' splitPairCounts' splitPairCounts.Length);  	ctx.Node1 = new BTreeBranch (ctx.TransactionId' splitKeys' splitChildren' splitPairCounts);  	splitKeys = new byte[keyCountRight - 1][];  	splitChildren = new IBTreeNode[keyCountRight];  	splitPairCounts = new long[keyCountRight];  	Array.Copy (newKeys' keyCountLeft' splitKeys' 0' splitKeys.Length);  	Array.Copy (newChildren' keyCountLeft' splitChildren' 0' splitChildren.Length);  	for (int i = 0; i < splitPairCounts.Length; i++) {  		splitPairCounts [i] = newPairCounts [keyCountLeft + i] - newPairCounts [keyCountLeft - 1];  	}  	ctx.Node2 = new BTreeBranch (ctx.TransactionId' splitKeys' splitChildren' splitPairCounts);  	if (index < keyCountLeft) {  		ctx.Stack [ctx.Depth] = new NodeIdxPair {  			Node = ctx.Node1'  			Idx = index  		};  		ctx.SplitInRight = false;  	} else {  		ctx.Stack [ctx.Depth] = new NodeIdxPair {  			Node = ctx.Node2'  			Idx = index - keyCountLeft  		};  		ctx.SplitInRight = true;  	}  	return;  }  
Magic Number,BTDB.KVDBLayer.BTree,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,CreateOrUpdate,The following statement contains a magic number: Array.Copy (_children' index + 1' newChildren' index + 2' _children.Length - index - 1);  
Magic Number,BTDB.KVDBLayer.BTree,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,FillStackByIndex,The following statement contains a magic number: while (left < right) {  	var middle = (left + right) / 2;  	var currentIndex = _pairCounts [middle];  	if (keyIndex < currentIndex) {  		right = middle;  	} else {  		left = middle + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTree,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeBranch.cs,FindLastWithPrefix,The following statement contains a magic number: while (left < right) {  	var middle = (left + right) / 2;  	var currentKey = _keys [middle];  	var result = BitArrayManipulation.CompareByteArray (prefix' prefix.Length' currentKey' Math.Min (currentKey.Length' prefix.Length));  	if (result < 0) {  		right = middle;  	} else {  		left = middle + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,Find,The following statement contains a magic number: while (left < right) {  	var middle = (left + right) / 2;  	var currentKey = _keyvalues [middle].Key;  	var result = BitArrayManipulation.CompareByteArray (prefix' prefix.Length' currentKey' Math.Min (currentKey.Length' prefix.Length));  	if (result == 0) {  		result = BitArrayManipulation.CompareByteArray (key.Buffer' key.Offset' key.Length' currentKey' prefix.Length' currentKey.Length - prefix.Length);  		if (result == 0) {  			return middle * 2 + 1;  		}  	}  	if (result < 0) {  		right = middle;  	} else {  		left = middle + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,Find,The following statement contains a magic number: while (left < right) {  	var middle = (left + right) / 2;  	var currentKey = _keyvalues [middle].Key;  	var result = BitArrayManipulation.CompareByteArray (prefix' prefix.Length' currentKey' Math.Min (currentKey.Length' prefix.Length));  	if (result == 0) {  		result = BitArrayManipulation.CompareByteArray (key.Buffer' key.Offset' key.Length' currentKey' prefix.Length' currentKey.Length - prefix.Length);  		if (result == 0) {  			return middle * 2 + 1;  		}  	}  	if (result < 0) {  		right = middle;  	} else {  		left = middle + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,Find,The following statement contains a magic number: if (result == 0) {  	result = BitArrayManipulation.CompareByteArray (key.Buffer' key.Offset' key.Length' currentKey' prefix.Length' currentKey.Length - prefix.Length);  	if (result == 0) {  		return middle * 2 + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,Find,The following statement contains a magic number: if (result == 0) {  	return middle * 2 + 1;  }  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,Find,The following statement contains a magic number: return middle * 2 + 1;  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,Find,The following statement contains a magic number: return left * 2;  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,CreateOrUpdate,The following statement contains a magic number: if ((index & 1) == 1) {  	index = index / 2;  	ctx.Created = false;  	ctx.KeyIndex = index;  	var m = _keyvalues [index];  	m.ValueFileId = ctx.ValueFileId;  	m.ValueOfs = ctx.ValueOfs;  	m.ValueSize = ctx.ValueSize;  	var leaf = this;  	if (ctx.TransactionId != TransactionId) {  		leaf = new BTreeLeaf (ctx.TransactionId' _keyvalues.Length);  		Array.Copy (_keyvalues' leaf._keyvalues' _keyvalues.Length);  		ctx.Node1 = leaf;  		ctx.Update = true;  	}  	leaf._keyvalues [index] = m;  	ctx.Stack.Add (new NodeIdxPair {  		Node = leaf'  		Idx = index  	});  	return;  }  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,CreateOrUpdate,The following statement contains a magic number: index = index / 2;  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,CreateOrUpdate,The following statement contains a magic number: index = index / 2;  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,FindKey,The following statement contains a magic number: if ((idx & 1) == 1) {  	result = FindResult.Exact;  	idx = idx / 2;  } else {  	result = FindResult.Previous;  	idx = idx / 2 - 1;  }  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,FindKey,The following statement contains a magic number: if ((idx & 1) == 1) {  	result = FindResult.Exact;  	idx = idx / 2;  } else {  	result = FindResult.Previous;  	idx = idx / 2 - 1;  }  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,FindKey,The following statement contains a magic number: idx = idx / 2;  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,FindKey,The following statement contains a magic number: idx = idx / 2 - 1;  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeaf.cs,FindLastWithPrefix,The following statement contains a magic number: while (left < right) {  	var middle = (left + right) / 2;  	currentKey = _keyvalues [middle].Key;  	result = BitArrayManipulation.CompareByteArray (prefix' prefix.Length' currentKey' Math.Min (currentKey.Length' prefix.Length));  	if (result < 0) {  		right = middle;  	} else {  		left = middle + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,Find,The following statement contains a magic number: while (left < right) {  	var middle = (left + right) / 2;  	int currentKeyOfs = _keyvalues [middle].KeyOffset;  	int currentKeyLen = _keyvalues [middle].KeyLength;  	var result = BitArrayManipulation.CompareByteArray (prefix' 0' prefix.Length' keyBytes' currentKeyOfs' Math.Min (currentKeyLen' prefix.Length));  	if (result == 0) {  		result = BitArrayManipulation.CompareByteArray (key.Buffer' key.Offset' key.Length' keyBytes' currentKeyOfs + prefix.Length' currentKeyLen - prefix.Length);  		if (result == 0) {  			return middle * 2 + 1;  		}  	}  	if (result < 0) {  		right = middle;  	} else {  		left = middle + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,Find,The following statement contains a magic number: while (left < right) {  	var middle = (left + right) / 2;  	int currentKeyOfs = _keyvalues [middle].KeyOffset;  	int currentKeyLen = _keyvalues [middle].KeyLength;  	var result = BitArrayManipulation.CompareByteArray (prefix' 0' prefix.Length' keyBytes' currentKeyOfs' Math.Min (currentKeyLen' prefix.Length));  	if (result == 0) {  		result = BitArrayManipulation.CompareByteArray (key.Buffer' key.Offset' key.Length' keyBytes' currentKeyOfs + prefix.Length' currentKeyLen - prefix.Length);  		if (result == 0) {  			return middle * 2 + 1;  		}  	}  	if (result < 0) {  		right = middle;  	} else {  		left = middle + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,Find,The following statement contains a magic number: if (result == 0) {  	result = BitArrayManipulation.CompareByteArray (key.Buffer' key.Offset' key.Length' keyBytes' currentKeyOfs + prefix.Length' currentKeyLen - prefix.Length);  	if (result == 0) {  		return middle * 2 + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,Find,The following statement contains a magic number: if (result == 0) {  	return middle * 2 + 1;  }  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,Find,The following statement contains a magic number: return middle * 2 + 1;  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,Find,The following statement contains a magic number: return left * 2;  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,CreateOrUpdate,The following statement contains a magic number: if ((index & 1) == 1) {  	index = index / 2;  	ctx.Created = false;  	ctx.KeyIndex = index;  	var m = _keyvalues [index];  	m.ValueFileId = ctx.ValueFileId;  	m.ValueOfs = ctx.ValueOfs;  	m.ValueSize = ctx.ValueSize;  	var leaf = this;  	if (ctx.TransactionId != TransactionId) {  		leaf = new BTreeLeafComp (ctx.TransactionId' _keyvalues.Length);  		Array.Copy (_keyvalues' leaf._keyvalues' _keyvalues.Length);  		leaf._keyBytes = _keyBytes;  		ctx.Node1 = leaf;  		ctx.Update = true;  	}  	leaf._keyvalues [index] = m;  	ctx.Stack.Add (new NodeIdxPair {  		Node = leaf'  		Idx = index  	});  	return;  }  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,CreateOrUpdate,The following statement contains a magic number: index = index / 2;  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,CreateOrUpdate,The following statement contains a magic number: index = index / 2;  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,FindKey,The following statement contains a magic number: if ((idx & 1) == 1) {  	result = FindResult.Exact;  	idx = idx / 2;  } else {  	result = FindResult.Previous;  	idx = idx / 2 - 1;  }  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,FindKey,The following statement contains a magic number: if ((idx & 1) == 1) {  	result = FindResult.Exact;  	idx = idx / 2;  } else {  	result = FindResult.Previous;  	idx = idx / 2 - 1;  }  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,FindKey,The following statement contains a magic number: idx = idx / 2;  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,FindKey,The following statement contains a magic number: idx = idx / 2 - 1;  
Magic Number,BTDB.KVDBLayer.BTree,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTree\BTreeLeafComp.cs,FindLastWithPrefix,The following statement contains a magic number: while (left < right) {  	var middle = (left + right) / 2;  	currentKeyOfs = _keyvalues [middle].KeyOffset;  	currentKeyLen = _keyvalues [middle].KeyLength;  	result = BitArrayManipulation.CompareByteArray (prefix' 0' prefix.Length' keyBytes' currentKeyOfs' Math.Min (currentKeyLen' prefix.Length));  	if (result < 0) {  		right = middle;  	} else {  		left = middle + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,Find,The following statement contains a magic number: while (left < right) {  	var middle = (left + right) / 2;  	var currentKey = _keys [middle];  	var result = BitArrayManipulation.CompareByteArray (prefix' prefix.Length' currentKey' Math.Min (currentKey.Length' prefix.Length));  	if (result == 0) {  		result = BitArrayManipulation.CompareByteArray (key.Buffer' key.Offset' key.Length' currentKey' prefix.Length' currentKey.Length - prefix.Length);  	}  	if (result < 0) {  		right = middle;  	} else {  		left = middle + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,CreateOrUpdate,The following statement contains a magic number: if (ctx.Split) {  	ctx.Split = false;  	var newKeys = new byte[_children.Length][];  	var newChildren = new IBTreeNode[_children.Length + 1];  	var newPairCounts = new long[_children.Length + 1];  	Array.Copy (_keys' 0' newKeys' 0' index);  	newKeys [index] = ctx.Node2.GetLeftMostKey ();  	Array.Copy (_keys' index' newKeys' index + 1' _keys.Length - index);  	Array.Copy (_children' 0' newChildren' 0' index);  	newChildren [index] = ctx.Node1;  	newChildren [index + 1] = ctx.Node2;  	Array.Copy (_children' index + 1' newChildren' index + 2' _children.Length - index - 1);  	Array.Copy (_pairCounts' newPairCounts' index);  	var previousPairCount = index > 0 ? newPairCounts [index - 1] : 0;  	for (var i = index; i < newPairCounts.Length; i++) {  		previousPairCount += newChildren [i].CalcKeyCount ();  		newPairCounts [i] = previousPairCount;  	}  	ctx.Node1 = null;  	ctx.Node2 = null;  	if (_children.Length < MaxChildren) {  		if (TransactionId != ctx.TransactionId) {  			newBranch = new BTreeBranch (ctx.TransactionId' newKeys' newChildren' newPairCounts);  			ctx.Node1 = newBranch;  			ctx.Update = true;  		} else {  			_keys = newKeys;  			_children = newChildren;  			_pairCounts = newPairCounts;  		}  		if (ctx.SplitInRight)  			index++;  		ctx.Stack [ctx.Depth] = new NodeIdxPair {  			Node = newBranch'  			Idx = index  		};  		return;  	}  	if (ctx.SplitInRight)  		index++;  	ctx.Split = true;  	var keyCountLeft = (newChildren.Length + 1) / 2;  	var keyCountRight = newChildren.Length - keyCountLeft;  	var splitKeys = new byte[keyCountLeft - 1][];  	var splitChildren = new IBTreeNode[keyCountLeft];  	var splitPairCounts = new long[keyCountLeft];  	Array.Copy (newKeys' splitKeys' splitKeys.Length);  	Array.Copy (newChildren' splitChildren' splitChildren.Length);  	Array.Copy (newPairCounts' splitPairCounts' splitPairCounts.Length);  	ctx.Node1 = new BTreeBranch (ctx.TransactionId' splitKeys' splitChildren' splitPairCounts);  	splitKeys = new byte[keyCountRight - 1][];  	splitChildren = new IBTreeNode[keyCountRight];  	splitPairCounts = new long[keyCountRight];  	Array.Copy (newKeys' keyCountLeft' splitKeys' 0' splitKeys.Length);  	Array.Copy (newChildren' keyCountLeft' splitChildren' 0' splitChildren.Length);  	for (int i = 0; i < splitPairCounts.Length; i++) {  		splitPairCounts [i] = newPairCounts [keyCountLeft + i] - newPairCounts [keyCountLeft - 1];  	}  	ctx.Node2 = new BTreeBranch (ctx.TransactionId' splitKeys' splitChildren' splitPairCounts);  	if (index < keyCountLeft) {  		ctx.Stack [ctx.Depth] = new NodeIdxPair {  			Node = ctx.Node1'  			Idx = index  		};  		ctx.SplitInRight = false;  	} else {  		ctx.Stack [ctx.Depth] = new NodeIdxPair {  			Node = ctx.Node2'  			Idx = index - keyCountLeft  		};  		ctx.SplitInRight = true;  	}  	return;  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,CreateOrUpdate,The following statement contains a magic number: if (ctx.Split) {  	ctx.Split = false;  	var newKeys = new byte[_children.Length][];  	var newChildren = new IBTreeNode[_children.Length + 1];  	var newPairCounts = new long[_children.Length + 1];  	Array.Copy (_keys' 0' newKeys' 0' index);  	newKeys [index] = ctx.Node2.GetLeftMostKey ();  	Array.Copy (_keys' index' newKeys' index + 1' _keys.Length - index);  	Array.Copy (_children' 0' newChildren' 0' index);  	newChildren [index] = ctx.Node1;  	newChildren [index + 1] = ctx.Node2;  	Array.Copy (_children' index + 1' newChildren' index + 2' _children.Length - index - 1);  	Array.Copy (_pairCounts' newPairCounts' index);  	var previousPairCount = index > 0 ? newPairCounts [index - 1] : 0;  	for (var i = index; i < newPairCounts.Length; i++) {  		previousPairCount += newChildren [i].CalcKeyCount ();  		newPairCounts [i] = previousPairCount;  	}  	ctx.Node1 = null;  	ctx.Node2 = null;  	if (_children.Length < MaxChildren) {  		if (TransactionId != ctx.TransactionId) {  			newBranch = new BTreeBranch (ctx.TransactionId' newKeys' newChildren' newPairCounts);  			ctx.Node1 = newBranch;  			ctx.Update = true;  		} else {  			_keys = newKeys;  			_children = newChildren;  			_pairCounts = newPairCounts;  		}  		if (ctx.SplitInRight)  			index++;  		ctx.Stack [ctx.Depth] = new NodeIdxPair {  			Node = newBranch'  			Idx = index  		};  		return;  	}  	if (ctx.SplitInRight)  		index++;  	ctx.Split = true;  	var keyCountLeft = (newChildren.Length + 1) / 2;  	var keyCountRight = newChildren.Length - keyCountLeft;  	var splitKeys = new byte[keyCountLeft - 1][];  	var splitChildren = new IBTreeNode[keyCountLeft];  	var splitPairCounts = new long[keyCountLeft];  	Array.Copy (newKeys' splitKeys' splitKeys.Length);  	Array.Copy (newChildren' splitChildren' splitChildren.Length);  	Array.Copy (newPairCounts' splitPairCounts' splitPairCounts.Length);  	ctx.Node1 = new BTreeBranch (ctx.TransactionId' splitKeys' splitChildren' splitPairCounts);  	splitKeys = new byte[keyCountRight - 1][];  	splitChildren = new IBTreeNode[keyCountRight];  	splitPairCounts = new long[keyCountRight];  	Array.Copy (newKeys' keyCountLeft' splitKeys' 0' splitKeys.Length);  	Array.Copy (newChildren' keyCountLeft' splitChildren' 0' splitChildren.Length);  	for (int i = 0; i < splitPairCounts.Length; i++) {  		splitPairCounts [i] = newPairCounts [keyCountLeft + i] - newPairCounts [keyCountLeft - 1];  	}  	ctx.Node2 = new BTreeBranch (ctx.TransactionId' splitKeys' splitChildren' splitPairCounts);  	if (index < keyCountLeft) {  		ctx.Stack [ctx.Depth] = new NodeIdxPair {  			Node = ctx.Node1'  			Idx = index  		};  		ctx.SplitInRight = false;  	} else {  		ctx.Stack [ctx.Depth] = new NodeIdxPair {  			Node = ctx.Node2'  			Idx = index - keyCountLeft  		};  		ctx.SplitInRight = true;  	}  	return;  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,CreateOrUpdate,The following statement contains a magic number: Array.Copy (_children' index + 1' newChildren' index + 2' _children.Length - index - 1);  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,FillStackByIndex,The following statement contains a magic number: while (left < right) {  	var middle = (left + right) / 2;  	var currentIndex = _pairCounts [middle];  	if (keyIndex < currentIndex) {  		right = middle;  	} else {  		left = middle + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeBranch,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeBranch.cs,FindLastWithPrefix,The following statement contains a magic number: while (left < right) {  	var middle = (left + right) / 2;  	var currentKey = _keys [middle];  	var result = BitArrayManipulation.CompareByteArray (prefix' prefix.Length' currentKey' Math.Min (currentKey.Length' prefix.Length));  	if (result < 0) {  		right = middle;  	} else {  		left = middle + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,Find,The following statement contains a magic number: while (left < right) {  	var middle = (left + right) / 2;  	var currentKey = _keyvalues [middle].Key;  	var result = BitArrayManipulation.CompareByteArray (prefix' prefix.Length' currentKey' Math.Min (currentKey.Length' prefix.Length));  	if (result == 0) {  		result = BitArrayManipulation.CompareByteArray (key.Buffer' key.Offset' key.Length' currentKey' prefix.Length' currentKey.Length - prefix.Length);  		if (result == 0) {  			return middle * 2 + 1;  		}  	}  	if (result < 0) {  		right = middle;  	} else {  		left = middle + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,Find,The following statement contains a magic number: while (left < right) {  	var middle = (left + right) / 2;  	var currentKey = _keyvalues [middle].Key;  	var result = BitArrayManipulation.CompareByteArray (prefix' prefix.Length' currentKey' Math.Min (currentKey.Length' prefix.Length));  	if (result == 0) {  		result = BitArrayManipulation.CompareByteArray (key.Buffer' key.Offset' key.Length' currentKey' prefix.Length' currentKey.Length - prefix.Length);  		if (result == 0) {  			return middle * 2 + 1;  		}  	}  	if (result < 0) {  		right = middle;  	} else {  		left = middle + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,Find,The following statement contains a magic number: if (result == 0) {  	result = BitArrayManipulation.CompareByteArray (key.Buffer' key.Offset' key.Length' currentKey' prefix.Length' currentKey.Length - prefix.Length);  	if (result == 0) {  		return middle * 2 + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,Find,The following statement contains a magic number: if (result == 0) {  	return middle * 2 + 1;  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,Find,The following statement contains a magic number: return middle * 2 + 1;  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,Find,The following statement contains a magic number: return left * 2;  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,CreateOrUpdate,The following statement contains a magic number: if ((index & 1) == 1) {  	index = index / 2;  	ctx.Created = false;  	ctx.KeyIndex = index;  	var m = _keyvalues [index];  	m.Value = ctx.Value.ToByteArray ();  	var leaf = this;  	if (ctx.TransactionId != TransactionId) {  		leaf = new BTreeLeaf (ctx.TransactionId' _keyvalues.Length);  		Array.Copy (_keyvalues' leaf._keyvalues' _keyvalues.Length);  		ctx.Node1 = leaf;  		ctx.Update = true;  	}  	leaf._keyvalues [index] = m;  	ctx.Stack.Add (new NodeIdxPair {  		Node = leaf'  		Idx = index  	});  	return;  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,CreateOrUpdate,The following statement contains a magic number: index = index / 2;  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,CreateOrUpdate,The following statement contains a magic number: index = index / 2;  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,FindKey,The following statement contains a magic number: if ((idx & 1) == 1) {  	result = FindResult.Exact;  	idx = idx / 2;  } else {  	result = FindResult.Previous;  	idx = idx / 2 - 1;  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,FindKey,The following statement contains a magic number: if ((idx & 1) == 1) {  	result = FindResult.Exact;  	idx = idx / 2;  } else {  	result = FindResult.Previous;  	idx = idx / 2 - 1;  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,FindKey,The following statement contains a magic number: idx = idx / 2;  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,FindKey,The following statement contains a magic number: idx = idx / 2 - 1;  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeaf,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeaf.cs,FindLastWithPrefix,The following statement contains a magic number: while (left < right) {  	var middle = (left + right) / 2;  	currentKey = _keyvalues [middle].Key;  	result = BitArrayManipulation.CompareByteArray (prefix' prefix.Length' currentKey' Math.Min (currentKey.Length' prefix.Length));  	if (result < 0) {  		right = middle;  	} else {  		left = middle + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,Find,The following statement contains a magic number: while (left < right) {  	var middle = (left + right) / 2;  	int currentKeyOfs = _keyvalues [middle].KeyOffset;  	int currentKeyLen = _keyvalues [middle].KeyLength;  	var result = BitArrayManipulation.CompareByteArray (prefix' 0' prefix.Length' keyBytes' currentKeyOfs' Math.Min (currentKeyLen' prefix.Length));  	if (result == 0) {  		result = BitArrayManipulation.CompareByteArray (key.Buffer' key.Offset' key.Length' keyBytes' currentKeyOfs + prefix.Length' currentKeyLen - prefix.Length);  		if (result == 0) {  			return middle * 2 + 1;  		}  	}  	if (result < 0) {  		right = middle;  	} else {  		left = middle + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,Find,The following statement contains a magic number: while (left < right) {  	var middle = (left + right) / 2;  	int currentKeyOfs = _keyvalues [middle].KeyOffset;  	int currentKeyLen = _keyvalues [middle].KeyLength;  	var result = BitArrayManipulation.CompareByteArray (prefix' 0' prefix.Length' keyBytes' currentKeyOfs' Math.Min (currentKeyLen' prefix.Length));  	if (result == 0) {  		result = BitArrayManipulation.CompareByteArray (key.Buffer' key.Offset' key.Length' keyBytes' currentKeyOfs + prefix.Length' currentKeyLen - prefix.Length);  		if (result == 0) {  			return middle * 2 + 1;  		}  	}  	if (result < 0) {  		right = middle;  	} else {  		left = middle + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,Find,The following statement contains a magic number: if (result == 0) {  	result = BitArrayManipulation.CompareByteArray (key.Buffer' key.Offset' key.Length' keyBytes' currentKeyOfs + prefix.Length' currentKeyLen - prefix.Length);  	if (result == 0) {  		return middle * 2 + 1;  	}  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,Find,The following statement contains a magic number: if (result == 0) {  	return middle * 2 + 1;  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,Find,The following statement contains a magic number: return middle * 2 + 1;  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,Find,The following statement contains a magic number: return left * 2;  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,The following statement contains a magic number: if ((index & 1) == 1) {  	index = index / 2;  	ctx.Created = false;  	ctx.KeyIndex = index;  	var m = _keyvalues [index];  	m.Value = ctx.Value.ToByteArray ();  	var leaf = this;  	if (ctx.TransactionId != TransactionId) {  		leaf = new BTreeLeafComp (ctx.TransactionId' _keyvalues.Length);  		Array.Copy (_keyvalues' leaf._keyvalues' _keyvalues.Length);  		leaf._keyBytes = _keyBytes;  		ctx.Node1 = leaf;  		ctx.Update = true;  	}  	leaf._keyvalues [index] = m;  	ctx.Stack.Add (new NodeIdxPair {  		Node = leaf'  		Idx = index  	});  	return;  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,The following statement contains a magic number: index = index / 2;  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,CreateOrUpdate,The following statement contains a magic number: index = index / 2;  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,FindKey,The following statement contains a magic number: if ((idx & 1) == 1) {  	result = FindResult.Exact;  	idx = idx / 2;  } else {  	result = FindResult.Previous;  	idx = idx / 2 - 1;  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,FindKey,The following statement contains a magic number: if ((idx & 1) == 1) {  	result = FindResult.Exact;  	idx = idx / 2;  } else {  	result = FindResult.Previous;  	idx = idx / 2 - 1;  }  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,FindKey,The following statement contains a magic number: idx = idx / 2;  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,FindKey,The following statement contains a magic number: idx = idx / 2 - 1;  
Magic Number,BTDB.KVDBLayer.BTreeMem,BTreeLeafComp,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\BTreeMem\BTreeLeafComp.cs,FindLastWithPrefix,The following statement contains a magic number: while (left < right) {  	var middle = (left + right) / 2;  	currentKeyOfs = _keyvalues [middle].KeyOffset;  	currentKeyLen = _keyvalues [middle].KeyLength;  	result = BitArrayManipulation.CompareByteArray (prefix' 0' prefix.Length' keyBytes' currentKeyOfs' Math.Min (currentKeyLen' prefix.Length));  	if (result < 0) {  		right = middle;  	} else {  		left = middle + 1;  	}  }  
Magic Number,BTDB.KVDBLayer,ChunkStorageInKV,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\ChunkStorageInKV.cs,CheckOrInitKeyLen,The following statement contains a magic number: if (_keyLen == -1) {  	if (keyLen != 20)  		throw new ArgumentException ("Length of Key must be 20 bytes");  	#pragma  	Interlocked.CompareExchange (ref _keyLen' keyLen' -1);  	#pragma  }  
Magic Number,BTDB.KVDBLayer,ChunkStorageInKV,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\ChunkStorageInKV.cs,CheckOrInitKeyLen,The following statement contains a magic number: if (_keyLen == -1) {  	if (keyLen != 20)  		throw new ArgumentException ("Length of Key must be 20 bytes");  	#pragma  	Interlocked.CompareExchange (ref _keyLen' keyLen' -1);  	#pragma  }  
Magic Number,BTDB.KVDBLayer,ChunkStorageInKV,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\ChunkStorageInKV.cs,CheckOrInitKeyLen,The following statement contains a magic number: if (_keyLen == -1) {  	if (keyLen != 20)  		throw new ArgumentException ("Length of Key must be 20 bytes");  	#pragma  	Interlocked.CompareExchange (ref _keyLen' keyLen' -1);  	#pragma  }  
Magic Number,BTDB.KVDBLayer,ChunkStorageInKV,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\ChunkStorageInKV.cs,CheckOrInitKeyLen,The following statement contains a magic number: if (keyLen != 20)  	throw new ArgumentException ("Length of Key must be 20 bytes");  
Magic Number,BTDB.KVDBLayer,Compactor,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,Run,The following statement contains a magic number: if (IsWasteSmall (totalWaste)) {  	if (_keyValueDB.DistanceFromLastKeyIndex (_root) > (ulong)(_keyValueDB.MaxTrLogFileSize / 4))  		_keyValueDB.CreateIndexFile (_cancellation);  	_keyValueDB.FileCollection.DeleteAllUnknownFiles ();  	return false;  }  
Magic Number,BTDB.KVDBLayer,Compactor,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,Run,The following statement contains a magic number: if (_keyValueDB.DistanceFromLastKeyIndex (_root) > (ulong)(_keyValueDB.MaxTrLogFileSize / 4))  	_keyValueDB.CreateIndexFile (_cancellation);  
Magic Number,BTDB.KVDBLayer,Compactor,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,Run,The following statement contains a magic number: return _newPositionMap.TryGetValue (((ulong)oldFileId << 32) | oldOffset' out newOffset);  
Magic Number,BTDB.KVDBLayer,Compactor,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,IsWasteSmall,The following statement contains a magic number: return totalWaste < (ulong)_keyValueDB.MaxTrLogFileSize / 4;  
Magic Number,BTDB.KVDBLayer,Compactor,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,MoveValuesContent,The following statement contains a magic number: _root.Iterate ((valueFileId' valueOfs' valueSize) => {  	if (valueFileId != wastefullFileId)  		return;  	var size = (uint)Math.Abs (valueSize);  	_newPositionMap.Add (((ulong)wastefullFileId << 32) | valueOfs' (uint)writer.GetCurrentPosition ());  	pos = valueOfs;  	while (size > 0) {  		_cancellation.ThrowIfCancellationRequested ();  		var blockId = pos / blockSize;  		var blockStart = pos % blockSize;  		var writeSize = (uint)(blockSize - blockStart);  		if (writeSize > size)  			writeSize = size;  		writer.WriteBlock (wasteInMemory [blockId]' (int)blockStart' (int)writeSize);  		size -= writeSize;  		pos += writeSize;  	}  });  
Magic Number,BTDB.KVDBLayer,Compactor,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,MoveValuesContent,The following statement contains a magic number: _newPositionMap.Add (((ulong)wastefullFileId << 32) | valueOfs' (uint)writer.GetCurrentPosition ());  
Magic Number,BTDB.KVDBLayer,Compactor,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,CalcTotalWaste,The following statement contains a magic number: foreach (var fileStat in _fileStats) {  	var waste = fileStat.CalcWasteUptodate ();  	if (waste > 1024)  		total += waste;  }  
Magic Number,BTDB.KVDBLayer,Compactor,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\Compactor.cs,CalcTotalWaste,The following statement contains a magic number: if (waste > 1024)  	total += waste;  
Magic Number,BTDB.KVDBLayer,CompactorScheduler,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\CompactorScheduler.cs,CompactorScheduler,The following statement contains a magic number: WaitTime = TimeSpan.FromMinutes (10 + new Random ().NextDouble () * 5);  
Magic Number,BTDB.KVDBLayer,CompactorScheduler,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\CompactorScheduler.cs,CompactorScheduler,The following statement contains a magic number: WaitTime = TimeSpan.FromMinutes (10 + new Random ().NextDouble () * 5);  
Magic Number,BTDB.KVDBLayer,SnappyCompressionStrategy,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\SnappyCompressionStrategy.cs,ShouldTryToCompressKey,The following statement contains a magic number: return length > 1024;  
Magic Number,BTDB.KVDBLayer,SnappyCompressionStrategy,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\SnappyCompressionStrategy.cs,CompressKey,The following statement contains a magic number: return SnappyCompress.TryCompress (ref data' 80);  
Magic Number,BTDB.KVDBLayer,SnappyCompressionStrategy,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\SnappyCompressionStrategy.cs,CompressValue,The following statement contains a magic number: if (data.Length < 32)  	return false;  
Magic Number,BTDB.KVDBLayer,SnappyCompressionStrategy,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\SnappyCompressionStrategy.cs,CompressValue,The following statement contains a magic number: return SnappyCompress.TryCompress (ref data' 80);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,KeyValueDB,The following statement contains a magic number: if (fileSplitSize < 1024 || fileSplitSize > int.MaxValue)  	throw new ArgumentOutOfRangeException (nameof (fileSplitSize)' "Allowed range 1024 - 2G");  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: switch (valueLen) {  case 0:  	valueOfs = 0;  	valueSize = 0;  	break;  case 1:  	valueOfs = 0;  	valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  	break;  case 2:  	valueOfs = 0;  	valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  	break;  case 3:  	valueOfs = 0;  	valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 4:  	valueOfs = inlineValueBuf [ofs + 3];  	valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 5:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  	valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 6:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  	valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  case 7:  	valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  	valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueSize = 0x1000000 | (inlineValueBuf [ofs] << 16);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueSize = 0x2000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueSize = 0x3000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueOfs = inlineValueBuf [ofs + 3];  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueSize = 0x4000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueSize = 0x5000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueSize = 0x6000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueOfs = inlineValueBuf [ofs + 3] | ((uint)inlineValueBuf [ofs + 4] << 8) | ((uint)inlineValueBuf [ofs + 5] << 16) | (((uint)inlineValueBuf [ofs + 6]) << 24);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,StoreValueInlineInMemory,The following statement contains a magic number: valueSize = 0x7000000 | (inlineValueBuf [ofs] << 16) | (inlineValueBuf [ofs + 1] << 8) | inlineValueBuf [ofs + 2];  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,WriteCreateOrUpdateCommand,The following statement contains a magic number: if (_writerWithTransactionLog.GetCurrentPosition () + prefix.Length + key.Length + 16 > MaxTrLogFileSize) {  	WriteStartOfNewTransactionLogFile ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,CalcValueSize,The following statement contains a magic number: if (valueFileId == 0) {  	return (uint)(valueSize >> 24);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,CalcValueSize,The following statement contains a magic number: return (uint)(valueSize >> 24);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: if (valueFileId == 0) {  	var len = valueSize >> 24;  	var buf = new byte[len];  	switch (len) {  	case 7:  		buf [6] = (byte)(valueOfs >> 24);  		goto case 6;  	case 6:  		buf [5] = (byte)(valueOfs >> 16);  		goto case 5;  	case 5:  		buf [4] = (byte)(valueOfs >> 8);  		goto case 4;  	case 4:  		buf [3] = (byte)valueOfs;  		goto case 3;  	case 3:  		buf [2] = (byte)valueSize;  		goto case 2;  	case 2:  		buf [1] = (byte)(valueSize >> 8);  		goto case 1;  	case 1:  		buf [0] = (byte)(valueSize >> 16);  		break;  	default:  		throw new BTDBException ("Corrupted DB");  	}  	return ByteBuffer.NewAsync (buf);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: switch (len) {  case 7:  	buf [6] = (byte)(valueOfs >> 24);  	goto case 6;  case 6:  	buf [5] = (byte)(valueOfs >> 16);  	goto case 5;  case 5:  	buf [4] = (byte)(valueOfs >> 8);  	goto case 4;  case 4:  	buf [3] = (byte)valueOfs;  	goto case 3;  case 3:  	buf [2] = (byte)valueSize;  	goto case 2;  case 2:  	buf [1] = (byte)(valueSize >> 8);  	goto case 1;  case 1:  	buf [0] = (byte)(valueSize >> 16);  	break;  default:  	throw new BTDBException ("Corrupted DB");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: buf [6] = (byte)(valueOfs >> 24);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: buf [6] = (byte)(valueOfs >> 24);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: goto case 6;  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: buf [5] = (byte)(valueOfs >> 16);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: buf [5] = (byte)(valueOfs >> 16);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: goto case 5;  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: buf [4] = (byte)(valueOfs >> 8);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: buf [4] = (byte)(valueOfs >> 8);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: goto case 4;  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: buf [3] = (byte)valueOfs;  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: goto case 3;  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: buf [2] = (byte)valueSize;  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: goto case 2;  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: buf [1] = (byte)(valueSize >> 8);  
Magic Number,BTDB.KVDBLayer,KeyValueDB,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Implementation\KeyValueDB.cs,ReadValue,The following statement contains a magic number: buf [0] = (byte)(valueSize >> 16);  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: tempbuf [2] = (byte)'D';  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: tempbuf [3] = (byte)'B';  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: tempbuf [4] = (byte)'E';  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: tempbuf [5] = (byte)'X';  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: tempbuf [6] = (byte)'P';  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: tempbuf [7] = (byte)'2';  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: PackUnpack.PackInt64LE (tempbuf' 8' keyValueCount);  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: stream.Write (tempbuf' 0' 16);  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: for (long kv = 0; kv < keyValueCount; kv++) {  	var key = transaction.GetKey ();  	PackUnpack.PackInt32LE (tempbuf' 0' key.Length);  	stream.Write (tempbuf' 0' 4);  	stream.Write (key.Buffer' key.Offset' key.Length);  	var value = transaction.GetValue ();  	PackUnpack.PackInt32LE (tempbuf' 0' value.Length);  	stream.Write (tempbuf' 0' 4);  	stream.Write (value.Buffer' value.Offset' value.Length);  	transaction.FindNextKey ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: for (long kv = 0; kv < keyValueCount; kv++) {  	var key = transaction.GetKey ();  	PackUnpack.PackInt32LE (tempbuf' 0' key.Length);  	stream.Write (tempbuf' 0' 4);  	stream.Write (key.Buffer' key.Offset' key.Length);  	var value = transaction.GetValue ();  	PackUnpack.PackInt32LE (tempbuf' 0' value.Length);  	stream.Write (tempbuf' 0' 4);  	stream.Write (value.Buffer' value.Offset' value.Length);  	transaction.FindNextKey ();  }  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: stream.Write (tempbuf' 0' 4);  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: stream.Write (tempbuf' 0' 4);  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: if (transaction.GetCommitUlong () != 0) {  	PackUnpack.PackUInt64LE (tempbuf' 0' transaction.GetCommitUlong ());  	stream.Write (tempbuf' 0' 8);  }  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Export,The following statement contains a magic number: stream.Write (tempbuf' 0' 8);  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (stream.Read (tempbuf' 0' 16) != 16)  	throw new EndOfStreamException ();  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (stream.Read (tempbuf' 0' 16) != 16)  	throw new EndOfStreamException ();  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (tempbuf [0] != 'B' || tempbuf [1] != 'T' || tempbuf [2] != 'D' || tempbuf [3] != 'B' || tempbuf [4] != 'E' || tempbuf [5] != 'X' || tempbuf [6] != 'P' || tempbuf [7] != '2') {  	throw new BTDBException ("Invalid header (it should Start with BTDBEXP2)");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (tempbuf [0] != 'B' || tempbuf [1] != 'T' || tempbuf [2] != 'D' || tempbuf [3] != 'B' || tempbuf [4] != 'E' || tempbuf [5] != 'X' || tempbuf [6] != 'P' || tempbuf [7] != '2') {  	throw new BTDBException ("Invalid header (it should Start with BTDBEXP2)");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (tempbuf [0] != 'B' || tempbuf [1] != 'T' || tempbuf [2] != 'D' || tempbuf [3] != 'B' || tempbuf [4] != 'E' || tempbuf [5] != 'X' || tempbuf [6] != 'P' || tempbuf [7] != '2') {  	throw new BTDBException ("Invalid header (it should Start with BTDBEXP2)");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (tempbuf [0] != 'B' || tempbuf [1] != 'T' || tempbuf [2] != 'D' || tempbuf [3] != 'B' || tempbuf [4] != 'E' || tempbuf [5] != 'X' || tempbuf [6] != 'P' || tempbuf [7] != '2') {  	throw new BTDBException ("Invalid header (it should Start with BTDBEXP2)");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (tempbuf [0] != 'B' || tempbuf [1] != 'T' || tempbuf [2] != 'D' || tempbuf [3] != 'B' || tempbuf [4] != 'E' || tempbuf [5] != 'X' || tempbuf [6] != 'P' || tempbuf [7] != '2') {  	throw new BTDBException ("Invalid header (it should Start with BTDBEXP2)");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (tempbuf [0] != 'B' || tempbuf [1] != 'T' || tempbuf [2] != 'D' || tempbuf [3] != 'B' || tempbuf [4] != 'E' || tempbuf [5] != 'X' || tempbuf [6] != 'P' || tempbuf [7] != '2') {  	throw new BTDBException ("Invalid header (it should Start with BTDBEXP2)");  }  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: for (var kv = 0; kv < keyValuePairs; kv++) {  	if (stream.Read (tempbuf' 0' 4) != 4)  		throw new EndOfStreamException ();  	var keySize = PackUnpack.UnpackInt32LE (tempbuf' 0);  	if (keySize < 0)  		throw new BTDBException ("Negative key size");  	if (keySize > tempbuf.Length)  		tempbuf = new byte[keySize];  	if (stream.Read (tempbuf' 0' keySize) != keySize)  		throw new EndOfStreamException ();  	if (stream.Read (tempbuf2' 0' 4) != 4)  		throw new EndOfStreamException ();  	var valueSize = PackUnpack.UnpackInt32LE (tempbuf2' 0);  	if (valueSize < 0)  		throw new BTDBException ("Negative value size");  	if (valueSize > tempbuf2.Length)  		tempbuf2 = new byte[valueSize];  	if (stream.Read (tempbuf2' 0' valueSize) != valueSize)  		throw new EndOfStreamException ();  	transaction.CreateOrUpdateKeyValue (ByteBuffer.NewSync (tempbuf' 0' keySize)' ByteBuffer.NewSync (tempbuf2' 0' valueSize));  }  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: for (var kv = 0; kv < keyValuePairs; kv++) {  	if (stream.Read (tempbuf' 0' 4) != 4)  		throw new EndOfStreamException ();  	var keySize = PackUnpack.UnpackInt32LE (tempbuf' 0);  	if (keySize < 0)  		throw new BTDBException ("Negative key size");  	if (keySize > tempbuf.Length)  		tempbuf = new byte[keySize];  	if (stream.Read (tempbuf' 0' keySize) != keySize)  		throw new EndOfStreamException ();  	if (stream.Read (tempbuf2' 0' 4) != 4)  		throw new EndOfStreamException ();  	var valueSize = PackUnpack.UnpackInt32LE (tempbuf2' 0);  	if (valueSize < 0)  		throw new BTDBException ("Negative value size");  	if (valueSize > tempbuf2.Length)  		tempbuf2 = new byte[valueSize];  	if (stream.Read (tempbuf2' 0' valueSize) != valueSize)  		throw new EndOfStreamException ();  	transaction.CreateOrUpdateKeyValue (ByteBuffer.NewSync (tempbuf' 0' keySize)' ByteBuffer.NewSync (tempbuf2' 0' valueSize));  }  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: for (var kv = 0; kv < keyValuePairs; kv++) {  	if (stream.Read (tempbuf' 0' 4) != 4)  		throw new EndOfStreamException ();  	var keySize = PackUnpack.UnpackInt32LE (tempbuf' 0);  	if (keySize < 0)  		throw new BTDBException ("Negative key size");  	if (keySize > tempbuf.Length)  		tempbuf = new byte[keySize];  	if (stream.Read (tempbuf' 0' keySize) != keySize)  		throw new EndOfStreamException ();  	if (stream.Read (tempbuf2' 0' 4) != 4)  		throw new EndOfStreamException ();  	var valueSize = PackUnpack.UnpackInt32LE (tempbuf2' 0);  	if (valueSize < 0)  		throw new BTDBException ("Negative value size");  	if (valueSize > tempbuf2.Length)  		tempbuf2 = new byte[valueSize];  	if (stream.Read (tempbuf2' 0' valueSize) != valueSize)  		throw new EndOfStreamException ();  	transaction.CreateOrUpdateKeyValue (ByteBuffer.NewSync (tempbuf' 0' keySize)' ByteBuffer.NewSync (tempbuf2' 0' valueSize));  }  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: for (var kv = 0; kv < keyValuePairs; kv++) {  	if (stream.Read (tempbuf' 0' 4) != 4)  		throw new EndOfStreamException ();  	var keySize = PackUnpack.UnpackInt32LE (tempbuf' 0);  	if (keySize < 0)  		throw new BTDBException ("Negative key size");  	if (keySize > tempbuf.Length)  		tempbuf = new byte[keySize];  	if (stream.Read (tempbuf' 0' keySize) != keySize)  		throw new EndOfStreamException ();  	if (stream.Read (tempbuf2' 0' 4) != 4)  		throw new EndOfStreamException ();  	var valueSize = PackUnpack.UnpackInt32LE (tempbuf2' 0);  	if (valueSize < 0)  		throw new BTDBException ("Negative value size");  	if (valueSize > tempbuf2.Length)  		tempbuf2 = new byte[valueSize];  	if (stream.Read (tempbuf2' 0' valueSize) != valueSize)  		throw new EndOfStreamException ();  	transaction.CreateOrUpdateKeyValue (ByteBuffer.NewSync (tempbuf' 0' keySize)' ByteBuffer.NewSync (tempbuf2' 0' valueSize));  }  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (stream.Read (tempbuf' 0' 4) != 4)  	throw new EndOfStreamException ();  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (stream.Read (tempbuf' 0' 4) != 4)  	throw new EndOfStreamException ();  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (stream.Read (tempbuf2' 0' 4) != 4)  	throw new EndOfStreamException ();  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (stream.Read (tempbuf2' 0' 4) != 4)  	throw new EndOfStreamException ();  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (stream.Read (tempbuf' 0' 8) == 8) {  	transaction.SetCommitUlong (PackUnpack.UnpackUInt64LE (tempbuf' 0));  }  
Magic Number,BTDB.KVDBLayer,KeyValueDBExportImporter,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\KeyValueDBExportImporter.cs,Import,The following statement contains a magic number: if (stream.Read (tempbuf' 0' 8) == 8) {  	transaction.SetCommitUlong (PackUnpack.UnpackUInt64LE (tempbuf' 0));  }  
Magic Number,BTDB.KVDBLayer,PtrLenList,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,FindFreeSizeAfter,The following statement contains a magic number: while (l < r) {  	uint m = (l + r) / 2;  	cur = _list [m];  	if (pos < cur.Key) {  		r = m;  	} else if (cur.Key + cur.Value <= pos) {  		l = m + 1;  	} else {  		pos = cur.Key + cur.Value;  		l = m + 1;  		break;  	}  }  
Magic Number,BTDB.KVDBLayer,PtrLenList,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryExclude,The following statement contains a magic number: while (l < r) {  	uint m = (l + r) / 2;  	cur = _list [m];  	if (excludePos < cur.Key) {  		r = m;  	} else if (cur.Key + cur.Value <= excludePos) {  		l = m + 1;  	} else {  		if (excludePos == cur.Key) {  			if (excludePos + excludeLen < cur.Key + cur.Value) {  				_list [m] = new KeyValuePair<ulong' ulong> (excludePos + excludeLen' cur.Value - excludeLen);  				return true;  			}  			if (excludePos + excludeLen == cur.Key + cur.Value) {  				_size--;  				Array.Copy (_list' m + 1' _list' m' _size - m);  				return true;  			}  			r = m + 1;  			while (r < _size && excludePos + excludeLen > _list [r].Key) {  				r++;  			}  			cur = _list [r - 1];  			if (excludePos + excludeLen < cur.Key + cur.Value) {  				r--;  				_list [r] = new KeyValuePair<ulong' ulong> (excludePos + excludeLen' cur.Key - excludePos + cur.Value - excludeLen);  			}  			Array.Copy (_list' r' _list' m' _size - r);  			_size -= r - m;  			return false;  		}  		if (excludePos + excludeLen == cur.Key + cur.Value) {  			_list [m] = new KeyValuePair<ulong' ulong> (cur.Key' excludePos - cur.Key);  			return true;  		}  		if (excludePos + excludeLen < cur.Key + cur.Value) {  			GrowIfNeeded ();  			Array.Copy (_list' m + 1' _list' m + 2' _size - m - 1);  			_size++;  			_list [m] = new KeyValuePair<ulong' ulong> (cur.Key' excludePos - cur.Key);  			_list [m + 1] = new KeyValuePair<ulong' ulong> (excludePos + excludeLen' cur.Key + cur.Value - excludePos - excludeLen);  			return true;  		}  		_list [m] = new KeyValuePair<ulong' ulong> (cur.Key' excludePos - cur.Key);  		l = m + 1;  		break;  	}  }  
Magic Number,BTDB.KVDBLayer,PtrLenList,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryExclude,The following statement contains a magic number: while (l < r) {  	uint m = (l + r) / 2;  	cur = _list [m];  	if (excludePos < cur.Key) {  		r = m;  	} else if (cur.Key + cur.Value <= excludePos) {  		l = m + 1;  	} else {  		if (excludePos == cur.Key) {  			if (excludePos + excludeLen < cur.Key + cur.Value) {  				_list [m] = new KeyValuePair<ulong' ulong> (excludePos + excludeLen' cur.Value - excludeLen);  				return true;  			}  			if (excludePos + excludeLen == cur.Key + cur.Value) {  				_size--;  				Array.Copy (_list' m + 1' _list' m' _size - m);  				return true;  			}  			r = m + 1;  			while (r < _size && excludePos + excludeLen > _list [r].Key) {  				r++;  			}  			cur = _list [r - 1];  			if (excludePos + excludeLen < cur.Key + cur.Value) {  				r--;  				_list [r] = new KeyValuePair<ulong' ulong> (excludePos + excludeLen' cur.Key - excludePos + cur.Value - excludeLen);  			}  			Array.Copy (_list' r' _list' m' _size - r);  			_size -= r - m;  			return false;  		}  		if (excludePos + excludeLen == cur.Key + cur.Value) {  			_list [m] = new KeyValuePair<ulong' ulong> (cur.Key' excludePos - cur.Key);  			return true;  		}  		if (excludePos + excludeLen < cur.Key + cur.Value) {  			GrowIfNeeded ();  			Array.Copy (_list' m + 1' _list' m + 2' _size - m - 1);  			_size++;  			_list [m] = new KeyValuePair<ulong' ulong> (cur.Key' excludePos - cur.Key);  			_list [m + 1] = new KeyValuePair<ulong' ulong> (excludePos + excludeLen' cur.Key + cur.Value - excludePos - excludeLen);  			return true;  		}  		_list [m] = new KeyValuePair<ulong' ulong> (cur.Key' excludePos - cur.Key);  		l = m + 1;  		break;  	}  }  
Magic Number,BTDB.KVDBLayer,PtrLenList,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryExclude,The following statement contains a magic number: if (excludePos < cur.Key) {  	r = m;  } else if (cur.Key + cur.Value <= excludePos) {  	l = m + 1;  } else {  	if (excludePos == cur.Key) {  		if (excludePos + excludeLen < cur.Key + cur.Value) {  			_list [m] = new KeyValuePair<ulong' ulong> (excludePos + excludeLen' cur.Value - excludeLen);  			return true;  		}  		if (excludePos + excludeLen == cur.Key + cur.Value) {  			_size--;  			Array.Copy (_list' m + 1' _list' m' _size - m);  			return true;  		}  		r = m + 1;  		while (r < _size && excludePos + excludeLen > _list [r].Key) {  			r++;  		}  		cur = _list [r - 1];  		if (excludePos + excludeLen < cur.Key + cur.Value) {  			r--;  			_list [r] = new KeyValuePair<ulong' ulong> (excludePos + excludeLen' cur.Key - excludePos + cur.Value - excludeLen);  		}  		Array.Copy (_list' r' _list' m' _size - r);  		_size -= r - m;  		return false;  	}  	if (excludePos + excludeLen == cur.Key + cur.Value) {  		_list [m] = new KeyValuePair<ulong' ulong> (cur.Key' excludePos - cur.Key);  		return true;  	}  	if (excludePos + excludeLen < cur.Key + cur.Value) {  		GrowIfNeeded ();  		Array.Copy (_list' m + 1' _list' m + 2' _size - m - 1);  		_size++;  		_list [m] = new KeyValuePair<ulong' ulong> (cur.Key' excludePos - cur.Key);  		_list [m + 1] = new KeyValuePair<ulong' ulong> (excludePos + excludeLen' cur.Key + cur.Value - excludePos - excludeLen);  		return true;  	}  	_list [m] = new KeyValuePair<ulong' ulong> (cur.Key' excludePos - cur.Key);  	l = m + 1;  	break;  }  
Magic Number,BTDB.KVDBLayer,PtrLenList,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryExclude,The following statement contains a magic number: if (cur.Key + cur.Value <= excludePos) {  	l = m + 1;  } else {  	if (excludePos == cur.Key) {  		if (excludePos + excludeLen < cur.Key + cur.Value) {  			_list [m] = new KeyValuePair<ulong' ulong> (excludePos + excludeLen' cur.Value - excludeLen);  			return true;  		}  		if (excludePos + excludeLen == cur.Key + cur.Value) {  			_size--;  			Array.Copy (_list' m + 1' _list' m' _size - m);  			return true;  		}  		r = m + 1;  		while (r < _size && excludePos + excludeLen > _list [r].Key) {  			r++;  		}  		cur = _list [r - 1];  		if (excludePos + excludeLen < cur.Key + cur.Value) {  			r--;  			_list [r] = new KeyValuePair<ulong' ulong> (excludePos + excludeLen' cur.Key - excludePos + cur.Value - excludeLen);  		}  		Array.Copy (_list' r' _list' m' _size - r);  		_size -= r - m;  		return false;  	}  	if (excludePos + excludeLen == cur.Key + cur.Value) {  		_list [m] = new KeyValuePair<ulong' ulong> (cur.Key' excludePos - cur.Key);  		return true;  	}  	if (excludePos + excludeLen < cur.Key + cur.Value) {  		GrowIfNeeded ();  		Array.Copy (_list' m + 1' _list' m + 2' _size - m - 1);  		_size++;  		_list [m] = new KeyValuePair<ulong' ulong> (cur.Key' excludePos - cur.Key);  		_list [m + 1] = new KeyValuePair<ulong' ulong> (excludePos + excludeLen' cur.Key + cur.Value - excludePos - excludeLen);  		return true;  	}  	_list [m] = new KeyValuePair<ulong' ulong> (cur.Key' excludePos - cur.Key);  	l = m + 1;  	break;  }  
Magic Number,BTDB.KVDBLayer,PtrLenList,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryExclude,The following statement contains a magic number: if (excludePos + excludeLen < cur.Key + cur.Value) {  	GrowIfNeeded ();  	Array.Copy (_list' m + 1' _list' m + 2' _size - m - 1);  	_size++;  	_list [m] = new KeyValuePair<ulong' ulong> (cur.Key' excludePos - cur.Key);  	_list [m + 1] = new KeyValuePair<ulong' ulong> (excludePos + excludeLen' cur.Key + cur.Value - excludePos - excludeLen);  	return true;  }  
Magic Number,BTDB.KVDBLayer,PtrLenList,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryExclude,The following statement contains a magic number: Array.Copy (_list' m + 1' _list' m + 2' _size - m - 1);  
Magic Number,BTDB.KVDBLayer,PtrLenList,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryInclude,The following statement contains a magic number: if (_list == null) {  	_list = new KeyValuePair<ulong' ulong>[4];  	_size = 1;  	_list [0] = new KeyValuePair<ulong' ulong> (includePos' includeLen);  	return true;  }  
Magic Number,BTDB.KVDBLayer,PtrLenList,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryInclude,The following statement contains a magic number: _list = new KeyValuePair<ulong' ulong>[4];  
Magic Number,BTDB.KVDBLayer,PtrLenList,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,TryInclude,The following statement contains a magic number: while (l < r) {  	uint m = (l + r) / 2;  	cur = _list [m];  	if (includePos < cur.Key) {  		r = m;  	} else if (cur.Key + cur.Value < includePos) {  		l = m + 1;  	} else {  		if (includePos + includeLen <= cur.Key + cur.Value) {  			return false;  		}  		bool result = true;  		l = m + 1;  		if (includePos < cur.Key + cur.Value)  			result = false;  		else {  			if (l < _size && includePos + includeLen > _list [l].Key) {  				l++;  				result = false;  			}  		}  		while (l < _size && includePos + includeLen >= _list [l].Key) {  			l++;  		}  		var lastOk = _list [l - 1];  		_list [m] = new KeyValuePair<ulong' ulong> (cur.Key' Math.Max (lastOk.Key + lastOk.Value' includePos + includeLen) - cur.Key);  		Array.Copy (_list' l' _list' m + 1' _size - l);  		_size -= l - (m + 1);  		return result;  	}  }  
Magic Number,BTDB.KVDBLayer,PtrLenList,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,Contains,The following statement contains a magic number: while (l < r) {  	uint m = (l + r) / 2;  	var cur = _list [m];  	if (position < cur.Key) {  		r = m;  	} else if (cur.Key + cur.Value <= position) {  		l = m + 1;  	} else {  		return true;  	}  }  
Magic Number,BTDB.KVDBLayer,PtrLenList,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,GrowIfNeeded,The following statement contains a magic number: if (_size == _list.Length) {  	Array.Resize (ref _list' (int)_size * 2);  }  
Magic Number,BTDB.KVDBLayer,PtrLenList,F:\newReposMay17\Bobris_BTDB\BTDB\KVDBLayer\Helpers\PtrLenList.cs,GrowIfNeeded,The following statement contains a magic number: Array.Resize (ref _list' (int)_size * 2);  
Magic Number,BTDB.ODBLayer,InstanceRegistry,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\InstanceRegistry.cs,RegisterInstance,The following statement contains a magic number: do {  	current = _objects;  	if (current == null) {  		future = new[] {  			content  		};  		id = 0;  	} else {  		id = Array.IndexOf (current' content);  		if (id >= 0)  			return id;  		future = new object[current.Length + 1];  		Array.Copy (current' future' current.Length);  		id = current.Length;  		future [id] = content;  	}  	#pragma  } while (Interlocked.CompareExchange (ref _objects' future' current) != current);  
Magic Number,BTDB.ODBLayer,ODBDictionary,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,FreeContent,The following statement contains a magic number: if (config.FreeContent == null) {  	var method = ILBuilder.Instance.NewMethod<Action<IInternalObjectDBTransaction' AbstractBufferedReader' IList<ulong>' IList<ulong>>> ();  	var ilGenerator = method.Generator;  	var readerLoc = ilGenerator.DeclareLocal (typeof(IReaderCtx));  	ilGenerator.Ldarg (0).Ldarg (1).Ldarg (2).Ldarg (3).Newobj (() => new DBReaderWithFreeInfoCtx (null' null' null' null)).Stloc (readerLoc);  	Action<IILGen> readerOrCtx;  	if (_valueHandler.NeedsCtx ())  		readerOrCtx = il => il.Ldloc (readerLoc);  	else  		readerOrCtx = il => il.Ldarg (1);  	_valueHandler.FreeContent (ilGenerator' readerOrCtx);  	ilGenerator.Ret ();  	config.FreeContent = method.Create ();  }  
Magic Number,BTDB.ODBLayer,ODBDictionary,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,FreeContent,The following statement contains a magic number: if (config.FreeContent == null) {  	var method = ILBuilder.Instance.NewMethod<Action<IInternalObjectDBTransaction' AbstractBufferedReader' IList<ulong>' IList<ulong>>> ();  	var ilGenerator = method.Generator;  	var readerLoc = ilGenerator.DeclareLocal (typeof(IReaderCtx));  	ilGenerator.Ldarg (0).Ldarg (1).Ldarg (2).Ldarg (3).Newobj (() => new DBReaderWithFreeInfoCtx (null' null' null' null)).Stloc (readerLoc);  	Action<IILGen> readerOrCtx;  	if (_valueHandler.NeedsCtx ())  		readerOrCtx = il => il.Ldloc (readerLoc);  	else  		readerOrCtx = il => il.Ldarg (1);  	_valueHandler.FreeContent (ilGenerator' readerOrCtx);  	ilGenerator.Ret ();  	config.FreeContent = method.Create ();  }  
Magic Number,BTDB.ODBLayer,ODBDictionary,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,FreeContent,The following statement contains a magic number: ilGenerator.Ldarg (0).Ldarg (1).Ldarg (2).Ldarg (3).Newobj (() => new DBReaderWithFreeInfoCtx (null' null' null' null)).Stloc (readerLoc);  
Magic Number,BTDB.ODBLayer,ODBDictionary,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ODBDictionary.cs,FreeContent,The following statement contains a magic number: ilGenerator.Ldarg (0).Ldarg (1).Ldarg (2).Ldarg (3).Newobj (() => new DBReaderWithFreeInfoCtx (null' null' null' null)).Stloc (readerLoc);  
Magic Number,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The following statement contains a magic number: il.Ldarg (0).Ldarg (1).Ldarg (2).Call (relationDBManipulatorType.GetConstructor (new[] {  	typeof(IObjectDBTransaction)'  	typeof(RelationInfo)  })).Ret ();  
Magic Number,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The following statement contains a magic number: foreach (var method in methods) {  	if (method.Name.StartsWith ("get_") || method.Name.StartsWith ("set_"))  		continue;  	var reqMethod = classImpl.DefineMethod ("_R_" + method.Name' method.ReturnType' method.GetParameters ().Select (pi => pi.ParameterType).ToArray ()' MethodAttributes.Virtual | MethodAttributes.Public);  	if (method.Name.StartsWith ("RemoveBy") || method.Name.StartsWith ("FindBy") || method.Name == "Contains") {  		SaveKeyBytesAndCallMethod (reqMethod.Generator' relationDBManipulatorType' method.Name' method.GetParameters ()' method.ReturnType' _relationInfo.ApartFields);  	} else if (method.Name == "ListById")//list by primary key  	 {  		var parameters = method.GetParameters ();  		var advEnumParamOrder = (ushort)parameters.Length;  		var advEnumParam = parameters [advEnumParamOrder - 1].ParameterType;  		var advEnumParamType = advEnumParam.GenericTypeArguments [0];  		var emptyBufferLoc = reqMethod.Generator.DeclareLocal (typeof(ByteBuffer));  		var prefixParamCount = method.GetParameters ().Length - 1;  		var field = _relationInfo.ClientRelationVersionInfo.GetPrimaryKeyFields ().Skip (_relationInfo.ApartFields.Count + prefixParamCount).First ();  		reqMethod.Generator.Ldarg (0);  		SavePKListPrefixBytes (reqMethod.Generator' method.Name' method.GetParameters ()' _relationInfo.ApartFields);  		reqMethod.Generator.LdcI4 (prefixParamCount + _relationInfo.ApartFields.Count).Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("Order")).Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("StartProposition"));  		FillBufferWhenNotIgnoredKeyPropositionIl (advEnumParamOrder' field' emptyBufferLoc' advEnumParam.GetField ("Start")' reqMethod.Generator);  		reqMethod.Generator.Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("EndProposition"));  		FillBufferWhenNotIgnoredKeyPropositionIl (advEnumParamOrder' field' emptyBufferLoc' advEnumParam.GetField ("End")' reqMethod.Generator);  		if (typeof(IEnumerator<>).MakeGenericType (_relationInfo.ClientType).IsAssignableFrom (method.ReturnType)) {  			//return new RelationAdvancedEnumerator<T>(relationManipulator'  			//    prefixBytes' prefixFieldCount'  			//    order'  			//    startKeyProposition' startKeyBytes'  			//    endKeyProposition' endKeyBytes' secondaryKeyIndex);  			var enumType = typeof(RelationAdvancedEnumerator<>).MakeGenericType (_relationInfo.ClientType);  			var advancedEnumeratorCtor = enumType.GetConstructors () [0];  			reqMethod.Generator.Newobj (advancedEnumeratorCtor);  		} else if (typeof(IOrderedDictionaryEnumerator<' >).MakeGenericType (advEnumParamType' _relationInfo.ClientType).IsAssignableFrom (method.ReturnType)) {  			reqMethod.Generator.LdcI4 (1);  			//init key reader  			//return new RelationAdvancedOrderedEnumerator<T>(relationManipulator'  			//    prefixBytes' prefixFieldCount'  			//    order'  			//    startKeyProposition' startKeyBytes'  			//    endKeyProposition' endKeyBytes' secondaryKeyIndex' initKeyReader);  			var enumType = typeof(RelationAdvancedOrderedEnumerator<' >).MakeGenericType (advEnumParamType' _relationInfo.ClientType);  			var advancedEnumeratorCtor = enumType.GetConstructors () [0];  			reqMethod.Generator.Newobj (advancedEnumeratorCtor);  		} else {  			throw new BTDBException ("Invalid method " + method.Name);  		}  	} else if (method.Name.StartsWith ("ListBy"' StringComparison.Ordinal))//ListBy{Name}(tenantId' ..' AdvancedEnumeratorParam)  	 {  		var parameters = method.GetParameters ();  		var advEnumParamOrder = (ushort)parameters.Length;  		var advEnumParam = parameters [advEnumParamOrder - 1].ParameterType;  		var advEnumParamType = advEnumParam.GenericTypeArguments [0];  		var emptyBufferLoc = reqMethod.Generator.DeclareLocal (typeof(ByteBuffer));  		var secondaryKeyIndex = _relationInfo.ClientRelationVersionInfo.GetSecondaryKeyIndex (method.Name.Substring (6));  		var prefixParamCount = method.GetParameters ().Length - 1;  		var field = _relationInfo.ClientRelationVersionInfo.GetSecondaryKeyFields (secondaryKeyIndex).Skip (_relationInfo.ApartFields.Count + prefixParamCount).First ();  		reqMethod.Generator.Ldarg (0);  		SaveListPrefixBytes (secondaryKeyIndex' reqMethod.Generator' method.Name' method.GetParameters ()' _relationInfo.ApartFields);  		reqMethod.Generator.LdcI4 (prefixParamCount + _relationInfo.ApartFields.Count).Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("Order")).Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("StartProposition"));  		FillBufferWhenNotIgnoredKeyPropositionIl (advEnumParamOrder' field' emptyBufferLoc' advEnumParam.GetField ("Start")' reqMethod.Generator);  		reqMethod.Generator.Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("EndProposition"));  		FillBufferWhenNotIgnoredKeyPropositionIl (advEnumParamOrder' field' emptyBufferLoc' advEnumParam.GetField ("End")' reqMethod.Generator);  		reqMethod.Generator.LdcI4 ((int)secondaryKeyIndex);  		if (typeof(IEnumerator<>).MakeGenericType (_relationInfo.ClientType).IsAssignableFrom (method.ReturnType)) {  			//return new RelationAdvancedSecondaryKeyEnumerator<T>(relationManipulator'  			//    prefixBytes' prefixFieldCount'  			//    order'  			//    startKeyProposition' startKeyBytes'  			//    endKeyProposition' endKeyBytes' secondaryKeyIndex);  			var enumType = typeof(RelationAdvancedSecondaryKeyEnumerator<>).MakeGenericType (_relationInfo.ClientType);  			var advancedEnumeratorCtor = enumType.GetConstructors () [0];  			reqMethod.Generator.Newobj (advancedEnumeratorCtor);  		} else if (typeof(IOrderedDictionaryEnumerator<' >).MakeGenericType (advEnumParamType' _relationInfo.ClientType).IsAssignableFrom (method.ReturnType)) {  			//return new RelationAdvancedOrderedSecondaryKeyEnumerator<T>(relationManipulator'  			//    prefixBytes' prefixFieldCount'  			//    order'  			//    startKeyProposition' startKeyBytes'  			//    endKeyProposition' endKeyBytes' secondaryKeyIndex);  			var enumType = typeof(RelationAdvancedOrderedSecondaryKeyEnumerator<' >).MakeGenericType (advEnumParamType' _relationInfo.ClientType);  			var advancedEnumeratorCtor = enumType.GetConstructors () [0];  			reqMethod.Generator.Newobj (advancedEnumeratorCtor);  		} else {  			throw new BTDBException ("Invalid method " + method.Name);  		}  	} else if (method.Name == "Insert") {  		var methodInfo = relationDBManipulatorType.GetMethod (method.Name);  		bool returningBoolVariant;  		var returnType = method.ReturnType;  		if (returnType == typeof(void))  			returningBoolVariant = false;  		else if (returnType == typeof(bool))  			returningBoolVariant = true;  		else  			throw new BTDBException ("Method Insert should be defined with void or bool return type.");  		var methodParams = method.GetParameters ();  		CheckParameterCount (method.Name' 1' methodParams.Length);  		CheckParameterType (method.Name' 0' methodInfo.GetParameters () [0].ParameterType' methodParams [0].ParameterType);  		reqMethod.Generator.Ldarg (0)//this  		.Ldarg (1).Callvirt (methodInfo);  		if (!returningBoolVariant) {  			var returnedTrueLabel = reqMethod.Generator.DefineLabel ("returnedTrueLabel");  			reqMethod.Generator.Brtrue (returnedTrueLabel).Ldstr ("Trying to insert duplicate key.").Newobj (() => new BTDBException (null)).Throw ().Mark (returnedTrueLabel);  		}  	} else//call the same method name with the same parameters  	 {  		var methodParams = method.GetParameters ();  		int paramCount = methodParams.Length;  		var methodInfo = relationDBManipulatorType.GetMethod (method.Name);  		if (methodInfo == null)  			throw new BTDBException ();  		CheckReturnType (method.Name' methodInfo.ReturnType' method.ReturnType);  		var calledMethodParams = methodInfo.GetParameters ();  		CheckParameterCount (method.Name' calledMethodParams.Length' methodParams.Length);  		for (int i = 0; i < methodParams.Length; i++) {  			CheckParameterType (method.Name' i' calledMethodParams [i].ParameterType' methodParams [i].ParameterType);  		}  		for (ushort i = 0; i <= paramCount; i++)  			reqMethod.Generator.Ldarg (i);  		reqMethod.Generator.Callvirt (methodInfo);  	}  	reqMethod.Generator.Ret ();  	classImpl.DefineMethodOverride (reqMethod' method);  }  
Magic Number,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The following statement contains a magic number: if (method.Name.StartsWith ("RemoveBy") || method.Name.StartsWith ("FindBy") || method.Name == "Contains") {  	SaveKeyBytesAndCallMethod (reqMethod.Generator' relationDBManipulatorType' method.Name' method.GetParameters ()' method.ReturnType' _relationInfo.ApartFields);  } else if (method.Name == "ListById")//list by primary key   {  	var parameters = method.GetParameters ();  	var advEnumParamOrder = (ushort)parameters.Length;  	var advEnumParam = parameters [advEnumParamOrder - 1].ParameterType;  	var advEnumParamType = advEnumParam.GenericTypeArguments [0];  	var emptyBufferLoc = reqMethod.Generator.DeclareLocal (typeof(ByteBuffer));  	var prefixParamCount = method.GetParameters ().Length - 1;  	var field = _relationInfo.ClientRelationVersionInfo.GetPrimaryKeyFields ().Skip (_relationInfo.ApartFields.Count + prefixParamCount).First ();  	reqMethod.Generator.Ldarg (0);  	SavePKListPrefixBytes (reqMethod.Generator' method.Name' method.GetParameters ()' _relationInfo.ApartFields);  	reqMethod.Generator.LdcI4 (prefixParamCount + _relationInfo.ApartFields.Count).Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("Order")).Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("StartProposition"));  	FillBufferWhenNotIgnoredKeyPropositionIl (advEnumParamOrder' field' emptyBufferLoc' advEnumParam.GetField ("Start")' reqMethod.Generator);  	reqMethod.Generator.Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("EndProposition"));  	FillBufferWhenNotIgnoredKeyPropositionIl (advEnumParamOrder' field' emptyBufferLoc' advEnumParam.GetField ("End")' reqMethod.Generator);  	if (typeof(IEnumerator<>).MakeGenericType (_relationInfo.ClientType).IsAssignableFrom (method.ReturnType)) {  		//return new RelationAdvancedEnumerator<T>(relationManipulator'  		//    prefixBytes' prefixFieldCount'  		//    order'  		//    startKeyProposition' startKeyBytes'  		//    endKeyProposition' endKeyBytes' secondaryKeyIndex);  		var enumType = typeof(RelationAdvancedEnumerator<>).MakeGenericType (_relationInfo.ClientType);  		var advancedEnumeratorCtor = enumType.GetConstructors () [0];  		reqMethod.Generator.Newobj (advancedEnumeratorCtor);  	} else if (typeof(IOrderedDictionaryEnumerator<' >).MakeGenericType (advEnumParamType' _relationInfo.ClientType).IsAssignableFrom (method.ReturnType)) {  		reqMethod.Generator.LdcI4 (1);  		//init key reader  		//return new RelationAdvancedOrderedEnumerator<T>(relationManipulator'  		//    prefixBytes' prefixFieldCount'  		//    order'  		//    startKeyProposition' startKeyBytes'  		//    endKeyProposition' endKeyBytes' secondaryKeyIndex' initKeyReader);  		var enumType = typeof(RelationAdvancedOrderedEnumerator<' >).MakeGenericType (advEnumParamType' _relationInfo.ClientType);  		var advancedEnumeratorCtor = enumType.GetConstructors () [0];  		reqMethod.Generator.Newobj (advancedEnumeratorCtor);  	} else {  		throw new BTDBException ("Invalid method " + method.Name);  	}  } else if (method.Name.StartsWith ("ListBy"' StringComparison.Ordinal))//ListBy{Name}(tenantId' ..' AdvancedEnumeratorParam)   {  	var parameters = method.GetParameters ();  	var advEnumParamOrder = (ushort)parameters.Length;  	var advEnumParam = parameters [advEnumParamOrder - 1].ParameterType;  	var advEnumParamType = advEnumParam.GenericTypeArguments [0];  	var emptyBufferLoc = reqMethod.Generator.DeclareLocal (typeof(ByteBuffer));  	var secondaryKeyIndex = _relationInfo.ClientRelationVersionInfo.GetSecondaryKeyIndex (method.Name.Substring (6));  	var prefixParamCount = method.GetParameters ().Length - 1;  	var field = _relationInfo.ClientRelationVersionInfo.GetSecondaryKeyFields (secondaryKeyIndex).Skip (_relationInfo.ApartFields.Count + prefixParamCount).First ();  	reqMethod.Generator.Ldarg (0);  	SaveListPrefixBytes (secondaryKeyIndex' reqMethod.Generator' method.Name' method.GetParameters ()' _relationInfo.ApartFields);  	reqMethod.Generator.LdcI4 (prefixParamCount + _relationInfo.ApartFields.Count).Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("Order")).Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("StartProposition"));  	FillBufferWhenNotIgnoredKeyPropositionIl (advEnumParamOrder' field' emptyBufferLoc' advEnumParam.GetField ("Start")' reqMethod.Generator);  	reqMethod.Generator.Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("EndProposition"));  	FillBufferWhenNotIgnoredKeyPropositionIl (advEnumParamOrder' field' emptyBufferLoc' advEnumParam.GetField ("End")' reqMethod.Generator);  	reqMethod.Generator.LdcI4 ((int)secondaryKeyIndex);  	if (typeof(IEnumerator<>).MakeGenericType (_relationInfo.ClientType).IsAssignableFrom (method.ReturnType)) {  		//return new RelationAdvancedSecondaryKeyEnumerator<T>(relationManipulator'  		//    prefixBytes' prefixFieldCount'  		//    order'  		//    startKeyProposition' startKeyBytes'  		//    endKeyProposition' endKeyBytes' secondaryKeyIndex);  		var enumType = typeof(RelationAdvancedSecondaryKeyEnumerator<>).MakeGenericType (_relationInfo.ClientType);  		var advancedEnumeratorCtor = enumType.GetConstructors () [0];  		reqMethod.Generator.Newobj (advancedEnumeratorCtor);  	} else if (typeof(IOrderedDictionaryEnumerator<' >).MakeGenericType (advEnumParamType' _relationInfo.ClientType).IsAssignableFrom (method.ReturnType)) {  		//return new RelationAdvancedOrderedSecondaryKeyEnumerator<T>(relationManipulator'  		//    prefixBytes' prefixFieldCount'  		//    order'  		//    startKeyProposition' startKeyBytes'  		//    endKeyProposition' endKeyBytes' secondaryKeyIndex);  		var enumType = typeof(RelationAdvancedOrderedSecondaryKeyEnumerator<' >).MakeGenericType (advEnumParamType' _relationInfo.ClientType);  		var advancedEnumeratorCtor = enumType.GetConstructors () [0];  		reqMethod.Generator.Newobj (advancedEnumeratorCtor);  	} else {  		throw new BTDBException ("Invalid method " + method.Name);  	}  } else if (method.Name == "Insert") {  	var methodInfo = relationDBManipulatorType.GetMethod (method.Name);  	bool returningBoolVariant;  	var returnType = method.ReturnType;  	if (returnType == typeof(void))  		returningBoolVariant = false;  	else if (returnType == typeof(bool))  		returningBoolVariant = true;  	else  		throw new BTDBException ("Method Insert should be defined with void or bool return type.");  	var methodParams = method.GetParameters ();  	CheckParameterCount (method.Name' 1' methodParams.Length);  	CheckParameterType (method.Name' 0' methodInfo.GetParameters () [0].ParameterType' methodParams [0].ParameterType);  	reqMethod.Generator.Ldarg (0)//this  	.Ldarg (1).Callvirt (methodInfo);  	if (!returningBoolVariant) {  		var returnedTrueLabel = reqMethod.Generator.DefineLabel ("returnedTrueLabel");  		reqMethod.Generator.Brtrue (returnedTrueLabel).Ldstr ("Trying to insert duplicate key.").Newobj (() => new BTDBException (null)).Throw ().Mark (returnedTrueLabel);  	}  } else//call the same method name with the same parameters   {  	var methodParams = method.GetParameters ();  	int paramCount = methodParams.Length;  	var methodInfo = relationDBManipulatorType.GetMethod (method.Name);  	if (methodInfo == null)  		throw new BTDBException ();  	CheckReturnType (method.Name' methodInfo.ReturnType' method.ReturnType);  	var calledMethodParams = methodInfo.GetParameters ();  	CheckParameterCount (method.Name' calledMethodParams.Length' methodParams.Length);  	for (int i = 0; i < methodParams.Length; i++) {  		CheckParameterType (method.Name' i' calledMethodParams [i].ParameterType' methodParams [i].ParameterType);  	}  	for (ushort i = 0; i <= paramCount; i++)  		reqMethod.Generator.Ldarg (i);  	reqMethod.Generator.Callvirt (methodInfo);  }  
Magic Number,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The following statement contains a magic number: if (method.Name == "ListById")//list by primary key   {  	var parameters = method.GetParameters ();  	var advEnumParamOrder = (ushort)parameters.Length;  	var advEnumParam = parameters [advEnumParamOrder - 1].ParameterType;  	var advEnumParamType = advEnumParam.GenericTypeArguments [0];  	var emptyBufferLoc = reqMethod.Generator.DeclareLocal (typeof(ByteBuffer));  	var prefixParamCount = method.GetParameters ().Length - 1;  	var field = _relationInfo.ClientRelationVersionInfo.GetPrimaryKeyFields ().Skip (_relationInfo.ApartFields.Count + prefixParamCount).First ();  	reqMethod.Generator.Ldarg (0);  	SavePKListPrefixBytes (reqMethod.Generator' method.Name' method.GetParameters ()' _relationInfo.ApartFields);  	reqMethod.Generator.LdcI4 (prefixParamCount + _relationInfo.ApartFields.Count).Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("Order")).Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("StartProposition"));  	FillBufferWhenNotIgnoredKeyPropositionIl (advEnumParamOrder' field' emptyBufferLoc' advEnumParam.GetField ("Start")' reqMethod.Generator);  	reqMethod.Generator.Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("EndProposition"));  	FillBufferWhenNotIgnoredKeyPropositionIl (advEnumParamOrder' field' emptyBufferLoc' advEnumParam.GetField ("End")' reqMethod.Generator);  	if (typeof(IEnumerator<>).MakeGenericType (_relationInfo.ClientType).IsAssignableFrom (method.ReturnType)) {  		//return new RelationAdvancedEnumerator<T>(relationManipulator'  		//    prefixBytes' prefixFieldCount'  		//    order'  		//    startKeyProposition' startKeyBytes'  		//    endKeyProposition' endKeyBytes' secondaryKeyIndex);  		var enumType = typeof(RelationAdvancedEnumerator<>).MakeGenericType (_relationInfo.ClientType);  		var advancedEnumeratorCtor = enumType.GetConstructors () [0];  		reqMethod.Generator.Newobj (advancedEnumeratorCtor);  	} else if (typeof(IOrderedDictionaryEnumerator<' >).MakeGenericType (advEnumParamType' _relationInfo.ClientType).IsAssignableFrom (method.ReturnType)) {  		reqMethod.Generator.LdcI4 (1);  		//init key reader  		//return new RelationAdvancedOrderedEnumerator<T>(relationManipulator'  		//    prefixBytes' prefixFieldCount'  		//    order'  		//    startKeyProposition' startKeyBytes'  		//    endKeyProposition' endKeyBytes' secondaryKeyIndex' initKeyReader);  		var enumType = typeof(RelationAdvancedOrderedEnumerator<' >).MakeGenericType (advEnumParamType' _relationInfo.ClientType);  		var advancedEnumeratorCtor = enumType.GetConstructors () [0];  		reqMethod.Generator.Newobj (advancedEnumeratorCtor);  	} else {  		throw new BTDBException ("Invalid method " + method.Name);  	}  } else if (method.Name.StartsWith ("ListBy"' StringComparison.Ordinal))//ListBy{Name}(tenantId' ..' AdvancedEnumeratorParam)   {  	var parameters = method.GetParameters ();  	var advEnumParamOrder = (ushort)parameters.Length;  	var advEnumParam = parameters [advEnumParamOrder - 1].ParameterType;  	var advEnumParamType = advEnumParam.GenericTypeArguments [0];  	var emptyBufferLoc = reqMethod.Generator.DeclareLocal (typeof(ByteBuffer));  	var secondaryKeyIndex = _relationInfo.ClientRelationVersionInfo.GetSecondaryKeyIndex (method.Name.Substring (6));  	var prefixParamCount = method.GetParameters ().Length - 1;  	var field = _relationInfo.ClientRelationVersionInfo.GetSecondaryKeyFields (secondaryKeyIndex).Skip (_relationInfo.ApartFields.Count + prefixParamCount).First ();  	reqMethod.Generator.Ldarg (0);  	SaveListPrefixBytes (secondaryKeyIndex' reqMethod.Generator' method.Name' method.GetParameters ()' _relationInfo.ApartFields);  	reqMethod.Generator.LdcI4 (prefixParamCount + _relationInfo.ApartFields.Count).Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("Order")).Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("StartProposition"));  	FillBufferWhenNotIgnoredKeyPropositionIl (advEnumParamOrder' field' emptyBufferLoc' advEnumParam.GetField ("Start")' reqMethod.Generator);  	reqMethod.Generator.Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("EndProposition"));  	FillBufferWhenNotIgnoredKeyPropositionIl (advEnumParamOrder' field' emptyBufferLoc' advEnumParam.GetField ("End")' reqMethod.Generator);  	reqMethod.Generator.LdcI4 ((int)secondaryKeyIndex);  	if (typeof(IEnumerator<>).MakeGenericType (_relationInfo.ClientType).IsAssignableFrom (method.ReturnType)) {  		//return new RelationAdvancedSecondaryKeyEnumerator<T>(relationManipulator'  		//    prefixBytes' prefixFieldCount'  		//    order'  		//    startKeyProposition' startKeyBytes'  		//    endKeyProposition' endKeyBytes' secondaryKeyIndex);  		var enumType = typeof(RelationAdvancedSecondaryKeyEnumerator<>).MakeGenericType (_relationInfo.ClientType);  		var advancedEnumeratorCtor = enumType.GetConstructors () [0];  		reqMethod.Generator.Newobj (advancedEnumeratorCtor);  	} else if (typeof(IOrderedDictionaryEnumerator<' >).MakeGenericType (advEnumParamType' _relationInfo.ClientType).IsAssignableFrom (method.ReturnType)) {  		//return new RelationAdvancedOrderedSecondaryKeyEnumerator<T>(relationManipulator'  		//    prefixBytes' prefixFieldCount'  		//    order'  		//    startKeyProposition' startKeyBytes'  		//    endKeyProposition' endKeyBytes' secondaryKeyIndex);  		var enumType = typeof(RelationAdvancedOrderedSecondaryKeyEnumerator<' >).MakeGenericType (advEnumParamType' _relationInfo.ClientType);  		var advancedEnumeratorCtor = enumType.GetConstructors () [0];  		reqMethod.Generator.Newobj (advancedEnumeratorCtor);  	} else {  		throw new BTDBException ("Invalid method " + method.Name);  	}  } else if (method.Name == "Insert") {  	var methodInfo = relationDBManipulatorType.GetMethod (method.Name);  	bool returningBoolVariant;  	var returnType = method.ReturnType;  	if (returnType == typeof(void))  		returningBoolVariant = false;  	else if (returnType == typeof(bool))  		returningBoolVariant = true;  	else  		throw new BTDBException ("Method Insert should be defined with void or bool return type.");  	var methodParams = method.GetParameters ();  	CheckParameterCount (method.Name' 1' methodParams.Length);  	CheckParameterType (method.Name' 0' methodInfo.GetParameters () [0].ParameterType' methodParams [0].ParameterType);  	reqMethod.Generator.Ldarg (0)//this  	.Ldarg (1).Callvirt (methodInfo);  	if (!returningBoolVariant) {  		var returnedTrueLabel = reqMethod.Generator.DefineLabel ("returnedTrueLabel");  		reqMethod.Generator.Brtrue (returnedTrueLabel).Ldstr ("Trying to insert duplicate key.").Newobj (() => new BTDBException (null)).Throw ().Mark (returnedTrueLabel);  	}  } else//call the same method name with the same parameters   {  	var methodParams = method.GetParameters ();  	int paramCount = methodParams.Length;  	var methodInfo = relationDBManipulatorType.GetMethod (method.Name);  	if (methodInfo == null)  		throw new BTDBException ();  	CheckReturnType (method.Name' methodInfo.ReturnType' method.ReturnType);  	var calledMethodParams = methodInfo.GetParameters ();  	CheckParameterCount (method.Name' calledMethodParams.Length' methodParams.Length);  	for (int i = 0; i < methodParams.Length; i++) {  		CheckParameterType (method.Name' i' calledMethodParams [i].ParameterType' methodParams [i].ParameterType);  	}  	for (ushort i = 0; i <= paramCount; i++)  		reqMethod.Generator.Ldarg (i);  	reqMethod.Generator.Callvirt (methodInfo);  }  
Magic Number,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,Build,The following statement contains a magic number: if (method.Name.StartsWith ("ListBy"' StringComparison.Ordinal))//ListBy{Name}(tenantId' ..' AdvancedEnumeratorParam)   {  	var parameters = method.GetParameters ();  	var advEnumParamOrder = (ushort)parameters.Length;  	var advEnumParam = parameters [advEnumParamOrder - 1].ParameterType;  	var advEnumParamType = advEnumParam.GenericTypeArguments [0];  	var emptyBufferLoc = reqMethod.Generator.DeclareLocal (typeof(ByteBuffer));  	var secondaryKeyIndex = _relationInfo.ClientRelationVersionInfo.GetSecondaryKeyIndex (method.Name.Substring (6));  	var prefixParamCount = method.GetParameters ().Length - 1;  	var field = _relationInfo.ClientRelationVersionInfo.GetSecondaryKeyFields (secondaryKeyIndex).Skip (_relationInfo.ApartFields.Count + prefixParamCount).First ();  	reqMethod.Generator.Ldarg (0);  	SaveListPrefixBytes (secondaryKeyIndex' reqMethod.Generator' method.Name' method.GetParameters ()' _relationInfo.ApartFields);  	reqMethod.Generator.LdcI4 (prefixParamCount + _relationInfo.ApartFields.Count).Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("Order")).Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("StartProposition"));  	FillBufferWhenNotIgnoredKeyPropositionIl (advEnumParamOrder' field' emptyBufferLoc' advEnumParam.GetField ("Start")' reqMethod.Generator);  	reqMethod.Generator.Ldarg (advEnumParamOrder).Ldfld (advEnumParam.GetField ("EndProposition"));  	FillBufferWhenNotIgnoredKeyPropositionIl (advEnumParamOrder' field' emptyBufferLoc' advEnumParam.GetField ("End")' reqMethod.Generator);  	reqMethod.Generator.LdcI4 ((int)secondaryKeyIndex);  	if (typeof(IEnumerator<>).MakeGenericType (_relationInfo.ClientType).IsAssignableFrom (method.ReturnType)) {  		//return new RelationAdvancedSecondaryKeyEnumerator<T>(relationManipulator'  		//    prefixBytes' prefixFieldCount'  		//    order'  		//    startKeyProposition' startKeyBytes'  		//    endKeyProposition' endKeyBytes' secondaryKeyIndex);  		var enumType = typeof(RelationAdvancedSecondaryKeyEnumerator<>).MakeGenericType (_relationInfo.ClientType);  		var advancedEnumeratorCtor = enumType.GetConstructors () [0];  		reqMethod.Generator.Newobj (advancedEnumeratorCtor);  	} else if (typeof(IOrderedDictionaryEnumerator<' >).MakeGenericType (advEnumParamType' _relationInfo.ClientType).IsAssignableFrom (method.ReturnType)) {  		//return new RelationAdvancedOrderedSecondaryKeyEnumerator<T>(relationManipulator'  		//    prefixBytes' prefixFieldCount'  		//    order'  		//    startKeyProposition' startKeyBytes'  		//    endKeyProposition' endKeyBytes' secondaryKeyIndex);  		var enumType = typeof(RelationAdvancedOrderedSecondaryKeyEnumerator<' >).MakeGenericType (advEnumParamType' _relationInfo.ClientType);  		var advancedEnumeratorCtor = enumType.GetConstructors () [0];  		reqMethod.Generator.Newobj (advancedEnumeratorCtor);  	} else {  		throw new BTDBException ("Invalid method " + method.Name);  	}  } else if (method.Name == "Insert") {  	var methodInfo = relationDBManipulatorType.GetMethod (method.Name);  	bool returningBoolVariant;  	var returnType = method.ReturnType;  	if (returnType == typeof(void))  		returningBoolVariant = false;  	else if (returnType == typeof(bool))  		returningBoolVariant = true;  	else  		throw new BTDBException ("Method Insert should be defined with void or bool return type.");  	var methodParams = method.GetParameters ();  	CheckParameterCount (method.Name' 1' methodParams.Length);  	CheckParameterType (method.Name' 0' methodInfo.GetParameters () [0].ParameterType' methodParams [0].ParameterType);  	reqMethod.Generator.Ldarg (0)//this  	.Ldarg (1).Callvirt (methodInfo);  	if (!returningBoolVariant) {  		var returnedTrueLabel = reqMethod.Generator.DefineLabel ("returnedTrueLabel");  		reqMethod.Generator.Brtrue (returnedTrueLabel).Ldstr ("Trying to insert duplicate key.").Newobj (() => new BTDBException (null)).Throw ().Mark (returnedTrueLabel);  	}  } else//call the same method name with the same parameters   {  	var methodParams = method.GetParameters ();  	int paramCount = methodParams.Length;  	var methodInfo = relationDBManipulatorType.GetMethod (method.Name);  	if (methodInfo == null)  		throw new BTDBException ();  	CheckReturnType (method.Name' methodInfo.ReturnType' method.ReturnType);  	var calledMethodParams = methodInfo.GetParameters ();  	CheckParameterCount (method.Name' calledMethodParams.Length' methodParams.Length);  	for (int i = 0; i < methodParams.Length; i++) {  		CheckParameterType (method.Name' i' calledMethodParams [i].ParameterType' methodParams [i].ParameterType);  	}  	for (ushort i = 0; i <= paramCount; i++)  		reqMethod.Generator.Ldarg (i);  	reqMethod.Generator.Callvirt (methodInfo);  }  
Magic Number,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodFindBy,The following statement contains a magic number: if (skName.EndsWith ("OrDefault")) {  	skName = skName.Substring (0' skName.Length - 9);  	allowDefault = true;  }  
Magic Number,BTDB.ODBLayer,RelationBuilder,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationBuilder.cs,CreateMethodFindBy,The following statement contains a magic number: skName = skName.Substring (0' skName.Length - 9);  
Magic Number,BTDB.ODBLayer,RelationDBManipulator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,CompareAndRelease,The following statement contains a magic number: if (newItems.Count == 0) {  	foreach (var id in oldItems)  		freeAction (_transaction' id);  } else if (newItems.Count < 10) {  	foreach (var id in oldItems) {  		if (newItems.Contains (id))  			continue;  		freeAction (_transaction' id);  	}  } else {  	var newItemsDictionary = new Dictionary<ulong' object> ();  	foreach (var id in newItems)  		newItemsDictionary [id] = null;  	foreach (var id in oldItems) {  		if (newItemsDictionary.ContainsKey (id))  			continue;  		freeAction (_transaction' id);  	}  }  
Magic Number,BTDB.ODBLayer,RelationDBManipulator,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationDBManipulator.cs,CompareAndRelease,The following statement contains a magic number: if (newItems.Count < 10) {  	foreach (var id in oldItems) {  		if (newItems.Contains (id))  			continue;  		freeAction (_transaction' id);  	}  } else {  	var newItemsDictionary = new Dictionary<ulong' object> ();  	foreach (var id in newItems)  		newItemsDictionary [id] = null;  	foreach (var id in oldItems) {  		if (newItemsDictionary.ContainsKey (id))  			continue;  		freeAction (_transaction' id);  	}  }  
Magic Number,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateSaverWithApartFields,The following statement contains a magic number: StoreNthArgumentOfTypeIntoLoc (ilGenerator' 2' ClientType' 0);  
Magic Number,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateSaverWithApartFields,The following statement contains a magic number: if (hasApartFields) {  	ilGenerator.DeclareLocal (_interfaceType);  	StoreNthArgumentOfTypeIntoLoc (ilGenerator' 3' _interfaceType' 1);  }  
Magic Number,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateSaverWithApartFields,The following statement contains a magic number: StoreNthArgumentOfTypeIntoLoc (ilGenerator' 3' _interfaceType' 1);  
Magic Number,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateSaver,The following statement contains a magic number: StoreNthArgumentOfTypeIntoLoc (ilGenerator' 2' ClientType' 0);  
Magic Number,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,FindApartFields,The following statement contains a magic number: for (var i = 0; i < methods.Length; i++) {  	var method = methods [i];  	if (!method.Name.StartsWith ("get_"))  		continue;  	var name = method.Name.Substring (4);  	TableFieldInfo tfi;  	if (!pks.TryGetValue (name' out tfi))  		throw new BTDBException ();  	if (method.ReturnType != tfi.Handler.HandledType ())  		throw new BTDBException ();  	result.Add (name' method);  }  
Magic Number,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateLoader,The following statement contains a magic number: ilGenerator.Ldarg (2).Castclass (ClientType).Stloc (0);  
Magic Number,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateIDictFinder,The following statement contains a magic number: if (anyNeedsCtx) {  	ilGenerator.DeclareLocal (typeof(IReaderCtx));  	ilGenerator.Ldarg (0).Ldarg (1).Ldarg (2).Ldarg (3).Newobj (() => new DBReaderWithFreeInfoCtx (null' null' null' null)).Stloc (0);  }  
Magic Number,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateIDictFinder,The following statement contains a magic number: if (anyNeedsCtx) {  	ilGenerator.DeclareLocal (typeof(IReaderCtx));  	ilGenerator.Ldarg (0).Ldarg (1).Ldarg (2).Ldarg (3).Newobj (() => new DBReaderWithFreeInfoCtx (null' null' null' null)).Stloc (0);  }  
Magic Number,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateIDictFinder,The following statement contains a magic number: ilGenerator.Ldarg (0).Ldarg (1).Ldarg (2).Ldarg (3).Newobj (() => new DBReaderWithFreeInfoCtx (null' null' null' null)).Stloc (0);  
Magic Number,BTDB.ODBLayer,RelationInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\RelationInfo.cs,CreateIDictFinder,The following statement contains a magic number: ilGenerator.Ldarg (0).Ldarg (1).Ldarg (2).Ldarg (3).Newobj (() => new DBReaderWithFreeInfoCtx (null' null' null' null)).Stloc (0);  
Magic Number,BTDB.ODBLayer,ObjectDBTransaction,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,AddToObjCache,The following statement contains a magic number: if (_objSmallCache == null) {  	_objSmallCache = new Dictionary<ulong' object> ();  	_objSmallMetadata = new Dictionary<object' DBObjectMetadata> (ReferenceEqualityComparer<object>.Instance);  } else if (_objSmallCache.Count > 30) {  	_objBigCache = new Dictionary<ulong' WeakReference> ();  	_objBigMetadata = new ConditionalWeakTable<object' DBObjectMetadata> ();  	foreach (var pair in _objSmallCache) {  		_objBigCache.Add (pair.Key' new WeakReference (pair.Value));  	}  	_objSmallCache = null;  	foreach (var pair in _objSmallMetadata) {  		_objBigMetadata.Add (pair.Key' pair.Value);  	}  	_objSmallMetadata = null;  	_objBigCache.Add (oid' new WeakReference (obj));  	_objBigMetadata.Add (obj' metadata);  	return;  }  
Magic Number,BTDB.ODBLayer,ObjectDBTransaction,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\ObjectDBTransaction.cs,AddToObjCache,The following statement contains a magic number: if (_objSmallCache.Count > 30) {  	_objBigCache = new Dictionary<ulong' WeakReference> ();  	_objBigMetadata = new ConditionalWeakTable<object' DBObjectMetadata> ();  	foreach (var pair in _objSmallCache) {  		_objBigCache.Add (pair.Key' new WeakReference (pair.Value));  	}  	_objSmallCache = null;  	foreach (var pair in _objSmallMetadata) {  		_objBigMetadata.Add (pair.Key' pair.Value);  	}  	_objSmallMetadata = null;  	_objBigCache.Add (oid' new WeakReference (obj));  	_objBigMetadata.Add (obj' metadata);  	return;  }  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateInitializer,The following statement contains a magic number: if (tableVersionInfo.NeedsInit ()) {  	ilGenerator.DeclareLocal (ClientType);  	ilGenerator.Ldarg (2).Castclass (ClientType).Stloc (0);  	var anyNeedsCtx = tableVersionInfo.NeedsCtx ();  	if (anyNeedsCtx) {  		ilGenerator.DeclareLocal (typeof(IReaderCtx));  		ilGenerator.Ldarg (0).Newobj (() => new DBReaderCtx (null)).Stloc (1);  	}  	var props = _clientType.GetProperties (BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);  	for (int fi = 0; fi < tableVersionInfo.FieldCount; fi++) {  		var srcFieldInfo = tableVersionInfo [fi];  		var iFieldHandlerWithInit = srcFieldInfo.Handler as IFieldHandlerWithInit;  		if (iFieldHandlerWithInit == null)  			continue;  		Action<IILGen> readerOrCtx;  		if (srcFieldInfo.Handler.NeedsCtx ())  			readerOrCtx = il => il.Ldloc (1);  		else  			readerOrCtx = il => il.Ldnull ();  		var specializedSrcHandler = srcFieldInfo.Handler;  		var willLoad = specializedSrcHandler.HandledType ();  		var setterMethod = props.First (p => GetPersistantName (p) == srcFieldInfo.Name).GetSetMethod (true);  		var converterGenerator = _tableInfoResolver.TypeConvertorGenerator.GenerateConversion (willLoad' setterMethod.GetParameters () [0].ParameterType);  		if (converterGenerator == null)  			continue;  		if (!iFieldHandlerWithInit.NeedInit ())  			continue;  		ilGenerator.Ldloc (0);  		iFieldHandlerWithInit.Init (ilGenerator' readerOrCtx);  		converterGenerator (ilGenerator);  		ilGenerator.Call (setterMethod);  	}  }  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateInitializer,The following statement contains a magic number: ilGenerator.Ldarg (2).Castclass (ClientType).Stloc (0);  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateSaver,The following statement contains a magic number: ilGenerator.Ldarg (3).Castclass (ClientType).Stloc (0);  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateSaver,The following statement contains a magic number: if (anyNeedsCtx) {  	ilGenerator.DeclareLocal (typeof(IWriterCtx));  	ilGenerator.Ldarg (0).Ldarg (2).Newobj (() => new DBWriterCtx (null' null)).Stloc (1);  }  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateSaver,The following statement contains a magic number: ilGenerator.Ldarg (0).Ldarg (2).Newobj (() => new DBWriterCtx (null' null)).Stloc (1);  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateSaver,The following statement contains a magic number: for (int i = 0; i < ClientTableVersionInfo.FieldCount; i++) {  	var field = ClientTableVersionInfo [i];  	var getter = props.First (p => GetPersistantName (p) == field.Name).GetGetMethod (true);  	Action<IILGen> writerOrCtx;  	var handler = field.Handler.SpecializeSaveForType (getter.ReturnType);  	if (handler.NeedsCtx ())  		writerOrCtx = il => il.Ldloc (1);  	else  		writerOrCtx = il => il.Ldarg (2);  	handler.Save (ilGenerator' writerOrCtx' il => {  		il.Ldloc (0).Callvirt (getter);  		_tableInfoResolver.TypeConvertorGenerator.GenerateConversion (getter.ReturnType' handler.HandledType ()) (il);  	});  }  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateSaver,The following statement contains a magic number: if (handler.NeedsCtx ())  	writerOrCtx = il => il.Ldloc (1);  else  	writerOrCtx = il => il.Ldarg (2);  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateSaver,The following statement contains a magic number: writerOrCtx = il => il.Ldarg (2);  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,The following statement contains a magic number: ilGenerator.Ldarg (3).Castclass (ClientType).Stloc (0);  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,The following statement contains a magic number: if (anyNeedsCtx) {  	ilGenerator.DeclareLocal (typeof(IReaderCtx));  	ilGenerator.Ldarg (0).Ldarg (2).Newobj (() => new DBReaderCtx (null' null)).Stloc (1);  }  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,The following statement contains a magic number: ilGenerator.Ldarg (0).Ldarg (2).Newobj (() => new DBReaderCtx (null' null)).Stloc (1);  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,The following statement contains a magic number: for (int fi = 0; fi < tableVersionInfo.FieldCount; fi++) {  	var srcFieldInfo = tableVersionInfo [fi];  	Action<IILGen> readerOrCtx;  	if (srcFieldInfo.Handler.NeedsCtx ())  		readerOrCtx = il => il.Ldloc (1);  	else  		readerOrCtx = il => il.Ldarg (2);  	var destFieldInfo = clientTableVersionInfo [srcFieldInfo.Name];  	if (destFieldInfo != null) {  		var fieldInfo = props.First (p => GetPersistantName (p) == destFieldInfo.Name).GetSetMethod (true);  		var fieldType = fieldInfo.GetParameters () [0].ParameterType;  		var specializedSrcHandler = srcFieldInfo.Handler.SpecializeLoadForType (fieldType' destFieldInfo.Handler);  		var willLoad = specializedSrcHandler.HandledType ();  		var converterGenerator = _tableInfoResolver.TypeConvertorGenerator.GenerateConversion (willLoad' fieldType);  		if (converterGenerator != null) {  			ilGenerator.Ldloc (0);  			specializedSrcHandler.Load (ilGenerator' readerOrCtx);  			converterGenerator (ilGenerator);  			ilGenerator.Call (fieldInfo);  			continue;  		}  	}  	srcFieldInfo.Handler.Skip (ilGenerator' readerOrCtx);  }  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,The following statement contains a magic number: if (srcFieldInfo.Handler.NeedsCtx ())  	readerOrCtx = il => il.Ldloc (1);  else  	readerOrCtx = il => il.Ldarg (2);  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateLoader,The following statement contains a magic number: readerOrCtx = il => il.Ldarg (2);  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateFreeContent,The following statement contains a magic number: if (anyNeedsCtx) {  	ilGenerator.DeclareLocal (typeof(IReaderCtx));  	ilGenerator.Ldarg (0).Ldarg (2).Ldarg (3).Ldarg (4).Newobj (() => new DBReaderWithFreeInfoCtx (null' null' null' null)).Stloc (0);  }  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateFreeContent,The following statement contains a magic number: if (anyNeedsCtx) {  	ilGenerator.DeclareLocal (typeof(IReaderCtx));  	ilGenerator.Ldarg (0).Ldarg (2).Ldarg (3).Ldarg (4).Newobj (() => new DBReaderWithFreeInfoCtx (null' null' null' null)).Stloc (0);  }  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateFreeContent,The following statement contains a magic number: if (anyNeedsCtx) {  	ilGenerator.DeclareLocal (typeof(IReaderCtx));  	ilGenerator.Ldarg (0).Ldarg (2).Ldarg (3).Ldarg (4).Newobj (() => new DBReaderWithFreeInfoCtx (null' null' null' null)).Stloc (0);  }  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateFreeContent,The following statement contains a magic number: ilGenerator.Ldarg (0).Ldarg (2).Ldarg (3).Ldarg (4).Newobj (() => new DBReaderWithFreeInfoCtx (null' null' null' null)).Stloc (0);  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateFreeContent,The following statement contains a magic number: ilGenerator.Ldarg (0).Ldarg (2).Ldarg (3).Ldarg (4).Newobj (() => new DBReaderWithFreeInfoCtx (null' null' null' null)).Stloc (0);  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateFreeContent,The following statement contains a magic number: ilGenerator.Ldarg (0).Ldarg (2).Ldarg (3).Ldarg (4).Newobj (() => new DBReaderWithFreeInfoCtx (null' null' null' null)).Stloc (0);  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateFreeContent,The following statement contains a magic number: for (int fi = 0; fi < tableVersionInfo.FieldCount; fi++) {  	var srcFieldInfo = tableVersionInfo [fi];  	Action<IILGen> readerOrCtx;  	if (srcFieldInfo.Handler.NeedsCtx ())  		readerOrCtx = il => il.Ldloc (0);  	else  		readerOrCtx = il => il.Ldarg (2);  	var needsFree = srcFieldInfo.Handler.FreeContent (ilGenerator' readerOrCtx);  	needsFreeContent |= needsFree;  }  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateFreeContent,The following statement contains a magic number: if (srcFieldInfo.Handler.NeedsCtx ())  	readerOrCtx = il => il.Ldloc (0);  else  	readerOrCtx = il => il.Ldarg (2);  
Magic Number,BTDB.ODBLayer,TableInfo,F:\newReposMay17\Bobris_BTDB\BTDB\ODBLayer\TableInfo.cs,CreateFreeContent,The following statement contains a magic number: readerOrCtx = il => il.Ldarg (2);  
Magic Number,BTDB.Reactive,FastSubject,F:\newReposMay17\Bobris_BTDB\BTDB\Reactive\FastSubject.cs,Unsubscribe,The following statement contains a magic number: do {  	original = _current;  	if (original is IStoppedSubjectMarker)  		return;  	if (original is FastSubjectHelpers<T>.MultiSubject) {  		var originalArray = ((FastSubjectHelpers<T>.MultiSubject)original).Array;  		var indexOf = Array.IndexOf (originalArray' observer);  		if (indexOf < 0)  			return;  		if (originalArray.Length == 2) {  			nextState = originalArray [1 - indexOf];  		} else {  			var newArray = new IObserver<T>[originalArray.Length - 1];  			Array.Copy (originalArray' newArray' indexOf);  			Array.Copy (originalArray' indexOf + 1' newArray' indexOf' newArray.Length - indexOf);  			nextState = new FastSubjectHelpers<T>.MultiSubject (newArray);  		}  	} else {  		if (original != observer)  			return;  		nextState = FastSubjectHelpers<T>.EmptySubjectMarker;  	}  } while (Interlocked.CompareExchange (ref _current' nextState' original) != original);  
Magic Number,BTDB.Reactive,FastSubject,F:\newReposMay17\Bobris_BTDB\BTDB\Reactive\FastSubject.cs,Unsubscribe,The following statement contains a magic number: if (original is FastSubjectHelpers<T>.MultiSubject) {  	var originalArray = ((FastSubjectHelpers<T>.MultiSubject)original).Array;  	var indexOf = Array.IndexOf (originalArray' observer);  	if (indexOf < 0)  		return;  	if (originalArray.Length == 2) {  		nextState = originalArray [1 - indexOf];  	} else {  		var newArray = new IObserver<T>[originalArray.Length - 1];  		Array.Copy (originalArray' newArray' indexOf);  		Array.Copy (originalArray' indexOf + 1' newArray' indexOf' newArray.Length - indexOf);  		nextState = new FastSubjectHelpers<T>.MultiSubject (newArray);  	}  } else {  	if (original != observer)  		return;  	nextState = FastSubjectHelpers<T>.EmptySubjectMarker;  }  
Magic Number,BTDB.Reactive,FastSubject,F:\newReposMay17\Bobris_BTDB\BTDB\Reactive\FastSubject.cs,Unsubscribe,The following statement contains a magic number: if (originalArray.Length == 2) {  	nextState = originalArray [1 - indexOf];  } else {  	var newArray = new IObserver<T>[originalArray.Length - 1];  	Array.Copy (originalArray' newArray' indexOf);  	Array.Copy (originalArray' indexOf + 1' newArray' indexOf' newArray.Length - indexOf);  	nextState = new FastSubjectHelpers<T>.MultiSubject (newArray);  }  
Magic Number,BTDB.Reactive,FastBehaviourSubject,F:\newReposMay17\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,Unsubscribe,The following statement contains a magic number: do {  	original = _current;  	if (original is IStoppedSubjectMarker)  		return;  	if (original is FastSubjectHelpers<T>.MultiSubject) {  		var originalArray = ((FastSubjectHelpers<T>.MultiSubject)original).Array;  		var indexOf = Array.IndexOf (originalArray' observer);  		if (indexOf < 0)  			return;  		if (originalArray.Length == 2) {  			nextState = originalArray [1 - indexOf];  		} else {  			var newArray = new IObserver<T>[originalArray.Length - 1];  			Array.Copy (originalArray' newArray' indexOf);  			Array.Copy (originalArray' indexOf + 1' newArray' indexOf' newArray.Length - indexOf);  			nextState = new FastSubjectHelpers<T>.MultiSubject (newArray);  		}  	} else if (original is FastSubjectHelpers<T>.MultiSubjectWithValue) {  		var o = (FastSubjectHelpers<T>.MultiSubjectWithValue)original;  		var originalArray = o.Array;  		var indexOf = Array.IndexOf (originalArray' observer);  		if (indexOf < 0)  			return;  		if (originalArray.Length == 2) {  			nextState = new FastSubjectHelpers<T>.SingleSubjectWithValue (originalArray [1 - indexOf]' o.Value);  		} else {  			var newArray = new IObserver<T>[originalArray.Length - 1];  			Array.Copy (originalArray' newArray' indexOf);  			Array.Copy (originalArray' indexOf + 1' newArray' indexOf' newArray.Length - indexOf);  			nextState = new FastSubjectHelpers<T>.MultiSubjectWithValue (newArray' o.Value);  		}  	} else if (original is FastSubjectHelpers<T>.SingleSubjectWithValue) {  		var o = (FastSubjectHelpers<T>.SingleSubjectWithValue)original;  		if (o.Observer != observer)  			return;  		nextState = new FastSubjectHelpers<T>.EmptySubjectWithValue (o.Value);  	} else {  		if (original != observer)  			return;  		nextState = FastSubjectHelpers<T>.EmptySubjectMarker;  	}  } while (Interlocked.CompareExchange (ref _current' nextState' original) != original);  
Magic Number,BTDB.Reactive,FastBehaviourSubject,F:\newReposMay17\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,Unsubscribe,The following statement contains a magic number: do {  	original = _current;  	if (original is IStoppedSubjectMarker)  		return;  	if (original is FastSubjectHelpers<T>.MultiSubject) {  		var originalArray = ((FastSubjectHelpers<T>.MultiSubject)original).Array;  		var indexOf = Array.IndexOf (originalArray' observer);  		if (indexOf < 0)  			return;  		if (originalArray.Length == 2) {  			nextState = originalArray [1 - indexOf];  		} else {  			var newArray = new IObserver<T>[originalArray.Length - 1];  			Array.Copy (originalArray' newArray' indexOf);  			Array.Copy (originalArray' indexOf + 1' newArray' indexOf' newArray.Length - indexOf);  			nextState = new FastSubjectHelpers<T>.MultiSubject (newArray);  		}  	} else if (original is FastSubjectHelpers<T>.MultiSubjectWithValue) {  		var o = (FastSubjectHelpers<T>.MultiSubjectWithValue)original;  		var originalArray = o.Array;  		var indexOf = Array.IndexOf (originalArray' observer);  		if (indexOf < 0)  			return;  		if (originalArray.Length == 2) {  			nextState = new FastSubjectHelpers<T>.SingleSubjectWithValue (originalArray [1 - indexOf]' o.Value);  		} else {  			var newArray = new IObserver<T>[originalArray.Length - 1];  			Array.Copy (originalArray' newArray' indexOf);  			Array.Copy (originalArray' indexOf + 1' newArray' indexOf' newArray.Length - indexOf);  			nextState = new FastSubjectHelpers<T>.MultiSubjectWithValue (newArray' o.Value);  		}  	} else if (original is FastSubjectHelpers<T>.SingleSubjectWithValue) {  		var o = (FastSubjectHelpers<T>.SingleSubjectWithValue)original;  		if (o.Observer != observer)  			return;  		nextState = new FastSubjectHelpers<T>.EmptySubjectWithValue (o.Value);  	} else {  		if (original != observer)  			return;  		nextState = FastSubjectHelpers<T>.EmptySubjectMarker;  	}  } while (Interlocked.CompareExchange (ref _current' nextState' original) != original);  
Magic Number,BTDB.Reactive,FastBehaviourSubject,F:\newReposMay17\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,Unsubscribe,The following statement contains a magic number: if (original is FastSubjectHelpers<T>.MultiSubject) {  	var originalArray = ((FastSubjectHelpers<T>.MultiSubject)original).Array;  	var indexOf = Array.IndexOf (originalArray' observer);  	if (indexOf < 0)  		return;  	if (originalArray.Length == 2) {  		nextState = originalArray [1 - indexOf];  	} else {  		var newArray = new IObserver<T>[originalArray.Length - 1];  		Array.Copy (originalArray' newArray' indexOf);  		Array.Copy (originalArray' indexOf + 1' newArray' indexOf' newArray.Length - indexOf);  		nextState = new FastSubjectHelpers<T>.MultiSubject (newArray);  	}  } else if (original is FastSubjectHelpers<T>.MultiSubjectWithValue) {  	var o = (FastSubjectHelpers<T>.MultiSubjectWithValue)original;  	var originalArray = o.Array;  	var indexOf = Array.IndexOf (originalArray' observer);  	if (indexOf < 0)  		return;  	if (originalArray.Length == 2) {  		nextState = new FastSubjectHelpers<T>.SingleSubjectWithValue (originalArray [1 - indexOf]' o.Value);  	} else {  		var newArray = new IObserver<T>[originalArray.Length - 1];  		Array.Copy (originalArray' newArray' indexOf);  		Array.Copy (originalArray' indexOf + 1' newArray' indexOf' newArray.Length - indexOf);  		nextState = new FastSubjectHelpers<T>.MultiSubjectWithValue (newArray' o.Value);  	}  } else if (original is FastSubjectHelpers<T>.SingleSubjectWithValue) {  	var o = (FastSubjectHelpers<T>.SingleSubjectWithValue)original;  	if (o.Observer != observer)  		return;  	nextState = new FastSubjectHelpers<T>.EmptySubjectWithValue (o.Value);  } else {  	if (original != observer)  		return;  	nextState = FastSubjectHelpers<T>.EmptySubjectMarker;  }  
Magic Number,BTDB.Reactive,FastBehaviourSubject,F:\newReposMay17\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,Unsubscribe,The following statement contains a magic number: if (original is FastSubjectHelpers<T>.MultiSubject) {  	var originalArray = ((FastSubjectHelpers<T>.MultiSubject)original).Array;  	var indexOf = Array.IndexOf (originalArray' observer);  	if (indexOf < 0)  		return;  	if (originalArray.Length == 2) {  		nextState = originalArray [1 - indexOf];  	} else {  		var newArray = new IObserver<T>[originalArray.Length - 1];  		Array.Copy (originalArray' newArray' indexOf);  		Array.Copy (originalArray' indexOf + 1' newArray' indexOf' newArray.Length - indexOf);  		nextState = new FastSubjectHelpers<T>.MultiSubject (newArray);  	}  } else if (original is FastSubjectHelpers<T>.MultiSubjectWithValue) {  	var o = (FastSubjectHelpers<T>.MultiSubjectWithValue)original;  	var originalArray = o.Array;  	var indexOf = Array.IndexOf (originalArray' observer);  	if (indexOf < 0)  		return;  	if (originalArray.Length == 2) {  		nextState = new FastSubjectHelpers<T>.SingleSubjectWithValue (originalArray [1 - indexOf]' o.Value);  	} else {  		var newArray = new IObserver<T>[originalArray.Length - 1];  		Array.Copy (originalArray' newArray' indexOf);  		Array.Copy (originalArray' indexOf + 1' newArray' indexOf' newArray.Length - indexOf);  		nextState = new FastSubjectHelpers<T>.MultiSubjectWithValue (newArray' o.Value);  	}  } else if (original is FastSubjectHelpers<T>.SingleSubjectWithValue) {  	var o = (FastSubjectHelpers<T>.SingleSubjectWithValue)original;  	if (o.Observer != observer)  		return;  	nextState = new FastSubjectHelpers<T>.EmptySubjectWithValue (o.Value);  } else {  	if (original != observer)  		return;  	nextState = FastSubjectHelpers<T>.EmptySubjectMarker;  }  
Magic Number,BTDB.Reactive,FastBehaviourSubject,F:\newReposMay17\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,Unsubscribe,The following statement contains a magic number: if (originalArray.Length == 2) {  	nextState = originalArray [1 - indexOf];  } else {  	var newArray = new IObserver<T>[originalArray.Length - 1];  	Array.Copy (originalArray' newArray' indexOf);  	Array.Copy (originalArray' indexOf + 1' newArray' indexOf' newArray.Length - indexOf);  	nextState = new FastSubjectHelpers<T>.MultiSubject (newArray);  }  
Magic Number,BTDB.Reactive,FastBehaviourSubject,F:\newReposMay17\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,Unsubscribe,The following statement contains a magic number: if (original is FastSubjectHelpers<T>.MultiSubjectWithValue) {  	var o = (FastSubjectHelpers<T>.MultiSubjectWithValue)original;  	var originalArray = o.Array;  	var indexOf = Array.IndexOf (originalArray' observer);  	if (indexOf < 0)  		return;  	if (originalArray.Length == 2) {  		nextState = new FastSubjectHelpers<T>.SingleSubjectWithValue (originalArray [1 - indexOf]' o.Value);  	} else {  		var newArray = new IObserver<T>[originalArray.Length - 1];  		Array.Copy (originalArray' newArray' indexOf);  		Array.Copy (originalArray' indexOf + 1' newArray' indexOf' newArray.Length - indexOf);  		nextState = new FastSubjectHelpers<T>.MultiSubjectWithValue (newArray' o.Value);  	}  } else if (original is FastSubjectHelpers<T>.SingleSubjectWithValue) {  	var o = (FastSubjectHelpers<T>.SingleSubjectWithValue)original;  	if (o.Observer != observer)  		return;  	nextState = new FastSubjectHelpers<T>.EmptySubjectWithValue (o.Value);  } else {  	if (original != observer)  		return;  	nextState = FastSubjectHelpers<T>.EmptySubjectMarker;  }  
Magic Number,BTDB.Reactive,FastBehaviourSubject,F:\newReposMay17\Bobris_BTDB\BTDB\Reactive\FastBehaviourSubject.cs,Unsubscribe,The following statement contains a magic number: if (originalArray.Length == 2) {  	nextState = new FastSubjectHelpers<T>.SingleSubjectWithValue (originalArray [1 - indexOf]' o.Value);  } else {  	var newArray = new IObserver<T>[originalArray.Length - 1];  	Array.Copy (originalArray' newArray' indexOf);  	Array.Copy (originalArray' indexOf + 1' newArray' indexOf' newArray.Length - indexOf);  	nextState = new FastSubjectHelpers<T>.MultiSubjectWithValue (newArray' o.Value);  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (needsCtx) {  	localReaderCtx = ilGenerator.DeclareLocal (typeof(IReaderCtx)' "readerCtx");  	ilGenerator.Ldarg (2).Ldarg (1).Newobj (() => new ServiceReaderCtx ((IServiceInternalServer)null' null)).Castclass (typeof(IReaderCtx)).Stloc (localReaderCtx);  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: ilGenerator.Ldarg (2).Ldarg (1).Newobj (() => new ServiceReaderCtx ((IServiceInternalServer)null' null)).Castclass (typeof(IReaderCtx)).Stloc (localReaderCtx);  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (binding.OneWay) {  	if (returnType != typeof(void))  		ilGenerator.Pop ();  } else {  	if (localResult == null) {  		if (isAsync) {  			ilGenerator.Ldarg (2).Ldloc (localResultId).Newobj (CreateTaskContinuationWithResultMarshaling (methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler)).Pop ();  		} else {  			if (methodInf.MethodInfo.ReturnType != typeof(void))  				ilGenerator.Pop ();  			ilGenerator.Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).VoidResultMarshaling (0u));  		}  	} else {  		_typeConvertorGenerator.GenerateConversion (returnType' localResult.LocalType) (ilGenerator);  		ilGenerator.Stloc (localResult).Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).StartResultMarshaling (0u)).Stloc (localWriter);  		IILLocal localWriterCtx = null;  		if (resultFieldHandler.NeedsCtx ()) {  			localWriterCtx = ilGenerator.DeclareLocal (typeof(IWriterCtx)' "writerCtx");  			ilGenerator.Ldarg (2).Ldloc (localWriter).Newobj (() => new ServiceWriterCtx ((IServiceInternalServer)null' null)).Castclass (typeof(IWriterCtx)).Stloc (localWriterCtx);  		}  		resultFieldHandler.Save (ilGenerator' il => il.Ldloc (resultFieldHandler.NeedsCtx () ? localWriterCtx : localWriter)' il => il.Ldloc (localResult));  		ilGenerator.Ldarg (2).Ldloc (localWriter).Callvirt (() => default(IServiceInternalServer).FinishResultMarshaling (null));  	}  	ilGenerator.Catch (typeof(Exception)).Stloc (localException).Ldarg (2).Ldloc (localResultId).Ldloc (localException).Callvirt (() => default(IServiceInternalServer).ExceptionMarshaling (0u' null)).EndTry ();  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (binding.OneWay) {  	if (returnType != typeof(void))  		ilGenerator.Pop ();  } else {  	if (localResult == null) {  		if (isAsync) {  			ilGenerator.Ldarg (2).Ldloc (localResultId).Newobj (CreateTaskContinuationWithResultMarshaling (methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler)).Pop ();  		} else {  			if (methodInf.MethodInfo.ReturnType != typeof(void))  				ilGenerator.Pop ();  			ilGenerator.Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).VoidResultMarshaling (0u));  		}  	} else {  		_typeConvertorGenerator.GenerateConversion (returnType' localResult.LocalType) (ilGenerator);  		ilGenerator.Stloc (localResult).Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).StartResultMarshaling (0u)).Stloc (localWriter);  		IILLocal localWriterCtx = null;  		if (resultFieldHandler.NeedsCtx ()) {  			localWriterCtx = ilGenerator.DeclareLocal (typeof(IWriterCtx)' "writerCtx");  			ilGenerator.Ldarg (2).Ldloc (localWriter).Newobj (() => new ServiceWriterCtx ((IServiceInternalServer)null' null)).Castclass (typeof(IWriterCtx)).Stloc (localWriterCtx);  		}  		resultFieldHandler.Save (ilGenerator' il => il.Ldloc (resultFieldHandler.NeedsCtx () ? localWriterCtx : localWriter)' il => il.Ldloc (localResult));  		ilGenerator.Ldarg (2).Ldloc (localWriter).Callvirt (() => default(IServiceInternalServer).FinishResultMarshaling (null));  	}  	ilGenerator.Catch (typeof(Exception)).Stloc (localException).Ldarg (2).Ldloc (localResultId).Ldloc (localException).Callvirt (() => default(IServiceInternalServer).ExceptionMarshaling (0u' null)).EndTry ();  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (binding.OneWay) {  	if (returnType != typeof(void))  		ilGenerator.Pop ();  } else {  	if (localResult == null) {  		if (isAsync) {  			ilGenerator.Ldarg (2).Ldloc (localResultId).Newobj (CreateTaskContinuationWithResultMarshaling (methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler)).Pop ();  		} else {  			if (methodInf.MethodInfo.ReturnType != typeof(void))  				ilGenerator.Pop ();  			ilGenerator.Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).VoidResultMarshaling (0u));  		}  	} else {  		_typeConvertorGenerator.GenerateConversion (returnType' localResult.LocalType) (ilGenerator);  		ilGenerator.Stloc (localResult).Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).StartResultMarshaling (0u)).Stloc (localWriter);  		IILLocal localWriterCtx = null;  		if (resultFieldHandler.NeedsCtx ()) {  			localWriterCtx = ilGenerator.DeclareLocal (typeof(IWriterCtx)' "writerCtx");  			ilGenerator.Ldarg (2).Ldloc (localWriter).Newobj (() => new ServiceWriterCtx ((IServiceInternalServer)null' null)).Castclass (typeof(IWriterCtx)).Stloc (localWriterCtx);  		}  		resultFieldHandler.Save (ilGenerator' il => il.Ldloc (resultFieldHandler.NeedsCtx () ? localWriterCtx : localWriter)' il => il.Ldloc (localResult));  		ilGenerator.Ldarg (2).Ldloc (localWriter).Callvirt (() => default(IServiceInternalServer).FinishResultMarshaling (null));  	}  	ilGenerator.Catch (typeof(Exception)).Stloc (localException).Ldarg (2).Ldloc (localResultId).Ldloc (localException).Callvirt (() => default(IServiceInternalServer).ExceptionMarshaling (0u' null)).EndTry ();  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (binding.OneWay) {  	if (returnType != typeof(void))  		ilGenerator.Pop ();  } else {  	if (localResult == null) {  		if (isAsync) {  			ilGenerator.Ldarg (2).Ldloc (localResultId).Newobj (CreateTaskContinuationWithResultMarshaling (methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler)).Pop ();  		} else {  			if (methodInf.MethodInfo.ReturnType != typeof(void))  				ilGenerator.Pop ();  			ilGenerator.Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).VoidResultMarshaling (0u));  		}  	} else {  		_typeConvertorGenerator.GenerateConversion (returnType' localResult.LocalType) (ilGenerator);  		ilGenerator.Stloc (localResult).Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).StartResultMarshaling (0u)).Stloc (localWriter);  		IILLocal localWriterCtx = null;  		if (resultFieldHandler.NeedsCtx ()) {  			localWriterCtx = ilGenerator.DeclareLocal (typeof(IWriterCtx)' "writerCtx");  			ilGenerator.Ldarg (2).Ldloc (localWriter).Newobj (() => new ServiceWriterCtx ((IServiceInternalServer)null' null)).Castclass (typeof(IWriterCtx)).Stloc (localWriterCtx);  		}  		resultFieldHandler.Save (ilGenerator' il => il.Ldloc (resultFieldHandler.NeedsCtx () ? localWriterCtx : localWriter)' il => il.Ldloc (localResult));  		ilGenerator.Ldarg (2).Ldloc (localWriter).Callvirt (() => default(IServiceInternalServer).FinishResultMarshaling (null));  	}  	ilGenerator.Catch (typeof(Exception)).Stloc (localException).Ldarg (2).Ldloc (localResultId).Ldloc (localException).Callvirt (() => default(IServiceInternalServer).ExceptionMarshaling (0u' null)).EndTry ();  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (binding.OneWay) {  	if (returnType != typeof(void))  		ilGenerator.Pop ();  } else {  	if (localResult == null) {  		if (isAsync) {  			ilGenerator.Ldarg (2).Ldloc (localResultId).Newobj (CreateTaskContinuationWithResultMarshaling (methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler)).Pop ();  		} else {  			if (methodInf.MethodInfo.ReturnType != typeof(void))  				ilGenerator.Pop ();  			ilGenerator.Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).VoidResultMarshaling (0u));  		}  	} else {  		_typeConvertorGenerator.GenerateConversion (returnType' localResult.LocalType) (ilGenerator);  		ilGenerator.Stloc (localResult).Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).StartResultMarshaling (0u)).Stloc (localWriter);  		IILLocal localWriterCtx = null;  		if (resultFieldHandler.NeedsCtx ()) {  			localWriterCtx = ilGenerator.DeclareLocal (typeof(IWriterCtx)' "writerCtx");  			ilGenerator.Ldarg (2).Ldloc (localWriter).Newobj (() => new ServiceWriterCtx ((IServiceInternalServer)null' null)).Castclass (typeof(IWriterCtx)).Stloc (localWriterCtx);  		}  		resultFieldHandler.Save (ilGenerator' il => il.Ldloc (resultFieldHandler.NeedsCtx () ? localWriterCtx : localWriter)' il => il.Ldloc (localResult));  		ilGenerator.Ldarg (2).Ldloc (localWriter).Callvirt (() => default(IServiceInternalServer).FinishResultMarshaling (null));  	}  	ilGenerator.Catch (typeof(Exception)).Stloc (localException).Ldarg (2).Ldloc (localResultId).Ldloc (localException).Callvirt (() => default(IServiceInternalServer).ExceptionMarshaling (0u' null)).EndTry ();  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (binding.OneWay) {  	if (returnType != typeof(void))  		ilGenerator.Pop ();  } else {  	if (localResult == null) {  		if (isAsync) {  			ilGenerator.Ldarg (2).Ldloc (localResultId).Newobj (CreateTaskContinuationWithResultMarshaling (methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler)).Pop ();  		} else {  			if (methodInf.MethodInfo.ReturnType != typeof(void))  				ilGenerator.Pop ();  			ilGenerator.Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).VoidResultMarshaling (0u));  		}  	} else {  		_typeConvertorGenerator.GenerateConversion (returnType' localResult.LocalType) (ilGenerator);  		ilGenerator.Stloc (localResult).Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).StartResultMarshaling (0u)).Stloc (localWriter);  		IILLocal localWriterCtx = null;  		if (resultFieldHandler.NeedsCtx ()) {  			localWriterCtx = ilGenerator.DeclareLocal (typeof(IWriterCtx)' "writerCtx");  			ilGenerator.Ldarg (2).Ldloc (localWriter).Newobj (() => new ServiceWriterCtx ((IServiceInternalServer)null' null)).Castclass (typeof(IWriterCtx)).Stloc (localWriterCtx);  		}  		resultFieldHandler.Save (ilGenerator' il => il.Ldloc (resultFieldHandler.NeedsCtx () ? localWriterCtx : localWriter)' il => il.Ldloc (localResult));  		ilGenerator.Ldarg (2).Ldloc (localWriter).Callvirt (() => default(IServiceInternalServer).FinishResultMarshaling (null));  	}  	ilGenerator.Catch (typeof(Exception)).Stloc (localException).Ldarg (2).Ldloc (localResultId).Ldloc (localException).Callvirt (() => default(IServiceInternalServer).ExceptionMarshaling (0u' null)).EndTry ();  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (localResult == null) {  	if (isAsync) {  		ilGenerator.Ldarg (2).Ldloc (localResultId).Newobj (CreateTaskContinuationWithResultMarshaling (methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler)).Pop ();  	} else {  		if (methodInf.MethodInfo.ReturnType != typeof(void))  			ilGenerator.Pop ();  		ilGenerator.Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).VoidResultMarshaling (0u));  	}  } else {  	_typeConvertorGenerator.GenerateConversion (returnType' localResult.LocalType) (ilGenerator);  	ilGenerator.Stloc (localResult).Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).StartResultMarshaling (0u)).Stloc (localWriter);  	IILLocal localWriterCtx = null;  	if (resultFieldHandler.NeedsCtx ()) {  		localWriterCtx = ilGenerator.DeclareLocal (typeof(IWriterCtx)' "writerCtx");  		ilGenerator.Ldarg (2).Ldloc (localWriter).Newobj (() => new ServiceWriterCtx ((IServiceInternalServer)null' null)).Castclass (typeof(IWriterCtx)).Stloc (localWriterCtx);  	}  	resultFieldHandler.Save (ilGenerator' il => il.Ldloc (resultFieldHandler.NeedsCtx () ? localWriterCtx : localWriter)' il => il.Ldloc (localResult));  	ilGenerator.Ldarg (2).Ldloc (localWriter).Callvirt (() => default(IServiceInternalServer).FinishResultMarshaling (null));  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (localResult == null) {  	if (isAsync) {  		ilGenerator.Ldarg (2).Ldloc (localResultId).Newobj (CreateTaskContinuationWithResultMarshaling (methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler)).Pop ();  	} else {  		if (methodInf.MethodInfo.ReturnType != typeof(void))  			ilGenerator.Pop ();  		ilGenerator.Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).VoidResultMarshaling (0u));  	}  } else {  	_typeConvertorGenerator.GenerateConversion (returnType' localResult.LocalType) (ilGenerator);  	ilGenerator.Stloc (localResult).Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).StartResultMarshaling (0u)).Stloc (localWriter);  	IILLocal localWriterCtx = null;  	if (resultFieldHandler.NeedsCtx ()) {  		localWriterCtx = ilGenerator.DeclareLocal (typeof(IWriterCtx)' "writerCtx");  		ilGenerator.Ldarg (2).Ldloc (localWriter).Newobj (() => new ServiceWriterCtx ((IServiceInternalServer)null' null)).Castclass (typeof(IWriterCtx)).Stloc (localWriterCtx);  	}  	resultFieldHandler.Save (ilGenerator' il => il.Ldloc (resultFieldHandler.NeedsCtx () ? localWriterCtx : localWriter)' il => il.Ldloc (localResult));  	ilGenerator.Ldarg (2).Ldloc (localWriter).Callvirt (() => default(IServiceInternalServer).FinishResultMarshaling (null));  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (localResult == null) {  	if (isAsync) {  		ilGenerator.Ldarg (2).Ldloc (localResultId).Newobj (CreateTaskContinuationWithResultMarshaling (methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler)).Pop ();  	} else {  		if (methodInf.MethodInfo.ReturnType != typeof(void))  			ilGenerator.Pop ();  		ilGenerator.Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).VoidResultMarshaling (0u));  	}  } else {  	_typeConvertorGenerator.GenerateConversion (returnType' localResult.LocalType) (ilGenerator);  	ilGenerator.Stloc (localResult).Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).StartResultMarshaling (0u)).Stloc (localWriter);  	IILLocal localWriterCtx = null;  	if (resultFieldHandler.NeedsCtx ()) {  		localWriterCtx = ilGenerator.DeclareLocal (typeof(IWriterCtx)' "writerCtx");  		ilGenerator.Ldarg (2).Ldloc (localWriter).Newobj (() => new ServiceWriterCtx ((IServiceInternalServer)null' null)).Castclass (typeof(IWriterCtx)).Stloc (localWriterCtx);  	}  	resultFieldHandler.Save (ilGenerator' il => il.Ldloc (resultFieldHandler.NeedsCtx () ? localWriterCtx : localWriter)' il => il.Ldloc (localResult));  	ilGenerator.Ldarg (2).Ldloc (localWriter).Callvirt (() => default(IServiceInternalServer).FinishResultMarshaling (null));  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (localResult == null) {  	if (isAsync) {  		ilGenerator.Ldarg (2).Ldloc (localResultId).Newobj (CreateTaskContinuationWithResultMarshaling (methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler)).Pop ();  	} else {  		if (methodInf.MethodInfo.ReturnType != typeof(void))  			ilGenerator.Pop ();  		ilGenerator.Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).VoidResultMarshaling (0u));  	}  } else {  	_typeConvertorGenerator.GenerateConversion (returnType' localResult.LocalType) (ilGenerator);  	ilGenerator.Stloc (localResult).Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).StartResultMarshaling (0u)).Stloc (localWriter);  	IILLocal localWriterCtx = null;  	if (resultFieldHandler.NeedsCtx ()) {  		localWriterCtx = ilGenerator.DeclareLocal (typeof(IWriterCtx)' "writerCtx");  		ilGenerator.Ldarg (2).Ldloc (localWriter).Newobj (() => new ServiceWriterCtx ((IServiceInternalServer)null' null)).Castclass (typeof(IWriterCtx)).Stloc (localWriterCtx);  	}  	resultFieldHandler.Save (ilGenerator' il => il.Ldloc (resultFieldHandler.NeedsCtx () ? localWriterCtx : localWriter)' il => il.Ldloc (localResult));  	ilGenerator.Ldarg (2).Ldloc (localWriter).Callvirt (() => default(IServiceInternalServer).FinishResultMarshaling (null));  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (localResult == null) {  	if (isAsync) {  		ilGenerator.Ldarg (2).Ldloc (localResultId).Newobj (CreateTaskContinuationWithResultMarshaling (methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler)).Pop ();  	} else {  		if (methodInf.MethodInfo.ReturnType != typeof(void))  			ilGenerator.Pop ();  		ilGenerator.Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).VoidResultMarshaling (0u));  	}  } else {  	_typeConvertorGenerator.GenerateConversion (returnType' localResult.LocalType) (ilGenerator);  	ilGenerator.Stloc (localResult).Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).StartResultMarshaling (0u)).Stloc (localWriter);  	IILLocal localWriterCtx = null;  	if (resultFieldHandler.NeedsCtx ()) {  		localWriterCtx = ilGenerator.DeclareLocal (typeof(IWriterCtx)' "writerCtx");  		ilGenerator.Ldarg (2).Ldloc (localWriter).Newobj (() => new ServiceWriterCtx ((IServiceInternalServer)null' null)).Castclass (typeof(IWriterCtx)).Stloc (localWriterCtx);  	}  	resultFieldHandler.Save (ilGenerator' il => il.Ldloc (resultFieldHandler.NeedsCtx () ? localWriterCtx : localWriter)' il => il.Ldloc (localResult));  	ilGenerator.Ldarg (2).Ldloc (localWriter).Callvirt (() => default(IServiceInternalServer).FinishResultMarshaling (null));  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (isAsync) {  	ilGenerator.Ldarg (2).Ldloc (localResultId).Newobj (CreateTaskContinuationWithResultMarshaling (methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler)).Pop ();  } else {  	if (methodInf.MethodInfo.ReturnType != typeof(void))  		ilGenerator.Pop ();  	ilGenerator.Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).VoidResultMarshaling (0u));  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (isAsync) {  	ilGenerator.Ldarg (2).Ldloc (localResultId).Newobj (CreateTaskContinuationWithResultMarshaling (methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler)).Pop ();  } else {  	if (methodInf.MethodInfo.ReturnType != typeof(void))  		ilGenerator.Pop ();  	ilGenerator.Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).VoidResultMarshaling (0u));  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: ilGenerator.Ldarg (2).Ldloc (localResultId).Newobj (CreateTaskContinuationWithResultMarshaling (methodInf.MethodInfo.ReturnType' methodInf.ResultFieldHandler)).Pop ();  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: ilGenerator.Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).VoidResultMarshaling (0u));  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: ilGenerator.Stloc (localResult).Ldarg (2).Ldloc (localResultId).Callvirt (() => default(IServiceInternalServer).StartResultMarshaling (0u)).Stloc (localWriter);  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: if (resultFieldHandler.NeedsCtx ()) {  	localWriterCtx = ilGenerator.DeclareLocal (typeof(IWriterCtx)' "writerCtx");  	ilGenerator.Ldarg (2).Ldloc (localWriter).Newobj (() => new ServiceWriterCtx ((IServiceInternalServer)null' null)).Castclass (typeof(IWriterCtx)).Stloc (localWriterCtx);  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: ilGenerator.Ldarg (2).Ldloc (localWriter).Newobj (() => new ServiceWriterCtx ((IServiceInternalServer)null' null)).Castclass (typeof(IWriterCtx)).Stloc (localWriterCtx);  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: ilGenerator.Ldarg (2).Ldloc (localWriter).Callvirt (() => default(IServiceInternalServer).FinishResultMarshaling (null));  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,OnBind,The following statement contains a magic number: ilGenerator.Catch (typeof(Exception)).Stloc (localException).Ldarg (2).Ldloc (localResultId).Ldloc (localException).Callvirt (() => default(IServiceInternalServer).ExceptionMarshaling (0u' null)).EndTry ();  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,CreateTaskContinuationWithResultMarshaling,The following statement contains a magic number: ilGenerator.Ldarg (0).Call (() => new object ()).Ldarg (0).Ldarg (2).Stfld (ownerField).Ldarg (0).Ldarg (3).Stfld (resultIdField).Ldarg (1).Ldarg (0).Ldftn (methodBuilder).Newobj (actionOfTaskType.GetConstructor (new[] {  	typeof(object)'  	typeof(IntPtr)  })).Callvirt (taskType.GetMethod ("ContinueWith"' new[] {  	actionOfTaskType  })).Pop ().Ret ();  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,CreateTaskContinuationWithResultMarshaling,The following statement contains a magic number: ilGenerator.Ldarg (0).Call (() => new object ()).Ldarg (0).Ldarg (2).Stfld (ownerField).Ldarg (0).Ldarg (3).Stfld (resultIdField).Ldarg (1).Ldarg (0).Ldftn (methodBuilder).Newobj (actionOfTaskType.GetConstructor (new[] {  	typeof(object)'  	typeof(IntPtr)  })).Callvirt (taskType.GetMethod ("ContinueWith"' new[] {  	actionOfTaskType  })).Pop ().Ret ();  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: for (int sourceMethodIndex = 0; sourceMethodIndex < typeInf.MethodInfs.Length; sourceMethodIndex++) {  	var methodInf = typeInf.MethodInfs [sourceMethodIndex];  	var methodInfo = methodInf.MethodInfo;  	var bindingField = tb.DefineField (typeof(ClientBindInf)' FieldAttributes.Private);  	bindingFields.Add (bindingField);  	var parameterTypes = methodInfo.GetParameters ().Select (pi => pi.ParameterType).ToArray ();  	var returnType = methodInfo.ReturnType.UnwrapTask ();  	var isAsync = returnType != methodInfo.ReturnType;  	var methodBuilder = tb.DefineMethod (methodInfo.Name' methodInfo.ReturnType' parameterTypes' MethodAttributes.Public | MethodAttributes.Virtual);  	ilGenerator = methodBuilder.Generator;  	var targetMethodInf = bestServiceTypeInf.MethodInfs [mapping [sourceMethodIndex] [0]];  	var targetMethodIndex = Array.IndexOf (bestServiceTypeInf.MethodInfs' targetMethodInf);  	var bindingId = _clientBindNumbers.Allocate ();  	Type resultAsTask;  	Type resultAsTcs;  	if (returnType != typeof(void)) {  		resultAsTask = typeof(Task<>).MakeGenericType (returnType);  		resultAsTcs = typeof(TaskCompletionSource<>).MakeGenericType (returnType);  	} else {  		resultAsTask = typeof(Task);  		resultAsTcs = typeof(TaskCompletionSource<bool>);  	}  	var bindingInf = new ClientBindInf {  		BindingId = bindingId'  		ServiceId = bestServiceId'  		MethodId = (uint)targetMethodIndex'  		OneWay = !isAsync && returnType == typeof(void)  	};  	_clientBindings.TryAdd (bindingId' bindingInf);  	bindings.Add (bindingInf);  	var writer = new ByteBufferWriter ();  	writer.WriteVUInt32 ((uint)Command.Subcommand);  	writer.WriteVUInt32 ((uint)Subcommand.Bind);  	bindingInf.Store (writer);  	_channel.Send (writer.Data);  	IILLocal resultTaskLocal = null;  	if (!bindingInf.OneWay) {  		resultTaskLocal = ilGenerator.DeclareLocal (typeof(Task)' "resultTask");  	}  	var writerLocal = ilGenerator.DeclareLocal (typeof(AbstractBufferedWriter));  	ilGenerator.Ldarg (0).Ldfld (ownerField).Ldarg (0).Ldfld (bindingField);  	if (bindingInf.OneWay) {  		ilGenerator.Callvirt (() => default(IServiceInternalClient).StartOneWayMarshaling (null));  	} else {  		Task placebo;  		ilGenerator.Ldloca (resultTaskLocal).Callvirt (() => default(IServiceInternalClient).StartTwoWayMarshaling (null' out placebo));  	}  	ilGenerator.Stloc (writerLocal);  	var needsCtx = targetMethodInf.Parameters.Any (p => p.FieldHandler.NeedsCtx ());  	IILLocal writerCtxLocal = null;  	if (needsCtx) {  		writerCtxLocal = ilGenerator.DeclareLocal (typeof(IWriterCtx));  		ilGenerator.Ldarg (0).Ldfld (ownerField).Ldloc (writerLocal).Newobj (() => new ServiceWriterCtx ((IServiceInternalClient)null' null)).Castclass (typeof(IWriterCtx)).Stloc (writerCtxLocal);  	}  	for (int paramOrder = 0; paramOrder < targetMethodInf.Parameters.Length; paramOrder++) {  		var parameterInf = targetMethodInf.Parameters [paramOrder];  		var sourceParamIndex = mapping [sourceMethodIndex] [paramOrder + 1];  		Type inputType;  		Action<IILGen> loadInput;  		if (sourceParamIndex != uint.MaxValue) {  			inputType = parameterTypes [sourceParamIndex];  			loadInput = il => il.Ldarg ((ushort)(sourceParamIndex + 1));  		} else {  			inputType = null;  			loadInput = null;  		}  		Action<IILGen> pushWriterOrCtx;  		var fieldHandler = parameterInf.FieldHandler;  		if (fieldHandler.NeedsCtx ())  			pushWriterOrCtx = il => il.Ldloc (writerCtxLocal);  		else  			pushWriterOrCtx = il => il.Ldloc (writerLocal);  		GenerateOneFieldHandlerSave (loadInput' fieldHandler' inputType' ilGenerator' pushWriterOrCtx);  	}  	ilGenerator.Ldarg (0).Ldfld (ownerField).Ldloc (writerLocal);  	if (bindingInf.OneWay)  		ilGenerator.Callvirt (() => default(IServiceInternalClient).FinishOneWayMarshaling (null));  	else {  		ilGenerator.Callvirt (() => default(IServiceInternalClient).FinishTwoWayMarshaling (null)).Ldloc (resultTaskLocal).Castclass (resultAsTask);  		if (!isAsync)  			ilGenerator.Callvirt (resultAsTask.GetMethod ("get_Result"));  	}  	ilGenerator.Ret ();  	if (!isDelegate)  		tb.DefineMethodOverride (methodBuilder' methodInfo);  	if (bindingInf.OneWay) {  		bindingResultTypes.Add ("");  		continue;  	}  	if (bindingResultTypes.Contains (returnType.FullName)) {  		bindingResultTypes.Add (returnType.FullName);  		continue;  	}  	bindingResultTypes.Add (returnType.FullName);  	methodBuilder = tb.DefineMethod ("HandleResult_" + returnType.FullName' typeof(void)' new[] {  		typeof(object)'  		typeof(AbstractBufferedReader)'  		typeof(IServiceInternalClient)  	}' MethodAttributes.Public | MethodAttributes.Static);  	ilGenerator = methodBuilder.Generator;  	var localException = ilGenerator.DeclareLocal (typeof(Exception)' "ex");  	ilGenerator.Try ().Ldarg (0).Castclass (resultAsTcs);  	if (targetMethodInf.ResultFieldHandler == null && returnType == typeof(void)) {  		ilGenerator.Ldnull ();  	} else {  		var specializedLoad = targetMethodInf.ResultFieldHandler.SpecializeLoadForType (returnType' null);  		if (specializedLoad.NeedsCtx ()) {  			var readerCtxLocal = ilGenerator.DeclareLocal (typeof(IReaderCtx));  			ilGenerator.Ldarg (2).Ldarg (1).Newobj (() => new ServiceReaderCtx ((IServiceInternalClient)null' null)).Castclass (typeof(IReaderCtx)).Stloc (readerCtxLocal);  			specializedLoad.Load (ilGenerator' il => il.Ldloc (readerCtxLocal));  		} else {  			specializedLoad.Load (ilGenerator' il => il.Ldarg (1));  		}  		_typeConvertorGenerator.GenerateConversion (specializedLoad.HandledType ()' returnType) (ilGenerator);  	}  	ilGenerator.Callvirt (resultAsTcs.GetMethod ("TrySetResult")).Pop ().Catch (typeof(Exception)).Stloc (localException).Ldarg (0).Castclass (resultAsTcs).Ldloc (localException).Callvirt (resultAsTcs.GetMethod ("TrySetException"' new[] {  		typeof(Exception)  	})).EndTry ().Ret ();  	methodBuilder = tb.DefineMethod ("HandleException_" + returnType.FullName' typeof(void)' new[] {  		typeof(object)'  		typeof(Exception)  	}' MethodAttributes.Public | MethodAttributes.Static);  	methodBuilder.ExpectedLength (16);  	ilGenerator = methodBuilder.Generator;  	ilGenerator.Ldarg (0).Castclass (resultAsTcs).Ldarg (1).Callvirt (resultAsTcs.GetMethod ("TrySetException"' new[] {  		typeof(Exception)  	})).Pop ().Ret ();  	methodBuilder = tb.DefineMethod ("HandleCancellation_" + returnType.FullName' typeof(void)' new[] {  		typeof(object)  	}' MethodAttributes.Public | MethodAttributes.Static);  	methodBuilder.ExpectedLength (16);  	ilGenerator = methodBuilder.Generator;  	ilGenerator.Ldarg (0).Castclass (resultAsTcs).Callvirt (resultAsTcs.GetMethod ("TrySetCanceled"' Type.EmptyTypes)).Pop ().Ret ();  	methodBuilder = tb.DefineMethod ("TaskWithSourceCreator_" + returnType.FullName' typeof(TaskWithSource)' Type.EmptyTypes' MethodAttributes.Public | MethodAttributes.Static);  	methodBuilder.ExpectedLength (32);  	ilGenerator = methodBuilder.Generator;  	ilGenerator.DeclareLocal (resultAsTcs);  	ilGenerator.Newobj (resultAsTcs.GetConstructor (Type.EmptyTypes)).Stloc (0).Ldloc (0).Ldloc (0).Callvirt (resultAsTcs.GetMethod ("get_Task")).Newobj (() => new TaskWithSource (null' null)).Ret ();  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: for (int sourceMethodIndex = 0; sourceMethodIndex < typeInf.MethodInfs.Length; sourceMethodIndex++) {  	var methodInf = typeInf.MethodInfs [sourceMethodIndex];  	var methodInfo = methodInf.MethodInfo;  	var bindingField = tb.DefineField (typeof(ClientBindInf)' FieldAttributes.Private);  	bindingFields.Add (bindingField);  	var parameterTypes = methodInfo.GetParameters ().Select (pi => pi.ParameterType).ToArray ();  	var returnType = methodInfo.ReturnType.UnwrapTask ();  	var isAsync = returnType != methodInfo.ReturnType;  	var methodBuilder = tb.DefineMethod (methodInfo.Name' methodInfo.ReturnType' parameterTypes' MethodAttributes.Public | MethodAttributes.Virtual);  	ilGenerator = methodBuilder.Generator;  	var targetMethodInf = bestServiceTypeInf.MethodInfs [mapping [sourceMethodIndex] [0]];  	var targetMethodIndex = Array.IndexOf (bestServiceTypeInf.MethodInfs' targetMethodInf);  	var bindingId = _clientBindNumbers.Allocate ();  	Type resultAsTask;  	Type resultAsTcs;  	if (returnType != typeof(void)) {  		resultAsTask = typeof(Task<>).MakeGenericType (returnType);  		resultAsTcs = typeof(TaskCompletionSource<>).MakeGenericType (returnType);  	} else {  		resultAsTask = typeof(Task);  		resultAsTcs = typeof(TaskCompletionSource<bool>);  	}  	var bindingInf = new ClientBindInf {  		BindingId = bindingId'  		ServiceId = bestServiceId'  		MethodId = (uint)targetMethodIndex'  		OneWay = !isAsync && returnType == typeof(void)  	};  	_clientBindings.TryAdd (bindingId' bindingInf);  	bindings.Add (bindingInf);  	var writer = new ByteBufferWriter ();  	writer.WriteVUInt32 ((uint)Command.Subcommand);  	writer.WriteVUInt32 ((uint)Subcommand.Bind);  	bindingInf.Store (writer);  	_channel.Send (writer.Data);  	IILLocal resultTaskLocal = null;  	if (!bindingInf.OneWay) {  		resultTaskLocal = ilGenerator.DeclareLocal (typeof(Task)' "resultTask");  	}  	var writerLocal = ilGenerator.DeclareLocal (typeof(AbstractBufferedWriter));  	ilGenerator.Ldarg (0).Ldfld (ownerField).Ldarg (0).Ldfld (bindingField);  	if (bindingInf.OneWay) {  		ilGenerator.Callvirt (() => default(IServiceInternalClient).StartOneWayMarshaling (null));  	} else {  		Task placebo;  		ilGenerator.Ldloca (resultTaskLocal).Callvirt (() => default(IServiceInternalClient).StartTwoWayMarshaling (null' out placebo));  	}  	ilGenerator.Stloc (writerLocal);  	var needsCtx = targetMethodInf.Parameters.Any (p => p.FieldHandler.NeedsCtx ());  	IILLocal writerCtxLocal = null;  	if (needsCtx) {  		writerCtxLocal = ilGenerator.DeclareLocal (typeof(IWriterCtx));  		ilGenerator.Ldarg (0).Ldfld (ownerField).Ldloc (writerLocal).Newobj (() => new ServiceWriterCtx ((IServiceInternalClient)null' null)).Castclass (typeof(IWriterCtx)).Stloc (writerCtxLocal);  	}  	for (int paramOrder = 0; paramOrder < targetMethodInf.Parameters.Length; paramOrder++) {  		var parameterInf = targetMethodInf.Parameters [paramOrder];  		var sourceParamIndex = mapping [sourceMethodIndex] [paramOrder + 1];  		Type inputType;  		Action<IILGen> loadInput;  		if (sourceParamIndex != uint.MaxValue) {  			inputType = parameterTypes [sourceParamIndex];  			loadInput = il => il.Ldarg ((ushort)(sourceParamIndex + 1));  		} else {  			inputType = null;  			loadInput = null;  		}  		Action<IILGen> pushWriterOrCtx;  		var fieldHandler = parameterInf.FieldHandler;  		if (fieldHandler.NeedsCtx ())  			pushWriterOrCtx = il => il.Ldloc (writerCtxLocal);  		else  			pushWriterOrCtx = il => il.Ldloc (writerLocal);  		GenerateOneFieldHandlerSave (loadInput' fieldHandler' inputType' ilGenerator' pushWriterOrCtx);  	}  	ilGenerator.Ldarg (0).Ldfld (ownerField).Ldloc (writerLocal);  	if (bindingInf.OneWay)  		ilGenerator.Callvirt (() => default(IServiceInternalClient).FinishOneWayMarshaling (null));  	else {  		ilGenerator.Callvirt (() => default(IServiceInternalClient).FinishTwoWayMarshaling (null)).Ldloc (resultTaskLocal).Castclass (resultAsTask);  		if (!isAsync)  			ilGenerator.Callvirt (resultAsTask.GetMethod ("get_Result"));  	}  	ilGenerator.Ret ();  	if (!isDelegate)  		tb.DefineMethodOverride (methodBuilder' methodInfo);  	if (bindingInf.OneWay) {  		bindingResultTypes.Add ("");  		continue;  	}  	if (bindingResultTypes.Contains (returnType.FullName)) {  		bindingResultTypes.Add (returnType.FullName);  		continue;  	}  	bindingResultTypes.Add (returnType.FullName);  	methodBuilder = tb.DefineMethod ("HandleResult_" + returnType.FullName' typeof(void)' new[] {  		typeof(object)'  		typeof(AbstractBufferedReader)'  		typeof(IServiceInternalClient)  	}' MethodAttributes.Public | MethodAttributes.Static);  	ilGenerator = methodBuilder.Generator;  	var localException = ilGenerator.DeclareLocal (typeof(Exception)' "ex");  	ilGenerator.Try ().Ldarg (0).Castclass (resultAsTcs);  	if (targetMethodInf.ResultFieldHandler == null && returnType == typeof(void)) {  		ilGenerator.Ldnull ();  	} else {  		var specializedLoad = targetMethodInf.ResultFieldHandler.SpecializeLoadForType (returnType' null);  		if (specializedLoad.NeedsCtx ()) {  			var readerCtxLocal = ilGenerator.DeclareLocal (typeof(IReaderCtx));  			ilGenerator.Ldarg (2).Ldarg (1).Newobj (() => new ServiceReaderCtx ((IServiceInternalClient)null' null)).Castclass (typeof(IReaderCtx)).Stloc (readerCtxLocal);  			specializedLoad.Load (ilGenerator' il => il.Ldloc (readerCtxLocal));  		} else {  			specializedLoad.Load (ilGenerator' il => il.Ldarg (1));  		}  		_typeConvertorGenerator.GenerateConversion (specializedLoad.HandledType ()' returnType) (ilGenerator);  	}  	ilGenerator.Callvirt (resultAsTcs.GetMethod ("TrySetResult")).Pop ().Catch (typeof(Exception)).Stloc (localException).Ldarg (0).Castclass (resultAsTcs).Ldloc (localException).Callvirt (resultAsTcs.GetMethod ("TrySetException"' new[] {  		typeof(Exception)  	})).EndTry ().Ret ();  	methodBuilder = tb.DefineMethod ("HandleException_" + returnType.FullName' typeof(void)' new[] {  		typeof(object)'  		typeof(Exception)  	}' MethodAttributes.Public | MethodAttributes.Static);  	methodBuilder.ExpectedLength (16);  	ilGenerator = methodBuilder.Generator;  	ilGenerator.Ldarg (0).Castclass (resultAsTcs).Ldarg (1).Callvirt (resultAsTcs.GetMethod ("TrySetException"' new[] {  		typeof(Exception)  	})).Pop ().Ret ();  	methodBuilder = tb.DefineMethod ("HandleCancellation_" + returnType.FullName' typeof(void)' new[] {  		typeof(object)  	}' MethodAttributes.Public | MethodAttributes.Static);  	methodBuilder.ExpectedLength (16);  	ilGenerator = methodBuilder.Generator;  	ilGenerator.Ldarg (0).Castclass (resultAsTcs).Callvirt (resultAsTcs.GetMethod ("TrySetCanceled"' Type.EmptyTypes)).Pop ().Ret ();  	methodBuilder = tb.DefineMethod ("TaskWithSourceCreator_" + returnType.FullName' typeof(TaskWithSource)' Type.EmptyTypes' MethodAttributes.Public | MethodAttributes.Static);  	methodBuilder.ExpectedLength (32);  	ilGenerator = methodBuilder.Generator;  	ilGenerator.DeclareLocal (resultAsTcs);  	ilGenerator.Newobj (resultAsTcs.GetConstructor (Type.EmptyTypes)).Stloc (0).Ldloc (0).Ldloc (0).Callvirt (resultAsTcs.GetMethod ("get_Task")).Newobj (() => new TaskWithSource (null' null)).Ret ();  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: for (int sourceMethodIndex = 0; sourceMethodIndex < typeInf.MethodInfs.Length; sourceMethodIndex++) {  	var methodInf = typeInf.MethodInfs [sourceMethodIndex];  	var methodInfo = methodInf.MethodInfo;  	var bindingField = tb.DefineField (typeof(ClientBindInf)' FieldAttributes.Private);  	bindingFields.Add (bindingField);  	var parameterTypes = methodInfo.GetParameters ().Select (pi => pi.ParameterType).ToArray ();  	var returnType = methodInfo.ReturnType.UnwrapTask ();  	var isAsync = returnType != methodInfo.ReturnType;  	var methodBuilder = tb.DefineMethod (methodInfo.Name' methodInfo.ReturnType' parameterTypes' MethodAttributes.Public | MethodAttributes.Virtual);  	ilGenerator = methodBuilder.Generator;  	var targetMethodInf = bestServiceTypeInf.MethodInfs [mapping [sourceMethodIndex] [0]];  	var targetMethodIndex = Array.IndexOf (bestServiceTypeInf.MethodInfs' targetMethodInf);  	var bindingId = _clientBindNumbers.Allocate ();  	Type resultAsTask;  	Type resultAsTcs;  	if (returnType != typeof(void)) {  		resultAsTask = typeof(Task<>).MakeGenericType (returnType);  		resultAsTcs = typeof(TaskCompletionSource<>).MakeGenericType (returnType);  	} else {  		resultAsTask = typeof(Task);  		resultAsTcs = typeof(TaskCompletionSource<bool>);  	}  	var bindingInf = new ClientBindInf {  		BindingId = bindingId'  		ServiceId = bestServiceId'  		MethodId = (uint)targetMethodIndex'  		OneWay = !isAsync && returnType == typeof(void)  	};  	_clientBindings.TryAdd (bindingId' bindingInf);  	bindings.Add (bindingInf);  	var writer = new ByteBufferWriter ();  	writer.WriteVUInt32 ((uint)Command.Subcommand);  	writer.WriteVUInt32 ((uint)Subcommand.Bind);  	bindingInf.Store (writer);  	_channel.Send (writer.Data);  	IILLocal resultTaskLocal = null;  	if (!bindingInf.OneWay) {  		resultTaskLocal = ilGenerator.DeclareLocal (typeof(Task)' "resultTask");  	}  	var writerLocal = ilGenerator.DeclareLocal (typeof(AbstractBufferedWriter));  	ilGenerator.Ldarg (0).Ldfld (ownerField).Ldarg (0).Ldfld (bindingField);  	if (bindingInf.OneWay) {  		ilGenerator.Callvirt (() => default(IServiceInternalClient).StartOneWayMarshaling (null));  	} else {  		Task placebo;  		ilGenerator.Ldloca (resultTaskLocal).Callvirt (() => default(IServiceInternalClient).StartTwoWayMarshaling (null' out placebo));  	}  	ilGenerator.Stloc (writerLocal);  	var needsCtx = targetMethodInf.Parameters.Any (p => p.FieldHandler.NeedsCtx ());  	IILLocal writerCtxLocal = null;  	if (needsCtx) {  		writerCtxLocal = ilGenerator.DeclareLocal (typeof(IWriterCtx));  		ilGenerator.Ldarg (0).Ldfld (ownerField).Ldloc (writerLocal).Newobj (() => new ServiceWriterCtx ((IServiceInternalClient)null' null)).Castclass (typeof(IWriterCtx)).Stloc (writerCtxLocal);  	}  	for (int paramOrder = 0; paramOrder < targetMethodInf.Parameters.Length; paramOrder++) {  		var parameterInf = targetMethodInf.Parameters [paramOrder];  		var sourceParamIndex = mapping [sourceMethodIndex] [paramOrder + 1];  		Type inputType;  		Action<IILGen> loadInput;  		if (sourceParamIndex != uint.MaxValue) {  			inputType = parameterTypes [sourceParamIndex];  			loadInput = il => il.Ldarg ((ushort)(sourceParamIndex + 1));  		} else {  			inputType = null;  			loadInput = null;  		}  		Action<IILGen> pushWriterOrCtx;  		var fieldHandler = parameterInf.FieldHandler;  		if (fieldHandler.NeedsCtx ())  			pushWriterOrCtx = il => il.Ldloc (writerCtxLocal);  		else  			pushWriterOrCtx = il => il.Ldloc (writerLocal);  		GenerateOneFieldHandlerSave (loadInput' fieldHandler' inputType' ilGenerator' pushWriterOrCtx);  	}  	ilGenerator.Ldarg (0).Ldfld (ownerField).Ldloc (writerLocal);  	if (bindingInf.OneWay)  		ilGenerator.Callvirt (() => default(IServiceInternalClient).FinishOneWayMarshaling (null));  	else {  		ilGenerator.Callvirt (() => default(IServiceInternalClient).FinishTwoWayMarshaling (null)).Ldloc (resultTaskLocal).Castclass (resultAsTask);  		if (!isAsync)  			ilGenerator.Callvirt (resultAsTask.GetMethod ("get_Result"));  	}  	ilGenerator.Ret ();  	if (!isDelegate)  		tb.DefineMethodOverride (methodBuilder' methodInfo);  	if (bindingInf.OneWay) {  		bindingResultTypes.Add ("");  		continue;  	}  	if (bindingResultTypes.Contains (returnType.FullName)) {  		bindingResultTypes.Add (returnType.FullName);  		continue;  	}  	bindingResultTypes.Add (returnType.FullName);  	methodBuilder = tb.DefineMethod ("HandleResult_" + returnType.FullName' typeof(void)' new[] {  		typeof(object)'  		typeof(AbstractBufferedReader)'  		typeof(IServiceInternalClient)  	}' MethodAttributes.Public | MethodAttributes.Static);  	ilGenerator = methodBuilder.Generator;  	var localException = ilGenerator.DeclareLocal (typeof(Exception)' "ex");  	ilGenerator.Try ().Ldarg (0).Castclass (resultAsTcs);  	if (targetMethodInf.ResultFieldHandler == null && returnType == typeof(void)) {  		ilGenerator.Ldnull ();  	} else {  		var specializedLoad = targetMethodInf.ResultFieldHandler.SpecializeLoadForType (returnType' null);  		if (specializedLoad.NeedsCtx ()) {  			var readerCtxLocal = ilGenerator.DeclareLocal (typeof(IReaderCtx));  			ilGenerator.Ldarg (2).Ldarg (1).Newobj (() => new ServiceReaderCtx ((IServiceInternalClient)null' null)).Castclass (typeof(IReaderCtx)).Stloc (readerCtxLocal);  			specializedLoad.Load (ilGenerator' il => il.Ldloc (readerCtxLocal));  		} else {  			specializedLoad.Load (ilGenerator' il => il.Ldarg (1));  		}  		_typeConvertorGenerator.GenerateConversion (specializedLoad.HandledType ()' returnType) (ilGenerator);  	}  	ilGenerator.Callvirt (resultAsTcs.GetMethod ("TrySetResult")).Pop ().Catch (typeof(Exception)).Stloc (localException).Ldarg (0).Castclass (resultAsTcs).Ldloc (localException).Callvirt (resultAsTcs.GetMethod ("TrySetException"' new[] {  		typeof(Exception)  	})).EndTry ().Ret ();  	methodBuilder = tb.DefineMethod ("HandleException_" + returnType.FullName' typeof(void)' new[] {  		typeof(object)'  		typeof(Exception)  	}' MethodAttributes.Public | MethodAttributes.Static);  	methodBuilder.ExpectedLength (16);  	ilGenerator = methodBuilder.Generator;  	ilGenerator.Ldarg (0).Castclass (resultAsTcs).Ldarg (1).Callvirt (resultAsTcs.GetMethod ("TrySetException"' new[] {  		typeof(Exception)  	})).Pop ().Ret ();  	methodBuilder = tb.DefineMethod ("HandleCancellation_" + returnType.FullName' typeof(void)' new[] {  		typeof(object)  	}' MethodAttributes.Public | MethodAttributes.Static);  	methodBuilder.ExpectedLength (16);  	ilGenerator = methodBuilder.Generator;  	ilGenerator.Ldarg (0).Castclass (resultAsTcs).Callvirt (resultAsTcs.GetMethod ("TrySetCanceled"' Type.EmptyTypes)).Pop ().Ret ();  	methodBuilder = tb.DefineMethod ("TaskWithSourceCreator_" + returnType.FullName' typeof(TaskWithSource)' Type.EmptyTypes' MethodAttributes.Public | MethodAttributes.Static);  	methodBuilder.ExpectedLength (32);  	ilGenerator = methodBuilder.Generator;  	ilGenerator.DeclareLocal (resultAsTcs);  	ilGenerator.Newobj (resultAsTcs.GetConstructor (Type.EmptyTypes)).Stloc (0).Ldloc (0).Ldloc (0).Callvirt (resultAsTcs.GetMethod ("get_Task")).Newobj (() => new TaskWithSource (null' null)).Ret ();  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: for (int sourceMethodIndex = 0; sourceMethodIndex < typeInf.MethodInfs.Length; sourceMethodIndex++) {  	var methodInf = typeInf.MethodInfs [sourceMethodIndex];  	var methodInfo = methodInf.MethodInfo;  	var bindingField = tb.DefineField (typeof(ClientBindInf)' FieldAttributes.Private);  	bindingFields.Add (bindingField);  	var parameterTypes = methodInfo.GetParameters ().Select (pi => pi.ParameterType).ToArray ();  	var returnType = methodInfo.ReturnType.UnwrapTask ();  	var isAsync = returnType != methodInfo.ReturnType;  	var methodBuilder = tb.DefineMethod (methodInfo.Name' methodInfo.ReturnType' parameterTypes' MethodAttributes.Public | MethodAttributes.Virtual);  	ilGenerator = methodBuilder.Generator;  	var targetMethodInf = bestServiceTypeInf.MethodInfs [mapping [sourceMethodIndex] [0]];  	var targetMethodIndex = Array.IndexOf (bestServiceTypeInf.MethodInfs' targetMethodInf);  	var bindingId = _clientBindNumbers.Allocate ();  	Type resultAsTask;  	Type resultAsTcs;  	if (returnType != typeof(void)) {  		resultAsTask = typeof(Task<>).MakeGenericType (returnType);  		resultAsTcs = typeof(TaskCompletionSource<>).MakeGenericType (returnType);  	} else {  		resultAsTask = typeof(Task);  		resultAsTcs = typeof(TaskCompletionSource<bool>);  	}  	var bindingInf = new ClientBindInf {  		BindingId = bindingId'  		ServiceId = bestServiceId'  		MethodId = (uint)targetMethodIndex'  		OneWay = !isAsync && returnType == typeof(void)  	};  	_clientBindings.TryAdd (bindingId' bindingInf);  	bindings.Add (bindingInf);  	var writer = new ByteBufferWriter ();  	writer.WriteVUInt32 ((uint)Command.Subcommand);  	writer.WriteVUInt32 ((uint)Subcommand.Bind);  	bindingInf.Store (writer);  	_channel.Send (writer.Data);  	IILLocal resultTaskLocal = null;  	if (!bindingInf.OneWay) {  		resultTaskLocal = ilGenerator.DeclareLocal (typeof(Task)' "resultTask");  	}  	var writerLocal = ilGenerator.DeclareLocal (typeof(AbstractBufferedWriter));  	ilGenerator.Ldarg (0).Ldfld (ownerField).Ldarg (0).Ldfld (bindingField);  	if (bindingInf.OneWay) {  		ilGenerator.Callvirt (() => default(IServiceInternalClient).StartOneWayMarshaling (null));  	} else {  		Task placebo;  		ilGenerator.Ldloca (resultTaskLocal).Callvirt (() => default(IServiceInternalClient).StartTwoWayMarshaling (null' out placebo));  	}  	ilGenerator.Stloc (writerLocal);  	var needsCtx = targetMethodInf.Parameters.Any (p => p.FieldHandler.NeedsCtx ());  	IILLocal writerCtxLocal = null;  	if (needsCtx) {  		writerCtxLocal = ilGenerator.DeclareLocal (typeof(IWriterCtx));  		ilGenerator.Ldarg (0).Ldfld (ownerField).Ldloc (writerLocal).Newobj (() => new ServiceWriterCtx ((IServiceInternalClient)null' null)).Castclass (typeof(IWriterCtx)).Stloc (writerCtxLocal);  	}  	for (int paramOrder = 0; paramOrder < targetMethodInf.Parameters.Length; paramOrder++) {  		var parameterInf = targetMethodInf.Parameters [paramOrder];  		var sourceParamIndex = mapping [sourceMethodIndex] [paramOrder + 1];  		Type inputType;  		Action<IILGen> loadInput;  		if (sourceParamIndex != uint.MaxValue) {  			inputType = parameterTypes [sourceParamIndex];  			loadInput = il => il.Ldarg ((ushort)(sourceParamIndex + 1));  		} else {  			inputType = null;  			loadInput = null;  		}  		Action<IILGen> pushWriterOrCtx;  		var fieldHandler = parameterInf.FieldHandler;  		if (fieldHandler.NeedsCtx ())  			pushWriterOrCtx = il => il.Ldloc (writerCtxLocal);  		else  			pushWriterOrCtx = il => il.Ldloc (writerLocal);  		GenerateOneFieldHandlerSave (loadInput' fieldHandler' inputType' ilGenerator' pushWriterOrCtx);  	}  	ilGenerator.Ldarg (0).Ldfld (ownerField).Ldloc (writerLocal);  	if (bindingInf.OneWay)  		ilGenerator.Callvirt (() => default(IServiceInternalClient).FinishOneWayMarshaling (null));  	else {  		ilGenerator.Callvirt (() => default(IServiceInternalClient).FinishTwoWayMarshaling (null)).Ldloc (resultTaskLocal).Castclass (resultAsTask);  		if (!isAsync)  			ilGenerator.Callvirt (resultAsTask.GetMethod ("get_Result"));  	}  	ilGenerator.Ret ();  	if (!isDelegate)  		tb.DefineMethodOverride (methodBuilder' methodInfo);  	if (bindingInf.OneWay) {  		bindingResultTypes.Add ("");  		continue;  	}  	if (bindingResultTypes.Contains (returnType.FullName)) {  		bindingResultTypes.Add (returnType.FullName);  		continue;  	}  	bindingResultTypes.Add (returnType.FullName);  	methodBuilder = tb.DefineMethod ("HandleResult_" + returnType.FullName' typeof(void)' new[] {  		typeof(object)'  		typeof(AbstractBufferedReader)'  		typeof(IServiceInternalClient)  	}' MethodAttributes.Public | MethodAttributes.Static);  	ilGenerator = methodBuilder.Generator;  	var localException = ilGenerator.DeclareLocal (typeof(Exception)' "ex");  	ilGenerator.Try ().Ldarg (0).Castclass (resultAsTcs);  	if (targetMethodInf.ResultFieldHandler == null && returnType == typeof(void)) {  		ilGenerator.Ldnull ();  	} else {  		var specializedLoad = targetMethodInf.ResultFieldHandler.SpecializeLoadForType (returnType' null);  		if (specializedLoad.NeedsCtx ()) {  			var readerCtxLocal = ilGenerator.DeclareLocal (typeof(IReaderCtx));  			ilGenerator.Ldarg (2).Ldarg (1).Newobj (() => new ServiceReaderCtx ((IServiceInternalClient)null' null)).Castclass (typeof(IReaderCtx)).Stloc (readerCtxLocal);  			specializedLoad.Load (ilGenerator' il => il.Ldloc (readerCtxLocal));  		} else {  			specializedLoad.Load (ilGenerator' il => il.Ldarg (1));  		}  		_typeConvertorGenerator.GenerateConversion (specializedLoad.HandledType ()' returnType) (ilGenerator);  	}  	ilGenerator.Callvirt (resultAsTcs.GetMethod ("TrySetResult")).Pop ().Catch (typeof(Exception)).Stloc (localException).Ldarg (0).Castclass (resultAsTcs).Ldloc (localException).Callvirt (resultAsTcs.GetMethod ("TrySetException"' new[] {  		typeof(Exception)  	})).EndTry ().Ret ();  	methodBuilder = tb.DefineMethod ("HandleException_" + returnType.FullName' typeof(void)' new[] {  		typeof(object)'  		typeof(Exception)  	}' MethodAttributes.Public | MethodAttributes.Static);  	methodBuilder.ExpectedLength (16);  	ilGenerator = methodBuilder.Generator;  	ilGenerator.Ldarg (0).Castclass (resultAsTcs).Ldarg (1).Callvirt (resultAsTcs.GetMethod ("TrySetException"' new[] {  		typeof(Exception)  	})).Pop ().Ret ();  	methodBuilder = tb.DefineMethod ("HandleCancellation_" + returnType.FullName' typeof(void)' new[] {  		typeof(object)  	}' MethodAttributes.Public | MethodAttributes.Static);  	methodBuilder.ExpectedLength (16);  	ilGenerator = methodBuilder.Generator;  	ilGenerator.Ldarg (0).Castclass (resultAsTcs).Callvirt (resultAsTcs.GetMethod ("TrySetCanceled"' Type.EmptyTypes)).Pop ().Ret ();  	methodBuilder = tb.DefineMethod ("TaskWithSourceCreator_" + returnType.FullName' typeof(TaskWithSource)' Type.EmptyTypes' MethodAttributes.Public | MethodAttributes.Static);  	methodBuilder.ExpectedLength (32);  	ilGenerator = methodBuilder.Generator;  	ilGenerator.DeclareLocal (resultAsTcs);  	ilGenerator.Newobj (resultAsTcs.GetConstructor (Type.EmptyTypes)).Stloc (0).Ldloc (0).Ldloc (0).Callvirt (resultAsTcs.GetMethod ("get_Task")).Newobj (() => new TaskWithSource (null' null)).Ret ();  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: if (targetMethodInf.ResultFieldHandler == null && returnType == typeof(void)) {  	ilGenerator.Ldnull ();  } else {  	var specializedLoad = targetMethodInf.ResultFieldHandler.SpecializeLoadForType (returnType' null);  	if (specializedLoad.NeedsCtx ()) {  		var readerCtxLocal = ilGenerator.DeclareLocal (typeof(IReaderCtx));  		ilGenerator.Ldarg (2).Ldarg (1).Newobj (() => new ServiceReaderCtx ((IServiceInternalClient)null' null)).Castclass (typeof(IReaderCtx)).Stloc (readerCtxLocal);  		specializedLoad.Load (ilGenerator' il => il.Ldloc (readerCtxLocal));  	} else {  		specializedLoad.Load (ilGenerator' il => il.Ldarg (1));  	}  	_typeConvertorGenerator.GenerateConversion (specializedLoad.HandledType ()' returnType) (ilGenerator);  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: if (specializedLoad.NeedsCtx ()) {  	var readerCtxLocal = ilGenerator.DeclareLocal (typeof(IReaderCtx));  	ilGenerator.Ldarg (2).Ldarg (1).Newobj (() => new ServiceReaderCtx ((IServiceInternalClient)null' null)).Castclass (typeof(IReaderCtx)).Stloc (readerCtxLocal);  	specializedLoad.Load (ilGenerator' il => il.Ldloc (readerCtxLocal));  } else {  	specializedLoad.Load (ilGenerator' il => il.Ldarg (1));  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: ilGenerator.Ldarg (2).Ldarg (1).Newobj (() => new ServiceReaderCtx ((IServiceInternalClient)null' null)).Castclass (typeof(IReaderCtx)).Stloc (readerCtxLocal);  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: methodBuilder.ExpectedLength (16);  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: methodBuilder.ExpectedLength (16);  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: methodBuilder.ExpectedLength (32);  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: for (int i = 0; i < bindingFields.Count; i++) {  	ilGenerator.Ldarg (0).Ldarg (2).LdcI4 (i).LdelemRef ().Stfld (bindingFields [i]);  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,InternalQueryRemoteService,The following statement contains a magic number: ilGenerator.Ldarg (0).Ldarg (2).LdcI4 (i).LdelemRef ().Stfld (bindingFields [i]);  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibility,The following statement contains a magic number: if (from.MethodInfs.Length == 1 && to.MethodInfs.Length == 1) {  	uint[] parameterMapping = null;  	if (mapping != null) {  		parameterMapping = new uint[1 + to.MethodInfs [0].Parameters.Length];  		mapping [0] = parameterMapping;  	}  	result = EvaluateCompatibilityIgnoringName (from.MethodInfs [0]' to.MethodInfs [0]' parameterMapping);  	if (result == int.MinValue)  		return result;  	if (from.Name == to.Name)  		result += 5;  	return result;  }  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibility,The following statement contains a magic number: if (from.Name == to.Name)  	result += 5;  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibility,The following statement contains a magic number: result += 5;  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibility,The following statement contains a magic number: if (from.Name == to.Name && (from.Configuration == to.Configuration || from.Configuration.SequenceEqual (to.Configuration)))  	return 10;  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibility,The following statement contains a magic number: return 10;  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibility,The following statement contains a magic number: if (_typeConvertorGenerator.GenerateConversion (typeFrom' typeTo) != null)  	return 5;  
Magic Number,BTDB.Service,Service,F:\newReposMay17\Bobris_BTDB\BTDB\Service\Service.cs,EvaluateCompatibility,The following statement contains a magic number: return 5;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Equal4,The following statement contains a magic number: return buf [o1] == buf [o2] && buf [o1 + 1] == buf [o2 + 1] && buf [o1 + 2] == buf [o2 + 2] && buf [o1 + 3] == buf [o2 + 3];  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Equal4,The following statement contains a magic number: return buf [o1] == buf [o2] && buf [o1 + 1] == buf [o2 + 1] && buf [o1 + 2] == buf [o2 + 2] && buf [o1 + 3] == buf [o2 + 3];  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Equal4,The following statement contains a magic number: return buf [o1] == buf [o2] && buf [o1 + 1] == buf [o2 + 1] && buf [o1 + 2] == buf [o2 + 2] && buf [o1 + 3] == buf [o2 + 3];  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Equal4,The following statement contains a magic number: return buf [o1] == buf [o2] && buf [o1 + 1] == buf [o2 + 1] && buf [o1 + 2] == buf [o2 + 2] && buf [o1 + 3] == buf [o2 + 3];  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL < 61) {  	if (sL + 1 > dL)  		return false;  	dst [d] = (byte)((sL - 1) << 2);  	d++;  	dL--;  } else if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d] = (byte)((sL - 1) << 2);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x100) {  	if (sL + 2 > dL)  		return false;  	dst [d] = 60 << 2;  	dst [d + 1] = (byte)(sL - 1);  	d += 2;  	dL -= 2;  } else if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL + 2 > dL)  	return false;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d] = 60 << 2;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d] = 60 << 2;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: d += 2;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dL -= 2;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x10000) {  	if (sL + 3 > dL)  		return false;  	dst [d] = 61 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	d += 3;  	dL -= 3;  } else if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL + 3 > dL)  	return false;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d] = 61 << 2;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d] = 61 << 2;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d + 2] = (byte)((sL - 1) >> 8);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d + 2] = (byte)((sL - 1) >> 8);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: d += 3;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dL -= 3;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL <= 0x1000000) {  	if (sL + 4 > dL)  		return false;  	dst [d] = 62 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	d += 4;  	dL -= 4;  } else {  	if (sL + 5 > dL)  		return false;  	dst [d] = 63 << 2;  	dst [d + 1] = (byte)(sL - 1);  	dst [d + 2] = (byte)((sL - 1) >> 8);  	dst [d + 3] = (byte)((sL - 1) >> 16);  	dst [d + 4] = (byte)((sL - 1) >> 24);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL + 4 > dL)  	return false;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d] = 62 << 2;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d] = 62 << 2;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d + 2] = (byte)((sL - 1) >> 8);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d + 2] = (byte)((sL - 1) >> 8);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d + 3] = (byte)((sL - 1) >> 16);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d + 3] = (byte)((sL - 1) >> 16);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: d += 4;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dL -= 4;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: if (sL + 5 > dL)  	return false;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d] = 63 << 2;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d] = 63 << 2;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d + 2] = (byte)((sL - 1) >> 8);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d + 2] = (byte)((sL - 1) >> 8);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d + 3] = (byte)((sL - 1) >> 16);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d + 3] = (byte)((sL - 1) >> 16);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d + 4] = (byte)((sL - 1) >> 24);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dst [d + 4] = (byte)((sL - 1) >> 24);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: d += 5;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLiteral,The following statement contains a magic number: dL -= 5;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0) {  	var x = length - 4;  	if (0 <= x && x < 8 && offset < 1 << 11) {  		if (dL < 2)  			return false;  		dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  		dst [d + 1] = (byte)offset;  		d += 2;  		dL -= 2;  		break;  	}  	x = length;  	if (x > 1 << 6) {  		x = 1 << 6;  	}  	if (dL < 3)  		return false;  	dst [d] = (byte)((x - 1) << 2 | 2);  	dst [d + 1] = (byte)offset;  	dst [d + 2] = (byte)(offset >> 8);  	d += 3;  	dL -= 3;  	length -= x;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0) {  	var x = length - 4;  	if (0 <= x && x < 8 && offset < 1 << 11) {  		if (dL < 2)  			return false;  		dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  		dst [d + 1] = (byte)offset;  		d += 2;  		dL -= 2;  		break;  	}  	x = length;  	if (x > 1 << 6) {  		x = 1 << 6;  	}  	if (dL < 3)  		return false;  	dst [d] = (byte)((x - 1) << 2 | 2);  	dst [d + 1] = (byte)offset;  	dst [d + 2] = (byte)(offset >> 8);  	d += 3;  	dL -= 3;  	length -= x;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0) {  	var x = length - 4;  	if (0 <= x && x < 8 && offset < 1 << 11) {  		if (dL < 2)  			return false;  		dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  		dst [d + 1] = (byte)offset;  		d += 2;  		dL -= 2;  		break;  	}  	x = length;  	if (x > 1 << 6) {  		x = 1 << 6;  	}  	if (dL < 3)  		return false;  	dst [d] = (byte)((x - 1) << 2 | 2);  	dst [d + 1] = (byte)offset;  	dst [d + 2] = (byte)(offset >> 8);  	d += 3;  	dL -= 3;  	length -= x;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0) {  	var x = length - 4;  	if (0 <= x && x < 8 && offset < 1 << 11) {  		if (dL < 2)  			return false;  		dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  		dst [d + 1] = (byte)offset;  		d += 2;  		dL -= 2;  		break;  	}  	x = length;  	if (x > 1 << 6) {  		x = 1 << 6;  	}  	if (dL < 3)  		return false;  	dst [d] = (byte)((x - 1) << 2 | 2);  	dst [d + 1] = (byte)offset;  	dst [d + 2] = (byte)(offset >> 8);  	d += 3;  	dL -= 3;  	length -= x;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0) {  	var x = length - 4;  	if (0 <= x && x < 8 && offset < 1 << 11) {  		if (dL < 2)  			return false;  		dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  		dst [d + 1] = (byte)offset;  		d += 2;  		dL -= 2;  		break;  	}  	x = length;  	if (x > 1 << 6) {  		x = 1 << 6;  	}  	if (dL < 3)  		return false;  	dst [d] = (byte)((x - 1) << 2 | 2);  	dst [d + 1] = (byte)offset;  	dst [d + 2] = (byte)(offset >> 8);  	d += 3;  	dL -= 3;  	length -= x;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0) {  	var x = length - 4;  	if (0 <= x && x < 8 && offset < 1 << 11) {  		if (dL < 2)  			return false;  		dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  		dst [d + 1] = (byte)offset;  		d += 2;  		dL -= 2;  		break;  	}  	x = length;  	if (x > 1 << 6) {  		x = 1 << 6;  	}  	if (dL < 3)  		return false;  	dst [d] = (byte)((x - 1) << 2 | 2);  	dst [d + 1] = (byte)offset;  	dst [d + 2] = (byte)(offset >> 8);  	d += 3;  	dL -= 3;  	length -= x;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0) {  	var x = length - 4;  	if (0 <= x && x < 8 && offset < 1 << 11) {  		if (dL < 2)  			return false;  		dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  		dst [d + 1] = (byte)offset;  		d += 2;  		dL -= 2;  		break;  	}  	x = length;  	if (x > 1 << 6) {  		x = 1 << 6;  	}  	if (dL < 3)  		return false;  	dst [d] = (byte)((x - 1) << 2 | 2);  	dst [d + 1] = (byte)offset;  	dst [d + 2] = (byte)(offset >> 8);  	d += 3;  	dL -= 3;  	length -= x;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0) {  	var x = length - 4;  	if (0 <= x && x < 8 && offset < 1 << 11) {  		if (dL < 2)  			return false;  		dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  		dst [d + 1] = (byte)offset;  		d += 2;  		dL -= 2;  		break;  	}  	x = length;  	if (x > 1 << 6) {  		x = 1 << 6;  	}  	if (dL < 3)  		return false;  	dst [d] = (byte)((x - 1) << 2 | 2);  	dst [d + 1] = (byte)offset;  	dst [d + 2] = (byte)(offset >> 8);  	d += 3;  	dL -= 3;  	length -= x;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0) {  	var x = length - 4;  	if (0 <= x && x < 8 && offset < 1 << 11) {  		if (dL < 2)  			return false;  		dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  		dst [d + 1] = (byte)offset;  		d += 2;  		dL -= 2;  		break;  	}  	x = length;  	if (x > 1 << 6) {  		x = 1 << 6;  	}  	if (dL < 3)  		return false;  	dst [d] = (byte)((x - 1) << 2 | 2);  	dst [d + 1] = (byte)offset;  	dst [d + 2] = (byte)(offset >> 8);  	d += 3;  	dL -= 3;  	length -= x;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0) {  	var x = length - 4;  	if (0 <= x && x < 8 && offset < 1 << 11) {  		if (dL < 2)  			return false;  		dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  		dst [d + 1] = (byte)offset;  		d += 2;  		dL -= 2;  		break;  	}  	x = length;  	if (x > 1 << 6) {  		x = 1 << 6;  	}  	if (dL < 3)  		return false;  	dst [d] = (byte)((x - 1) << 2 | 2);  	dst [d + 1] = (byte)offset;  	dst [d + 2] = (byte)(offset >> 8);  	d += 3;  	dL -= 3;  	length -= x;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0) {  	var x = length - 4;  	if (0 <= x && x < 8 && offset < 1 << 11) {  		if (dL < 2)  			return false;  		dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  		dst [d + 1] = (byte)offset;  		d += 2;  		dL -= 2;  		break;  	}  	x = length;  	if (x > 1 << 6) {  		x = 1 << 6;  	}  	if (dL < 3)  		return false;  	dst [d] = (byte)((x - 1) << 2 | 2);  	dst [d + 1] = (byte)offset;  	dst [d + 2] = (byte)(offset >> 8);  	d += 3;  	dL -= 3;  	length -= x;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0) {  	var x = length - 4;  	if (0 <= x && x < 8 && offset < 1 << 11) {  		if (dL < 2)  			return false;  		dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  		dst [d + 1] = (byte)offset;  		d += 2;  		dL -= 2;  		break;  	}  	x = length;  	if (x > 1 << 6) {  		x = 1 << 6;  	}  	if (dL < 3)  		return false;  	dst [d] = (byte)((x - 1) << 2 | 2);  	dst [d + 1] = (byte)offset;  	dst [d + 2] = (byte)(offset >> 8);  	d += 3;  	dL -= 3;  	length -= x;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0) {  	var x = length - 4;  	if (0 <= x && x < 8 && offset < 1 << 11) {  		if (dL < 2)  			return false;  		dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  		dst [d + 1] = (byte)offset;  		d += 2;  		dL -= 2;  		break;  	}  	x = length;  	if (x > 1 << 6) {  		x = 1 << 6;  	}  	if (dL < 3)  		return false;  	dst [d] = (byte)((x - 1) << 2 | 2);  	dst [d + 1] = (byte)offset;  	dst [d + 2] = (byte)(offset >> 8);  	d += 3;  	dL -= 3;  	length -= x;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0) {  	var x = length - 4;  	if (0 <= x && x < 8 && offset < 1 << 11) {  		if (dL < 2)  			return false;  		dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  		dst [d + 1] = (byte)offset;  		d += 2;  		dL -= 2;  		break;  	}  	x = length;  	if (x > 1 << 6) {  		x = 1 << 6;  	}  	if (dL < 3)  		return false;  	dst [d] = (byte)((x - 1) << 2 | 2);  	dst [d + 1] = (byte)offset;  	dst [d + 2] = (byte)(offset >> 8);  	d += 3;  	dL -= 3;  	length -= x;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0) {  	var x = length - 4;  	if (0 <= x && x < 8 && offset < 1 << 11) {  		if (dL < 2)  			return false;  		dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  		dst [d + 1] = (byte)offset;  		d += 2;  		dL -= 2;  		break;  	}  	x = length;  	if (x > 1 << 6) {  		x = 1 << 6;  	}  	if (dL < 3)  		return false;  	dst [d] = (byte)((x - 1) << 2 | 2);  	dst [d + 1] = (byte)offset;  	dst [d + 2] = (byte)(offset >> 8);  	d += 3;  	dL -= 3;  	length -= x;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0) {  	var x = length - 4;  	if (0 <= x && x < 8 && offset < 1 << 11) {  		if (dL < 2)  			return false;  		dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  		dst [d + 1] = (byte)offset;  		d += 2;  		dL -= 2;  		break;  	}  	x = length;  	if (x > 1 << 6) {  		x = 1 << 6;  	}  	if (dL < 3)  		return false;  	dst [d] = (byte)((x - 1) << 2 | 2);  	dst [d + 1] = (byte)offset;  	dst [d + 2] = (byte)(offset >> 8);  	d += 3;  	dL -= 3;  	length -= x;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: while (length > 0) {  	var x = length - 4;  	if (0 <= x && x < 8 && offset < 1 << 11) {  		if (dL < 2)  			return false;  		dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  		dst [d + 1] = (byte)offset;  		d += 2;  		dL -= 2;  		break;  	}  	x = length;  	if (x > 1 << 6) {  		x = 1 << 6;  	}  	if (dL < 3)  		return false;  	dst [d] = (byte)((x - 1) << 2 | 2);  	dst [d + 1] = (byte)offset;  	dst [d + 2] = (byte)(offset >> 8);  	d += 3;  	dL -= 3;  	length -= x;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: if (0 <= x && x < 8 && offset < 1 << 11) {  	if (dL < 2)  		return false;  	dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  	dst [d + 1] = (byte)offset;  	d += 2;  	dL -= 2;  	break;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: if (0 <= x && x < 8 && offset < 1 << 11) {  	if (dL < 2)  		return false;  	dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  	dst [d + 1] = (byte)offset;  	d += 2;  	dL -= 2;  	break;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: if (0 <= x && x < 8 && offset < 1 << 11) {  	if (dL < 2)  		return false;  	dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  	dst [d + 1] = (byte)offset;  	d += 2;  	dL -= 2;  	break;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: if (0 <= x && x < 8 && offset < 1 << 11) {  	if (dL < 2)  		return false;  	dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  	dst [d + 1] = (byte)offset;  	d += 2;  	dL -= 2;  	break;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: if (0 <= x && x < 8 && offset < 1 << 11) {  	if (dL < 2)  		return false;  	dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  	dst [d + 1] = (byte)offset;  	d += 2;  	dL -= 2;  	break;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: if (0 <= x && x < 8 && offset < 1 << 11) {  	if (dL < 2)  		return false;  	dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  	dst [d + 1] = (byte)offset;  	d += 2;  	dL -= 2;  	break;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: if (0 <= x && x < 8 && offset < 1 << 11) {  	if (dL < 2)  		return false;  	dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  	dst [d + 1] = (byte)offset;  	d += 2;  	dL -= 2;  	break;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: if (dL < 2)  	return false;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: dst [d] = (byte)((offset >> 3) & 0xe0 | (x << 2) | 1);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: d += 2;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: dL -= 2;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: if (x > 1 << 6) {  	x = 1 << 6;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: if (x > 1 << 6) {  	x = 1 << 6;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: x = 1 << 6;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: if (dL < 3)  	return false;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: dst [d] = (byte)((x - 1) << 2 | 2);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: dst [d] = (byte)((x - 1) << 2 | 2);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: dst [d + 2] = (byte)(offset >> 8);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: dst [d + 2] = (byte)(offset >> 8);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: d += 3;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitCopy,The following statement contains a magic number: dL -= 3;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x80) {  	dst [d] = (byte)length;  	d++;  	dL--;  } else if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x4000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)(length >> 7);  	d += 2;  	dL -= 2;  } else if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d] = (byte)(length | 128);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 1] = (byte)(length >> 7);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: d += 2;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dL -= 2;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x200000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)(length >> 14);  	d += 3;  	dL -= 3;  } else if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d] = (byte)(length | 128);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 1] = (byte)((length >> 7) | 128);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 1] = (byte)((length >> 7) | 128);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 2] = (byte)(length >> 14);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 2] = (byte)(length >> 14);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: d += 3;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dL -= 3;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: if (length < 0x10000000) {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)(length >> 21);  	d += 4;  	dL -= 4;  } else {  	dst [d] = (byte)(length | 128);  	dst [d + 1] = (byte)((length >> 7) | 128);  	dst [d + 2] = (byte)((length >> 14) | 128);  	dst [d + 3] = (byte)((length >> 21) | 128);  	dst [d + 4] = (byte)(length >> 28);  	d += 5;  	dL -= 5;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d] = (byte)(length | 128);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 1] = (byte)((length >> 7) | 128);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 1] = (byte)((length >> 7) | 128);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 2] = (byte)((length >> 14) | 128);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 2] = (byte)((length >> 14) | 128);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 2] = (byte)((length >> 14) | 128);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 3] = (byte)(length >> 21);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 3] = (byte)(length >> 21);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: d += 4;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dL -= 4;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d] = (byte)(length | 128);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 1] = (byte)((length >> 7) | 128);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 1] = (byte)((length >> 7) | 128);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 2] = (byte)((length >> 14) | 128);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 2] = (byte)((length >> 14) | 128);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 2] = (byte)((length >> 14) | 128);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 3] = (byte)((length >> 21) | 128);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 3] = (byte)((length >> 21) | 128);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 3] = (byte)((length >> 21) | 128);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 4] = (byte)(length >> 28);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dst [d + 4] = (byte)(length >> 28);  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: d += 5;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,EmitLength,The following statement contains a magic number: dL -= 5;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: if (dL < 5)  	return -1;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: if (sL <= 4) {  	if (!EmitLiteral (dst' ref d' ref dL' src' s' sL))  		return -1;  	return d - dstBuf.Offset;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (tableSize < 1 << 14 && tableSize < sL) {  	shift--;  	tableSize *= 2;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (tableSize < 1 << 14 && tableSize < sL) {  	shift--;  	tableSize *= 2;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: tableSize *= 2;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3) {  	var v = src [s] | ((uint)src [s + 1]) << 8 | ((uint)src [s + 2]) << 16 | ((uint)src [s + 3]) << 24;  	nextfast:  	var h = (v * 0x1e35a7bd) >> shift;  	var t = table [h];  	table [h] = s;  	if (t < 0 || s - t >= MaxOffset || !Equal4 (src' t' s)) {  		s++;  		sL--;  		if (sL > 3) {  			v = (v >> 8) | ((uint)src [s + 3]) << 24;  			goto nextfast;  		}  		break;  	}  	if (lit != s) {  		if (!EmitLiteral (dst' ref d' ref dL' src' lit' s - lit))  			return -1;  	}  	var s0 = s;  	s += 4;  	sL -= 4;  	t += 4;  	while (sL > 0 && src [s] == src [t]) {  		s++;  		sL--;  		t++;  	}  	if (!EmitCopy (dst' ref d' ref dL' s - t' s - s0))  		return -1;  	lit = s;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3) {  	var v = src [s] | ((uint)src [s + 1]) << 8 | ((uint)src [s + 2]) << 16 | ((uint)src [s + 3]) << 24;  	nextfast:  	var h = (v * 0x1e35a7bd) >> shift;  	var t = table [h];  	table [h] = s;  	if (t < 0 || s - t >= MaxOffset || !Equal4 (src' t' s)) {  		s++;  		sL--;  		if (sL > 3) {  			v = (v >> 8) | ((uint)src [s + 3]) << 24;  			goto nextfast;  		}  		break;  	}  	if (lit != s) {  		if (!EmitLiteral (dst' ref d' ref dL' src' lit' s - lit))  			return -1;  	}  	var s0 = s;  	s += 4;  	sL -= 4;  	t += 4;  	while (sL > 0 && src [s] == src [t]) {  		s++;  		sL--;  		t++;  	}  	if (!EmitCopy (dst' ref d' ref dL' s - t' s - s0))  		return -1;  	lit = s;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3) {  	var v = src [s] | ((uint)src [s + 1]) << 8 | ((uint)src [s + 2]) << 16 | ((uint)src [s + 3]) << 24;  	nextfast:  	var h = (v * 0x1e35a7bd) >> shift;  	var t = table [h];  	table [h] = s;  	if (t < 0 || s - t >= MaxOffset || !Equal4 (src' t' s)) {  		s++;  		sL--;  		if (sL > 3) {  			v = (v >> 8) | ((uint)src [s + 3]) << 24;  			goto nextfast;  		}  		break;  	}  	if (lit != s) {  		if (!EmitLiteral (dst' ref d' ref dL' src' lit' s - lit))  			return -1;  	}  	var s0 = s;  	s += 4;  	sL -= 4;  	t += 4;  	while (sL > 0 && src [s] == src [t]) {  		s++;  		sL--;  		t++;  	}  	if (!EmitCopy (dst' ref d' ref dL' s - t' s - s0))  		return -1;  	lit = s;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3) {  	var v = src [s] | ((uint)src [s + 1]) << 8 | ((uint)src [s + 2]) << 16 | ((uint)src [s + 3]) << 24;  	nextfast:  	var h = (v * 0x1e35a7bd) >> shift;  	var t = table [h];  	table [h] = s;  	if (t < 0 || s - t >= MaxOffset || !Equal4 (src' t' s)) {  		s++;  		sL--;  		if (sL > 3) {  			v = (v >> 8) | ((uint)src [s + 3]) << 24;  			goto nextfast;  		}  		break;  	}  	if (lit != s) {  		if (!EmitLiteral (dst' ref d' ref dL' src' lit' s - lit))  			return -1;  	}  	var s0 = s;  	s += 4;  	sL -= 4;  	t += 4;  	while (sL > 0 && src [s] == src [t]) {  		s++;  		sL--;  		t++;  	}  	if (!EmitCopy (dst' ref d' ref dL' s - t' s - s0))  		return -1;  	lit = s;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3) {  	var v = src [s] | ((uint)src [s + 1]) << 8 | ((uint)src [s + 2]) << 16 | ((uint)src [s + 3]) << 24;  	nextfast:  	var h = (v * 0x1e35a7bd) >> shift;  	var t = table [h];  	table [h] = s;  	if (t < 0 || s - t >= MaxOffset || !Equal4 (src' t' s)) {  		s++;  		sL--;  		if (sL > 3) {  			v = (v >> 8) | ((uint)src [s + 3]) << 24;  			goto nextfast;  		}  		break;  	}  	if (lit != s) {  		if (!EmitLiteral (dst' ref d' ref dL' src' lit' s - lit))  			return -1;  	}  	var s0 = s;  	s += 4;  	sL -= 4;  	t += 4;  	while (sL > 0 && src [s] == src [t]) {  		s++;  		sL--;  		t++;  	}  	if (!EmitCopy (dst' ref d' ref dL' s - t' s - s0))  		return -1;  	lit = s;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3) {  	var v = src [s] | ((uint)src [s + 1]) << 8 | ((uint)src [s + 2]) << 16 | ((uint)src [s + 3]) << 24;  	nextfast:  	var h = (v * 0x1e35a7bd) >> shift;  	var t = table [h];  	table [h] = s;  	if (t < 0 || s - t >= MaxOffset || !Equal4 (src' t' s)) {  		s++;  		sL--;  		if (sL > 3) {  			v = (v >> 8) | ((uint)src [s + 3]) << 24;  			goto nextfast;  		}  		break;  	}  	if (lit != s) {  		if (!EmitLiteral (dst' ref d' ref dL' src' lit' s - lit))  			return -1;  	}  	var s0 = s;  	s += 4;  	sL -= 4;  	t += 4;  	while (sL > 0 && src [s] == src [t]) {  		s++;  		sL--;  		t++;  	}  	if (!EmitCopy (dst' ref d' ref dL' s - t' s - s0))  		return -1;  	lit = s;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3) {  	var v = src [s] | ((uint)src [s + 1]) << 8 | ((uint)src [s + 2]) << 16 | ((uint)src [s + 3]) << 24;  	nextfast:  	var h = (v * 0x1e35a7bd) >> shift;  	var t = table [h];  	table [h] = s;  	if (t < 0 || s - t >= MaxOffset || !Equal4 (src' t' s)) {  		s++;  		sL--;  		if (sL > 3) {  			v = (v >> 8) | ((uint)src [s + 3]) << 24;  			goto nextfast;  		}  		break;  	}  	if (lit != s) {  		if (!EmitLiteral (dst' ref d' ref dL' src' lit' s - lit))  			return -1;  	}  	var s0 = s;  	s += 4;  	sL -= 4;  	t += 4;  	while (sL > 0 && src [s] == src [t]) {  		s++;  		sL--;  		t++;  	}  	if (!EmitCopy (dst' ref d' ref dL' s - t' s - s0))  		return -1;  	lit = s;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3) {  	var v = src [s] | ((uint)src [s + 1]) << 8 | ((uint)src [s + 2]) << 16 | ((uint)src [s + 3]) << 24;  	nextfast:  	var h = (v * 0x1e35a7bd) >> shift;  	var t = table [h];  	table [h] = s;  	if (t < 0 || s - t >= MaxOffset || !Equal4 (src' t' s)) {  		s++;  		sL--;  		if (sL > 3) {  			v = (v >> 8) | ((uint)src [s + 3]) << 24;  			goto nextfast;  		}  		break;  	}  	if (lit != s) {  		if (!EmitLiteral (dst' ref d' ref dL' src' lit' s - lit))  			return -1;  	}  	var s0 = s;  	s += 4;  	sL -= 4;  	t += 4;  	while (sL > 0 && src [s] == src [t]) {  		s++;  		sL--;  		t++;  	}  	if (!EmitCopy (dst' ref d' ref dL' s - t' s - s0))  		return -1;  	lit = s;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3) {  	var v = src [s] | ((uint)src [s + 1]) << 8 | ((uint)src [s + 2]) << 16 | ((uint)src [s + 3]) << 24;  	nextfast:  	var h = (v * 0x1e35a7bd) >> shift;  	var t = table [h];  	table [h] = s;  	if (t < 0 || s - t >= MaxOffset || !Equal4 (src' t' s)) {  		s++;  		sL--;  		if (sL > 3) {  			v = (v >> 8) | ((uint)src [s + 3]) << 24;  			goto nextfast;  		}  		break;  	}  	if (lit != s) {  		if (!EmitLiteral (dst' ref d' ref dL' src' lit' s - lit))  			return -1;  	}  	var s0 = s;  	s += 4;  	sL -= 4;  	t += 4;  	while (sL > 0 && src [s] == src [t]) {  		s++;  		sL--;  		t++;  	}  	if (!EmitCopy (dst' ref d' ref dL' s - t' s - s0))  		return -1;  	lit = s;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3) {  	var v = src [s] | ((uint)src [s + 1]) << 8 | ((uint)src [s + 2]) << 16 | ((uint)src [s + 3]) << 24;  	nextfast:  	var h = (v * 0x1e35a7bd) >> shift;  	var t = table [h];  	table [h] = s;  	if (t < 0 || s - t >= MaxOffset || !Equal4 (src' t' s)) {  		s++;  		sL--;  		if (sL > 3) {  			v = (v >> 8) | ((uint)src [s + 3]) << 24;  			goto nextfast;  		}  		break;  	}  	if (lit != s) {  		if (!EmitLiteral (dst' ref d' ref dL' src' lit' s - lit))  			return -1;  	}  	var s0 = s;  	s += 4;  	sL -= 4;  	t += 4;  	while (sL > 0 && src [s] == src [t]) {  		s++;  		sL--;  		t++;  	}  	if (!EmitCopy (dst' ref d' ref dL' s - t' s - s0))  		return -1;  	lit = s;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3) {  	var v = src [s] | ((uint)src [s + 1]) << 8 | ((uint)src [s + 2]) << 16 | ((uint)src [s + 3]) << 24;  	nextfast:  	var h = (v * 0x1e35a7bd) >> shift;  	var t = table [h];  	table [h] = s;  	if (t < 0 || s - t >= MaxOffset || !Equal4 (src' t' s)) {  		s++;  		sL--;  		if (sL > 3) {  			v = (v >> 8) | ((uint)src [s + 3]) << 24;  			goto nextfast;  		}  		break;  	}  	if (lit != s) {  		if (!EmitLiteral (dst' ref d' ref dL' src' lit' s - lit))  			return -1;  	}  	var s0 = s;  	s += 4;  	sL -= 4;  	t += 4;  	while (sL > 0 && src [s] == src [t]) {  		s++;  		sL--;  		t++;  	}  	if (!EmitCopy (dst' ref d' ref dL' s - t' s - s0))  		return -1;  	lit = s;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3) {  	var v = src [s] | ((uint)src [s + 1]) << 8 | ((uint)src [s + 2]) << 16 | ((uint)src [s + 3]) << 24;  	nextfast:  	var h = (v * 0x1e35a7bd) >> shift;  	var t = table [h];  	table [h] = s;  	if (t < 0 || s - t >= MaxOffset || !Equal4 (src' t' s)) {  		s++;  		sL--;  		if (sL > 3) {  			v = (v >> 8) | ((uint)src [s + 3]) << 24;  			goto nextfast;  		}  		break;  	}  	if (lit != s) {  		if (!EmitLiteral (dst' ref d' ref dL' src' lit' s - lit))  			return -1;  	}  	var s0 = s;  	s += 4;  	sL -= 4;  	t += 4;  	while (sL > 0 && src [s] == src [t]) {  		s++;  		sL--;  		t++;  	}  	if (!EmitCopy (dst' ref d' ref dL' s - t' s - s0))  		return -1;  	lit = s;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: while (sL > 3) {  	var v = src [s] | ((uint)src [s + 1]) << 8 | ((uint)src [s + 2]) << 16 | ((uint)src [s + 3]) << 24;  	nextfast:  	var h = (v * 0x1e35a7bd) >> shift;  	var t = table [h];  	table [h] = s;  	if (t < 0 || s - t >= MaxOffset || !Equal4 (src' t' s)) {  		s++;  		sL--;  		if (sL > 3) {  			v = (v >> 8) | ((uint)src [s + 3]) << 24;  			goto nextfast;  		}  		break;  	}  	if (lit != s) {  		if (!EmitLiteral (dst' ref d' ref dL' src' lit' s - lit))  			return -1;  	}  	var s0 = s;  	s += 4;  	sL -= 4;  	t += 4;  	while (sL > 0 && src [s] == src [t]) {  		s++;  		sL--;  		t++;  	}  	if (!EmitCopy (dst' ref d' ref dL' s - t' s - s0))  		return -1;  	lit = s;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: if (t < 0 || s - t >= MaxOffset || !Equal4 (src' t' s)) {  	s++;  	sL--;  	if (sL > 3) {  		v = (v >> 8) | ((uint)src [s + 3]) << 24;  		goto nextfast;  	}  	break;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: if (t < 0 || s - t >= MaxOffset || !Equal4 (src' t' s)) {  	s++;  	sL--;  	if (sL > 3) {  		v = (v >> 8) | ((uint)src [s + 3]) << 24;  		goto nextfast;  	}  	break;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: if (t < 0 || s - t >= MaxOffset || !Equal4 (src' t' s)) {  	s++;  	sL--;  	if (sL > 3) {  		v = (v >> 8) | ((uint)src [s + 3]) << 24;  		goto nextfast;  	}  	break;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: if (t < 0 || s - t >= MaxOffset || !Equal4 (src' t' s)) {  	s++;  	sL--;  	if (sL > 3) {  		v = (v >> 8) | ((uint)src [s + 3]) << 24;  		goto nextfast;  	}  	break;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: if (sL > 3) {  	v = (v >> 8) | ((uint)src [s + 3]) << 24;  	goto nextfast;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: if (sL > 3) {  	v = (v >> 8) | ((uint)src [s + 3]) << 24;  	goto nextfast;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: if (sL > 3) {  	v = (v >> 8) | ((uint)src [s + 3]) << 24;  	goto nextfast;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: if (sL > 3) {  	v = (v >> 8) | ((uint)src [s + 3]) << 24;  	goto nextfast;  }  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: v = (v >> 8) | ((uint)src [s + 3]) << 24;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: v = (v >> 8) | ((uint)src [s + 3]) << 24;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: v = (v >> 8) | ((uint)src [s + 3]) << 24;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: s += 4;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: sL -= 4;  
Magic Number,BTDB.SnappyCompression,SnappyCompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyCompress.cs,Compress,The following statement contains a magic number: t += 4;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: if (b < 128)  	goto done;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint)(b & 127) << 7);  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint)(b & 127) << 7);  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: if (b < 128)  	goto done;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint)(b & 127) << 14);  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint)(b & 127) << 14);  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: if (b < 128)  	goto done;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint)(b & 127) << 21);  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint)(b & 127) << 21);  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: if (b < 128)  	goto done;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint)(b & 127) << 28);  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: result |= ((uint)(b & 127) << 28);  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressedSize,The following statement contains a magic number: if (b >= 16)  	goto error;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: while (sL > 0) {  	var b = src [s];  	s++;  	sL--;  	switch (b & 3) {  	case 0:  		len = b >> 2;  		if (len < 60) {  			len++;  		} else if (len == 60) {  			if (sL < 1)  				return false;  			len = src [s] + 1;  			s++;  			sL--;  		} else if (len == 61) {  			if (sL < 2)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 1;  			s += 2;  			sL -= 2;  		} else if (len == 62) {  			if (sL < 3)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  			s += 3;  			sL -= 3;  		} else {  			if (sL < 4)  				return false;  			len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  			s += 3;  			sL -= 3;  		}  		if (len <= 0)  			return false;  		if (len > dL || len > sL)  			return false;  		Array.Copy (src' s' dst' d' len);  		s += len;  		d += len;  		sL -= len;  		dL -= len;  		continue;  	case 1:  		if (sL < 1)  			return false;  		len = 4 + ((b >> 2) & 7);  		o = (b & 0xe0) << 3 | src [s];  		s++;  		sL--;  		break;  	case 2:  		if (sL < 2)  			return false;  		len = 1 + (b >> 2);  		o = src [s] + src [s + 1] * 0x100;  		s += 2;  		sL -= 2;  		break;  	case 3:  		return false;  	}  	var end = d + len;  	if (o > d || len > dL)  		return false;  	for (; d < end; d++) {  		dst [d] = dst [d - o];  	}  	dL -= len;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: len = b >> 2;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len < 60) {  	len++;  } else if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len < 60) {  	len++;  } else if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len < 60) {  	len++;  } else if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len < 60) {  	len++;  } else if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len < 60) {  	len++;  } else if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len < 60) {  	len++;  } else if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len < 60) {  	len++;  } else if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len < 60) {  	len++;  } else if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len < 60) {  	len++;  } else if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len < 60) {  	len++;  } else if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len < 60) {  	len++;  } else if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len < 60) {  	len++;  } else if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len < 60) {  	len++;  } else if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len < 60) {  	len++;  } else if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len < 60) {  	len++;  } else if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len < 60) {  	len++;  } else if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 60) {  	if (sL < 1)  		return false;  	len = src [s] + 1;  	s++;  	sL--;  } else if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 61) {  	if (sL < 2)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 1;  	s += 2;  	sL -= 2;  } else if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (sL < 2)  	return false;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: s += 2;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: sL -= 2;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (len == 62) {  	if (sL < 3)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  	s += 3;  	sL -= 3;  } else {  	if (sL < 4)  		return false;  	len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  	s += 3;  	sL -= 3;  }  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (sL < 3)  	return false;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: s += 3;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: sL -= 3;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (sL < 4)  	return false;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: s += 3;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: sL -= 3;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: len = 4 + ((b >> 2) & 7);  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: len = 4 + ((b >> 2) & 7);  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: len = 4 + ((b >> 2) & 7);  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: o = (b & 0xe0) << 3 | src [s];  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: if (sL < 2)  	return false;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: len = 1 + (b >> 2);  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: s += 2;  
Magic Number,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following statement contains a magic number: sL -= 2;  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt8Ordered,The following statement contains a magic number: return (sbyte)(Buf [Pos++] - 128);  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadVInt64,The following statement contains a magic number: if (Pos + l <= End) {  	res = PackUnpack.UnpackVInt (Buf' ref Pos);  } else {  	res = (Buf [Pos] >= 0x80) ? 0 : -1;  	if (l < 8)  		res <<= 8 - l;  	res += Buf [Pos] & (0xff >> l);  	do {  		Pos++;  		res <<= 8;  		NeedOneByteInBuffer ();  		res += Buf [Pos];  		l--;  	} while (l > 1);  	Pos++;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadVInt64,The following statement contains a magic number: if (Pos + l <= End) {  	res = PackUnpack.UnpackVInt (Buf' ref Pos);  } else {  	res = (Buf [Pos] >= 0x80) ? 0 : -1;  	if (l < 8)  		res <<= 8 - l;  	res += Buf [Pos] & (0xff >> l);  	do {  		Pos++;  		res <<= 8;  		NeedOneByteInBuffer ();  		res += Buf [Pos];  		l--;  	} while (l > 1);  	Pos++;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadVInt64,The following statement contains a magic number: if (Pos + l <= End) {  	res = PackUnpack.UnpackVInt (Buf' ref Pos);  } else {  	res = (Buf [Pos] >= 0x80) ? 0 : -1;  	if (l < 8)  		res <<= 8 - l;  	res += Buf [Pos] & (0xff >> l);  	do {  		Pos++;  		res <<= 8;  		NeedOneByteInBuffer ();  		res += Buf [Pos];  		l--;  	} while (l > 1);  	Pos++;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadVInt64,The following statement contains a magic number: if (l < 8)  	res <<= 8 - l;  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadVInt64,The following statement contains a magic number: if (l < 8)  	res <<= 8 - l;  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadVInt64,The following statement contains a magic number: res <<= 8 - l;  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadVInt64,The following statement contains a magic number: do {  	Pos++;  	res <<= 8;  	NeedOneByteInBuffer ();  	res += Buf [Pos];  	l--;  } while (l > 1);  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadVInt64,The following statement contains a magic number: res <<= 8;  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadVUInt64,The following statement contains a magic number: if (Pos + l <= End) {  	res = PackUnpack.UnpackVUInt (Buf' ref Pos);  } else {  	res = (ulong)(Buf [Pos] & (0xff >> l));  	do {  		Pos++;  		res <<= 8;  		NeedOneByteInBuffer ();  		res += Buf [Pos];  		l--;  	} while (l > 1);  	Pos++;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadVUInt64,The following statement contains a magic number: do {  	Pos++;  	res <<= 8;  	NeedOneByteInBuffer ();  	res += Buf [Pos];  	l--;  } while (l > 1);  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadVUInt64,The following statement contains a magic number: res <<= 8;  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt64,The following statement contains a magic number: if (Pos + 8 <= End) {  	res = PackUnpack.UnpackInt64BE (Buf' Pos);  	Pos += 8;  } else {  	for (int i = 0; i < 8; i++) {  		NeedOneByteInBuffer ();  		res <<= 8;  		res += Buf [Pos];  		Pos++;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt64,The following statement contains a magic number: if (Pos + 8 <= End) {  	res = PackUnpack.UnpackInt64BE (Buf' Pos);  	Pos += 8;  } else {  	for (int i = 0; i < 8; i++) {  		NeedOneByteInBuffer ();  		res <<= 8;  		res += Buf [Pos];  		Pos++;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt64,The following statement contains a magic number: if (Pos + 8 <= End) {  	res = PackUnpack.UnpackInt64BE (Buf' Pos);  	Pos += 8;  } else {  	for (int i = 0; i < 8; i++) {  		NeedOneByteInBuffer ();  		res <<= 8;  		res += Buf [Pos];  		Pos++;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt64,The following statement contains a magic number: if (Pos + 8 <= End) {  	res = PackUnpack.UnpackInt64BE (Buf' Pos);  	Pos += 8;  } else {  	for (int i = 0; i < 8; i++) {  		NeedOneByteInBuffer ();  		res <<= 8;  		res += Buf [Pos];  		Pos++;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt64,The following statement contains a magic number: Pos += 8;  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt64,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	NeedOneByteInBuffer ();  	res <<= 8;  	res += Buf [Pos];  	Pos++;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt64,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	NeedOneByteInBuffer ();  	res <<= 8;  	res += Buf [Pos];  	Pos++;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt64,The following statement contains a magic number: res <<= 8;  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipInt64,The following statement contains a magic number: if (Pos + 8 <= End) {  	Pos += 8;  } else {  	for (int i = 0; i < 8; i++) {  		NeedOneByteInBuffer ();  		Pos++;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipInt64,The following statement contains a magic number: if (Pos + 8 <= End) {  	Pos += 8;  } else {  	for (int i = 0; i < 8; i++) {  		NeedOneByteInBuffer ();  		Pos++;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipInt64,The following statement contains a magic number: if (Pos + 8 <= End) {  	Pos += 8;  } else {  	for (int i = 0; i < 8; i++) {  		NeedOneByteInBuffer ();  		Pos++;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipInt64,The following statement contains a magic number: Pos += 8;  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipInt64,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	NeedOneByteInBuffer ();  	Pos++;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32,The following statement contains a magic number: if (Pos + 4 <= End) {  	res = PackUnpack.UnpackInt32BE (Buf' Pos);  	Pos += 4;  } else {  	for (var i = 0; i < 4; i++) {  		NeedOneByteInBuffer ();  		res <<= 8;  		res += Buf [Pos];  		Pos++;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32,The following statement contains a magic number: if (Pos + 4 <= End) {  	res = PackUnpack.UnpackInt32BE (Buf' Pos);  	Pos += 4;  } else {  	for (var i = 0; i < 4; i++) {  		NeedOneByteInBuffer ();  		res <<= 8;  		res += Buf [Pos];  		Pos++;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32,The following statement contains a magic number: if (Pos + 4 <= End) {  	res = PackUnpack.UnpackInt32BE (Buf' Pos);  	Pos += 4;  } else {  	for (var i = 0; i < 4; i++) {  		NeedOneByteInBuffer ();  		res <<= 8;  		res += Buf [Pos];  		Pos++;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32,The following statement contains a magic number: if (Pos + 4 <= End) {  	res = PackUnpack.UnpackInt32BE (Buf' Pos);  	Pos += 4;  } else {  	for (var i = 0; i < 4; i++) {  		NeedOneByteInBuffer ();  		res <<= 8;  		res += Buf [Pos];  		Pos++;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32,The following statement contains a magic number: Pos += 4;  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32,The following statement contains a magic number: for (var i = 0; i < 4; i++) {  	NeedOneByteInBuffer ();  	res <<= 8;  	res += Buf [Pos];  	Pos++;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32,The following statement contains a magic number: for (var i = 0; i < 4; i++) {  	NeedOneByteInBuffer ();  	res <<= 8;  	res += Buf [Pos];  	Pos++;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32,The following statement contains a magic number: res <<= 8;  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32LE,The following statement contains a magic number: if (Pos + 4 <= End) {  	res = PackUnpack.UnpackInt32LE (Buf' Pos);  	Pos += 4;  } else {  	for (var rot = 0; rot < 32; rot += 8) {  		NeedOneByteInBuffer ();  		res += Buf [Pos] << rot;  		Pos++;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32LE,The following statement contains a magic number: if (Pos + 4 <= End) {  	res = PackUnpack.UnpackInt32LE (Buf' Pos);  	Pos += 4;  } else {  	for (var rot = 0; rot < 32; rot += 8) {  		NeedOneByteInBuffer ();  		res += Buf [Pos] << rot;  		Pos++;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32LE,The following statement contains a magic number: if (Pos + 4 <= End) {  	res = PackUnpack.UnpackInt32LE (Buf' Pos);  	Pos += 4;  } else {  	for (var rot = 0; rot < 32; rot += 8) {  		NeedOneByteInBuffer ();  		res += Buf [Pos] << rot;  		Pos++;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32LE,The following statement contains a magic number: if (Pos + 4 <= End) {  	res = PackUnpack.UnpackInt32LE (Buf' Pos);  	Pos += 4;  } else {  	for (var rot = 0; rot < 32; rot += 8) {  		NeedOneByteInBuffer ();  		res += Buf [Pos] << rot;  		Pos++;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32LE,The following statement contains a magic number: Pos += 4;  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32LE,The following statement contains a magic number: for (var rot = 0; rot < 32; rot += 8) {  	NeedOneByteInBuffer ();  	res += Buf [Pos] << rot;  	Pos++;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32LE,The following statement contains a magic number: for (var rot = 0; rot < 32; rot += 8) {  	NeedOneByteInBuffer ();  	res += Buf [Pos] << rot;  	Pos++;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadInt32LE,The following statement contains a magic number: rot += 8
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipInt32,The following statement contains a magic number: if (Pos + 4 <= End) {  	Pos += 4;  } else {  	for (int i = 0; i < 4; i++) {  		NeedOneByteInBuffer ();  		Pos++;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipInt32,The following statement contains a magic number: if (Pos + 4 <= End) {  	Pos += 4;  } else {  	for (int i = 0; i < 4; i++) {  		NeedOneByteInBuffer ();  		Pos++;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipInt32,The following statement contains a magic number: if (Pos + 4 <= End) {  	Pos += 4;  } else {  	for (int i = 0; i < 4; i++) {  		NeedOneByteInBuffer ();  		Pos++;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipInt32,The following statement contains a magic number: Pos += 4;  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipInt32,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	NeedOneByteInBuffer ();  	Pos++;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReserveCharBuf,The following statement contains a magic number: if (CharBuf == null) {  	CharBuf = new char[size];  } else {  	if (size <= CharBuf.Length)  		return;  	var newLen = Math.Max ((int)Math.Min ((long)CharBuf.Length * 2' 2147483591 / 2)' size);  	Array.Resize (ref CharBuf' newLen);  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReserveCharBuf,The following statement contains a magic number: if (CharBuf == null) {  	CharBuf = new char[size];  } else {  	if (size <= CharBuf.Length)  		return;  	var newLen = Math.Max ((int)Math.Min ((long)CharBuf.Length * 2' 2147483591 / 2)' size);  	Array.Resize (ref CharBuf' newLen);  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReserveCharBuf,The following statement contains a magic number: if (CharBuf == null) {  	CharBuf = new char[size];  } else {  	if (size <= CharBuf.Length)  		return;  	var newLen = Math.Max ((int)Math.Min ((long)CharBuf.Length * 2' 2147483591 / 2)' size);  	Array.Resize (ref CharBuf' newLen);  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadString,The following statement contains a magic number: while (i < l) {  	if (Pos != End) {  		var b = Buf [Pos];  		if (b < 0x80) {  			res [i] = (char)b;  			i++;  			Pos++;  			continue;  		}  	}  	var c = ReadVUInt64 ();  	if (c > 0xffff) {  		if (c > 0x10ffff)  			throw new InvalidDataException ();  		c -= 0x10000;  		res [i] = (char)((c >> 10) + 0xD800);  		i++;  		res [i] = (char)((c & 0x3FF) + 0xDC00);  		i++;  	} else {  		res [i] = (char)c;  		i++;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadString,The following statement contains a magic number: if (c > 0xffff) {  	if (c > 0x10ffff)  		throw new InvalidDataException ();  	c -= 0x10000;  	res [i] = (char)((c >> 10) + 0xD800);  	i++;  	res [i] = (char)((c & 0x3FF) + 0xDC00);  	i++;  } else {  	res [i] = (char)c;  	i++;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadString,The following statement contains a magic number: res [i] = (char)((c >> 10) + 0xD800);  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadStringOrdered,The following statement contains a magic number: while (true) {  	var c = ReadVUInt32 ();  	if (c == 0)  		break;  	c--;  	if (c > 0xffff) {  		if (c > 0x10ffff) {  			if (len == 0 && c == 0x110000)  				return null;  			throw new InvalidDataException ();  		}  		c -= 0x10000;  		ReserveCharBuf (len + 2);  		CharBuf [len++] = (char)((c >> 10) + 0xD800);  		CharBuf [len++] = (char)((c & 0x3FF) + 0xDC00);  	} else {  		ReserveCharBuf (len + 1);  		CharBuf [len++] = (char)c;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadStringOrdered,The following statement contains a magic number: while (true) {  	var c = ReadVUInt32 ();  	if (c == 0)  		break;  	c--;  	if (c > 0xffff) {  		if (c > 0x10ffff) {  			if (len == 0 && c == 0x110000)  				return null;  			throw new InvalidDataException ();  		}  		c -= 0x10000;  		ReserveCharBuf (len + 2);  		CharBuf [len++] = (char)((c >> 10) + 0xD800);  		CharBuf [len++] = (char)((c & 0x3FF) + 0xDC00);  	} else {  		ReserveCharBuf (len + 1);  		CharBuf [len++] = (char)c;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadStringOrdered,The following statement contains a magic number: if (c > 0xffff) {  	if (c > 0x10ffff) {  		if (len == 0 && c == 0x110000)  			return null;  		throw new InvalidDataException ();  	}  	c -= 0x10000;  	ReserveCharBuf (len + 2);  	CharBuf [len++] = (char)((c >> 10) + 0xD800);  	CharBuf [len++] = (char)((c & 0x3FF) + 0xDC00);  } else {  	ReserveCharBuf (len + 1);  	CharBuf [len++] = (char)c;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadStringOrdered,The following statement contains a magic number: if (c > 0xffff) {  	if (c > 0x10ffff) {  		if (len == 0 && c == 0x110000)  			return null;  		throw new InvalidDataException ();  	}  	c -= 0x10000;  	ReserveCharBuf (len + 2);  	CharBuf [len++] = (char)((c >> 10) + 0xD800);  	CharBuf [len++] = (char)((c & 0x3FF) + 0xDC00);  } else {  	ReserveCharBuf (len + 1);  	CharBuf [len++] = (char)c;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadStringOrdered,The following statement contains a magic number: ReserveCharBuf (len + 2);  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadStringOrdered,The following statement contains a magic number: CharBuf [len++] = (char)((c >> 10) + 0xD800);  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipString,The following statement contains a magic number: while (i < l) {  	var c = ReadVUInt64 ();  	if (c > 0xffff) {  		if (c > 0x10ffff)  			throw new InvalidDataException ();  		i += 2;  	} else {  		i++;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipString,The following statement contains a magic number: if (c > 0xffff) {  	if (c > 0x10ffff)  		throw new InvalidDataException ();  	i += 2;  } else {  	i++;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipString,The following statement contains a magic number: i += 2;  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,Get16Bytes,The following statement contains a magic number: return Bytes16 ?? (Bytes16 = new byte[16]);  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadGuid,The following statement contains a magic number: ReadBlock (res' 0' 16);  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipGuid,The following statement contains a magic number: SkipBlock (16);  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following statement contains a magic number: switch (header >> 5 & 3) {  case 0:  	break;  case 1:  	first = ReadVUInt64 ();  	break;  case 2:  	second = ReadVUInt32 ();  	first = (ulong)ReadInt64 ();  	break;  case 3:  	second = (uint)ReadInt32 ();  	first = (ulong)ReadInt64 ();  	break;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following statement contains a magic number: switch (header >> 5 & 3) {  case 0:  	break;  case 1:  	first = ReadVUInt64 ();  	break;  case 2:  	second = ReadVUInt32 ();  	first = (ulong)ReadInt64 ();  	break;  case 3:  	second = (uint)ReadInt32 ();  	first = (ulong)ReadInt64 ();  	break;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following statement contains a magic number: switch (header >> 5 & 3) {  case 0:  	break;  case 1:  	first = ReadVUInt64 ();  	break;  case 2:  	second = ReadVUInt32 ();  	first = (ulong)ReadInt64 ();  	break;  case 3:  	second = (uint)ReadInt32 ();  	first = (ulong)ReadInt64 ();  	break;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following statement contains a magic number: switch (header >> 5 & 3) {  case 0:  	break;  case 1:  	first = ReadVUInt64 ();  	break;  case 2:  	second = ReadVUInt32 ();  	first = (ulong)ReadInt64 ();  	break;  case 3:  	second = (uint)ReadInt32 ();  	first = (ulong)ReadInt64 ();  	break;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipDecimal,The following statement contains a magic number: switch (header >> 5 & 3) {  case 0:  	break;  case 1:  	SkipVUInt64 ();  	break;  case 2:  	SkipVUInt32 ();  	SkipInt64 ();  	break;  case 3:  	SkipInt32 ();  	SkipInt64 ();  	break;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipDecimal,The following statement contains a magic number: switch (header >> 5 & 3) {  case 0:  	break;  case 1:  	SkipVUInt64 ();  	break;  case 2:  	SkipVUInt32 ();  	SkipInt64 ();  	break;  case 3:  	SkipInt32 ();  	SkipInt64 ();  	break;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipDecimal,The following statement contains a magic number: switch (header >> 5 & 3) {  case 0:  	break;  case 1:  	SkipVUInt64 ();  	break;  case 2:  	SkipVUInt32 ();  	SkipInt64 ();  	break;  case 3:  	SkipInt32 ();  	SkipInt64 ();  	break;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipDecimal,The following statement contains a magic number: switch (header >> 5 & 3) {  case 0:  	break;  case 1:  	SkipVUInt64 ();  	break;  case 2:  	SkipVUInt32 ();  	SkipInt64 ();  	break;  case 3:  	SkipInt32 ();  	SkipInt64 ();  	break;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadIPAddress,The following statement contains a magic number: switch (ReadUInt8 ()) {  case 0:  	return new IPAddress ((uint)ReadInt32LE ());  case 1: {  	var ip6Bytes = Get16Bytes ();  	ReadBlock (ip6Bytes);  	return new IPAddress (ip6Bytes);  }  case 2: {  	var ip6Bytes = Get16Bytes ();  	ReadBlock (ip6Bytes);  	var scopeid = (long)ReadVUInt64 ();  	return new IPAddress (ip6Bytes' scopeid);  }  default:  	throw new InvalidDataException ("Unknown type of IPAddress");  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipIPAddress,The following statement contains a magic number: switch (ReadUInt8 ()) {  case 0:  	SkipInt32 ();  	return;  case 1:  	SkipBlock (16);  	return;  case 2:  	SkipBlock (16);  	SkipVUInt64 ();  	return;  default:  	throw new InvalidDataException ("Unknown type of IPAddress");  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipIPAddress,The following statement contains a magic number: switch (ReadUInt8 ()) {  case 0:  	SkipInt32 ();  	return;  case 1:  	SkipBlock (16);  	return;  case 2:  	SkipBlock (16);  	SkipVUInt64 ();  	return;  default:  	throw new InvalidDataException ("Unknown type of IPAddress");  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipIPAddress,The following statement contains a magic number: switch (ReadUInt8 ()) {  case 0:  	SkipInt32 ();  	return;  case 1:  	SkipBlock (16);  	return;  case 2:  	SkipBlock (16);  	SkipVUInt64 ();  	return;  default:  	throw new InvalidDataException ("Unknown type of IPAddress");  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipIPAddress,The following statement contains a magic number: SkipBlock (16);  
Magic Number,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipIPAddress,The following statement contains a magic number: SkipBlock (16);  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt8Ordered,The following statement contains a magic number: Buf [Pos++] = (byte)(value + 128);  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt64,The following statement contains a magic number: if (Pos + 8 > End) {  	FlushBuffer ();  	if (Pos + 8 > End) {  		var b = new byte[8];  		PackUnpack.PackInt64BE (b' 0' value);  		WriteBlock (b);  		return;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt64,The following statement contains a magic number: if (Pos + 8 > End) {  	FlushBuffer ();  	if (Pos + 8 > End) {  		var b = new byte[8];  		PackUnpack.PackInt64BE (b' 0' value);  		WriteBlock (b);  		return;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt64,The following statement contains a magic number: if (Pos + 8 > End) {  	FlushBuffer ();  	if (Pos + 8 > End) {  		var b = new byte[8];  		PackUnpack.PackInt64BE (b' 0' value);  		WriteBlock (b);  		return;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt64,The following statement contains a magic number: if (Pos + 8 > End) {  	var b = new byte[8];  	PackUnpack.PackInt64BE (b' 0' value);  	WriteBlock (b);  	return;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt64,The following statement contains a magic number: if (Pos + 8 > End) {  	var b = new byte[8];  	PackUnpack.PackInt64BE (b' 0' value);  	WriteBlock (b);  	return;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt64,The following statement contains a magic number: Pos += 8;  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32,The following statement contains a magic number: if (Pos + 4 > End) {  	FlushBuffer ();  	if (Pos + 4 > End) {  		var b = new byte[4];  		PackUnpack.PackInt32BE (b' 0' value);  		WriteBlock (b);  		return;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32,The following statement contains a magic number: if (Pos + 4 > End) {  	FlushBuffer ();  	if (Pos + 4 > End) {  		var b = new byte[4];  		PackUnpack.PackInt32BE (b' 0' value);  		WriteBlock (b);  		return;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32,The following statement contains a magic number: if (Pos + 4 > End) {  	FlushBuffer ();  	if (Pos + 4 > End) {  		var b = new byte[4];  		PackUnpack.PackInt32BE (b' 0' value);  		WriteBlock (b);  		return;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32,The following statement contains a magic number: if (Pos + 4 > End) {  	var b = new byte[4];  	PackUnpack.PackInt32BE (b' 0' value);  	WriteBlock (b);  	return;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32,The following statement contains a magic number: if (Pos + 4 > End) {  	var b = new byte[4];  	PackUnpack.PackInt32BE (b' 0' value);  	WriteBlock (b);  	return;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32,The following statement contains a magic number: Pos += 4;  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32LE,The following statement contains a magic number: if (Pos + 4 > End) {  	FlushBuffer ();  	if (Pos + 4 > End) {  		var b = new byte[4];  		PackUnpack.PackInt32LE (b' 0' value);  		WriteBlock (b);  		return;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32LE,The following statement contains a magic number: if (Pos + 4 > End) {  	FlushBuffer ();  	if (Pos + 4 > End) {  		var b = new byte[4];  		PackUnpack.PackInt32LE (b' 0' value);  		WriteBlock (b);  		return;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32LE,The following statement contains a magic number: if (Pos + 4 > End) {  	FlushBuffer ();  	if (Pos + 4 > End) {  		var b = new byte[4];  		PackUnpack.PackInt32LE (b' 0' value);  		WriteBlock (b);  		return;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32LE,The following statement contains a magic number: if (Pos + 4 > End) {  	var b = new byte[4];  	PackUnpack.PackInt32LE (b' 0' value);  	WriteBlock (b);  	return;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32LE,The following statement contains a magic number: if (Pos + 4 > End) {  	var b = new byte[4];  	PackUnpack.PackInt32LE (b' 0' value);  	WriteBlock (b);  	return;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteInt32LE,The following statement contains a magic number: Pos += 4;  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteStringOrdered,The following statement contains a magic number: while (i < l) {  	var c = value [i];  	if (char.IsHighSurrogate (c) && i + 1 < l) {  		var c2 = value [i + 1];  		if (char.IsLowSurrogate (c2)) {  			WriteVUInt32 ((uint)((c - 0xD800) * 0x400 + (c2 - 0xDC00) + 0x10000) + 1);  			i += 2;  			continue;  		}  	}  	WriteVUInt32 ((uint)c + 1);  	i++;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteStringOrdered,The following statement contains a magic number: if (char.IsHighSurrogate (c) && i + 1 < l) {  	var c2 = value [i + 1];  	if (char.IsLowSurrogate (c2)) {  		WriteVUInt32 ((uint)((c - 0xD800) * 0x400 + (c2 - 0xDC00) + 0x10000) + 1);  		i += 2;  		continue;  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteStringOrdered,The following statement contains a magic number: if (char.IsLowSurrogate (c2)) {  	WriteVUInt32 ((uint)((c - 0xD800) * 0x400 + (c2 - 0xDC00) + 0x10000) + 1);  	i += 2;  	continue;  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteStringOrdered,The following statement contains a magic number: i += 2;  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteGuid,The following statement contains a magic number: WriteBlock (ptr' 16);  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (ints [3] < 0)  	header |= 128;  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (ints [3] < 0)  	header |= 128;  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: header |= 128;  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (ints [2] == 0) {  	if (first == 0) {  		WriteUInt8 (header);  	} else {  		header |= 32;  		WriteUInt8 (header);  		WriteVUInt64 (first);  	}  } else {  	if ((uint)ints [2] < 0x10000000) {  		header |= 64;  		WriteUInt8 (header);  		WriteVUInt32 ((uint)ints [2]);  		WriteInt64 ((long)first);  	} else {  		header |= 64 | 32;  		WriteUInt8 (header);  		WriteInt32 (ints [2]);  		WriteInt64 ((long)first);  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (ints [2] == 0) {  	if (first == 0) {  		WriteUInt8 (header);  	} else {  		header |= 32;  		WriteUInt8 (header);  		WriteVUInt64 (first);  	}  } else {  	if ((uint)ints [2] < 0x10000000) {  		header |= 64;  		WriteUInt8 (header);  		WriteVUInt32 ((uint)ints [2]);  		WriteInt64 ((long)first);  	} else {  		header |= 64 | 32;  		WriteUInt8 (header);  		WriteInt32 (ints [2]);  		WriteInt64 ((long)first);  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (ints [2] == 0) {  	if (first == 0) {  		WriteUInt8 (header);  	} else {  		header |= 32;  		WriteUInt8 (header);  		WriteVUInt64 (first);  	}  } else {  	if ((uint)ints [2] < 0x10000000) {  		header |= 64;  		WriteUInt8 (header);  		WriteVUInt32 ((uint)ints [2]);  		WriteInt64 ((long)first);  	} else {  		header |= 64 | 32;  		WriteUInt8 (header);  		WriteInt32 (ints [2]);  		WriteInt64 ((long)first);  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (ints [2] == 0) {  	if (first == 0) {  		WriteUInt8 (header);  	} else {  		header |= 32;  		WriteUInt8 (header);  		WriteVUInt64 (first);  	}  } else {  	if ((uint)ints [2] < 0x10000000) {  		header |= 64;  		WriteUInt8 (header);  		WriteVUInt32 ((uint)ints [2]);  		WriteInt64 ((long)first);  	} else {  		header |= 64 | 32;  		WriteUInt8 (header);  		WriteInt32 (ints [2]);  		WriteInt64 ((long)first);  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (ints [2] == 0) {  	if (first == 0) {  		WriteUInt8 (header);  	} else {  		header |= 32;  		WriteUInt8 (header);  		WriteVUInt64 (first);  	}  } else {  	if ((uint)ints [2] < 0x10000000) {  		header |= 64;  		WriteUInt8 (header);  		WriteVUInt32 ((uint)ints [2]);  		WriteInt64 ((long)first);  	} else {  		header |= 64 | 32;  		WriteUInt8 (header);  		WriteInt32 (ints [2]);  		WriteInt64 ((long)first);  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (ints [2] == 0) {  	if (first == 0) {  		WriteUInt8 (header);  	} else {  		header |= 32;  		WriteUInt8 (header);  		WriteVUInt64 (first);  	}  } else {  	if ((uint)ints [2] < 0x10000000) {  		header |= 64;  		WriteUInt8 (header);  		WriteVUInt32 ((uint)ints [2]);  		WriteInt64 ((long)first);  	} else {  		header |= 64 | 32;  		WriteUInt8 (header);  		WriteInt32 (ints [2]);  		WriteInt64 ((long)first);  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (ints [2] == 0) {  	if (first == 0) {  		WriteUInt8 (header);  	} else {  		header |= 32;  		WriteUInt8 (header);  		WriteVUInt64 (first);  	}  } else {  	if ((uint)ints [2] < 0x10000000) {  		header |= 64;  		WriteUInt8 (header);  		WriteVUInt32 ((uint)ints [2]);  		WriteInt64 ((long)first);  	} else {  		header |= 64 | 32;  		WriteUInt8 (header);  		WriteInt32 (ints [2]);  		WriteInt64 ((long)first);  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (ints [2] == 0) {  	if (first == 0) {  		WriteUInt8 (header);  	} else {  		header |= 32;  		WriteUInt8 (header);  		WriteVUInt64 (first);  	}  } else {  	if ((uint)ints [2] < 0x10000000) {  		header |= 64;  		WriteUInt8 (header);  		WriteVUInt32 ((uint)ints [2]);  		WriteInt64 ((long)first);  	} else {  		header |= 64 | 32;  		WriteUInt8 (header);  		WriteInt32 (ints [2]);  		WriteInt64 ((long)first);  	}  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if (first == 0) {  	WriteUInt8 (header);  } else {  	header |= 32;  	WriteUInt8 (header);  	WriteVUInt64 (first);  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: header |= 32;  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if ((uint)ints [2] < 0x10000000) {  	header |= 64;  	WriteUInt8 (header);  	WriteVUInt32 ((uint)ints [2]);  	WriteInt64 ((long)first);  } else {  	header |= 64 | 32;  	WriteUInt8 (header);  	WriteInt32 (ints [2]);  	WriteInt64 ((long)first);  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if ((uint)ints [2] < 0x10000000) {  	header |= 64;  	WriteUInt8 (header);  	WriteVUInt32 ((uint)ints [2]);  	WriteInt64 ((long)first);  } else {  	header |= 64 | 32;  	WriteUInt8 (header);  	WriteInt32 (ints [2]);  	WriteInt64 ((long)first);  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if ((uint)ints [2] < 0x10000000) {  	header |= 64;  	WriteUInt8 (header);  	WriteVUInt32 ((uint)ints [2]);  	WriteInt64 ((long)first);  } else {  	header |= 64 | 32;  	WriteUInt8 (header);  	WriteInt32 (ints [2]);  	WriteInt64 ((long)first);  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if ((uint)ints [2] < 0x10000000) {  	header |= 64;  	WriteUInt8 (header);  	WriteVUInt32 ((uint)ints [2]);  	WriteInt64 ((long)first);  } else {  	header |= 64 | 32;  	WriteUInt8 (header);  	WriteInt32 (ints [2]);  	WriteInt64 ((long)first);  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if ((uint)ints [2] < 0x10000000) {  	header |= 64;  	WriteUInt8 (header);  	WriteVUInt32 ((uint)ints [2]);  	WriteInt64 ((long)first);  } else {  	header |= 64 | 32;  	WriteUInt8 (header);  	WriteInt32 (ints [2]);  	WriteInt64 ((long)first);  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: if ((uint)ints [2] < 0x10000000) {  	header |= 64;  	WriteUInt8 (header);  	WriteVUInt32 ((uint)ints [2]);  	WriteInt64 ((long)first);  } else {  	header |= 64 | 32;  	WriteUInt8 (header);  	WriteInt32 (ints [2]);  	WriteInt64 ((long)first);  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: header |= 64;  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: WriteVUInt32 ((uint)ints [2]);  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: header |= 64 | 32;  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: header |= 64 | 32;  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteDecimal,The following statement contains a magic number: WriteInt32 (ints [2]);  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteIPAddress,The following statement contains a magic number: if (value.AddressFamily == AddressFamily.InterNetworkV6) {  	if (value.ScopeId != 0) {  		WriteUInt8 (2);  		WriteBlock (value.GetAddressBytes ());  		WriteVUInt64 ((ulong)value.ScopeId);  	} else {  		WriteUInt8 (1);  		WriteBlock (value.GetAddressBytes ());  	}  } else {  	WriteUInt8 (0);  	#pragma  	WriteInt32LE ((int)value.Address);  	#pragma  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteIPAddress,The following statement contains a magic number: if (value.AddressFamily == AddressFamily.InterNetworkV6) {  	if (value.ScopeId != 0) {  		WriteUInt8 (2);  		WriteBlock (value.GetAddressBytes ());  		WriteVUInt64 ((ulong)value.ScopeId);  	} else {  		WriteUInt8 (1);  		WriteBlock (value.GetAddressBytes ());  	}  } else {  	WriteUInt8 (0);  	#pragma  	WriteInt32LE ((int)value.Address);  	#pragma  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteIPAddress,The following statement contains a magic number: if (value.AddressFamily == AddressFamily.InterNetworkV6) {  	if (value.ScopeId != 0) {  		WriteUInt8 (2);  		WriteBlock (value.GetAddressBytes ());  		WriteVUInt64 ((ulong)value.ScopeId);  	} else {  		WriteUInt8 (1);  		WriteBlock (value.GetAddressBytes ());  	}  } else {  	WriteUInt8 (0);  	#pragma  	WriteInt32LE ((int)value.Address);  	#pragma  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteIPAddress,The following statement contains a magic number: if (value.AddressFamily == AddressFamily.InterNetworkV6) {  	if (value.ScopeId != 0) {  		WriteUInt8 (2);  		WriteBlock (value.GetAddressBytes ());  		WriteVUInt64 ((ulong)value.ScopeId);  	} else {  		WriteUInt8 (1);  		WriteBlock (value.GetAddressBytes ());  	}  } else {  	WriteUInt8 (0);  	#pragma  	WriteInt32LE ((int)value.Address);  	#pragma  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteIPAddress,The following statement contains a magic number: if (value.AddressFamily == AddressFamily.InterNetworkV6) {  	if (value.ScopeId != 0) {  		WriteUInt8 (2);  		WriteBlock (value.GetAddressBytes ());  		WriteVUInt64 ((ulong)value.ScopeId);  	} else {  		WriteUInt8 (1);  		WriteBlock (value.GetAddressBytes ());  	}  } else {  	WriteUInt8 (0);  	#pragma  	WriteInt32LE ((int)value.Address);  	#pragma  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteIPAddress,The following statement contains a magic number: if (value.ScopeId != 0) {  	WriteUInt8 (2);  	WriteBlock (value.GetAddressBytes ());  	WriteVUInt64 ((ulong)value.ScopeId);  } else {  	WriteUInt8 (1);  	WriteBlock (value.GetAddressBytes ());  }  
Magic Number,BTDB.StreamLayer,AbstractBufferedWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedWriter.cs,WriteIPAddress,The following statement contains a magic number: WriteUInt8 (2);  
Magic Number,BTDB.StreamLayer,ByteBufferWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\ByteBufferWriter.cs,ByteBufferWriter,The following statement contains a magic number: Buf = new byte[32];  
Magic Number,BTDB.StreamLayer,ByteBufferWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\ByteBufferWriter.cs,Reset,The following statement contains a magic number: Buf = new byte[32];  
Magic Number,BTDB.StreamLayer,PositionLessStreamReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\PositionLessStreamReader.cs,PositionLessStreamReader,The following statement contains a magic number: Buf = new byte[8192];  
Magic Number,BTDB.StreamLayer,PositionLessStreamWriter,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\PositionLessStreamWriter.cs,PositionLessStreamWriter,The following statement contains a magic number: Buf = new byte[8192];  
Magic Number,BTDB.StreamLayer,LoggingPositionLessStream,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\LoggingPositionLessStream.cs,Read,The following statement contains a magic number: while (i < res) {  	if (j == 16) {  		Log (sb.ToString ());  		sb.Length = 0;  		j = 0;  	}  	if (j == 0) {  		sb.AppendFormat ("{0:X8}"' pos + (uint)i);  	}  	sb.AppendFormat (" {0:X2}"' data [offset + i]);  	j++;  	i++;  }  
Magic Number,BTDB.StreamLayer,LoggingPositionLessStream,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\LoggingPositionLessStream.cs,Read,The following statement contains a magic number: if (j == 16) {  	Log (sb.ToString ());  	sb.Length = 0;  	j = 0;  }  
Magic Number,BTDB.StreamLayer,LoggingPositionLessStream,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\LoggingPositionLessStream.cs,Write,The following statement contains a magic number: while (i < size) {  	if (j == 16) {  		Log (sb.ToString ());  		sb.Length = 0;  		j = 0;  	}  	if (j == 0) {  		sb.AppendFormat ("{0:X8}"' pos + (uint)i);  	}  	sb.AppendFormat (" {0:X2}"' data [offset + i]);  	j++;  	i++;  }  
Magic Number,BTDB.StreamLayer,LoggingPositionLessStream,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\LoggingPositionLessStream.cs,Write,The following statement contains a magic number: if (j == 16) {  	Log (sb.ToString ());  	sb.Length = 0;  	j = 0;  }  
Magic Number,BTDB.StreamLayer,PositionLessStreamProxy,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\PositionLessStreamProxy.cs,PositionLessStreamProxy,The following statement contains a magic number: _writeBufSize = 32768;  
Duplicate Code,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,IncrementInt64LE,The method contains a code clone-set at the following line numbers (starting from the method definition): ((3' 22)' (8' 27)' (13' 32)' (18' 37))
Duplicate Code,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,IncrementInt64LE,The method contains a code clone-set at the following line numbers (starting from the method definition): ((3' 31)' (8' 36))
Duplicate Code,BTDB.Buffer,PackUnpack,F:\newReposMay17\Bobris_BTDB\BTDB\Buffer\PackUnpack.cs,IncrementInt64LE,The method contains a code clone-set at the following line numbers (starting from the method definition): ((3' 22)' (13' 32)' (18' 37))
Missing Default,BTDB.SnappyCompression,SnappyDecompress,F:\newReposMay17\Bobris_BTDB\BTDB\SnappyCompression\SnappyDecompress.cs,DecompressRaw,The following switch statement is missing a default case: switch (b & 3) {  case 0:  	len = b >> 2;  	if (len < 60) {  		len++;  	} else if (len == 60) {  		if (sL < 1)  			return false;  		len = src [s] + 1;  		s++;  		sL--;  	} else if (len == 61) {  		if (sL < 2)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 1;  		s += 2;  		sL -= 2;  	} else if (len == 62) {  		if (sL < 3)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 1;  		s += 3;  		sL -= 3;  	} else {  		if (sL < 4)  			return false;  		len = src [s] + 0x100 * src [s + 1] + 0x10000 * src [s + 2] + 0x1000000 * src [s + 3] + 1;  		s += 3;  		sL -= 3;  	}  	if (len <= 0)  		return false;  	if (len > dL || len > sL)  		return false;  	Array.Copy (src' s' dst' d' len);  	s += len;  	d += len;  	sL -= len;  	dL -= len;  	continue;  case 1:  	if (sL < 1)  		return false;  	len = 4 + ((b >> 2) & 7);  	o = (b & 0xe0) << 3 | src [s];  	s++;  	sL--;  	break;  case 2:  	if (sL < 2)  		return false;  	len = 1 + (b >> 2);  	o = src [s] + src [s + 1] * 0x100;  	s += 2;  	sL -= 2;  	break;  case 3:  	return false;  }  
Missing Default,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,ReadDecimal,The following switch statement is missing a default case: switch (header >> 5 & 3) {  case 0:  	break;  case 1:  	first = ReadVUInt64 ();  	break;  case 2:  	second = ReadVUInt32 ();  	first = (ulong)ReadInt64 ();  	break;  case 3:  	second = (uint)ReadInt32 ();  	first = (ulong)ReadInt64 ();  	break;  }  
Missing Default,BTDB.StreamLayer,AbstractBufferedReader,F:\newReposMay17\Bobris_BTDB\BTDB\StreamLayer\AbstractBufferedReader.cs,SkipDecimal,The following switch statement is missing a default case: switch (header >> 5 & 3) {  case 0:  	break;  case 1:  	SkipVUInt64 ();  	break;  case 2:  	SkipVUInt32 ();  	SkipInt64 ();  	break;  case 3:  	SkipInt32 ();  	SkipInt64 ();  	break;  }  
