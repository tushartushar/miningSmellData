Implementation smell,Namespace,Class,File,Method,Description
Long Method,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The method has 150 lines of code.
Long Method,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForCompression,The method has 203 lines of code.
Long Method,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForDecompression,The method has 161 lines of code.
Complex Method,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_colormap,Cyclomatic complexity of the method is 8
Complex Method,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,Cyclomatic complexity of the method is 15
Complex Method,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,applyOptions,Cyclomatic complexity of the method is 12
Complex Method,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,applyOptions,Cyclomatic complexity of the method is 9
Long Statement,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,GET_4B,The length of the statement  "            return (int)array[offset] + ((int)array[offset + 1] << 8) + ((int)array[offset + 2] << 16) + ((int)array[offset + 3] << 24); " is 124.
Long Statement,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,writeUsageForDCT,The length of the statement  "            Console.WriteLine("  -dct int       Use integer DCT method {0}"' (JpegConstants.JDCT_DEFAULT == J_DCT_METHOD.JDCT_ISLOW) ? " (default)" : ""); " is 142.
Long Statement,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,writeUsageForDCT,The length of the statement  "            Console.WriteLine("  -dct fast      Use fast integer DCT (less accurate) {0}"' (JpegConstants.JDCT_DEFAULT == J_DCT_METHOD.JDCT_IFAST) ? " (default)" : ""); " is 156.
Long Statement,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,writeUsageForDCT,The length of the statement  "            Console.WriteLine("  -dct float     Use floating-point DCT method {0}"' (JpegConstants.JDCT_DEFAULT == J_DCT_METHOD.JDCT_FLOAT) ? " (default)" : ""); " is 149.
Long Statement,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForCompression,The length of the statement  "                        Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright)); " is 130.
Long Statement,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,decompress,The length of the statement  "            cinfo.jpeg_set_marker_processor((int)JPEG_MARKER.COM' new jpeg_decompress_struct.jpeg_marker_parser_method(printTextMarker)); " is 125.
Long Statement,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForDecompression,The length of the statement  "                        Console.Write(string.Format("Bit Miracle's DJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright)); " is 130.
Complex Conditional,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForDecompression,The conditional expression  "cdjpeg_utils.keymatch(arg' "colors"' 1) ||                           cdjpeg_utils.keymatch(arg' "colours"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantize"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantise"' 1)"  is complex.
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,bmp_dest_struct,The following statement contains a magic number: while ((row_width & 3) != 0)                  row_width++;
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,put_24bit_rows,The following statement contains a magic number: for (int col = cinfo.Output_width; col > 0; col--)              {                  image_ptr[0][imageIndex + 2] = buffer[0][bufferIndex];   /* can omit GETJSAMPLE() safely */                  bufferIndex++;                  image_ptr[0][imageIndex + 1] = buffer[0][bufferIndex];                  bufferIndex++;                  image_ptr[0][imageIndex] = buffer[0][bufferIndex];                  bufferIndex++;                  imageIndex += 3;              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,put_24bit_rows,The following statement contains a magic number: for (int col = cinfo.Output_width; col > 0; col--)              {                  image_ptr[0][imageIndex + 2] = buffer[0][bufferIndex];   /* can omit GETJSAMPLE() safely */                  bufferIndex++;                  image_ptr[0][imageIndex + 1] = buffer[0][bufferIndex];                  bufferIndex++;                  image_ptr[0][imageIndex] = buffer[0][bufferIndex];                  bufferIndex++;                  imageIndex += 3;              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: if (cinfo.Out_color_space == J_COLOR_SPACE.JCS_RGB)              {                  if (cinfo.Quantize_colors)                  {                      /* Colormapped RGB */                      bits_per_pixel = 8;                      cmap_entries = 256;                  }                  else                  {                      /* Unquantized' full color RGB */                      bits_per_pixel = 24;                      cmap_entries = 0;                  }              }              else              {                  /* Grayscale output.  We need to fake a 256-entry colormap. */                  bits_per_pixel = 8;                  cmap_entries = 256;              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: if (cinfo.Out_color_space == J_COLOR_SPACE.JCS_RGB)              {                  if (cinfo.Quantize_colors)                  {                      /* Colormapped RGB */                      bits_per_pixel = 8;                      cmap_entries = 256;                  }                  else                  {                      /* Unquantized' full color RGB */                      bits_per_pixel = 24;                      cmap_entries = 0;                  }              }              else              {                  /* Grayscale output.  We need to fake a 256-entry colormap. */                  bits_per_pixel = 8;                  cmap_entries = 256;              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: if (cinfo.Out_color_space == J_COLOR_SPACE.JCS_RGB)              {                  if (cinfo.Quantize_colors)                  {                      /* Colormapped RGB */                      bits_per_pixel = 8;                      cmap_entries = 256;                  }                  else                  {                      /* Unquantized' full color RGB */                      bits_per_pixel = 24;                      cmap_entries = 0;                  }              }              else              {                  /* Grayscale output.  We need to fake a 256-entry colormap. */                  bits_per_pixel = 8;                  cmap_entries = 256;              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: if (cinfo.Out_color_space == J_COLOR_SPACE.JCS_RGB)              {                  if (cinfo.Quantize_colors)                  {                      /* Colormapped RGB */                      bits_per_pixel = 8;                      cmap_entries = 256;                  }                  else                  {                      /* Unquantized' full color RGB */                      bits_per_pixel = 24;                      cmap_entries = 0;                  }              }              else              {                  /* Grayscale output.  We need to fake a 256-entry colormap. */                  bits_per_pixel = 8;                  cmap_entries = 256;              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: if (cinfo.Out_color_space == J_COLOR_SPACE.JCS_RGB)              {                  if (cinfo.Quantize_colors)                  {                      /* Colormapped RGB */                      bits_per_pixel = 8;                      cmap_entries = 256;                  }                  else                  {                      /* Unquantized' full color RGB */                      bits_per_pixel = 24;                      cmap_entries = 0;                  }              }              else              {                  /* Grayscale output.  We need to fake a 256-entry colormap. */                  bits_per_pixel = 8;                  cmap_entries = 256;              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: int headersize = 14 + 40 + cmap_entries * 4;
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: int headersize = 14 + 40 + cmap_entries * 4;
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: int headersize = 14 + 40 + cmap_entries * 4;
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: byte[] bmpfileheader = new byte[14];
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: byte[] bmpinfoheader = new byte[40];
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: PUT_4B(bmpfileheader' 2' bfSize);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: PUT_4B(bmpfileheader' 10' headersize);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: PUT_2B(bmpinfoheader' 0' 40);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: PUT_4B(bmpinfoheader' 4' cinfo.Output_width);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: PUT_4B(bmpinfoheader' 8' cinfo.Output_height);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: PUT_2B(bmpinfoheader' 12' 1);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: PUT_2B(bmpinfoheader' 14' bits_per_pixel);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: if (cinfo.Density_unit == DensityUnit.DotsCm)              {                  /* if have density in dots/cm' then */                  PUT_4B(bmpinfoheader' 24' (int)(cinfo.X_density * 100)); /* XPels/M */                  PUT_4B(bmpinfoheader' 28' (int)(cinfo.Y_density * 100)); /* XPels/M */              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: if (cinfo.Density_unit == DensityUnit.DotsCm)              {                  /* if have density in dots/cm' then */                  PUT_4B(bmpinfoheader' 24' (int)(cinfo.X_density * 100)); /* XPels/M */                  PUT_4B(bmpinfoheader' 28' (int)(cinfo.Y_density * 100)); /* XPels/M */              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: if (cinfo.Density_unit == DensityUnit.DotsCm)              {                  /* if have density in dots/cm' then */                  PUT_4B(bmpinfoheader' 24' (int)(cinfo.X_density * 100)); /* XPels/M */                  PUT_4B(bmpinfoheader' 28' (int)(cinfo.Y_density * 100)); /* XPels/M */              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: if (cinfo.Density_unit == DensityUnit.DotsCm)              {                  /* if have density in dots/cm' then */                  PUT_4B(bmpinfoheader' 24' (int)(cinfo.X_density * 100)); /* XPels/M */                  PUT_4B(bmpinfoheader' 28' (int)(cinfo.Y_density * 100)); /* XPels/M */              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: PUT_2B(bmpinfoheader' 32' cmap_entries);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: try              {                  output_file.Write(bmpfileheader' 0' 14);              }              catch (Exception e)              {                  cinfo.TRACEMS(0' J_MESSAGE_CODE.JERR_FILE_WRITE' e.Message);                  cinfo.ERREXIT(J_MESSAGE_CODE.JERR_FILE_WRITE);              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: try              {                  output_file.Write(bmpinfoheader' 0' 40);              }              catch (Exception e)              {                  cinfo.TRACEMS(0' J_MESSAGE_CODE.JERR_FILE_WRITE' e.Message);                  cinfo.ERREXIT(J_MESSAGE_CODE.JERR_FILE_WRITE);              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_bmp_header,The following statement contains a magic number: if (cmap_entries > 0)                  write_colormap(cmap_entries' 4);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_os2_header,The following statement contains a magic number: if (cinfo.Out_color_space == J_COLOR_SPACE.JCS_RGB)              {                  if (cinfo.Quantize_colors)                  {                      /* Colormapped RGB */                      bits_per_pixel = 8;                      cmap_entries = 256;                  }                  else                  {                      /* Unquantized' full color RGB */                      bits_per_pixel = 24;                      cmap_entries = 0;                  }              }              else              {                  /* Grayscale output.  We need to fake a 256-entry colormap. */                  bits_per_pixel = 8;                  cmap_entries = 256;              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_os2_header,The following statement contains a magic number: if (cinfo.Out_color_space == J_COLOR_SPACE.JCS_RGB)              {                  if (cinfo.Quantize_colors)                  {                      /* Colormapped RGB */                      bits_per_pixel = 8;                      cmap_entries = 256;                  }                  else                  {                      /* Unquantized' full color RGB */                      bits_per_pixel = 24;                      cmap_entries = 0;                  }              }              else              {                  /* Grayscale output.  We need to fake a 256-entry colormap. */                  bits_per_pixel = 8;                  cmap_entries = 256;              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_os2_header,The following statement contains a magic number: if (cinfo.Out_color_space == J_COLOR_SPACE.JCS_RGB)              {                  if (cinfo.Quantize_colors)                  {                      /* Colormapped RGB */                      bits_per_pixel = 8;                      cmap_entries = 256;                  }                  else                  {                      /* Unquantized' full color RGB */                      bits_per_pixel = 24;                      cmap_entries = 0;                  }              }              else              {                  /* Grayscale output.  We need to fake a 256-entry colormap. */                  bits_per_pixel = 8;                  cmap_entries = 256;              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_os2_header,The following statement contains a magic number: if (cinfo.Out_color_space == J_COLOR_SPACE.JCS_RGB)              {                  if (cinfo.Quantize_colors)                  {                      /* Colormapped RGB */                      bits_per_pixel = 8;                      cmap_entries = 256;                  }                  else                  {                      /* Unquantized' full color RGB */                      bits_per_pixel = 24;                      cmap_entries = 0;                  }              }              else              {                  /* Grayscale output.  We need to fake a 256-entry colormap. */                  bits_per_pixel = 8;                  cmap_entries = 256;              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_os2_header,The following statement contains a magic number: if (cinfo.Out_color_space == J_COLOR_SPACE.JCS_RGB)              {                  if (cinfo.Quantize_colors)                  {                      /* Colormapped RGB */                      bits_per_pixel = 8;                      cmap_entries = 256;                  }                  else                  {                      /* Unquantized' full color RGB */                      bits_per_pixel = 24;                      cmap_entries = 0;                  }              }              else              {                  /* Grayscale output.  We need to fake a 256-entry colormap. */                  bits_per_pixel = 8;                  cmap_entries = 256;              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_os2_header,The following statement contains a magic number: int headersize = 14 + 12 + cmap_entries * 3;
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_os2_header,The following statement contains a magic number: int headersize = 14 + 12 + cmap_entries * 3;
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_os2_header,The following statement contains a magic number: int headersize = 14 + 12 + cmap_entries * 3;
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_os2_header,The following statement contains a magic number: byte[] bmpfileheader = new byte[14];
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_os2_header,The following statement contains a magic number: byte[] bmpcoreheader = new byte[12];
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_os2_header,The following statement contains a magic number: PUT_4B(bmpfileheader' 2' bfSize);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_os2_header,The following statement contains a magic number: PUT_4B(bmpfileheader' 10' headersize);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_os2_header,The following statement contains a magic number: PUT_2B(bmpcoreheader' 0' 12);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_os2_header,The following statement contains a magic number: PUT_2B(bmpcoreheader' 4' cinfo.Output_width);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_os2_header,The following statement contains a magic number: PUT_2B(bmpcoreheader' 6' cinfo.Output_height);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_os2_header,The following statement contains a magic number: PUT_2B(bmpcoreheader' 8' 1);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_os2_header,The following statement contains a magic number: PUT_2B(bmpcoreheader' 10' bits_per_pixel);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_os2_header,The following statement contains a magic number: try              {                  output_file.Write(bmpfileheader' 0' 14);              }              catch (Exception e)              {                  cinfo.TRACEMS(0' J_MESSAGE_CODE.JERR_FILE_WRITE' e.Message);                  cinfo.ERREXIT(J_MESSAGE_CODE.JERR_FILE_WRITE);              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_os2_header,The following statement contains a magic number: try              {                  output_file.Write(bmpcoreheader' 0' 12);              }              catch (Exception e)              {                  cinfo.TRACEMS(0' J_MESSAGE_CODE.JERR_FILE_WRITE' e.Message);                  cinfo.ERREXIT(J_MESSAGE_CODE.JERR_FILE_WRITE);              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_os2_header,The following statement contains a magic number: if (cmap_entries > 0)                  write_colormap(cmap_entries' 3);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_colormap,The following statement contains a magic number: if (colormap != null)              {                  if (cinfo.Out_color_components == 3)                  {                      /* Normal case with RGB colormap */                      for (i = 0; i < num_colors; i++)                      {                          output_file.WriteByte(colormap[2][i]);                          output_file.WriteByte(colormap[1][i]);                          output_file.WriteByte(colormap[0][i]);                          if (map_entry_size == 4)                              output_file.WriteByte(0);                      }                  }                  else                  {                      /* Grayscale colormap (only happens with grayscale quantization) */                      for (i = 0; i < num_colors; i++)                      {                          output_file.WriteByte(colormap[0][i]);                          output_file.WriteByte(colormap[0][i]);                          output_file.WriteByte(colormap[0][i]);                          if (map_entry_size == 4)                              output_file.WriteByte(0);                      }                  }              }              else              {                  /* If no colormap' must be grayscale data.  Generate a linear "map". */                  for (i = 0; i < 256; i++)                  {                      output_file.WriteByte((byte)i);                      output_file.WriteByte((byte)i);                      output_file.WriteByte((byte)i);                      if (map_entry_size == 4)                          output_file.WriteByte(0);                  }              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_colormap,The following statement contains a magic number: if (colormap != null)              {                  if (cinfo.Out_color_components == 3)                  {                      /* Normal case with RGB colormap */                      for (i = 0; i < num_colors; i++)                      {                          output_file.WriteByte(colormap[2][i]);                          output_file.WriteByte(colormap[1][i]);                          output_file.WriteByte(colormap[0][i]);                          if (map_entry_size == 4)                              output_file.WriteByte(0);                      }                  }                  else                  {                      /* Grayscale colormap (only happens with grayscale quantization) */                      for (i = 0; i < num_colors; i++)                      {                          output_file.WriteByte(colormap[0][i]);                          output_file.WriteByte(colormap[0][i]);                          output_file.WriteByte(colormap[0][i]);                          if (map_entry_size == 4)                              output_file.WriteByte(0);                      }                  }              }              else              {                  /* If no colormap' must be grayscale data.  Generate a linear "map". */                  for (i = 0; i < 256; i++)                  {                      output_file.WriteByte((byte)i);                      output_file.WriteByte((byte)i);                      output_file.WriteByte((byte)i);                      if (map_entry_size == 4)                          output_file.WriteByte(0);                  }              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_colormap,The following statement contains a magic number: if (colormap != null)              {                  if (cinfo.Out_color_components == 3)                  {                      /* Normal case with RGB colormap */                      for (i = 0; i < num_colors; i++)                      {                          output_file.WriteByte(colormap[2][i]);                          output_file.WriteByte(colormap[1][i]);                          output_file.WriteByte(colormap[0][i]);                          if (map_entry_size == 4)                              output_file.WriteByte(0);                      }                  }                  else                  {                      /* Grayscale colormap (only happens with grayscale quantization) */                      for (i = 0; i < num_colors; i++)                      {                          output_file.WriteByte(colormap[0][i]);                          output_file.WriteByte(colormap[0][i]);                          output_file.WriteByte(colormap[0][i]);                          if (map_entry_size == 4)                              output_file.WriteByte(0);                      }                  }              }              else              {                  /* If no colormap' must be grayscale data.  Generate a linear "map". */                  for (i = 0; i < 256; i++)                  {                      output_file.WriteByte((byte)i);                      output_file.WriteByte((byte)i);                      output_file.WriteByte((byte)i);                      if (map_entry_size == 4)                          output_file.WriteByte(0);                  }              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_colormap,The following statement contains a magic number: if (colormap != null)              {                  if (cinfo.Out_color_components == 3)                  {                      /* Normal case with RGB colormap */                      for (i = 0; i < num_colors; i++)                      {                          output_file.WriteByte(colormap[2][i]);                          output_file.WriteByte(colormap[1][i]);                          output_file.WriteByte(colormap[0][i]);                          if (map_entry_size == 4)                              output_file.WriteByte(0);                      }                  }                  else                  {                      /* Grayscale colormap (only happens with grayscale quantization) */                      for (i = 0; i < num_colors; i++)                      {                          output_file.WriteByte(colormap[0][i]);                          output_file.WriteByte(colormap[0][i]);                          output_file.WriteByte(colormap[0][i]);                          if (map_entry_size == 4)                              output_file.WriteByte(0);                      }                  }              }              else              {                  /* If no colormap' must be grayscale data.  Generate a linear "map". */                  for (i = 0; i < 256; i++)                  {                      output_file.WriteByte((byte)i);                      output_file.WriteByte((byte)i);                      output_file.WriteByte((byte)i);                      if (map_entry_size == 4)                          output_file.WriteByte(0);                  }              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_colormap,The following statement contains a magic number: if (colormap != null)              {                  if (cinfo.Out_color_components == 3)                  {                      /* Normal case with RGB colormap */                      for (i = 0; i < num_colors; i++)                      {                          output_file.WriteByte(colormap[2][i]);                          output_file.WriteByte(colormap[1][i]);                          output_file.WriteByte(colormap[0][i]);                          if (map_entry_size == 4)                              output_file.WriteByte(0);                      }                  }                  else                  {                      /* Grayscale colormap (only happens with grayscale quantization) */                      for (i = 0; i < num_colors; i++)                      {                          output_file.WriteByte(colormap[0][i]);                          output_file.WriteByte(colormap[0][i]);                          output_file.WriteByte(colormap[0][i]);                          if (map_entry_size == 4)                              output_file.WriteByte(0);                      }                  }              }              else              {                  /* If no colormap' must be grayscale data.  Generate a linear "map". */                  for (i = 0; i < 256; i++)                  {                      output_file.WriteByte((byte)i);                      output_file.WriteByte((byte)i);                      output_file.WriteByte((byte)i);                      if (map_entry_size == 4)                          output_file.WriteByte(0);                  }              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_colormap,The following statement contains a magic number: if (colormap != null)              {                  if (cinfo.Out_color_components == 3)                  {                      /* Normal case with RGB colormap */                      for (i = 0; i < num_colors; i++)                      {                          output_file.WriteByte(colormap[2][i]);                          output_file.WriteByte(colormap[1][i]);                          output_file.WriteByte(colormap[0][i]);                          if (map_entry_size == 4)                              output_file.WriteByte(0);                      }                  }                  else                  {                      /* Grayscale colormap (only happens with grayscale quantization) */                      for (i = 0; i < num_colors; i++)                      {                          output_file.WriteByte(colormap[0][i]);                          output_file.WriteByte(colormap[0][i]);                          output_file.WriteByte(colormap[0][i]);                          if (map_entry_size == 4)                              output_file.WriteByte(0);                      }                  }              }              else              {                  /* If no colormap' must be grayscale data.  Generate a linear "map". */                  for (i = 0; i < 256; i++)                  {                      output_file.WriteByte((byte)i);                      output_file.WriteByte((byte)i);                      output_file.WriteByte((byte)i);                      if (map_entry_size == 4)                          output_file.WriteByte(0);                  }              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,write_colormap,The following statement contains a magic number: for (; i < map_colors; i++)              {                  output_file.WriteByte(0);                  output_file.WriteByte(0);                  output_file.WriteByte(0);                  if (map_entry_size == 4)                      output_file.WriteByte(0);              }
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,PUT_2B,The following statement contains a magic number: array[offset + 1] = (byte)(((value) >> 8) & 0xFF);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,PUT_4B,The following statement contains a magic number: array[offset + 1] = (byte)(((value) >> 8) & 0xFF);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,PUT_4B,The following statement contains a magic number: array[offset + 2] = (byte)(((value) >> 16) & 0xFF);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,PUT_4B,The following statement contains a magic number: array[offset + 2] = (byte)(((value) >> 16) & 0xFF);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,PUT_4B,The following statement contains a magic number: array[offset + 3] = (byte)(((value) >> 24) & 0xFF);
Magic Number,BitMiracle.Jpeg,bmp_dest_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_dest_struct.cs,PUT_4B,The following statement contains a magic number: array[offset + 3] = (byte)(((value) >> 24) & 0xFF);
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: byte[] bmpfileheader = new byte[14];
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (!ReadOK(input_file' bmpfileheader' 0' 14))                  cinfo.ERREXIT(J_MESSAGE_CODE.JERR_INPUT_EOF);
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: int bfOffBits = GET_4B(bmpfileheader' 10);
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: byte[] bmpinfoheader = new byte[64];
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (!ReadOK(input_file' bmpinfoheader' 0' 4))                  cinfo.ERREXIT(J_MESSAGE_CODE.JERR_INPUT_EOF);
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (headerSize < 12 || headerSize> 64)                  cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (headerSize < 12 || headerSize> 64)                  cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (!ReadOK(input_file' bmpinfoheader' 4' headerSize - 4))                  cinfo.ERREXIT(J_MESSAGE_CODE.JERR_INPUT_EOF);
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (!ReadOK(input_file' bmpinfoheader' 4' headerSize - 4))                  cinfo.ERREXIT(J_MESSAGE_CODE.JERR_INPUT_EOF);
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                      break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biPlanes != 1)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADPLANES);                                            if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: int bPad = bfOffBits - (headerSize + 14);
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (mapentrysize > 0)              {                  if (biClrUsed <= 0)                      biClrUsed = 256;        /* assume it's 256 */                  else if (biClrUsed > 256)                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADCMAP);                    /* Allocate space to store the colormap */                  colormap = jpeg_common_struct.AllocJpegSamples(biClrUsed' 3);                  /* and read it from the file */                  read_colormap(biClrUsed' mapentrysize);                  /* account for size of colormap */                  bPad -= biClrUsed * mapentrysize;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (mapentrysize > 0)              {                  if (biClrUsed <= 0)                      biClrUsed = 256;        /* assume it's 256 */                  else if (biClrUsed > 256)                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADCMAP);                    /* Allocate space to store the colormap */                  colormap = jpeg_common_struct.AllocJpegSamples(biClrUsed' 3);                  /* and read it from the file */                  read_colormap(biClrUsed' mapentrysize);                  /* account for size of colormap */                  bPad -= biClrUsed * mapentrysize;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (mapentrysize > 0)              {                  if (biClrUsed <= 0)                      biClrUsed = 256;        /* assume it's 256 */                  else if (biClrUsed > 256)                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADCMAP);                    /* Allocate space to store the colormap */                  colormap = jpeg_common_struct.AllocJpegSamples(biClrUsed' 3);                  /* and read it from the file */                  read_colormap(biClrUsed' mapentrysize);                  /* account for size of colormap */                  bPad -= biClrUsed * mapentrysize;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (bits_per_pixel == 24)                  row_width = biWidth * 3;              else                  row_width = biWidth;
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (bits_per_pixel == 24)                  row_width = biWidth * 3;              else                  row_width = biWidth;
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: while ((row_width & 3) != 0)                  row_width++;
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: buffer = jpeg_common_struct.AllocJpegSamples(biWidth * 3' 1);
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: cinfo.Input_components = 3;
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: cinfo.Data_precision = 8;
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,get_8bit_row,The following statement contains a magic number: for (int col = cinfo.Image_width; col > 0; col--)              {                  int t = image_ptr[0][imageIndex];                  imageIndex++;                    buffer[0][outIndex] = colormap[0][t]; /* can omit GETbyte() safely */                  outIndex++;                  buffer[0][outIndex] = colormap[1][t];                  outIndex++;                  buffer[0][outIndex] = colormap[2][t];                  outIndex++;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,get_24bit_row,The following statement contains a magic number: for (int col = cinfo.Image_width; col > 0; col--)              {                  buffer[0][outIndex + 2] = image_ptr[0][imageIndex];   /* can omit GETbyte() safely */                  imageIndex++;                  buffer[0][outIndex + 1] = image_ptr[0][imageIndex];                  imageIndex++;                  buffer[0][outIndex] = image_ptr[0][imageIndex];                  imageIndex++;                  outIndex += 3;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,get_24bit_row,The following statement contains a magic number: for (int col = cinfo.Image_width; col > 0; col--)              {                  buffer[0][outIndex + 2] = image_ptr[0][imageIndex];   /* can omit GETbyte() safely */                  imageIndex++;                  buffer[0][outIndex + 1] = image_ptr[0][imageIndex];                  imageIndex++;                  buffer[0][outIndex] = image_ptr[0][imageIndex];                  imageIndex++;                  outIndex += 3;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,preload_image,The following statement contains a magic number: switch (bits_per_pixel)              {                  case 8:                      m_pixelRowsMethod = PixelRowsMethod.use8bit;                      break;                  case 24:                      m_pixelRowsMethod = PixelRowsMethod.use24bit;                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,preload_image,The following statement contains a magic number: switch (bits_per_pixel)              {                  case 8:                      m_pixelRowsMethod = PixelRowsMethod.use8bit;                      break;                  case 24:                      m_pixelRowsMethod = PixelRowsMethod.use24bit;                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,read_colormap,The following statement contains a magic number: switch (mapentrysize)              {                  case 3:                      /* BGR format (occurs in OS/2 files) */                      for (int i = 0; i < cmaplen; i++)                      {                          colormap[2][i] = (byte)read_byte();                          colormap[1][i] = (byte)read_byte();                          colormap[0][i] = (byte)read_byte();                      }                      break;                  case 4:                      /* BGR0 format (occurs in MS Windows files) */                      for (int i = 0; i < cmaplen; i++)                      {                          colormap[2][i] = (byte)read_byte();                          colormap[1][i] = (byte)read_byte();                          colormap[0][i] = (byte)read_byte();                          read_byte();                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADCMAP);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,read_colormap,The following statement contains a magic number: switch (mapentrysize)              {                  case 3:                      /* BGR format (occurs in OS/2 files) */                      for (int i = 0; i < cmaplen; i++)                      {                          colormap[2][i] = (byte)read_byte();                          colormap[1][i] = (byte)read_byte();                          colormap[0][i] = (byte)read_byte();                      }                      break;                  case 4:                      /* BGR0 format (occurs in MS Windows files) */                      for (int i = 0; i < cmaplen; i++)                      {                          colormap[2][i] = (byte)read_byte();                          colormap[1][i] = (byte)read_byte();                          colormap[0][i] = (byte)read_byte();                          read_byte();                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADCMAP);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,read_colormap,The following statement contains a magic number: switch (mapentrysize)              {                  case 3:                      /* BGR format (occurs in OS/2 files) */                      for (int i = 0; i < cmaplen; i++)                      {                          colormap[2][i] = (byte)read_byte();                          colormap[1][i] = (byte)read_byte();                          colormap[0][i] = (byte)read_byte();                      }                      break;                  case 4:                      /* BGR0 format (occurs in MS Windows files) */                      for (int i = 0; i < cmaplen; i++)                      {                          colormap[2][i] = (byte)read_byte();                          colormap[1][i] = (byte)read_byte();                          colormap[0][i] = (byte)read_byte();                          read_byte();                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADCMAP);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,read_colormap,The following statement contains a magic number: switch (mapentrysize)              {                  case 3:                      /* BGR format (occurs in OS/2 files) */                      for (int i = 0; i < cmaplen; i++)                      {                          colormap[2][i] = (byte)read_byte();                          colormap[1][i] = (byte)read_byte();                          colormap[0][i] = (byte)read_byte();                      }                      break;                  case 4:                      /* BGR0 format (occurs in MS Windows files) */                      for (int i = 0; i < cmaplen; i++)                      {                          colormap[2][i] = (byte)read_byte();                          colormap[1][i] = (byte)read_byte();                          colormap[0][i] = (byte)read_byte();                          read_byte();                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADCMAP);                      break;              }
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,GET_2B,The following statement contains a magic number: return (int)array[offset] + ((int)array[offset + 1] << 8);
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,GET_4B,The following statement contains a magic number: return (int)array[offset] + ((int)array[offset + 1] << 8) + ((int)array[offset + 2] << 16) + ((int)array[offset + 3] << 24);
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,GET_4B,The following statement contains a magic number: return (int)array[offset] + ((int)array[offset + 1] << 8) + ((int)array[offset + 2] << 16) + ((int)array[offset + 3] << 24);
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,GET_4B,The following statement contains a magic number: return (int)array[offset] + ((int)array[offset + 1] << 8) + ((int)array[offset + 2] << 16) + ((int)array[offset + 3] << 24);
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,GET_4B,The following statement contains a magic number: return (int)array[offset] + ((int)array[offset + 1] << 8) + ((int)array[offset + 2] << 16) + ((int)array[offset + 3] << 24);
Magic Number,BitMiracle.Jpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\Jpeg\bmp_source_struct.cs,GET_4B,The following statement contains a magic number: return (int)array[offset] + ((int)array[offset + 1] << 8) + ((int)array[offset + 2] << 16) + ((int)array[offset + 3] << 24);
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForCompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 1))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      options.ForceBaseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          options.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      options.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      options.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      options.Optimize = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.OutputFileName = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      options.Progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality factor (quantization table scaling factor). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          options.Quality = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qslots = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qtables = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return null;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        int val;                      try                      {                          val = int.Parse(parsee);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                        if (val < 0 || val > 65535)                          return null;                        if (inBlocks)                      {                          options.RestartInterval = val;                          options.RestartInRows = 0; /* else prior '-restart n' overrides me */                      }                      else                      {                          options.RestartInRows = val;                          /* restart_interval will be computed during startup */                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Sample = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return null;                            options.SmoothingFactor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForCompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 1))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      options.ForceBaseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          options.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      options.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      options.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      options.Optimize = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.OutputFileName = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      options.Progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality factor (quantization table scaling factor). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          options.Quality = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qslots = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qtables = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return null;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        int val;                      try                      {                          val = int.Parse(parsee);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                        if (val < 0 || val > 65535)                          return null;                        if (inBlocks)                      {                          options.RestartInterval = val;                          options.RestartInRows = 0; /* else prior '-restart n' overrides me */                      }                      else                      {                          options.RestartInRows = val;                          /* restart_interval will be computed during startup */                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Sample = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return null;                            options.SmoothingFactor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForCompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 1))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      options.ForceBaseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          options.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      options.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      options.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      options.Optimize = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.OutputFileName = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      options.Progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality factor (quantization table scaling factor). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          options.Quality = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qslots = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qtables = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return null;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        int val;                      try                      {                          val = int.Parse(parsee);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                        if (val < 0 || val > 65535)                          return null;                        if (inBlocks)                      {                          options.RestartInterval = val;                          options.RestartInRows = 0; /* else prior '-restart n' overrides me */                      }                      else                      {                          options.RestartInRows = val;                          /* restart_interval will be computed during startup */                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Sample = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return null;                            options.SmoothingFactor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForCompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 1))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      options.ForceBaseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          options.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      options.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      options.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      options.Optimize = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.OutputFileName = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      options.Progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality factor (quantization table scaling factor). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          options.Quality = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qslots = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qtables = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return null;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        int val;                      try                      {                          val = int.Parse(parsee);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                        if (val < 0 || val > 65535)                          return null;                        if (inBlocks)                      {                          options.RestartInterval = val;                          options.RestartInRows = 0; /* else prior '-restart n' overrides me */                      }                      else                      {                          options.RestartInRows = val;                          /* restart_interval will be computed during startup */                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Sample = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return null;                            options.SmoothingFactor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForCompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 1))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      options.ForceBaseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          options.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      options.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      options.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      options.Optimize = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.OutputFileName = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      options.Progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality factor (quantization table scaling factor). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          options.Quality = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qslots = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qtables = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return null;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        int val;                      try                      {                          val = int.Parse(parsee);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                        if (val < 0 || val > 65535)                          return null;                        if (inBlocks)                      {                          options.RestartInterval = val;                          options.RestartInRows = 0; /* else prior '-restart n' overrides me */                      }                      else                      {                          options.RestartInRows = val;                          /* restart_interval will be computed during startup */                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Sample = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return null;                            options.SmoothingFactor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForCompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 1))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      options.ForceBaseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          options.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      options.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      options.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      options.Optimize = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.OutputFileName = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      options.Progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality factor (quantization table scaling factor). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          options.Quality = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qslots = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qtables = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return null;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        int val;                      try                      {                          val = int.Parse(parsee);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                        if (val < 0 || val > 65535)                          return null;                        if (inBlocks)                      {                          options.RestartInterval = val;                          options.RestartInRows = 0; /* else prior '-restart n' overrides me */                      }                      else                      {                          options.RestartInRows = val;                          /* restart_interval will be computed during startup */                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Sample = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return null;                            options.SmoothingFactor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForCompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 1))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      options.ForceBaseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          options.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      options.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      options.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      options.Optimize = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.OutputFileName = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      options.Progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality factor (quantization table scaling factor). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          options.Quality = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qslots = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qtables = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return null;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        int val;                      try                      {                          val = int.Parse(parsee);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                        if (val < 0 || val > 65535)                          return null;                        if (inBlocks)                      {                          options.RestartInterval = val;                          options.RestartInRows = 0; /* else prior '-restart n' overrides me */                      }                      else                      {                          options.RestartInRows = val;                          /* restart_interval will be computed during startup */                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Sample = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return null;                            options.SmoothingFactor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForCompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 1))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      options.ForceBaseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          options.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      options.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      options.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      options.Optimize = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.OutputFileName = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      options.Progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality factor (quantization table scaling factor). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          options.Quality = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qslots = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qtables = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return null;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        int val;                      try                      {                          val = int.Parse(parsee);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                        if (val < 0 || val > 65535)                          return null;                        if (inBlocks)                      {                          options.RestartInterval = val;                          options.RestartInRows = 0; /* else prior '-restart n' overrides me */                      }                      else                      {                          options.RestartInRows = val;                          /* restart_interval will be computed during startup */                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Sample = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return null;                            options.SmoothingFactor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForCompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 1))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      options.ForceBaseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          options.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      options.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      options.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      options.Optimize = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.OutputFileName = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      options.Progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality factor (quantization table scaling factor). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          options.Quality = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qslots = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qtables = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return null;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        int val;                      try                      {                          val = int.Parse(parsee);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                        if (val < 0 || val > 65535)                          return null;                        if (inBlocks)                      {                          options.RestartInterval = val;                          options.RestartInRows = 0; /* else prior '-restart n' overrides me */                      }                      else                      {                          options.RestartInRows = val;                          /* restart_interval will be computed during startup */                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Sample = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return null;                            options.SmoothingFactor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForCompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 1))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      options.ForceBaseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          options.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      options.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      options.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      options.Optimize = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.OutputFileName = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      options.Progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality factor (quantization table scaling factor). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          options.Quality = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qslots = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qtables = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return null;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        int val;                      try                      {                          val = int.Parse(parsee);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                        if (val < 0 || val > 65535)                          return null;                        if (inBlocks)                      {                          options.RestartInterval = val;                          options.RestartInRows = 0; /* else prior '-restart n' overrides me */                      }                      else                      {                          options.RestartInRows = val;                          /* restart_interval will be computed during startup */                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Sample = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return null;                            options.SmoothingFactor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForCompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 1))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      options.ForceBaseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          options.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      options.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      options.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      options.Optimize = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.OutputFileName = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      options.Progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality factor (quantization table scaling factor). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          options.Quality = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qslots = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qtables = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return null;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        int val;                      try                      {                          val = int.Parse(parsee);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                        if (val < 0 || val > 65535)                          return null;                        if (inBlocks)                      {                          options.RestartInterval = val;                          options.RestartInRows = 0; /* else prior '-restart n' overrides me */                      }                      else                      {                          options.RestartInRows = val;                          /* restart_interval will be computed during startup */                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Sample = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return null;                            options.SmoothingFactor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForCompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 1))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      options.ForceBaseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          options.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          options.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      options.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      options.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      options.Optimize = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.OutputFileName = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      options.Progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality factor (quantization table scaling factor). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          options.Quality = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qslots = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Qtables = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return null;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        int val;                      try                      {                          val = int.Parse(parsee);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                        if (val < 0 || val > 65535)                          return null;                        if (inBlocks)                      {                          options.RestartInterval = val;                          options.RestartInRows = 0; /* else prior '-restart n' overrides me */                      }                      else                      {                          options.RestartInRows = val;                          /* restart_interval will be computed during startup */                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        options.Sample = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return null;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return null;                            options.SmoothingFactor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForCompression,The following statement contains a magic number: if (options.OutputFileName.Length == 0)              {                  // file_index should point to input file                   if (lastFileArgSeen != argv.Length - 2)                  {                      Console.WriteLine(string.Format("{0}: must name one input and one output file."' m_programName));                      return null;                  }                    // output file comes right after input one                  options.InputFileName = argv[lastFileArgSeen];                  options.OutputFileName = argv[lastFileArgSeen + 1];              }              else              {                  // file_index should point to input file                  if (lastFileArgSeen != argv.Length - 1)                  {                      Console.WriteLine(string.Format("{0}: must name one input and one output file."' m_programName));                      return null;                  }                    options.InputFileName = argv[lastFileArgSeen];              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,applyOptions,The following statement contains a magic number: int q_scale_factor = 100;
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,applyOptions,The following statement contains a magic number: if (options.Quality != 75)                  q_scale_factor = jpeg_compress_struct.jpeg_quality_scaling(options.Quality);
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,decompress,The following statement contains a magic number: cinfo.jpeg_set_marker_processor((int)JPEG_MARKER.APP0 + 12' printTextMarker);
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForDecompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "bmp"' 1))                  {                      result.OutputFormat = IMAGE_FORMATS.FMT_BMP;                  }                  else if (cdjpeg_utils.keymatch(arg' "colors"' 1) ||                           cdjpeg_utils.keymatch(arg' "colours"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantize"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantise"' 1))                  {                      /* Do color quantization. */                        if (++argn >= argv.Length) /* advance to next argument */                          return null;                        try                      {                          result.QuantizeColors = true;                          result.DesiredNumberOfColors = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select IDCT algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          result.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "dither"' 2))                  {                      /* Select dithering algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "fs"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_FS;                      else if (cdjpeg_utils.keymatch(argv[argn]' "none"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_NONE;                      else if (cdjpeg_utils.keymatch(argv[argn]' "ordered"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_ORDERED;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      result.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's DJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "fast"' 1))                  {                      result.Fast = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force monochrome output. */                      result.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy upsampling */                      result.NoSmooth = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "onepass"' 3))                  {                      /* Use fast one-pass quantization. */                      result.OnePass = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "os2"' 3))                  {                      /* BMP output format (OS/2 flavor). */                      result.OutputFormat = IMAGE_FORMATS.FMT_OS2;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        result.OutputFileName = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 1))                  {                      /* Scale the output image by a fraction M/N. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        int slashPos = argv[argn].IndexOf('/');                      if (slashPos == -1)                          return null;                        try                      {                          string num = argv[argn].Substring(0' slashPos);                          string denom = argv[argn].Substring(slashPos + 1);                          result.Scaled = true;                          result.ScaleNumerator = int.Parse(num);                          result.ScaleDenominator = int.Parse(denom);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForDecompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "bmp"' 1))                  {                      result.OutputFormat = IMAGE_FORMATS.FMT_BMP;                  }                  else if (cdjpeg_utils.keymatch(arg' "colors"' 1) ||                           cdjpeg_utils.keymatch(arg' "colours"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantize"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantise"' 1))                  {                      /* Do color quantization. */                        if (++argn >= argv.Length) /* advance to next argument */                          return null;                        try                      {                          result.QuantizeColors = true;                          result.DesiredNumberOfColors = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select IDCT algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          result.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "dither"' 2))                  {                      /* Select dithering algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "fs"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_FS;                      else if (cdjpeg_utils.keymatch(argv[argn]' "none"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_NONE;                      else if (cdjpeg_utils.keymatch(argv[argn]' "ordered"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_ORDERED;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      result.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's DJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "fast"' 1))                  {                      result.Fast = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force monochrome output. */                      result.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy upsampling */                      result.NoSmooth = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "onepass"' 3))                  {                      /* Use fast one-pass quantization. */                      result.OnePass = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "os2"' 3))                  {                      /* BMP output format (OS/2 flavor). */                      result.OutputFormat = IMAGE_FORMATS.FMT_OS2;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        result.OutputFileName = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 1))                  {                      /* Scale the output image by a fraction M/N. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        int slashPos = argv[argn].IndexOf('/');                      if (slashPos == -1)                          return null;                        try                      {                          string num = argv[argn].Substring(0' slashPos);                          string denom = argv[argn].Substring(slashPos + 1);                          result.Scaled = true;                          result.ScaleNumerator = int.Parse(num);                          result.ScaleDenominator = int.Parse(denom);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForDecompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "bmp"' 1))                  {                      result.OutputFormat = IMAGE_FORMATS.FMT_BMP;                  }                  else if (cdjpeg_utils.keymatch(arg' "colors"' 1) ||                           cdjpeg_utils.keymatch(arg' "colours"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantize"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantise"' 1))                  {                      /* Do color quantization. */                        if (++argn >= argv.Length) /* advance to next argument */                          return null;                        try                      {                          result.QuantizeColors = true;                          result.DesiredNumberOfColors = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select IDCT algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          result.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "dither"' 2))                  {                      /* Select dithering algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "fs"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_FS;                      else if (cdjpeg_utils.keymatch(argv[argn]' "none"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_NONE;                      else if (cdjpeg_utils.keymatch(argv[argn]' "ordered"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_ORDERED;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      result.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's DJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "fast"' 1))                  {                      result.Fast = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force monochrome output. */                      result.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy upsampling */                      result.NoSmooth = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "onepass"' 3))                  {                      /* Use fast one-pass quantization. */                      result.OnePass = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "os2"' 3))                  {                      /* BMP output format (OS/2 flavor). */                      result.OutputFormat = IMAGE_FORMATS.FMT_OS2;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        result.OutputFileName = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 1))                  {                      /* Scale the output image by a fraction M/N. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        int slashPos = argv[argn].IndexOf('/');                      if (slashPos == -1)                          return null;                        try                      {                          string num = argv[argn].Substring(0' slashPos);                          string denom = argv[argn].Substring(slashPos + 1);                          result.Scaled = true;                          result.ScaleNumerator = int.Parse(num);                          result.ScaleDenominator = int.Parse(denom);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForDecompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "bmp"' 1))                  {                      result.OutputFormat = IMAGE_FORMATS.FMT_BMP;                  }                  else if (cdjpeg_utils.keymatch(arg' "colors"' 1) ||                           cdjpeg_utils.keymatch(arg' "colours"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantize"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantise"' 1))                  {                      /* Do color quantization. */                        if (++argn >= argv.Length) /* advance to next argument */                          return null;                        try                      {                          result.QuantizeColors = true;                          result.DesiredNumberOfColors = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select IDCT algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          result.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "dither"' 2))                  {                      /* Select dithering algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "fs"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_FS;                      else if (cdjpeg_utils.keymatch(argv[argn]' "none"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_NONE;                      else if (cdjpeg_utils.keymatch(argv[argn]' "ordered"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_ORDERED;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      result.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's DJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "fast"' 1))                  {                      result.Fast = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force monochrome output. */                      result.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy upsampling */                      result.NoSmooth = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "onepass"' 3))                  {                      /* Use fast one-pass quantization. */                      result.OnePass = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "os2"' 3))                  {                      /* BMP output format (OS/2 flavor). */                      result.OutputFormat = IMAGE_FORMATS.FMT_OS2;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        result.OutputFileName = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 1))                  {                      /* Scale the output image by a fraction M/N. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        int slashPos = argv[argn].IndexOf('/');                      if (slashPos == -1)                          return null;                        try                      {                          string num = argv[argn].Substring(0' slashPos);                          string denom = argv[argn].Substring(slashPos + 1);                          result.Scaled = true;                          result.ScaleNumerator = int.Parse(num);                          result.ScaleDenominator = int.Parse(denom);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForDecompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "bmp"' 1))                  {                      result.OutputFormat = IMAGE_FORMATS.FMT_BMP;                  }                  else if (cdjpeg_utils.keymatch(arg' "colors"' 1) ||                           cdjpeg_utils.keymatch(arg' "colours"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantize"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantise"' 1))                  {                      /* Do color quantization. */                        if (++argn >= argv.Length) /* advance to next argument */                          return null;                        try                      {                          result.QuantizeColors = true;                          result.DesiredNumberOfColors = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select IDCT algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          result.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "dither"' 2))                  {                      /* Select dithering algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "fs"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_FS;                      else if (cdjpeg_utils.keymatch(argv[argn]' "none"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_NONE;                      else if (cdjpeg_utils.keymatch(argv[argn]' "ordered"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_ORDERED;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      result.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's DJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "fast"' 1))                  {                      result.Fast = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force monochrome output. */                      result.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy upsampling */                      result.NoSmooth = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "onepass"' 3))                  {                      /* Use fast one-pass quantization. */                      result.OnePass = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "os2"' 3))                  {                      /* BMP output format (OS/2 flavor). */                      result.OutputFormat = IMAGE_FORMATS.FMT_OS2;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        result.OutputFileName = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 1))                  {                      /* Scale the output image by a fraction M/N. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        int slashPos = argv[argn].IndexOf('/');                      if (slashPos == -1)                          return null;                        try                      {                          string num = argv[argn].Substring(0' slashPos);                          string denom = argv[argn].Substring(slashPos + 1);                          result.Scaled = true;                          result.ScaleNumerator = int.Parse(num);                          result.ScaleDenominator = int.Parse(denom);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForDecompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "bmp"' 1))                  {                      result.OutputFormat = IMAGE_FORMATS.FMT_BMP;                  }                  else if (cdjpeg_utils.keymatch(arg' "colors"' 1) ||                           cdjpeg_utils.keymatch(arg' "colours"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantize"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantise"' 1))                  {                      /* Do color quantization. */                        if (++argn >= argv.Length) /* advance to next argument */                          return null;                        try                      {                          result.QuantizeColors = true;                          result.DesiredNumberOfColors = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select IDCT algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          result.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "dither"' 2))                  {                      /* Select dithering algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "fs"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_FS;                      else if (cdjpeg_utils.keymatch(argv[argn]' "none"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_NONE;                      else if (cdjpeg_utils.keymatch(argv[argn]' "ordered"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_ORDERED;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      result.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's DJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "fast"' 1))                  {                      result.Fast = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force monochrome output. */                      result.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy upsampling */                      result.NoSmooth = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "onepass"' 3))                  {                      /* Use fast one-pass quantization. */                      result.OnePass = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "os2"' 3))                  {                      /* BMP output format (OS/2 flavor). */                      result.OutputFormat = IMAGE_FORMATS.FMT_OS2;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        result.OutputFileName = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 1))                  {                      /* Scale the output image by a fraction M/N. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        int slashPos = argv[argn].IndexOf('/');                      if (slashPos == -1)                          return null;                        try                      {                          string num = argv[argn].Substring(0' slashPos);                          string denom = argv[argn].Substring(slashPos + 1);                          result.Scaled = true;                          result.ScaleNumerator = int.Parse(num);                          result.ScaleDenominator = int.Parse(denom);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForDecompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "bmp"' 1))                  {                      result.OutputFormat = IMAGE_FORMATS.FMT_BMP;                  }                  else if (cdjpeg_utils.keymatch(arg' "colors"' 1) ||                           cdjpeg_utils.keymatch(arg' "colours"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantize"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantise"' 1))                  {                      /* Do color quantization. */                        if (++argn >= argv.Length) /* advance to next argument */                          return null;                        try                      {                          result.QuantizeColors = true;                          result.DesiredNumberOfColors = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select IDCT algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          result.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "dither"' 2))                  {                      /* Select dithering algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "fs"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_FS;                      else if (cdjpeg_utils.keymatch(argv[argn]' "none"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_NONE;                      else if (cdjpeg_utils.keymatch(argv[argn]' "ordered"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_ORDERED;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      result.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's DJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "fast"' 1))                  {                      result.Fast = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force monochrome output. */                      result.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy upsampling */                      result.NoSmooth = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "onepass"' 3))                  {                      /* Use fast one-pass quantization. */                      result.OnePass = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "os2"' 3))                  {                      /* BMP output format (OS/2 flavor). */                      result.OutputFormat = IMAGE_FORMATS.FMT_OS2;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        result.OutputFileName = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 1))                  {                      /* Scale the output image by a fraction M/N. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        int slashPos = argv[argn].IndexOf('/');                      if (slashPos == -1)                          return null;                        try                      {                          string num = argv[argn].Substring(0' slashPos);                          string denom = argv[argn].Substring(slashPos + 1);                          result.Scaled = true;                          result.ScaleNumerator = int.Parse(num);                          result.ScaleDenominator = int.Parse(denom);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForDecompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "bmp"' 1))                  {                      result.OutputFormat = IMAGE_FORMATS.FMT_BMP;                  }                  else if (cdjpeg_utils.keymatch(arg' "colors"' 1) ||                           cdjpeg_utils.keymatch(arg' "colours"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantize"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantise"' 1))                  {                      /* Do color quantization. */                        if (++argn >= argv.Length) /* advance to next argument */                          return null;                        try                      {                          result.QuantizeColors = true;                          result.DesiredNumberOfColors = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select IDCT algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          result.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "dither"' 2))                  {                      /* Select dithering algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "fs"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_FS;                      else if (cdjpeg_utils.keymatch(argv[argn]' "none"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_NONE;                      else if (cdjpeg_utils.keymatch(argv[argn]' "ordered"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_ORDERED;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      result.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's DJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "fast"' 1))                  {                      result.Fast = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force monochrome output. */                      result.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy upsampling */                      result.NoSmooth = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "onepass"' 3))                  {                      /* Use fast one-pass quantization. */                      result.OnePass = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "os2"' 3))                  {                      /* BMP output format (OS/2 flavor). */                      result.OutputFormat = IMAGE_FORMATS.FMT_OS2;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        result.OutputFileName = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 1))                  {                      /* Scale the output image by a fraction M/N. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        int slashPos = argv[argn].IndexOf('/');                      if (slashPos == -1)                          return null;                        try                      {                          string num = argv[argn].Substring(0' slashPos);                          string denom = argv[argn].Substring(slashPos + 1);                          result.Scaled = true;                          result.ScaleNumerator = int.Parse(num);                          result.ScaleDenominator = int.Parse(denom);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForDecompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "bmp"' 1))                  {                      result.OutputFormat = IMAGE_FORMATS.FMT_BMP;                  }                  else if (cdjpeg_utils.keymatch(arg' "colors"' 1) ||                           cdjpeg_utils.keymatch(arg' "colours"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantize"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantise"' 1))                  {                      /* Do color quantization. */                        if (++argn >= argv.Length) /* advance to next argument */                          return null;                        try                      {                          result.QuantizeColors = true;                          result.DesiredNumberOfColors = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select IDCT algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          result.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "dither"' 2))                  {                      /* Select dithering algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "fs"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_FS;                      else if (cdjpeg_utils.keymatch(argv[argn]' "none"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_NONE;                      else if (cdjpeg_utils.keymatch(argv[argn]' "ordered"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_ORDERED;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      result.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's DJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "fast"' 1))                  {                      result.Fast = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force monochrome output. */                      result.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy upsampling */                      result.NoSmooth = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "onepass"' 3))                  {                      /* Use fast one-pass quantization. */                      result.OnePass = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "os2"' 3))                  {                      /* BMP output format (OS/2 flavor). */                      result.OutputFormat = IMAGE_FORMATS.FMT_OS2;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        result.OutputFileName = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 1))                  {                      /* Scale the output image by a fraction M/N. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        int slashPos = argv[argn].IndexOf('/');                      if (slashPos == -1)                          return null;                        try                      {                          string num = argv[argn].Substring(0' slashPos);                          string denom = argv[argn].Substring(slashPos + 1);                          result.Scaled = true;                          result.ScaleNumerator = int.Parse(num);                          result.ScaleDenominator = int.Parse(denom);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForDecompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "bmp"' 1))                  {                      result.OutputFormat = IMAGE_FORMATS.FMT_BMP;                  }                  else if (cdjpeg_utils.keymatch(arg' "colors"' 1) ||                           cdjpeg_utils.keymatch(arg' "colours"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantize"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantise"' 1))                  {                      /* Do color quantization. */                        if (++argn >= argv.Length) /* advance to next argument */                          return null;                        try                      {                          result.QuantizeColors = true;                          result.DesiredNumberOfColors = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select IDCT algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          result.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "dither"' 2))                  {                      /* Select dithering algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "fs"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_FS;                      else if (cdjpeg_utils.keymatch(argv[argn]' "none"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_NONE;                      else if (cdjpeg_utils.keymatch(argv[argn]' "ordered"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_ORDERED;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      result.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's DJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "fast"' 1))                  {                      result.Fast = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force monochrome output. */                      result.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy upsampling */                      result.NoSmooth = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "onepass"' 3))                  {                      /* Use fast one-pass quantization. */                      result.OnePass = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "os2"' 3))                  {                      /* BMP output format (OS/2 flavor). */                      result.OutputFormat = IMAGE_FORMATS.FMT_OS2;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        result.OutputFileName = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 1))                  {                      /* Scale the output image by a fraction M/N. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        int slashPos = argv[argn].IndexOf('/');                      if (slashPos == -1)                          return null;                        try                      {                          string num = argv[argn].Substring(0' slashPos);                          string denom = argv[argn].Substring(slashPos + 1);                          result.Scaled = true;                          result.ScaleNumerator = int.Parse(num);                          result.ScaleDenominator = int.Parse(denom);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForDecompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "bmp"' 1))                  {                      result.OutputFormat = IMAGE_FORMATS.FMT_BMP;                  }                  else if (cdjpeg_utils.keymatch(arg' "colors"' 1) ||                           cdjpeg_utils.keymatch(arg' "colours"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantize"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantise"' 1))                  {                      /* Do color quantization. */                        if (++argn >= argv.Length) /* advance to next argument */                          return null;                        try                      {                          result.QuantizeColors = true;                          result.DesiredNumberOfColors = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select IDCT algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          result.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "dither"' 2))                  {                      /* Select dithering algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "fs"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_FS;                      else if (cdjpeg_utils.keymatch(argv[argn]' "none"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_NONE;                      else if (cdjpeg_utils.keymatch(argv[argn]' "ordered"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_ORDERED;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      result.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's DJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "fast"' 1))                  {                      result.Fast = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force monochrome output. */                      result.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy upsampling */                      result.NoSmooth = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "onepass"' 3))                  {                      /* Use fast one-pass quantization. */                      result.OnePass = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "os2"' 3))                  {                      /* BMP output format (OS/2 flavor). */                      result.OutputFormat = IMAGE_FORMATS.FMT_OS2;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        result.OutputFileName = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 1))                  {                      /* Scale the output image by a fraction M/N. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        int slashPos = argv[argn].IndexOf('/');                      if (slashPos == -1)                          return null;                        try                      {                          string num = argv[argn].Substring(0' slashPos);                          string denom = argv[argn].Substring(slashPos + 1);                          result.Scaled = true;                          result.ScaleNumerator = int.Parse(num);                          result.ScaleDenominator = int.Parse(denom);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForDecompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "bmp"' 1))                  {                      result.OutputFormat = IMAGE_FORMATS.FMT_BMP;                  }                  else if (cdjpeg_utils.keymatch(arg' "colors"' 1) ||                           cdjpeg_utils.keymatch(arg' "colours"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantize"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantise"' 1))                  {                      /* Do color quantization. */                        if (++argn >= argv.Length) /* advance to next argument */                          return null;                        try                      {                          result.QuantizeColors = true;                          result.DesiredNumberOfColors = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select IDCT algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          result.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "dither"' 2))                  {                      /* Select dithering algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "fs"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_FS;                      else if (cdjpeg_utils.keymatch(argv[argn]' "none"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_NONE;                      else if (cdjpeg_utils.keymatch(argv[argn]' "ordered"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_ORDERED;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      result.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's DJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "fast"' 1))                  {                      result.Fast = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force monochrome output. */                      result.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy upsampling */                      result.NoSmooth = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "onepass"' 3))                  {                      /* Use fast one-pass quantization. */                      result.OnePass = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "os2"' 3))                  {                      /* BMP output format (OS/2 flavor). */                      result.OutputFormat = IMAGE_FORMATS.FMT_OS2;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        result.OutputFileName = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 1))                  {                      /* Scale the output image by a fraction M/N. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        int slashPos = argv[argn].IndexOf('/');                      if (slashPos == -1)                          return null;                        try                      {                          string num = argv[argn].Substring(0' slashPos);                          string denom = argv[argn].Substring(slashPos + 1);                          result.Scaled = true;                          result.ScaleNumerator = int.Parse(num);                          result.ScaleDenominator = int.Parse(denom);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForDecompression,The following statement contains a magic number: for (int argn = 1; argn < argv.Length; argn++)              {                  arg = argv[argn];                  if (arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      lastFileArgSeen = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "bmp"' 1))                  {                      result.OutputFormat = IMAGE_FORMATS.FMT_BMP;                  }                  else if (cdjpeg_utils.keymatch(arg' "colors"' 1) ||                           cdjpeg_utils.keymatch(arg' "colours"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantize"' 1) ||                           cdjpeg_utils.keymatch(arg' "quantise"' 1))                  {                      /* Do color quantization. */                        if (++argn >= argv.Length) /* advance to next argument */                          return null;                        try                      {                          result.QuantizeColors = true;                          result.DesiredNumberOfColors = int.Parse(argv[argn]);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select IDCT algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          result.DCTMethod = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          result.DCTMethod = J_DCT_METHOD.JDCT_FLOAT;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "dither"' 2))                  {                      /* Select dithering algorithm. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        if (cdjpeg_utils.keymatch(argv[argn]' "fs"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_FS;                      else if (cdjpeg_utils.keymatch(argv[argn]' "none"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_NONE;                      else if (cdjpeg_utils.keymatch(argv[argn]' "ordered"' 2))                          result.DitherMode = J_DITHER_MODE.JDITHER_ORDERED;                      else                          return null;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      result.Debug = true;                        /* On first -d' print version identification */                      if (!m_printedVersion)                      {                          Console.Write(string.Format("Bit Miracle's DJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          m_printedVersion = true;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "fast"' 1))                  {                      result.Fast = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force monochrome output. */                      result.Grayscale = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy upsampling */                      result.NoSmooth = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "onepass"' 3))                  {                      /* Use fast one-pass quantization. */                      result.OnePass = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "os2"' 3))                  {                      /* BMP output format (OS/2 flavor). */                      result.OutputFormat = IMAGE_FORMATS.FMT_OS2;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        result.OutputFileName = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 1))                  {                      /* Scale the output image by a fraction M/N. */                      if (++argn >= argv.Length) /* advance to next argument */                          return null;                        int slashPos = argv[argn].IndexOf('/');                      if (slashPos == -1)                          return null;                        try                      {                          string num = argv[argn].Substring(0' slashPos);                          string denom = argv[argn].Substring(slashPos + 1);                          result.Scaled = true;                          result.ScaleNumerator = int.Parse(num);                          result.ScaleDenominator = int.Parse(denom);                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return null;                      }                  }                  else /* bogus switch */                      return null;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,parseSwitchesForDecompression,The following statement contains a magic number: if (result.OutputFileName.Length == 0)              {                  // file_index should point to input file                   if (lastFileArgSeen != argv.Length - 2)                  {                      Console.WriteLine(string.Format("{0}: must name one input and one output file."' m_programName));                      return null;                  }                    // output file comes right after input one                  result.InputFileName = argv[lastFileArgSeen];                  result.OutputFileName = argv[lastFileArgSeen + 1];              }              else              {                  // file_index should point to input file                  if (lastFileArgSeen != argv.Length - 1)                  {                      Console.WriteLine(string.Format("{0}: must name one input and one output file."' m_programName));                      return null;                  }                    result.InputFileName = argv[lastFileArgSeen];              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,applyOptions,The following statement contains a magic number: if (options.Fast)              {                  /* Select recommended processing options for quick-and-dirty output. */                  decompressor.Two_pass_quantize = false;                  decompressor.Dither_mode = J_DITHER_MODE.JDITHER_ORDERED;                  if (!decompressor.Quantize_colors) /* don't override an earlier -colors */                      decompressor.Desired_number_of_colors = 216;                  decompressor.Dct_method = JpegConstants.JDCT_FASTEST;                  decompressor.Do_fancy_upsampling = false;              }
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,printTextMarker,The following statement contains a magic number: int length = jpeg_getc(cinfo) << 8;
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,printTextMarker,The following statement contains a magic number: length -= 2;
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,encodeOctalString,The following statement contains a magic number: return string.Format(                  @"\{0}{1}{2}"'                  ((value >> 6) & 7)'                  ((value >> 3) & 7)'                  (value & 7)              );
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,encodeOctalString,The following statement contains a magic number: return string.Format(                  @"\{0}{1}{2}"'                  ((value >> 6) & 7)'                  ((value >> 3) & 7)'                  (value & 7)              );
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,encodeOctalString,The following statement contains a magic number: return string.Format(                  @"\{0}{1}{2}"'                  ((value >> 6) & 7)'                  ((value >> 3) & 7)'                  (value & 7)              );
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,encodeOctalString,The following statement contains a magic number: return string.Format(                  @"\{0}{1}{2}"'                  ((value >> 6) & 7)'                  ((value >> 3) & 7)'                  (value & 7)              );
Magic Number,BitMiracle.Jpeg,Program,C:\repos\BitMiracle_libjpeg.net\Jpeg\Program.cs,encodeOctalString,The following statement contains a magic number: return string.Format(                  @"\{0}{1}{2}"'                  ((value >> 6) & 7)'                  ((value >> 3) & 7)'                  (value & 7)              );
