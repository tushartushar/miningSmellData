Implementation smell,Namespace,Class,File,Method,Description
Long Method,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The method has 155 lines of code.
Long Method,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,Main,The method has 116 lines of code.
Long Method,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The method has 254 lines of code.
Complex Method,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,Cyclomatic complexity of the method is 17
Complex Method,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,Main,Cyclomatic complexity of the method is 8
Complex Method,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,Cyclomatic complexity of the method is 14
Long Statement,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,GET_4B,The length of the statement  "            return (int)array[offset] + ((int)array[offset + 1] << 8) + ((int)array[offset + 2] << 16) + ((int)array[offset + 3] << 24); " is 124.
Long Statement,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The length of the statement  "                        Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright)); " is 130.
Long Statement,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,usage,The length of the statement  "            Console.WriteLine(string.Format("  -dct int       Use integer DCT method {0}"' (JpegConstants.JDCT_DEFAULT == J_DCT_METHOD.JDCT_ISLOW ? " (default)" : ""))); " is 157.
Long Statement,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,usage,The length of the statement  "            Console.WriteLine(string.Format("  -dct fast      Use fast integer DCT (less accurate) {0}"' (JpegConstants.JDCT_DEFAULT == J_DCT_METHOD.JDCT_IFAST ? " (default)" : ""))); " is 171.
Long Statement,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,usage,The length of the statement  "            Console.WriteLine(string.Format("  -dct float     Use floating-point DCT method {0}"' (JpegConstants.JDCT_DEFAULT == J_DCT_METHOD.JDCT_FLOAT ? " (default)" : ""))); " is 164.
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: byte[] bmpfileheader = new byte[14];
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (!ReadOK(input_file' bmpfileheader' 0' 14))                  cinfo.ERREXIT(J_MESSAGE_CODE.JERR_INPUT_EOF);
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: int bfOffBits = GET_4B(bmpfileheader' 10);
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: byte[] bmpinfoheader = new byte[64];
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (!ReadOK(input_file' bmpinfoheader' 0' 4))                  cinfo.ERREXIT(J_MESSAGE_CODE.JERR_INPUT_EOF);
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (headerSize < 12 || headerSize> 64)                  cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (headerSize < 12 || headerSize> 64)                  cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (!ReadOK(input_file' bmpinfoheader' 4' headerSize - 4))                  cinfo.ERREXIT(J_MESSAGE_CODE.JERR_INPUT_EOF);
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (!ReadOK(input_file' bmpinfoheader' 4' headerSize - 4))                  cinfo.ERREXIT(J_MESSAGE_CODE.JERR_INPUT_EOF);
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: switch (headerSize)              {                  case 12:                      /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */                      biWidth = GET_2B(bmpinfoheader' 4);                      biHeight = GET_2B(bmpinfoheader' 6);                      biPlanes = GET_2B(bmpinfoheader' 8);                      bits_per_pixel = GET_2B(bmpinfoheader' 10);                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 3;       /* OS/2 uses RGBTRIPLE colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_OS2' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        break;                  case 40:                  case 64:                      /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */                      /* or OS/2 2.x header' which has additional fields that we ignore */                      biWidth = GET_4B(bmpinfoheader' 4);                      biHeight = GET_4B(bmpinfoheader' 8);                      biPlanes = GET_2B(bmpinfoheader' 12);                      bits_per_pixel = GET_2B(bmpinfoheader' 14);                      biCompression = GET_4B(bmpinfoheader' 16);                      biXPelsPerMeter = GET_4B(bmpinfoheader' 24);                      biYPelsPerMeter = GET_4B(bmpinfoheader' 28);                      biClrUsed = GET_4B(bmpinfoheader' 32);                      /* biSizeImage' biClrImportant fields are ignored */                        switch (bits_per_pixel)                      {                          case 8:                              /* colormapped image */                              mapentrysize = 4;       /* Windows uses RGBQUAD colormap */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP_MAPPED' biWidth' biHeight);                              break;                          case 24:                              /* RGB image */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          case 32:                              /* RGB image + Alpha channel */                              cinfo.TRACEMS(1' (int)ADDON_MESSAGE_CODE.JTRC_BMP' biWidth' biHeight);                              break;                          default:                              cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                              break;                      }                        if (biCompression != 0)                          cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_COMPRESSED);                        if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0)                      {                          /* Set JFIF density parameters from the BMP data */                          cinfo.X_density = (short)(biXPelsPerMeter / 100); /* 100 cm per meter */                          cinfo.Y_density = (short)(biYPelsPerMeter / 100);                          cinfo.Density_unit = DensityUnit.DotsCm;                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADHEADER);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: int bPad = bfOffBits - (headerSize + 14);
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (mapentrysize > 0)              {                  if (biClrUsed <= 0)                      biClrUsed = 256;        /* assume it's 256 */                  else if (biClrUsed > 256)                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADCMAP);                    /* Allocate space to store the colormap */                  colormap = jpeg_common_struct.AllocJpegSamples(biClrUsed' 3);                  /* and read it from the file */                  read_colormap(biClrUsed' mapentrysize);                  /* account for size of colormap */                  bPad -= biClrUsed * mapentrysize;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (mapentrysize > 0)              {                  if (biClrUsed <= 0)                      biClrUsed = 256;        /* assume it's 256 */                  else if (biClrUsed > 256)                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADCMAP);                    /* Allocate space to store the colormap */                  colormap = jpeg_common_struct.AllocJpegSamples(biClrUsed' 3);                  /* and read it from the file */                  read_colormap(biClrUsed' mapentrysize);                  /* account for size of colormap */                  bPad -= biClrUsed * mapentrysize;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (mapentrysize > 0)              {                  if (biClrUsed <= 0)                      biClrUsed = 256;        /* assume it's 256 */                  else if (biClrUsed > 256)                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADCMAP);                    /* Allocate space to store the colormap */                  colormap = jpeg_common_struct.AllocJpegSamples(biClrUsed' 3);                  /* and read it from the file */                  read_colormap(biClrUsed' mapentrysize);                  /* account for size of colormap */                  bPad -= biClrUsed * mapentrysize;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (bits_per_pixel == 24)                  row_width = biWidth * 3;              else if (bits_per_pixel == 32)                  row_width = biWidth * 4;              else                  row_width = biWidth;
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (bits_per_pixel == 24)                  row_width = biWidth * 3;              else if (bits_per_pixel == 32)                  row_width = biWidth * 4;              else                  row_width = biWidth;
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (bits_per_pixel == 24)                  row_width = biWidth * 3;              else if (bits_per_pixel == 32)                  row_width = biWidth * 4;              else                  row_width = biWidth;
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: if (bits_per_pixel == 24)                  row_width = biWidth * 3;              else if (bits_per_pixel == 32)                  row_width = biWidth * 4;              else                  row_width = biWidth;
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: while ((row_width & 3) != 0)                  row_width++;
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: buffer = jpeg_common_struct.AllocJpegSamples(biWidth * 3' 1);
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: cinfo.Input_components = 3;
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,start_input,The following statement contains a magic number: cinfo.Data_precision = 8;
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,get_8bit_row,The following statement contains a magic number: for (int col = cinfo.Image_width; col > 0; col--)              {                  int t = image_ptr[0][imageIndex];                  imageIndex++;                    buffer[0][outIndex] = colormap[0][t]; /* can omit GETbyte() safely */                  outIndex++;                  buffer[0][outIndex] = colormap[1][t];                  outIndex++;                  buffer[0][outIndex] = colormap[2][t];                  outIndex++;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,get_24bit_row,The following statement contains a magic number: for (int col = cinfo.Image_width; col > 0; col--)              {                  buffer[0][outIndex + 2] = image_ptr[0][imageIndex];   /* can omit GETbyte() safely */                  imageIndex++;                  buffer[0][outIndex + 1] = image_ptr[0][imageIndex];                  imageIndex++;                  buffer[0][outIndex] = image_ptr[0][imageIndex];                  imageIndex++;                  outIndex += 3;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,get_24bit_row,The following statement contains a magic number: for (int col = cinfo.Image_width; col > 0; col--)              {                  buffer[0][outIndex + 2] = image_ptr[0][imageIndex];   /* can omit GETbyte() safely */                  imageIndex++;                  buffer[0][outIndex + 1] = image_ptr[0][imageIndex];                  imageIndex++;                  buffer[0][outIndex] = image_ptr[0][imageIndex];                  imageIndex++;                  outIndex += 3;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,get_32bit_row,The following statement contains a magic number: for (int col = cinfo.Image_width; col > 0; col--)              {                  buffer[0][outIndex + 2] = image_ptr[0][imageIndex];   /* can omit GETbyte() safely */                  imageIndex++;                  buffer[0][outIndex + 1] = image_ptr[0][imageIndex];                  imageIndex++;                  buffer[0][outIndex] = image_ptr[0][imageIndex];                  imageIndex++;                  imageIndex++;   /* skip the 4th byte (Alpha channel) */                  outIndex += 3;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,get_32bit_row,The following statement contains a magic number: for (int col = cinfo.Image_width; col > 0; col--)              {                  buffer[0][outIndex + 2] = image_ptr[0][imageIndex];   /* can omit GETbyte() safely */                  imageIndex++;                  buffer[0][outIndex + 1] = image_ptr[0][imageIndex];                  imageIndex++;                  buffer[0][outIndex] = image_ptr[0][imageIndex];                  imageIndex++;                  imageIndex++;   /* skip the 4th byte (Alpha channel) */                  outIndex += 3;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,preload_image,The following statement contains a magic number: switch (bits_per_pixel)              {                  case 8:                      m_pixelRowsMethod = PixelRowsMethod.use8bit;                      break;                  case 24:                      m_pixelRowsMethod = PixelRowsMethod.use24bit;                      break;                  case 32:                      m_pixelRowsMethod = PixelRowsMethod.use32bit;                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,preload_image,The following statement contains a magic number: switch (bits_per_pixel)              {                  case 8:                      m_pixelRowsMethod = PixelRowsMethod.use8bit;                      break;                  case 24:                      m_pixelRowsMethod = PixelRowsMethod.use24bit;                      break;                  case 32:                      m_pixelRowsMethod = PixelRowsMethod.use32bit;                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,preload_image,The following statement contains a magic number: switch (bits_per_pixel)              {                  case 8:                      m_pixelRowsMethod = PixelRowsMethod.use8bit;                      break;                  case 24:                      m_pixelRowsMethod = PixelRowsMethod.use24bit;                      break;                  case 32:                      m_pixelRowsMethod = PixelRowsMethod.use32bit;                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADDEPTH);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,read_colormap,The following statement contains a magic number: switch (mapentrysize)              {                  case 3:                      /* BGR format (occurs in OS/2 files) */                      for (int i = 0; i < cmaplen; i++)                      {                          colormap[2][i] = (byte)read_byte();                          colormap[1][i] = (byte)read_byte();                          colormap[0][i] = (byte)read_byte();                      }                      break;                  case 4:                      /* BGR0 format (occurs in MS Windows files) */                      for (int i = 0; i < cmaplen; i++)                      {                          colormap[2][i] = (byte)read_byte();                          colormap[1][i] = (byte)read_byte();                          colormap[0][i] = (byte)read_byte();                          read_byte();                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADCMAP);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,read_colormap,The following statement contains a magic number: switch (mapentrysize)              {                  case 3:                      /* BGR format (occurs in OS/2 files) */                      for (int i = 0; i < cmaplen; i++)                      {                          colormap[2][i] = (byte)read_byte();                          colormap[1][i] = (byte)read_byte();                          colormap[0][i] = (byte)read_byte();                      }                      break;                  case 4:                      /* BGR0 format (occurs in MS Windows files) */                      for (int i = 0; i < cmaplen; i++)                      {                          colormap[2][i] = (byte)read_byte();                          colormap[1][i] = (byte)read_byte();                          colormap[0][i] = (byte)read_byte();                          read_byte();                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADCMAP);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,read_colormap,The following statement contains a magic number: switch (mapentrysize)              {                  case 3:                      /* BGR format (occurs in OS/2 files) */                      for (int i = 0; i < cmaplen; i++)                      {                          colormap[2][i] = (byte)read_byte();                          colormap[1][i] = (byte)read_byte();                          colormap[0][i] = (byte)read_byte();                      }                      break;                  case 4:                      /* BGR0 format (occurs in MS Windows files) */                      for (int i = 0; i < cmaplen; i++)                      {                          colormap[2][i] = (byte)read_byte();                          colormap[1][i] = (byte)read_byte();                          colormap[0][i] = (byte)read_byte();                          read_byte();                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADCMAP);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,read_colormap,The following statement contains a magic number: switch (mapentrysize)              {                  case 3:                      /* BGR format (occurs in OS/2 files) */                      for (int i = 0; i < cmaplen; i++)                      {                          colormap[2][i] = (byte)read_byte();                          colormap[1][i] = (byte)read_byte();                          colormap[0][i] = (byte)read_byte();                      }                      break;                  case 4:                      /* BGR0 format (occurs in MS Windows files) */                      for (int i = 0; i < cmaplen; i++)                      {                          colormap[2][i] = (byte)read_byte();                          colormap[1][i] = (byte)read_byte();                          colormap[0][i] = (byte)read_byte();                          read_byte();                      }                      break;                  default:                      cinfo.ERREXIT((int)ADDON_MESSAGE_CODE.JERR_BMP_BADCMAP);                      break;              }
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,GET_2B,The following statement contains a magic number: return (int)array[offset] + ((int)array[offset + 1] << 8);
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,GET_4B,The following statement contains a magic number: return (int)array[offset] + ((int)array[offset + 1] << 8) + ((int)array[offset + 2] << 16) + ((int)array[offset + 3] << 24);
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,GET_4B,The following statement contains a magic number: return (int)array[offset] + ((int)array[offset + 1] << 8) + ((int)array[offset + 2] << 16) + ((int)array[offset + 3] << 24);
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,GET_4B,The following statement contains a magic number: return (int)array[offset] + ((int)array[offset + 1] << 8) + ((int)array[offset + 2] << 16) + ((int)array[offset + 3] << 24);
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,GET_4B,The following statement contains a magic number: return (int)array[offset] + ((int)array[offset + 1] << 8) + ((int)array[offset + 2] << 16) + ((int)array[offset + 3] << 24);
Magic Number,BitMiracle.cJpeg,bmp_source_struct,C:\repos\BitMiracle_libjpeg.net\cJpeg\bmp_source_struct.cs,GET_4B,The following statement contains a magic number: return (int)array[offset] + ((int)array[offset + 1] << 8) + ((int)array[offset + 2] << 16) + ((int)array[offset + 3] << 24);
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,Main,The following statement contains a magic number: if (outfilename == null)              {                  // file_index should point to input file                   if (file_index != args.Length - 2)                  {                      Console.WriteLine(string.Format("{0}: must name one input and one output file."' progname));                      usage();                      return;                  }                    // output file comes right after input one                  outfilename = args[file_index + 1];              }              else              {                  // file_index should point to input file                  if (file_index != args.Length - 1)                  {                      Console.WriteLine(string.Format("{0}: must name one input and one output file."' progname));                      usage();                      return;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,parse_switches,The following statement contains a magic number: for (; argn < argv.Length; argn++)              {                  string arg = argv[argn];                  if (string.IsNullOrEmpty(arg) || arg[0] != '-')                  {                      /* Not a switch' must be a file name argument */                      fileIndex = argn;                      break;                  }                    arg = arg.Substring(1);                    if (cdjpeg_utils.keymatch(arg' "baseline"' 2))                  {                      /* Force baseline-compatible output (8-bit quantizer values). */                      force_baseline = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "block"' 2))                  {                      /* Set DCT block size. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        int val;                      if (!int.TryParse(argv[argn]' out val))                          return false;                        if (val < 1 || val > 16)                          return false;                        cinfo.block_size = val;                  }                  else if (cdjpeg_utils.keymatch(arg' "dct"' 2))                  {                      /* Select DCT algorithm. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        if (cdjpeg_utils.keymatch(argv[argn]' "int"' 1))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_ISLOW;                      else if (cdjpeg_utils.keymatch(argv[argn]' "fast"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_IFAST;                      else if (cdjpeg_utils.keymatch(argv[argn]' "float"' 2))                          cinfo.Dct_method = J_DCT_METHOD.JDCT_FLOAT;                      else                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "debug"' 1) || cdjpeg_utils.keymatch(arg' "verbose"' 1))                  {                      /* Enable debug printouts. */                      /* On first -d' print version identification */                      if (!printed_version)                      {                          Console.Write(string.Format("Bit Miracle's CJPEG' version {0}\n{1}\n"' jpeg_common_struct.Version' jpeg_common_struct.Copyright));                          printed_version = true;                      }                      cinfo.Err.Trace_level++;                  }                  else if (cdjpeg_utils.keymatch(arg' "grayscale"' 2) || cdjpeg_utils.keymatch(arg' "greyscale"' 2))                  {                      /* Force a monochrome JPEG file to be generated. */                      cinfo.jpeg_set_colorspace(J_COLOR_SPACE.JCS_GRAYSCALE);                  }                  else if (cdjpeg_utils.keymatch(arg' "rgb"' 3) || cdjpeg_utils.keymatch(arg' "rgb1"' 4))                  {                      /* Force an RGB JPEG file to be generated. */                      /* Note: Entropy table assignment in Jpeg_color_space depends                       * on color_transform.                       */                      cinfo.color_transform = (arg == "rgb") ? J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN : J_COLOR_TRANSFORM.JCT_NONE;                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_RGB;                  }                  else if (cdjpeg_utils.keymatch(arg' "bgycc"' 5))                  {                      /* Force a big gamut YCC JPEG file to be generated. */                      cinfo.Jpeg_color_space = J_COLOR_SPACE.JCS_BG_YCC;                  }                  else if (cdjpeg_utils.keymatch(arg' "optimize"' 1) || cdjpeg_utils.keymatch(arg' "optimise"' 1))                  {                      /* Enable entropy parm optimization. */                      cinfo.Optimize_coding = true;                  }                  else if (cdjpeg_utils.keymatch(arg' "nosmooth"' 3))                  {                      /* Suppress fancy downsampling. */                      cinfo.do_fancy_downsampling = false;                  }                  else if (cdjpeg_utils.keymatch(arg' "outfile"' 4))                  {                      /* Set output file name. */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        outfilename = argv[argn];   /* save it away for later use */                  }                  else if (cdjpeg_utils.keymatch(arg' "progressive"' 1))                  {                      /* Select simple progressive mode. */                      simple_progressive = true;                      /* We must postpone execution until num_components is known. */                  }                  else if (cdjpeg_utils.keymatch(arg' "quality"' 1))                  {                      /* Quality ratings (quantization table scaling factors). */                      argn++;/* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qualityarg = argv[argn];                  }                  else if (cdjpeg_utils.keymatch(arg' "qslots"' 2))                  {                      /* Quantization table slot numbers. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qslotsarg = argv[argn];                      /* Must delay setting qslots until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default quant table numbers.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "qtables"' 2))                  {                      /* Quantization tables fetched from file. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        qtablefile = argv[argn];                      /* We postpone actually reading the file in case -quality comes later. */                  }                  else if (cdjpeg_utils.keymatch(arg' "restart"' 1))                  {                      /* Restart interval in MCU rows (or in MCUs with 'b'). */                      argn++; /* advance to next argument */                        if (argn >= argv.Length)                          return false;                        bool inBlocks = false;                      if (argv[argn].EndsWith("b") || argv[argn].EndsWith("B"))                          inBlocks = true;                        string parsee = argv[argn];                      if (inBlocks)                          parsee = parsee.Remove(parsee.Length - 1);                        try                      {                          int val = int.Parse(parsee);                          if (val < 0 || val > 65535)                              return false;                            if (inBlocks)                          {                              cinfo.Restart_interval = val;                              cinfo.Restart_in_rows = 0; /* else prior '-restart n' overrides me */                          }                          else                          {                              cinfo.Restart_in_rows = val;                              /* restart_interval will be computed during startup */                          }                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else if (cdjpeg_utils.keymatch(arg' "sample"' 2))                  {                      /* Set sampling factors. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        samplearg = argv[argn];                      /* Must delay setting sample factors until after we have processed any                       * colorspace-determining switches' since jpeg_set_colorspace sets                       * default sampling factors.                       */                  }                  else if (cdjpeg_utils.keymatch(arg' "scale"' 4))                  {                      /* Scale the image by a fraction M/N. */                      argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        string[] parts = argv[argn].Split(''');                      if (parts.Length != 2)                          return false;                        if (!int.TryParse(parts[0]' out cinfo.scale_num))                          return false;                        if (!int.TryParse(parts[1]' out cinfo.scale_denom))                          return false;                  }                  else if (cdjpeg_utils.keymatch(arg' "smooth"' 2))                  {                      /* Set input smoothing factor. */                        argn++; /* advance to next argument */                      if (argn >= argv.Length)                          return false;                        try                      {                          int val = int.Parse(argv[argn]);                          if (val < 0 || val > 100)                              return false;                            cinfo.Smoothing_factor = val;                      }                      catch (Exception e)                      {                          Console.WriteLine(e.Message);                          return false;                      }                  }                  else                  {                      /* bogus switch */                      return false;                  }              }
Magic Number,BitMiracle.cJpeg,Program,C:\repos\BitMiracle_libjpeg.net\cJpeg\Program.cs,set_quality_ratings,The following statement contains a magic number: int val = 75;
