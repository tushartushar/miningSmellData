Implementation smell,Namespace,Class,File,Method,Description
Long Method,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,OnKeyDown,The method has 103 lines of code.
Long Method,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,OnPaint,The method has 112 lines of code.
Complex Method,Ankh.Diff,NativeMethods,C:\repos\necora_ank_git\src\Ankh.Diff\Common\Classes\Windows.cs,SetBorderStyle,Cyclomatic complexity of the method is 12
Complex Method,Ankh.Diff,NumericTextBox,C:\repos\necora_ank_git\src\Ankh.Diff\Common\Components\NumericTextBox.cs,OnKeyPress,Cyclomatic complexity of the method is 9
Complex Method,Ankh.Diff.DiffUtils,BinaryDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\BinaryDiff.cs,Execute,Cyclomatic complexity of the method is 9
Complex Method,Ankh.Diff.DiffUtils,DirectoryDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\DirectoryDiff.cs,DiffFileSystemInfos,Cyclomatic complexity of the method is 19
Complex Method,Ankh.Diff.DiffUtils,DirectoryDiffFileFilter,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\DirectoryDiffFileFilter.cs,Filter,Cyclomatic complexity of the method is 8
Complex Method,Ankh.Diff.DiffUtils,Functions,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\Functions.cs,AreFilesDifferent,Cyclomatic complexity of the method is 8
Complex Method,Ankh.Diff.DiffUtils,Functions,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\Functions.cs,GetXMLTextLines,Cyclomatic complexity of the method is 60
Complex Method,Ankh.Diff.DiffUtils,Functions,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\Functions.cs,GetIndentString,Cyclomatic complexity of the method is 13
Complex Method,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,Cyclomatic complexity of the method is 10
Complex Method,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,GetMatchPoints,Cyclomatic complexity of the method is 9
Complex Method,Ankh.Diff.DiffUtils.Controls,DiffControl,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffControl.cs,ProcessCmdKey,Cyclomatic complexity of the method is 8
Complex Method,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,FindNext,Cyclomatic complexity of the method is 8
Complex Method,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,FindPrevious,Cyclomatic complexity of the method is 9
Complex Method,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,GetPosFromPoint,Cyclomatic complexity of the method is 8
Complex Method,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,WndProc,Cyclomatic complexity of the method is 24
Complex Method,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,OnKeyDown,Cyclomatic complexity of the method is 49
Complex Method,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,OnPaint,Cyclomatic complexity of the method is 12
Complex Method,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,OnMouseMove,Cyclomatic complexity of the method is 8
Complex Method,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,SetPosition,Cyclomatic complexity of the method is 14
Complex Method,Ankh.Diff.DiffUtils.Controls,DirDiffControl,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DirDiffControl.cs,TreeNode_StateChange,Cyclomatic complexity of the method is 9
Long Parameter List,Ankh.Diff,NativeMethods,C:\repos\necora_ank_git\src\Ankh.Diff\Common\Classes\Windows.cs,SetScrollPageAndRange,The method has 5 parameters.
Long Parameter List,Ankh.Diff,NativeMethods,C:\repos\necora_ank_git\src\Ankh.Diff\Common\Classes\Windows.cs,ScrollWindow,The method has 5 parameters.
Long Parameter List,Ankh.Diff,NativeMethods,C:\repos\necora_ank_git\src\Ankh.Diff\Common\Classes\Windows.cs,ScrollWindow,The method has 5 parameters.
Long Parameter List,Ankh.Diff,NativeMethods,C:\repos\necora_ank_git\src\Ankh.Diff\Common\Classes\Windows.cs,ScrollWindow,The method has 5 parameters.
Long Parameter List,Ankh.Diff.DiffUtils,BinaryDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\BinaryDiff.cs,EmitCodes,The method has 6 parameters.
Long Parameter List,Ankh.Diff.DiffUtils,BinaryDiffLines,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\BinaryDiffLines.cs,AddBytesFromStream,The method has 5 parameters.
Long Parameter List,Ankh.Diff.DiffUtils,DirectoryDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\DirectoryDiff.cs,DirectoryDiff,The method has 7 parameters.
Long Parameter List,Ankh.Diff.DiffUtils,DirectoryDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\DirectoryDiff.cs,DiffFileSystemInfos,The method has 5 parameters.
Long Parameter List,Ankh.Diff.DiffUtils,DirectoryDiffEntry,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\DirectoryDiffHelpers.cs,DirectoryDiffEntry,The method has 5 parameters.
Long Parameter List,Ankh.Diff.DiffUtils,DirectoryDiffResults,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\DirectoryDiffHelpers.cs,DirectoryDiffResults,The method has 5 parameters.
Long Parameter List,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,GetReverseDPaths,The method has 5 parameters.
Long Parameter List,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The method has 5 parameters.
Long Parameter List,Ankh.Diff.DiffUtils.Controls,DiffControl,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffControl.cs,SetData,The method has 5 parameters.
Long Parameter List,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,DrawStringWithWS,The method has 5 parameters.
Long Parameter List,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,MeasureStringDisplayWidth,The method has 5 parameters.
Long Statement,Ankh.Diff,Utilities,C:\repos\necora_ank_git\src\Ankh.Diff\Common\Classes\Utilities.cs,IndexOfNoCase,The length of the statement  "	int iResult = CultureInfo.CurrentCulture.CompareInfo.IndexOf (strText' strSubstring' iStartIndex' iCount' CompareOptions.IgnoreCase); " is 133.
Long Statement,Ankh.Diff.DiffUtils,BinaryDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\BinaryDiff.cs,Execute,The length of the statement  "			if (VerFile == BaseEntry.File && Verify (VerFile' BaseEntry.Offset' BaseFile' iBasePos) && iVerStart <= BaseEntry.Offset) { " is 123.
Long Statement,Ankh.Diff.DiffUtils,BinaryDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\BinaryDiff.cs,Execute,The length of the statement  "	Debug.Assert (List.TotalByteLength == (int)VerFile.Length' "The total byte length of the AddCopyList MUST equal the length of the version file!"); " is 146.
Long Statement,Ankh.Diff.DiffUtils.Controls,DiffControl,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffControl.cs,PaintColorLegendItem,The length of the statement  "		Rectangle ImageRect = new Rectangle (R.X + (R.Width - I.Width) / 2' R.Y + (R.Height - I.Height) / 2' I.Width' I.Height); " is 120.
Long Statement,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,UpdateTextMetrics,The length of the statement  "		m_fCharWidth = MeasureStringDisplayWidth (G' "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"' 52' Font' m_StringFormat) / 52; " is 132.
Complex Conditional,Ankh.Diff.DiffUtils,DirectoryDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\DirectoryDiff.cs,DiffFileSystemInfos,The conditional expression  "(bDifferent && m_bShowDifferent) || (!bDifferent && m_bShowSame)"  is complex.
Complex Conditional,Ankh.Diff.DiffUtils,DirectoryDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\DirectoryDiff.cs,DiffFileSystemInfos,The conditional expression  "m_bIgnoreDirectoryComparison || (bDifferent && m_bShowDifferent) || (!bDifferent && m_bShowSame)"  is complex.
Complex Conditional,Ankh.Diff.DiffUtils.Controls,DiffOverview,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffOverview.cs,RenderImage,The conditional expression  "iWidth > 0 && iHeight > 0 && m_View != null && m_View.Lines != null"  is complex.
Complex Conditional,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,GoToLine,The conditional expression  "iLine >= 0 && m_Lines != null && iLine < m_Lines.Count && iLine < m_StringList.Count"  is complex.
Complex Conditional,Ankh.Diff.DiffUtils.Controls,DirDiffTreeView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DirDiffTreeView.cs,SetNodeText,The conditional expression  "(Entry.InA && Entry.InB) || (m_bUseA && Entry.InA) || (!m_bUseA && Entry.InB)"  is complex.
Complex Conditional,Ankh.Diff.DiffUtils.Controls,DirDiffTreeView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DirDiffTreeView.cs,SetNodeImage,The conditional expression  "m_Results.Recursive && Node.IsExpanded && Entry.InA && Entry.InB"  is complex.
Magic Number,Ankh.Diff,Utilities,C:\repos\necora_ank_git\src\Ankh.Diff\Common\Classes\Utilities.cs,GetAngle,The following statement contains a magic number: return (float)(dRadians / Math.PI * 180.0);  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFF,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	Diff.WriteByte (0xd1);  	Diff.WriteByte (0xff);  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFAdd,The following statement contains a magic number: if (iLength <= 246) {  	Diff.WriteByte ((byte)iLength);  	Diff.Write (Add.arBytes' 0' iLength);  }  else if (iLength <= ushort.MaxValue) {  	Diff.WriteByte (247);  	WriteBigEndian (Diff' (ushort)iLength);  	Diff.Write (Add.arBytes' 0' iLength);  }  else {  	Diff.WriteByte (248);  	WriteBigEndian (Diff' iLength);  	Diff.Write (Add.arBytes' 0' iLength);  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFAdd,The following statement contains a magic number: if (iLength <= 246) {  	Diff.WriteByte ((byte)iLength);  	Diff.Write (Add.arBytes' 0' iLength);  }  else if (iLength <= ushort.MaxValue) {  	Diff.WriteByte (247);  	WriteBigEndian (Diff' (ushort)iLength);  	Diff.Write (Add.arBytes' 0' iLength);  }  else {  	Diff.WriteByte (248);  	WriteBigEndian (Diff' iLength);  	Diff.Write (Add.arBytes' 0' iLength);  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFAdd,The following statement contains a magic number: if (iLength <= 246) {  	Diff.WriteByte ((byte)iLength);  	Diff.Write (Add.arBytes' 0' iLength);  }  else if (iLength <= ushort.MaxValue) {  	Diff.WriteByte (247);  	WriteBigEndian (Diff' (ushort)iLength);  	Diff.Write (Add.arBytes' 0' iLength);  }  else {  	Diff.WriteByte (248);  	WriteBigEndian (Diff' iLength);  	Diff.Write (Add.arBytes' 0' iLength);  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFAdd,The following statement contains a magic number: if (iLength <= ushort.MaxValue) {  	Diff.WriteByte (247);  	WriteBigEndian (Diff' (ushort)iLength);  	Diff.Write (Add.arBytes' 0' iLength);  }  else {  	Diff.WriteByte (248);  	WriteBigEndian (Diff' iLength);  	Diff.Write (Add.arBytes' 0' iLength);  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFAdd,The following statement contains a magic number: if (iLength <= ushort.MaxValue) {  	Diff.WriteByte (247);  	WriteBigEndian (Diff' (ushort)iLength);  	Diff.Write (Add.arBytes' 0' iLength);  }  else {  	Diff.WriteByte (248);  	WriteBigEndian (Diff' iLength);  	Diff.Write (Add.arBytes' 0' iLength);  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFAdd,The following statement contains a magic number: Diff.WriteByte (247);  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFAdd,The following statement contains a magic number: Diff.WriteByte (248);  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: if (C.iBaseOffset <= ushort.MaxValue) {  	if (C.iLength <= byte.MaxValue) {  		Diff.WriteByte (249);  		WriteBigEndian (Diff' (ushort)C.iBaseOffset);  		Diff.WriteByte ((byte)C.iLength);  	}  	else if (C.iLength <= ushort.MaxValue) {  		Diff.WriteByte (250);  		WriteBigEndian (Diff' (ushort)C.iBaseOffset);  		WriteBigEndian (Diff' (ushort)C.iLength);  	}  	else {  		Diff.WriteByte (251);  		WriteBigEndian (Diff' (ushort)C.iBaseOffset);  		WriteBigEndian (Diff' C.iLength);  	}  }  else {  	if (C.iLength <= byte.MaxValue) {  		Diff.WriteByte (252);  		WriteBigEndian (Diff' C.iBaseOffset);  		Diff.WriteByte ((byte)C.iLength);  	}  	else if (C.iLength <= ushort.MaxValue) {  		Diff.WriteByte (253);  		WriteBigEndian (Diff' C.iBaseOffset);  		WriteBigEndian (Diff' (ushort)C.iLength);  	}  	else {  		Diff.WriteByte (254);  		WriteBigEndian (Diff' C.iBaseOffset);  		WriteBigEndian (Diff' C.iLength);  	}  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: if (C.iBaseOffset <= ushort.MaxValue) {  	if (C.iLength <= byte.MaxValue) {  		Diff.WriteByte (249);  		WriteBigEndian (Diff' (ushort)C.iBaseOffset);  		Diff.WriteByte ((byte)C.iLength);  	}  	else if (C.iLength <= ushort.MaxValue) {  		Diff.WriteByte (250);  		WriteBigEndian (Diff' (ushort)C.iBaseOffset);  		WriteBigEndian (Diff' (ushort)C.iLength);  	}  	else {  		Diff.WriteByte (251);  		WriteBigEndian (Diff' (ushort)C.iBaseOffset);  		WriteBigEndian (Diff' C.iLength);  	}  }  else {  	if (C.iLength <= byte.MaxValue) {  		Diff.WriteByte (252);  		WriteBigEndian (Diff' C.iBaseOffset);  		Diff.WriteByte ((byte)C.iLength);  	}  	else if (C.iLength <= ushort.MaxValue) {  		Diff.WriteByte (253);  		WriteBigEndian (Diff' C.iBaseOffset);  		WriteBigEndian (Diff' (ushort)C.iLength);  	}  	else {  		Diff.WriteByte (254);  		WriteBigEndian (Diff' C.iBaseOffset);  		WriteBigEndian (Diff' C.iLength);  	}  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: if (C.iBaseOffset <= ushort.MaxValue) {  	if (C.iLength <= byte.MaxValue) {  		Diff.WriteByte (249);  		WriteBigEndian (Diff' (ushort)C.iBaseOffset);  		Diff.WriteByte ((byte)C.iLength);  	}  	else if (C.iLength <= ushort.MaxValue) {  		Diff.WriteByte (250);  		WriteBigEndian (Diff' (ushort)C.iBaseOffset);  		WriteBigEndian (Diff' (ushort)C.iLength);  	}  	else {  		Diff.WriteByte (251);  		WriteBigEndian (Diff' (ushort)C.iBaseOffset);  		WriteBigEndian (Diff' C.iLength);  	}  }  else {  	if (C.iLength <= byte.MaxValue) {  		Diff.WriteByte (252);  		WriteBigEndian (Diff' C.iBaseOffset);  		Diff.WriteByte ((byte)C.iLength);  	}  	else if (C.iLength <= ushort.MaxValue) {  		Diff.WriteByte (253);  		WriteBigEndian (Diff' C.iBaseOffset);  		WriteBigEndian (Diff' (ushort)C.iLength);  	}  	else {  		Diff.WriteByte (254);  		WriteBigEndian (Diff' C.iBaseOffset);  		WriteBigEndian (Diff' C.iLength);  	}  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: if (C.iBaseOffset <= ushort.MaxValue) {  	if (C.iLength <= byte.MaxValue) {  		Diff.WriteByte (249);  		WriteBigEndian (Diff' (ushort)C.iBaseOffset);  		Diff.WriteByte ((byte)C.iLength);  	}  	else if (C.iLength <= ushort.MaxValue) {  		Diff.WriteByte (250);  		WriteBigEndian (Diff' (ushort)C.iBaseOffset);  		WriteBigEndian (Diff' (ushort)C.iLength);  	}  	else {  		Diff.WriteByte (251);  		WriteBigEndian (Diff' (ushort)C.iBaseOffset);  		WriteBigEndian (Diff' C.iLength);  	}  }  else {  	if (C.iLength <= byte.MaxValue) {  		Diff.WriteByte (252);  		WriteBigEndian (Diff' C.iBaseOffset);  		Diff.WriteByte ((byte)C.iLength);  	}  	else if (C.iLength <= ushort.MaxValue) {  		Diff.WriteByte (253);  		WriteBigEndian (Diff' C.iBaseOffset);  		WriteBigEndian (Diff' (ushort)C.iLength);  	}  	else {  		Diff.WriteByte (254);  		WriteBigEndian (Diff' C.iBaseOffset);  		WriteBigEndian (Diff' C.iLength);  	}  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: if (C.iBaseOffset <= ushort.MaxValue) {  	if (C.iLength <= byte.MaxValue) {  		Diff.WriteByte (249);  		WriteBigEndian (Diff' (ushort)C.iBaseOffset);  		Diff.WriteByte ((byte)C.iLength);  	}  	else if (C.iLength <= ushort.MaxValue) {  		Diff.WriteByte (250);  		WriteBigEndian (Diff' (ushort)C.iBaseOffset);  		WriteBigEndian (Diff' (ushort)C.iLength);  	}  	else {  		Diff.WriteByte (251);  		WriteBigEndian (Diff' (ushort)C.iBaseOffset);  		WriteBigEndian (Diff' C.iLength);  	}  }  else {  	if (C.iLength <= byte.MaxValue) {  		Diff.WriteByte (252);  		WriteBigEndian (Diff' C.iBaseOffset);  		Diff.WriteByte ((byte)C.iLength);  	}  	else if (C.iLength <= ushort.MaxValue) {  		Diff.WriteByte (253);  		WriteBigEndian (Diff' C.iBaseOffset);  		WriteBigEndian (Diff' (ushort)C.iLength);  	}  	else {  		Diff.WriteByte (254);  		WriteBigEndian (Diff' C.iBaseOffset);  		WriteBigEndian (Diff' C.iLength);  	}  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: if (C.iBaseOffset <= ushort.MaxValue) {  	if (C.iLength <= byte.MaxValue) {  		Diff.WriteByte (249);  		WriteBigEndian (Diff' (ushort)C.iBaseOffset);  		Diff.WriteByte ((byte)C.iLength);  	}  	else if (C.iLength <= ushort.MaxValue) {  		Diff.WriteByte (250);  		WriteBigEndian (Diff' (ushort)C.iBaseOffset);  		WriteBigEndian (Diff' (ushort)C.iLength);  	}  	else {  		Diff.WriteByte (251);  		WriteBigEndian (Diff' (ushort)C.iBaseOffset);  		WriteBigEndian (Diff' C.iLength);  	}  }  else {  	if (C.iLength <= byte.MaxValue) {  		Diff.WriteByte (252);  		WriteBigEndian (Diff' C.iBaseOffset);  		Diff.WriteByte ((byte)C.iLength);  	}  	else if (C.iLength <= ushort.MaxValue) {  		Diff.WriteByte (253);  		WriteBigEndian (Diff' C.iBaseOffset);  		WriteBigEndian (Diff' (ushort)C.iLength);  	}  	else {  		Diff.WriteByte (254);  		WriteBigEndian (Diff' C.iBaseOffset);  		WriteBigEndian (Diff' C.iLength);  	}  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: if (C.iLength <= byte.MaxValue) {  	Diff.WriteByte (249);  	WriteBigEndian (Diff' (ushort)C.iBaseOffset);  	Diff.WriteByte ((byte)C.iLength);  }  else if (C.iLength <= ushort.MaxValue) {  	Diff.WriteByte (250);  	WriteBigEndian (Diff' (ushort)C.iBaseOffset);  	WriteBigEndian (Diff' (ushort)C.iLength);  }  else {  	Diff.WriteByte (251);  	WriteBigEndian (Diff' (ushort)C.iBaseOffset);  	WriteBigEndian (Diff' C.iLength);  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: if (C.iLength <= byte.MaxValue) {  	Diff.WriteByte (249);  	WriteBigEndian (Diff' (ushort)C.iBaseOffset);  	Diff.WriteByte ((byte)C.iLength);  }  else if (C.iLength <= ushort.MaxValue) {  	Diff.WriteByte (250);  	WriteBigEndian (Diff' (ushort)C.iBaseOffset);  	WriteBigEndian (Diff' (ushort)C.iLength);  }  else {  	Diff.WriteByte (251);  	WriteBigEndian (Diff' (ushort)C.iBaseOffset);  	WriteBigEndian (Diff' C.iLength);  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: if (C.iLength <= byte.MaxValue) {  	Diff.WriteByte (249);  	WriteBigEndian (Diff' (ushort)C.iBaseOffset);  	Diff.WriteByte ((byte)C.iLength);  }  else if (C.iLength <= ushort.MaxValue) {  	Diff.WriteByte (250);  	WriteBigEndian (Diff' (ushort)C.iBaseOffset);  	WriteBigEndian (Diff' (ushort)C.iLength);  }  else {  	Diff.WriteByte (251);  	WriteBigEndian (Diff' (ushort)C.iBaseOffset);  	WriteBigEndian (Diff' C.iLength);  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: Diff.WriteByte (249);  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: if (C.iLength <= ushort.MaxValue) {  	Diff.WriteByte (250);  	WriteBigEndian (Diff' (ushort)C.iBaseOffset);  	WriteBigEndian (Diff' (ushort)C.iLength);  }  else {  	Diff.WriteByte (251);  	WriteBigEndian (Diff' (ushort)C.iBaseOffset);  	WriteBigEndian (Diff' C.iLength);  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: if (C.iLength <= ushort.MaxValue) {  	Diff.WriteByte (250);  	WriteBigEndian (Diff' (ushort)C.iBaseOffset);  	WriteBigEndian (Diff' (ushort)C.iLength);  }  else {  	Diff.WriteByte (251);  	WriteBigEndian (Diff' (ushort)C.iBaseOffset);  	WriteBigEndian (Diff' C.iLength);  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: Diff.WriteByte (250);  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: Diff.WriteByte (251);  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: if (C.iLength <= byte.MaxValue) {  	Diff.WriteByte (252);  	WriteBigEndian (Diff' C.iBaseOffset);  	Diff.WriteByte ((byte)C.iLength);  }  else if (C.iLength <= ushort.MaxValue) {  	Diff.WriteByte (253);  	WriteBigEndian (Diff' C.iBaseOffset);  	WriteBigEndian (Diff' (ushort)C.iLength);  }  else {  	Diff.WriteByte (254);  	WriteBigEndian (Diff' C.iBaseOffset);  	WriteBigEndian (Diff' C.iLength);  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: if (C.iLength <= byte.MaxValue) {  	Diff.WriteByte (252);  	WriteBigEndian (Diff' C.iBaseOffset);  	Diff.WriteByte ((byte)C.iLength);  }  else if (C.iLength <= ushort.MaxValue) {  	Diff.WriteByte (253);  	WriteBigEndian (Diff' C.iBaseOffset);  	WriteBigEndian (Diff' (ushort)C.iLength);  }  else {  	Diff.WriteByte (254);  	WriteBigEndian (Diff' C.iBaseOffset);  	WriteBigEndian (Diff' C.iLength);  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: if (C.iLength <= byte.MaxValue) {  	Diff.WriteByte (252);  	WriteBigEndian (Diff' C.iBaseOffset);  	Diff.WriteByte ((byte)C.iLength);  }  else if (C.iLength <= ushort.MaxValue) {  	Diff.WriteByte (253);  	WriteBigEndian (Diff' C.iBaseOffset);  	WriteBigEndian (Diff' (ushort)C.iLength);  }  else {  	Diff.WriteByte (254);  	WriteBigEndian (Diff' C.iBaseOffset);  	WriteBigEndian (Diff' C.iLength);  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: Diff.WriteByte (252);  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: if (C.iLength <= ushort.MaxValue) {  	Diff.WriteByte (253);  	WriteBigEndian (Diff' C.iBaseOffset);  	WriteBigEndian (Diff' (ushort)C.iLength);  }  else {  	Diff.WriteByte (254);  	WriteBigEndian (Diff' C.iBaseOffset);  	WriteBigEndian (Diff' C.iLength);  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: if (C.iLength <= ushort.MaxValue) {  	Diff.WriteByte (253);  	WriteBigEndian (Diff' C.iBaseOffset);  	WriteBigEndian (Diff' (ushort)C.iLength);  }  else {  	Diff.WriteByte (254);  	WriteBigEndian (Diff' C.iBaseOffset);  	WriteBigEndian (Diff' C.iLength);  }  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: Diff.WriteByte (253);  
Magic Number,Ankh.Diff.DiffUtils,AddCopyList,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\AddCopyList.cs,GDIFFCopy,The following statement contains a magic number: Diff.WriteByte (254);  
Magic Number,Ankh.Diff.DiffUtils,BinaryDiffLines,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\BinaryDiffLines.cs,GetLineString,The following statement contains a magic number: while (sbHex.Length < 3 * m_iBytesPerLine) {  	sbHex.Append ("   ");  }  
Magic Number,Ankh.Diff.DiffUtils,DiagonalVector,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\DiagonalVector.cs,DiagonalVector,The following statement contains a magic number: m_arData = new int[2 * m_iMax + 1];  
Magic Number,Ankh.Diff.DiffUtils,EditScript,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\EditDataTypes.cs,Add,The following statement contains a magic number: if (E.Type == EditType.Change)  	m_iLength += 2 * E.Length;  else  	m_iLength += E.Length;  
Magic Number,Ankh.Diff.DiffUtils,EditScript,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\EditDataTypes.cs,Add,The following statement contains a magic number: m_iLength += 2 * E.Length;  
Magic Number,Ankh.Diff.DiffUtils,Functions,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\Functions.cs,GetIndentString,The following statement contains a magic number: switch (iDepth) {  case 0:  	return "";  case 1:  	return "\t";  case 2:  	return "\t\t";  case 3:  	return "\t\t\t";  case 4:  	return "\t\t\t\t";  case 5:  	return "\t\t\t\t\t";  case 6:  	return "\t\t\t\t\t\t";  case 7:  	return "\t\t\t\t\t\t\t";  case 8:  	return "\t\t\t\t\t\t\t\t";  case 9:  	return "\t\t\t\t\t\t\t\t\t";  default: {  	StringBuilder B = new StringBuilder ();  	for (int i = 0; i < iDepth; i++) {  		B.Append ("\t");  	}  	return B.ToString ();  }  }  
Magic Number,Ankh.Diff.DiffUtils,Functions,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\Functions.cs,GetIndentString,The following statement contains a magic number: switch (iDepth) {  case 0:  	return "";  case 1:  	return "\t";  case 2:  	return "\t\t";  case 3:  	return "\t\t\t";  case 4:  	return "\t\t\t\t";  case 5:  	return "\t\t\t\t\t";  case 6:  	return "\t\t\t\t\t\t";  case 7:  	return "\t\t\t\t\t\t\t";  case 8:  	return "\t\t\t\t\t\t\t\t";  case 9:  	return "\t\t\t\t\t\t\t\t\t";  default: {  	StringBuilder B = new StringBuilder ();  	for (int i = 0; i < iDepth; i++) {  		B.Append ("\t");  	}  	return B.ToString ();  }  }  
Magic Number,Ankh.Diff.DiffUtils,Functions,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\Functions.cs,GetIndentString,The following statement contains a magic number: switch (iDepth) {  case 0:  	return "";  case 1:  	return "\t";  case 2:  	return "\t\t";  case 3:  	return "\t\t\t";  case 4:  	return "\t\t\t\t";  case 5:  	return "\t\t\t\t\t";  case 6:  	return "\t\t\t\t\t\t";  case 7:  	return "\t\t\t\t\t\t\t";  case 8:  	return "\t\t\t\t\t\t\t\t";  case 9:  	return "\t\t\t\t\t\t\t\t\t";  default: {  	StringBuilder B = new StringBuilder ();  	for (int i = 0; i < iDepth; i++) {  		B.Append ("\t");  	}  	return B.ToString ();  }  }  
Magic Number,Ankh.Diff.DiffUtils,Functions,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\Functions.cs,GetIndentString,The following statement contains a magic number: switch (iDepth) {  case 0:  	return "";  case 1:  	return "\t";  case 2:  	return "\t\t";  case 3:  	return "\t\t\t";  case 4:  	return "\t\t\t\t";  case 5:  	return "\t\t\t\t\t";  case 6:  	return "\t\t\t\t\t\t";  case 7:  	return "\t\t\t\t\t\t\t";  case 8:  	return "\t\t\t\t\t\t\t\t";  case 9:  	return "\t\t\t\t\t\t\t\t\t";  default: {  	StringBuilder B = new StringBuilder ();  	for (int i = 0; i < iDepth; i++) {  		B.Append ("\t");  	}  	return B.ToString ();  }  }  
Magic Number,Ankh.Diff.DiffUtils,Functions,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\Functions.cs,GetIndentString,The following statement contains a magic number: switch (iDepth) {  case 0:  	return "";  case 1:  	return "\t";  case 2:  	return "\t\t";  case 3:  	return "\t\t\t";  case 4:  	return "\t\t\t\t";  case 5:  	return "\t\t\t\t\t";  case 6:  	return "\t\t\t\t\t\t";  case 7:  	return "\t\t\t\t\t\t\t";  case 8:  	return "\t\t\t\t\t\t\t\t";  case 9:  	return "\t\t\t\t\t\t\t\t\t";  default: {  	StringBuilder B = new StringBuilder ();  	for (int i = 0; i < iDepth; i++) {  		B.Append ("\t");  	}  	return B.ToString ();  }  }  
Magic Number,Ankh.Diff.DiffUtils,Functions,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\Functions.cs,GetIndentString,The following statement contains a magic number: switch (iDepth) {  case 0:  	return "";  case 1:  	return "\t";  case 2:  	return "\t\t";  case 3:  	return "\t\t\t";  case 4:  	return "\t\t\t\t";  case 5:  	return "\t\t\t\t\t";  case 6:  	return "\t\t\t\t\t\t";  case 7:  	return "\t\t\t\t\t\t\t";  case 8:  	return "\t\t\t\t\t\t\t\t";  case 9:  	return "\t\t\t\t\t\t\t\t\t";  default: {  	StringBuilder B = new StringBuilder ();  	for (int i = 0; i < iDepth; i++) {  		B.Append ("\t");  	}  	return B.ToString ();  }  }  
Magic Number,Ankh.Diff.DiffUtils,Functions,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\Functions.cs,GetIndentString,The following statement contains a magic number: switch (iDepth) {  case 0:  	return "";  case 1:  	return "\t";  case 2:  	return "\t\t";  case 3:  	return "\t\t\t";  case 4:  	return "\t\t\t\t";  case 5:  	return "\t\t\t\t\t";  case 6:  	return "\t\t\t\t\t\t";  case 7:  	return "\t\t\t\t\t\t\t";  case 8:  	return "\t\t\t\t\t\t\t\t";  case 9:  	return "\t\t\t\t\t\t\t\t\t";  default: {  	StringBuilder B = new StringBuilder ();  	for (int i = 0; i < iDepth; i++) {  		B.Append ("\t");  	}  	return B.ToString ();  }  }  
Magic Number,Ankh.Diff.DiffUtils,Functions,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\Functions.cs,GetIndentString,The following statement contains a magic number: switch (iDepth) {  case 0:  	return "";  case 1:  	return "\t";  case 2:  	return "\t\t";  case 3:  	return "\t\t\t";  case 4:  	return "\t\t\t\t";  case 5:  	return "\t\t\t\t\t";  case 6:  	return "\t\t\t\t\t\t";  case 7:  	return "\t\t\t\t\t\t\t";  case 8:  	return "\t\t\t\t\t\t\t\t";  case 9:  	return "\t\t\t\t\t\t\t\t\t";  default: {  	StringBuilder B = new StringBuilder ();  	for (int i = 0; i < iDepth; i++) {  		B.Append ("\t");  	}  	return B.ToString ();  }  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,GetLCSLength,The following statement contains a magic number: return (m_arA.Length + m_arB.Length - GetSESLength ()) / 2;  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,GetSimilarity,The following statement contains a magic number: return (2.0 * GetLCSLength ()) / (double)(m_arA.Length + m_arB.Length);  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,GetSESLength,The following statement contains a magic number: if (SetupFictitiousPoints (A' B)) {  	int N = m_arA.Length;  	int M = m_arB.Length;  	for (int D = 0; D <= N + M; D++) {  		for (int k = -D; k <= D; k += 2) {  			int x = GetForwardDPaths (A' B' D' k);  			int y = x - k;  			if (x >= N && y >= M) {  				return D;  			}  		}  	}  	//We should never get here if the algorithm is coded correctly.  	Debug.Assert (false);  	return -1;  }  else if (m_arA.Length == 0) {  	return m_arB.Length;  }  else {  	return m_arA.Length;  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,GetSESLength,The following statement contains a magic number: for (int D = 0; D <= N + M; D++) {  	for (int k = -D; k <= D; k += 2) {  		int x = GetForwardDPaths (A' B' D' k);  		int y = x - k;  		if (x >= N && y >= M) {  			return D;  		}  	}  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,GetSESLength,The following statement contains a magic number: for (int k = -D; k <= D; k += 2) {  	int x = GetForwardDPaths (A' B' D' k);  	int y = x - k;  	if (x >= N && y >= M) {  		return D;  	}  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,GetSESLength,The following statement contains a magic number: k += 2
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,GetReverseSESLength,The following statement contains a magic number: if (SetupFictitiousPoints (A' B)) {  	int N = m_arA.Length;  	int M = m_arB.Length;  	int iDelta = N - M;  	for (int D = 0; D <= N + M; D++) {  		for (int k = -D; k <= D; k += 2) {  			int x = GetReverseDPaths (A' B' D' k' iDelta);  			int y = x - (k + iDelta);  			if (x <= 0 && y <= 0) {  				return D;  			}  		}  	}  	//We should never get here if the algorithm is coded correctly.  	Debug.Assert (false);  	return -1;  }  else if (m_arA.Length == 0) {  	return m_arB.Length;  }  else {  	return m_arA.Length;  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,GetReverseSESLength,The following statement contains a magic number: for (int D = 0; D <= N + M; D++) {  	for (int k = -D; k <= D; k += 2) {  		int x = GetReverseDPaths (A' B' D' k' iDelta);  		int y = x - (k + iDelta);  		if (x <= 0 && y <= 0) {  			return D;  		}  	}  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,GetReverseSESLength,The following statement contains a magic number: for (int k = -D; k <= D; k += 2) {  	int x = GetReverseDPaths (A' B' D' k' iDelta);  	int y = x - (k + iDelta);  	if (x <= 0 && y <= 0) {  		return D;  	}  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,GetReverseSESLength,The following statement contains a magic number: k += 2
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: for (int D = 0; D <= iCeiling; D++) {  	for (int k = -D; k <= D; k += 2) {  		//Find the end of the furthest reaching forward D-path in diagonal k.  		GetForwardDPaths (A' B' D' k);  		//If iDelta is odd (i.e. remainder == 1 or -1) and ...  		if ((iDelta % 2 != 0) && (k >= (iDelta - (D - 1)) && k <= (iDelta + (D - 1)))) {  			//If the path overlaps the furthest reaching reverse (D-1)-path in diagonal k.  			if (m_vecForward [k] >= m_vecReverse [k]) {  				//The last snake of the forward path is the middle snake.  				iPathK = k;  				iPathEndX = m_vecForward [k];  				iPathStartX = iPathEndX;  				int iPathStartY = iPathStartX - iPathK;  				while (iPathStartX > 0 && iPathStartY > 0 && A [iPathStartX] == B [iPathStartY]) {  					iPathStartX--;  					iPathStartY--;  				}  				//Length of an SES is 2D-1.  				return 2 * D - 1;  			}  		}  	}  	for (int k = -D; k <= D; k += 2) {  		//Find the end of the furthest reaching reverse D=path in diagonal k+iDelta  		GetReverseDPaths (A' B' D' k' iDelta);  		//If iDelta is even and ...  		if ((iDelta % 2 == 0) && ((k + iDelta) >= -D && (k + iDelta) <= D)) {  			//If the path overlaps the furthest reaching forward D-path in diagonal k+iDelta.  			if (m_vecReverse [k + iDelta] <= m_vecForward [k + iDelta]) {  				//The last snake of the reverse path is the middle snake.  				iPathK = k + iDelta;  				iPathStartX = m_vecReverse [iPathK];  				iPathEndX = iPathStartX;  				int iPathEndY = iPathEndX - iPathK;  				while (iPathEndX < A.Length && iPathEndY < B.Length && A [iPathEndX + 1] == B [iPathEndY + 1]) {  					iPathEndX++;  					iPathEndY++;  				}  				//Length of an SES is 2D.  				return 2 * D;  			}  		}  	}  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: for (int D = 0; D <= iCeiling; D++) {  	for (int k = -D; k <= D; k += 2) {  		//Find the end of the furthest reaching forward D-path in diagonal k.  		GetForwardDPaths (A' B' D' k);  		//If iDelta is odd (i.e. remainder == 1 or -1) and ...  		if ((iDelta % 2 != 0) && (k >= (iDelta - (D - 1)) && k <= (iDelta + (D - 1)))) {  			//If the path overlaps the furthest reaching reverse (D-1)-path in diagonal k.  			if (m_vecForward [k] >= m_vecReverse [k]) {  				//The last snake of the forward path is the middle snake.  				iPathK = k;  				iPathEndX = m_vecForward [k];  				iPathStartX = iPathEndX;  				int iPathStartY = iPathStartX - iPathK;  				while (iPathStartX > 0 && iPathStartY > 0 && A [iPathStartX] == B [iPathStartY]) {  					iPathStartX--;  					iPathStartY--;  				}  				//Length of an SES is 2D-1.  				return 2 * D - 1;  			}  		}  	}  	for (int k = -D; k <= D; k += 2) {  		//Find the end of the furthest reaching reverse D=path in diagonal k+iDelta  		GetReverseDPaths (A' B' D' k' iDelta);  		//If iDelta is even and ...  		if ((iDelta % 2 == 0) && ((k + iDelta) >= -D && (k + iDelta) <= D)) {  			//If the path overlaps the furthest reaching forward D-path in diagonal k+iDelta.  			if (m_vecReverse [k + iDelta] <= m_vecForward [k + iDelta]) {  				//The last snake of the reverse path is the middle snake.  				iPathK = k + iDelta;  				iPathStartX = m_vecReverse [iPathK];  				iPathEndX = iPathStartX;  				int iPathEndY = iPathEndX - iPathK;  				while (iPathEndX < A.Length && iPathEndY < B.Length && A [iPathEndX + 1] == B [iPathEndY + 1]) {  					iPathEndX++;  					iPathEndY++;  				}  				//Length of an SES is 2D.  				return 2 * D;  			}  		}  	}  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: for (int D = 0; D <= iCeiling; D++) {  	for (int k = -D; k <= D; k += 2) {  		//Find the end of the furthest reaching forward D-path in diagonal k.  		GetForwardDPaths (A' B' D' k);  		//If iDelta is odd (i.e. remainder == 1 or -1) and ...  		if ((iDelta % 2 != 0) && (k >= (iDelta - (D - 1)) && k <= (iDelta + (D - 1)))) {  			//If the path overlaps the furthest reaching reverse (D-1)-path in diagonal k.  			if (m_vecForward [k] >= m_vecReverse [k]) {  				//The last snake of the forward path is the middle snake.  				iPathK = k;  				iPathEndX = m_vecForward [k];  				iPathStartX = iPathEndX;  				int iPathStartY = iPathStartX - iPathK;  				while (iPathStartX > 0 && iPathStartY > 0 && A [iPathStartX] == B [iPathStartY]) {  					iPathStartX--;  					iPathStartY--;  				}  				//Length of an SES is 2D-1.  				return 2 * D - 1;  			}  		}  	}  	for (int k = -D; k <= D; k += 2) {  		//Find the end of the furthest reaching reverse D=path in diagonal k+iDelta  		GetReverseDPaths (A' B' D' k' iDelta);  		//If iDelta is even and ...  		if ((iDelta % 2 == 0) && ((k + iDelta) >= -D && (k + iDelta) <= D)) {  			//If the path overlaps the furthest reaching forward D-path in diagonal k+iDelta.  			if (m_vecReverse [k + iDelta] <= m_vecForward [k + iDelta]) {  				//The last snake of the reverse path is the middle snake.  				iPathK = k + iDelta;  				iPathStartX = m_vecReverse [iPathK];  				iPathEndX = iPathStartX;  				int iPathEndY = iPathEndX - iPathK;  				while (iPathEndX < A.Length && iPathEndY < B.Length && A [iPathEndX + 1] == B [iPathEndY + 1]) {  					iPathEndX++;  					iPathEndY++;  				}  				//Length of an SES is 2D.  				return 2 * D;  			}  		}  	}  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: for (int D = 0; D <= iCeiling; D++) {  	for (int k = -D; k <= D; k += 2) {  		//Find the end of the furthest reaching forward D-path in diagonal k.  		GetForwardDPaths (A' B' D' k);  		//If iDelta is odd (i.e. remainder == 1 or -1) and ...  		if ((iDelta % 2 != 0) && (k >= (iDelta - (D - 1)) && k <= (iDelta + (D - 1)))) {  			//If the path overlaps the furthest reaching reverse (D-1)-path in diagonal k.  			if (m_vecForward [k] >= m_vecReverse [k]) {  				//The last snake of the forward path is the middle snake.  				iPathK = k;  				iPathEndX = m_vecForward [k];  				iPathStartX = iPathEndX;  				int iPathStartY = iPathStartX - iPathK;  				while (iPathStartX > 0 && iPathStartY > 0 && A [iPathStartX] == B [iPathStartY]) {  					iPathStartX--;  					iPathStartY--;  				}  				//Length of an SES is 2D-1.  				return 2 * D - 1;  			}  		}  	}  	for (int k = -D; k <= D; k += 2) {  		//Find the end of the furthest reaching reverse D=path in diagonal k+iDelta  		GetReverseDPaths (A' B' D' k' iDelta);  		//If iDelta is even and ...  		if ((iDelta % 2 == 0) && ((k + iDelta) >= -D && (k + iDelta) <= D)) {  			//If the path overlaps the furthest reaching forward D-path in diagonal k+iDelta.  			if (m_vecReverse [k + iDelta] <= m_vecForward [k + iDelta]) {  				//The last snake of the reverse path is the middle snake.  				iPathK = k + iDelta;  				iPathStartX = m_vecReverse [iPathK];  				iPathEndX = iPathStartX;  				int iPathEndY = iPathEndX - iPathK;  				while (iPathEndX < A.Length && iPathEndY < B.Length && A [iPathEndX + 1] == B [iPathEndY + 1]) {  					iPathEndX++;  					iPathEndY++;  				}  				//Length of an SES is 2D.  				return 2 * D;  			}  		}  	}  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: for (int D = 0; D <= iCeiling; D++) {  	for (int k = -D; k <= D; k += 2) {  		//Find the end of the furthest reaching forward D-path in diagonal k.  		GetForwardDPaths (A' B' D' k);  		//If iDelta is odd (i.e. remainder == 1 or -1) and ...  		if ((iDelta % 2 != 0) && (k >= (iDelta - (D - 1)) && k <= (iDelta + (D - 1)))) {  			//If the path overlaps the furthest reaching reverse (D-1)-path in diagonal k.  			if (m_vecForward [k] >= m_vecReverse [k]) {  				//The last snake of the forward path is the middle snake.  				iPathK = k;  				iPathEndX = m_vecForward [k];  				iPathStartX = iPathEndX;  				int iPathStartY = iPathStartX - iPathK;  				while (iPathStartX > 0 && iPathStartY > 0 && A [iPathStartX] == B [iPathStartY]) {  					iPathStartX--;  					iPathStartY--;  				}  				//Length of an SES is 2D-1.  				return 2 * D - 1;  			}  		}  	}  	for (int k = -D; k <= D; k += 2) {  		//Find the end of the furthest reaching reverse D=path in diagonal k+iDelta  		GetReverseDPaths (A' B' D' k' iDelta);  		//If iDelta is even and ...  		if ((iDelta % 2 == 0) && ((k + iDelta) >= -D && (k + iDelta) <= D)) {  			//If the path overlaps the furthest reaching forward D-path in diagonal k+iDelta.  			if (m_vecReverse [k + iDelta] <= m_vecForward [k + iDelta]) {  				//The last snake of the reverse path is the middle snake.  				iPathK = k + iDelta;  				iPathStartX = m_vecReverse [iPathK];  				iPathEndX = iPathStartX;  				int iPathEndY = iPathEndX - iPathK;  				while (iPathEndX < A.Length && iPathEndY < B.Length && A [iPathEndX + 1] == B [iPathEndY + 1]) {  					iPathEndX++;  					iPathEndY++;  				}  				//Length of an SES is 2D.  				return 2 * D;  			}  		}  	}  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: for (int D = 0; D <= iCeiling; D++) {  	for (int k = -D; k <= D; k += 2) {  		//Find the end of the furthest reaching forward D-path in diagonal k.  		GetForwardDPaths (A' B' D' k);  		//If iDelta is odd (i.e. remainder == 1 or -1) and ...  		if ((iDelta % 2 != 0) && (k >= (iDelta - (D - 1)) && k <= (iDelta + (D - 1)))) {  			//If the path overlaps the furthest reaching reverse (D-1)-path in diagonal k.  			if (m_vecForward [k] >= m_vecReverse [k]) {  				//The last snake of the forward path is the middle snake.  				iPathK = k;  				iPathEndX = m_vecForward [k];  				iPathStartX = iPathEndX;  				int iPathStartY = iPathStartX - iPathK;  				while (iPathStartX > 0 && iPathStartY > 0 && A [iPathStartX] == B [iPathStartY]) {  					iPathStartX--;  					iPathStartY--;  				}  				//Length of an SES is 2D-1.  				return 2 * D - 1;  			}  		}  	}  	for (int k = -D; k <= D; k += 2) {  		//Find the end of the furthest reaching reverse D=path in diagonal k+iDelta  		GetReverseDPaths (A' B' D' k' iDelta);  		//If iDelta is even and ...  		if ((iDelta % 2 == 0) && ((k + iDelta) >= -D && (k + iDelta) <= D)) {  			//If the path overlaps the furthest reaching forward D-path in diagonal k+iDelta.  			if (m_vecReverse [k + iDelta] <= m_vecForward [k + iDelta]) {  				//The last snake of the reverse path is the middle snake.  				iPathK = k + iDelta;  				iPathStartX = m_vecReverse [iPathK];  				iPathEndX = iPathStartX;  				int iPathEndY = iPathEndX - iPathK;  				while (iPathEndX < A.Length && iPathEndY < B.Length && A [iPathEndX + 1] == B [iPathEndY + 1]) {  					iPathEndX++;  					iPathEndY++;  				}  				//Length of an SES is 2D.  				return 2 * D;  			}  		}  	}  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: for (int k = -D; k <= D; k += 2) {  	//Find the end of the furthest reaching forward D-path in diagonal k.  	GetForwardDPaths (A' B' D' k);  	//If iDelta is odd (i.e. remainder == 1 or -1) and ...  	if ((iDelta % 2 != 0) && (k >= (iDelta - (D - 1)) && k <= (iDelta + (D - 1)))) {  		//If the path overlaps the furthest reaching reverse (D-1)-path in diagonal k.  		if (m_vecForward [k] >= m_vecReverse [k]) {  			//The last snake of the forward path is the middle snake.  			iPathK = k;  			iPathEndX = m_vecForward [k];  			iPathStartX = iPathEndX;  			int iPathStartY = iPathStartX - iPathK;  			while (iPathStartX > 0 && iPathStartY > 0 && A [iPathStartX] == B [iPathStartY]) {  				iPathStartX--;  				iPathStartY--;  			}  			//Length of an SES is 2D-1.  			return 2 * D - 1;  		}  	}  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: for (int k = -D; k <= D; k += 2) {  	//Find the end of the furthest reaching forward D-path in diagonal k.  	GetForwardDPaths (A' B' D' k);  	//If iDelta is odd (i.e. remainder == 1 or -1) and ...  	if ((iDelta % 2 != 0) && (k >= (iDelta - (D - 1)) && k <= (iDelta + (D - 1)))) {  		//If the path overlaps the furthest reaching reverse (D-1)-path in diagonal k.  		if (m_vecForward [k] >= m_vecReverse [k]) {  			//The last snake of the forward path is the middle snake.  			iPathK = k;  			iPathEndX = m_vecForward [k];  			iPathStartX = iPathEndX;  			int iPathStartY = iPathStartX - iPathK;  			while (iPathStartX > 0 && iPathStartY > 0 && A [iPathStartX] == B [iPathStartY]) {  				iPathStartX--;  				iPathStartY--;  			}  			//Length of an SES is 2D-1.  			return 2 * D - 1;  		}  	}  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: for (int k = -D; k <= D; k += 2) {  	//Find the end of the furthest reaching forward D-path in diagonal k.  	GetForwardDPaths (A' B' D' k);  	//If iDelta is odd (i.e. remainder == 1 or -1) and ...  	if ((iDelta % 2 != 0) && (k >= (iDelta - (D - 1)) && k <= (iDelta + (D - 1)))) {  		//If the path overlaps the furthest reaching reverse (D-1)-path in diagonal k.  		if (m_vecForward [k] >= m_vecReverse [k]) {  			//The last snake of the forward path is the middle snake.  			iPathK = k;  			iPathEndX = m_vecForward [k];  			iPathStartX = iPathEndX;  			int iPathStartY = iPathStartX - iPathK;  			while (iPathStartX > 0 && iPathStartY > 0 && A [iPathStartX] == B [iPathStartY]) {  				iPathStartX--;  				iPathStartY--;  			}  			//Length of an SES is 2D-1.  			return 2 * D - 1;  		}  	}  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: k += 2
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: if ((iDelta % 2 != 0) && (k >= (iDelta - (D - 1)) && k <= (iDelta + (D - 1)))) {  	//If the path overlaps the furthest reaching reverse (D-1)-path in diagonal k.  	if (m_vecForward [k] >= m_vecReverse [k]) {  		//The last snake of the forward path is the middle snake.  		iPathK = k;  		iPathEndX = m_vecForward [k];  		iPathStartX = iPathEndX;  		int iPathStartY = iPathStartX - iPathK;  		while (iPathStartX > 0 && iPathStartY > 0 && A [iPathStartX] == B [iPathStartY]) {  			iPathStartX--;  			iPathStartY--;  		}  		//Length of an SES is 2D-1.  		return 2 * D - 1;  	}  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: if ((iDelta % 2 != 0) && (k >= (iDelta - (D - 1)) && k <= (iDelta + (D - 1)))) {  	//If the path overlaps the furthest reaching reverse (D-1)-path in diagonal k.  	if (m_vecForward [k] >= m_vecReverse [k]) {  		//The last snake of the forward path is the middle snake.  		iPathK = k;  		iPathEndX = m_vecForward [k];  		iPathStartX = iPathEndX;  		int iPathStartY = iPathStartX - iPathK;  		while (iPathStartX > 0 && iPathStartY > 0 && A [iPathStartX] == B [iPathStartY]) {  			iPathStartX--;  			iPathStartY--;  		}  		//Length of an SES is 2D-1.  		return 2 * D - 1;  	}  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: if (m_vecForward [k] >= m_vecReverse [k]) {  	//The last snake of the forward path is the middle snake.  	iPathK = k;  	iPathEndX = m_vecForward [k];  	iPathStartX = iPathEndX;  	int iPathStartY = iPathStartX - iPathK;  	while (iPathStartX > 0 && iPathStartY > 0 && A [iPathStartX] == B [iPathStartY]) {  		iPathStartX--;  		iPathStartY--;  	}  	//Length of an SES is 2D-1.  	return 2 * D - 1;  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: return 2 * D - 1;  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: for (int k = -D; k <= D; k += 2) {  	//Find the end of the furthest reaching reverse D=path in diagonal k+iDelta  	GetReverseDPaths (A' B' D' k' iDelta);  	//If iDelta is even and ...  	if ((iDelta % 2 == 0) && ((k + iDelta) >= -D && (k + iDelta) <= D)) {  		//If the path overlaps the furthest reaching forward D-path in diagonal k+iDelta.  		if (m_vecReverse [k + iDelta] <= m_vecForward [k + iDelta]) {  			//The last snake of the reverse path is the middle snake.  			iPathK = k + iDelta;  			iPathStartX = m_vecReverse [iPathK];  			iPathEndX = iPathStartX;  			int iPathEndY = iPathEndX - iPathK;  			while (iPathEndX < A.Length && iPathEndY < B.Length && A [iPathEndX + 1] == B [iPathEndY + 1]) {  				iPathEndX++;  				iPathEndY++;  			}  			//Length of an SES is 2D.  			return 2 * D;  		}  	}  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: for (int k = -D; k <= D; k += 2) {  	//Find the end of the furthest reaching reverse D=path in diagonal k+iDelta  	GetReverseDPaths (A' B' D' k' iDelta);  	//If iDelta is even and ...  	if ((iDelta % 2 == 0) && ((k + iDelta) >= -D && (k + iDelta) <= D)) {  		//If the path overlaps the furthest reaching forward D-path in diagonal k+iDelta.  		if (m_vecReverse [k + iDelta] <= m_vecForward [k + iDelta]) {  			//The last snake of the reverse path is the middle snake.  			iPathK = k + iDelta;  			iPathStartX = m_vecReverse [iPathK];  			iPathEndX = iPathStartX;  			int iPathEndY = iPathEndX - iPathK;  			while (iPathEndX < A.Length && iPathEndY < B.Length && A [iPathEndX + 1] == B [iPathEndY + 1]) {  				iPathEndX++;  				iPathEndY++;  			}  			//Length of an SES is 2D.  			return 2 * D;  		}  	}  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: for (int k = -D; k <= D; k += 2) {  	//Find the end of the furthest reaching reverse D=path in diagonal k+iDelta  	GetReverseDPaths (A' B' D' k' iDelta);  	//If iDelta is even and ...  	if ((iDelta % 2 == 0) && ((k + iDelta) >= -D && (k + iDelta) <= D)) {  		//If the path overlaps the furthest reaching forward D-path in diagonal k+iDelta.  		if (m_vecReverse [k + iDelta] <= m_vecForward [k + iDelta]) {  			//The last snake of the reverse path is the middle snake.  			iPathK = k + iDelta;  			iPathStartX = m_vecReverse [iPathK];  			iPathEndX = iPathStartX;  			int iPathEndY = iPathEndX - iPathK;  			while (iPathEndX < A.Length && iPathEndY < B.Length && A [iPathEndX + 1] == B [iPathEndY + 1]) {  				iPathEndX++;  				iPathEndY++;  			}  			//Length of an SES is 2D.  			return 2 * D;  		}  	}  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: k += 2
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: if ((iDelta % 2 == 0) && ((k + iDelta) >= -D && (k + iDelta) <= D)) {  	//If the path overlaps the furthest reaching forward D-path in diagonal k+iDelta.  	if (m_vecReverse [k + iDelta] <= m_vecForward [k + iDelta]) {  		//The last snake of the reverse path is the middle snake.  		iPathK = k + iDelta;  		iPathStartX = m_vecReverse [iPathK];  		iPathEndX = iPathStartX;  		int iPathEndY = iPathEndX - iPathK;  		while (iPathEndX < A.Length && iPathEndY < B.Length && A [iPathEndX + 1] == B [iPathEndY + 1]) {  			iPathEndX++;  			iPathEndY++;  		}  		//Length of an SES is 2D.  		return 2 * D;  	}  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: if ((iDelta % 2 == 0) && ((k + iDelta) >= -D && (k + iDelta) <= D)) {  	//If the path overlaps the furthest reaching forward D-path in diagonal k+iDelta.  	if (m_vecReverse [k + iDelta] <= m_vecForward [k + iDelta]) {  		//The last snake of the reverse path is the middle snake.  		iPathK = k + iDelta;  		iPathStartX = m_vecReverse [iPathK];  		iPathEndX = iPathStartX;  		int iPathEndY = iPathEndX - iPathK;  		while (iPathEndX < A.Length && iPathEndY < B.Length && A [iPathEndX + 1] == B [iPathEndY + 1]) {  			iPathEndX++;  			iPathEndY++;  		}  		//Length of an SES is 2D.  		return 2 * D;  	}  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: if (m_vecReverse [k + iDelta] <= m_vecForward [k + iDelta]) {  	//The last snake of the reverse path is the middle snake.  	iPathK = k + iDelta;  	iPathStartX = m_vecReverse [iPathK];  	iPathEndX = iPathStartX;  	int iPathEndY = iPathEndX - iPathK;  	while (iPathEndX < A.Length && iPathEndY < B.Length && A [iPathEndX + 1] == B [iPathEndY + 1]) {  		iPathEndX++;  		iPathEndY++;  	}  	//Length of an SES is 2D.  	return 2 * D;  }  
Magic Number,Ankh.Diff.DiffUtils,MyersDiff,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\MyersDiff.cs,FindMiddleSnake,The following statement contains a magic number: return 2 * D;  
Magic Number,Ankh.Diff.DiffUtils,StringHasher,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\StringHasher.cs,GetCRC32,The following statement contains a magic number: for (int i = 0; i < iNumBytes; i++) {  	uiResult = (uiResult >> 8) ^ c_arCRC32 [arBytes [i] ^ (uiResult & 0xFF)];  }  
Magic Number,Ankh.Diff.DiffUtils,StringHasher,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\StringHasher.cs,GetCRC32,The following statement contains a magic number: uiResult = (uiResult >> 8) ^ c_arCRC32 [arBytes [i] ^ (uiResult & 0xFF)];  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffControl,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffControl.cs,PaintColorLegendItem,The following statement contains a magic number: if (Item != null) {  	//Make our outermost painting rect a little smaller.  	Rectangle R = e.ClipRectangle;  	R.Inflate (-1' -1);  	//Paint the background.  	Graphics G = e.Graphics;  	using (Brush B = new SolidBrush (Item.BackColor)) {  		G.FillRectangle (B' R);  	}  	//Draw a border.  	Rectangle BorderRect = new Rectangle (R.X' R.Y' R.Width - 1' R.Height - 1);  	ControlPaint.DrawVisualStyleBorder (G' BorderRect);  	//Draw the image centered.  (I should probably check the  	//item's ImageAlign property here' but I know I'm always  	//using MiddleCenter for all the passed-in items.)  	Image I = Item.Image;  	Rectangle ImageRect = new Rectangle (R.X + (R.Width - I.Width) / 2' R.Y + (R.Height - I.Height) / 2' I.Width' I.Height);  	G.DrawImage (I' ImageRect);  }  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffControl,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffControl.cs,PaintColorLegendItem,The following statement contains a magic number: if (Item != null) {  	//Make our outermost painting rect a little smaller.  	Rectangle R = e.ClipRectangle;  	R.Inflate (-1' -1);  	//Paint the background.  	Graphics G = e.Graphics;  	using (Brush B = new SolidBrush (Item.BackColor)) {  		G.FillRectangle (B' R);  	}  	//Draw a border.  	Rectangle BorderRect = new Rectangle (R.X' R.Y' R.Width - 1' R.Height - 1);  	ControlPaint.DrawVisualStyleBorder (G' BorderRect);  	//Draw the image centered.  (I should probably check the  	//item's ImageAlign property here' but I know I'm always  	//using MiddleCenter for all the passed-in items.)  	Image I = Item.Image;  	Rectangle ImageRect = new Rectangle (R.X + (R.Width - I.Width) / 2' R.Y + (R.Height - I.Height) / 2' I.Width' I.Height);  	G.DrawImage (I' ImageRect);  }  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffControl,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffControl.cs,DiffControl_SizeChanged,The following statement contains a magic number: pnlLeft.Width = (Width - pnlLeft.Left - MiddleSplitter.Width) / 2;  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffOverview,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffOverview.cs,OnPaint,The following statement contains a magic number: if (m_Image != null) {  	Rectangle R = e.ClipRectangle;  	G.DrawImage (m_Image' R.X' R.Y' R' GraphicsUnit.Pixel);  	//Repaint the view window if any of it is invalid  	if (R.IntersectsWith (m_ViewRect)) {  		bool bDisposePen = false;  		Pen P = SystemPens.Highlight;  		Rectangle rPen;  		if (UseTranslucentView) {  			//Set the alpha blend to 20% (51/256);  			SolidBrush B = new SolidBrush (Color.FromArgb (51' SystemColors.Highlight));  			R.Intersect (m_ViewRect);  			G.FillRectangle (B' R);  			B.Dispose ();  			//Draw the pen border with view rect.  			rPen = m_ViewRect;  		}  		else {  			//Create a two pixel wide highlight pen.  			P = new Pen (SystemColors.Highlight' 2);  			bDisposePen = true;  			//Because the lines will go back up a pixel  			//we have to shrink the bounds of the rect.  			rPen = new Rectangle (m_ViewRect.X + 1' m_ViewRect.Y + 1' m_ViewRect.Width - 1' m_ViewRect.Height - 1);  		}  		//Draw a Highlight Pen border.  In some cases' it will  		//draw a pixel too far (because we always round up)' so  		//we'll check for that case here.  If we're scrolled to  		//the bottom' I don't want the last line cut off.  		int iViewHeight = rPen.Height - 1;  		int iUsableHeight = ClientSize.Height - rPen.Y - 1;  		int iHeight = Math.Min (iViewHeight' iUsableHeight);  		G.DrawRectangle (P' rPen.X' rPen.Y' rPen.Width - 1' iHeight);  		if (bDisposePen) {  			P.Dispose ();  		}  	}  }  else {  	G.FillRectangle (SystemBrushes.Control' ClientRectangle);  }  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffOverview,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffOverview.cs,OnPaint,The following statement contains a magic number: if (m_Image != null) {  	Rectangle R = e.ClipRectangle;  	G.DrawImage (m_Image' R.X' R.Y' R' GraphicsUnit.Pixel);  	//Repaint the view window if any of it is invalid  	if (R.IntersectsWith (m_ViewRect)) {  		bool bDisposePen = false;  		Pen P = SystemPens.Highlight;  		Rectangle rPen;  		if (UseTranslucentView) {  			//Set the alpha blend to 20% (51/256);  			SolidBrush B = new SolidBrush (Color.FromArgb (51' SystemColors.Highlight));  			R.Intersect (m_ViewRect);  			G.FillRectangle (B' R);  			B.Dispose ();  			//Draw the pen border with view rect.  			rPen = m_ViewRect;  		}  		else {  			//Create a two pixel wide highlight pen.  			P = new Pen (SystemColors.Highlight' 2);  			bDisposePen = true;  			//Because the lines will go back up a pixel  			//we have to shrink the bounds of the rect.  			rPen = new Rectangle (m_ViewRect.X + 1' m_ViewRect.Y + 1' m_ViewRect.Width - 1' m_ViewRect.Height - 1);  		}  		//Draw a Highlight Pen border.  In some cases' it will  		//draw a pixel too far (because we always round up)' so  		//we'll check for that case here.  If we're scrolled to  		//the bottom' I don't want the last line cut off.  		int iViewHeight = rPen.Height - 1;  		int iUsableHeight = ClientSize.Height - rPen.Y - 1;  		int iHeight = Math.Min (iViewHeight' iUsableHeight);  		G.DrawRectangle (P' rPen.X' rPen.Y' rPen.Width - 1' iHeight);  		if (bDisposePen) {  			P.Dispose ();  		}  	}  }  else {  	G.FillRectangle (SystemBrushes.Control' ClientRectangle);  }  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffOverview,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffOverview.cs,OnPaint,The following statement contains a magic number: if (R.IntersectsWith (m_ViewRect)) {  	bool bDisposePen = false;  	Pen P = SystemPens.Highlight;  	Rectangle rPen;  	if (UseTranslucentView) {  		//Set the alpha blend to 20% (51/256);  		SolidBrush B = new SolidBrush (Color.FromArgb (51' SystemColors.Highlight));  		R.Intersect (m_ViewRect);  		G.FillRectangle (B' R);  		B.Dispose ();  		//Draw the pen border with view rect.  		rPen = m_ViewRect;  	}  	else {  		//Create a two pixel wide highlight pen.  		P = new Pen (SystemColors.Highlight' 2);  		bDisposePen = true;  		//Because the lines will go back up a pixel  		//we have to shrink the bounds of the rect.  		rPen = new Rectangle (m_ViewRect.X + 1' m_ViewRect.Y + 1' m_ViewRect.Width - 1' m_ViewRect.Height - 1);  	}  	//Draw a Highlight Pen border.  In some cases' it will  	//draw a pixel too far (because we always round up)' so  	//we'll check for that case here.  If we're scrolled to  	//the bottom' I don't want the last line cut off.  	int iViewHeight = rPen.Height - 1;  	int iUsableHeight = ClientSize.Height - rPen.Y - 1;  	int iHeight = Math.Min (iViewHeight' iUsableHeight);  	G.DrawRectangle (P' rPen.X' rPen.Y' rPen.Width - 1' iHeight);  	if (bDisposePen) {  		P.Dispose ();  	}  }  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffOverview,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffOverview.cs,OnPaint,The following statement contains a magic number: if (R.IntersectsWith (m_ViewRect)) {  	bool bDisposePen = false;  	Pen P = SystemPens.Highlight;  	Rectangle rPen;  	if (UseTranslucentView) {  		//Set the alpha blend to 20% (51/256);  		SolidBrush B = new SolidBrush (Color.FromArgb (51' SystemColors.Highlight));  		R.Intersect (m_ViewRect);  		G.FillRectangle (B' R);  		B.Dispose ();  		//Draw the pen border with view rect.  		rPen = m_ViewRect;  	}  	else {  		//Create a two pixel wide highlight pen.  		P = new Pen (SystemColors.Highlight' 2);  		bDisposePen = true;  		//Because the lines will go back up a pixel  		//we have to shrink the bounds of the rect.  		rPen = new Rectangle (m_ViewRect.X + 1' m_ViewRect.Y + 1' m_ViewRect.Width - 1' m_ViewRect.Height - 1);  	}  	//Draw a Highlight Pen border.  In some cases' it will  	//draw a pixel too far (because we always round up)' so  	//we'll check for that case here.  If we're scrolled to  	//the bottom' I don't want the last line cut off.  	int iViewHeight = rPen.Height - 1;  	int iUsableHeight = ClientSize.Height - rPen.Y - 1;  	int iHeight = Math.Min (iViewHeight' iUsableHeight);  	G.DrawRectangle (P' rPen.X' rPen.Y' rPen.Width - 1' iHeight);  	if (bDisposePen) {  		P.Dispose ();  	}  }  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffOverview,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffOverview.cs,OnPaint,The following statement contains a magic number: if (UseTranslucentView) {  	//Set the alpha blend to 20% (51/256);  	SolidBrush B = new SolidBrush (Color.FromArgb (51' SystemColors.Highlight));  	R.Intersect (m_ViewRect);  	G.FillRectangle (B' R);  	B.Dispose ();  	//Draw the pen border with view rect.  	rPen = m_ViewRect;  }  else {  	//Create a two pixel wide highlight pen.  	P = new Pen (SystemColors.Highlight' 2);  	bDisposePen = true;  	//Because the lines will go back up a pixel  	//we have to shrink the bounds of the rect.  	rPen = new Rectangle (m_ViewRect.X + 1' m_ViewRect.Y + 1' m_ViewRect.Width - 1' m_ViewRect.Height - 1);  }  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffOverview,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffOverview.cs,OnPaint,The following statement contains a magic number: if (UseTranslucentView) {  	//Set the alpha blend to 20% (51/256);  	SolidBrush B = new SolidBrush (Color.FromArgb (51' SystemColors.Highlight));  	R.Intersect (m_ViewRect);  	G.FillRectangle (B' R);  	B.Dispose ();  	//Draw the pen border with view rect.  	rPen = m_ViewRect;  }  else {  	//Create a two pixel wide highlight pen.  	P = new Pen (SystemColors.Highlight' 2);  	bDisposePen = true;  	//Because the lines will go back up a pixel  	//we have to shrink the bounds of the rect.  	rPen = new Rectangle (m_ViewRect.X + 1' m_ViewRect.Y + 1' m_ViewRect.Width - 1' m_ViewRect.Height - 1);  }  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffOverview,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffOverview.cs,OnPaint,The following statement contains a magic number: P = new Pen (SystemColors.Highlight' 2);  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffOverview,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffOverview.cs,RenderImage,The following statement contains a magic number: if (iWidth > 0 && iHeight > 0 && m_View != null && m_View.Lines != null) {  	//Draw a bitmap in memory that we can render from  	m_Image = new Bitmap (iWidth' iHeight);  	Graphics G = Graphics.FromImage (m_Image);  	SolidBrush B = new SolidBrush (BackColor);  	G.FillRectangle (B' 0' 0' iWidth' iHeight);  	const float c_fGutter = 2.0F;  	//Make sure each line is at least 1 pixel high  	float fLineHeight = (float)Math.Max (1.0' GetPixelLineHeightF (1));  	DiffViewLines Lines = m_View.Lines;  	int iNumLines = Lines.Count;  	for (int i = 0; i < iNumLines; i++) {  		DiffViewLine L = Lines [i];  		if (L.Edited) {  			B.Color = DiffOptions.GetColorForEditType (L.EditType);  			float fY = GetPixelLineHeightF (i);  			G.FillRectangle (B' c_fGutter' fY' iWidth - 2 * c_fGutter' fLineHeight);  		}  	}  	B.Dispose ();  	G.Dispose ();  }  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffOverview,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffOverview.cs,RenderImage,The following statement contains a magic number: for (int i = 0; i < iNumLines; i++) {  	DiffViewLine L = Lines [i];  	if (L.Edited) {  		B.Color = DiffOptions.GetColorForEditType (L.EditType);  		float fY = GetPixelLineHeightF (i);  		G.FillRectangle (B' c_fGutter' fY' iWidth - 2 * c_fGutter' fLineHeight);  	}  }  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffOverview,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffOverview.cs,RenderImage,The following statement contains a magic number: if (L.Edited) {  	B.Color = DiffOptions.GetColorForEditType (L.EditType);  	float fY = GetPixelLineHeightF (i);  	G.FillRectangle (B' c_fGutter' fY' iWidth - 2 * c_fGutter' fLineHeight);  }  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffOverview,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffOverview.cs,RenderImage,The following statement contains a magic number: G.FillRectangle (B' c_fGutter' fY' iWidth - 2 * c_fGutter' fLineHeight);  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,DiffView,The following statement contains a magic number: m_AutoScrollTimer.Interval = 100;  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,OnMouseWheel,The following statement contains a magic number: if (Math.Abs (m_iWheelDelta) >= 120) {  	//I'm using "-=" here because Delta is reversed from what seems normal to me.  	//(e.g. wheel scrolling towards the user returns a negative value).  	VScrollPos -= SystemInformation.MouseWheelScrollLines * (m_iWheelDelta / 120);  	m_iWheelDelta = 0;  }  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,OnMouseWheel,The following statement contains a magic number: if (Math.Abs (m_iWheelDelta) >= 120) {  	//I'm using "-=" here because Delta is reversed from what seems normal to me.  	//(e.g. wheel scrolling towards the user returns a negative value).  	VScrollPos -= SystemInformation.MouseWheelScrollLines * (m_iWheelDelta / 120);  	m_iWheelDelta = 0;  }  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,OnMouseWheel,The following statement contains a magic number: VScrollPos -= SystemInformation.MouseWheelScrollLines * (m_iWheelDelta / 120);  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,UpdateTextMetrics,The following statement contains a magic number: if (bFontOrTabsChanged) {  	//Get the pixel width that a space should be.  	Graphics G = Graphics.FromHwnd (Handle);  	//See KBase article Q125681 for what I'm doing here to get the average character width.  	m_fCharWidth = MeasureStringDisplayWidth (G' "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"' 52' Font' m_StringFormat) / 52;  	m_iCharWidth = (int)Math.Ceiling (m_fCharWidth);  	//Get the average pixels per inch  	float fDpi = (G.DpiX + G.DpiY) / 2;  	G.Dispose ();  	//Get the line height in pixels  	FontFamily FF = Font.FontFamily;  	int iLineSpacingDesignUnits = FF.GetLineSpacing (Font.Style);  	int iFontHeightDesignUnits = FF.GetEmHeight (Font.Style);  	float fFontPoints = Font.Size;  	float fFontPixels = fFontPoints * fDpi / 72;  	m_iLineHeight = (int)Math.Ceiling ((fFontPixels * iLineSpacingDesignUnits) / iFontHeightDesignUnits);  	//This height still isn't "enough" (i.e. it still doesn't match   	//what the GetTextMetrics API would return as TEXTMETRICS.Height   	//+ TEXTMETRICS.ExternalLeading.  It seems to be one pixel too  	//short' so I'll just add it back.  	m_iLineHeight++;  	//Update the string format's Tab stops  	float[] arTabStops = new float[100];  	float fTabWidth = m_fCharWidth * DiffOptions.SpacesPerTab;  	//Without Floor() then sometimes we end up with tabs that are  	//only a few pixels wide' when they should be fTabWidth wide.  	//It happens when a cumulative tab stop has enough fractional  	//portion to be more than a pixel larger than the current  	//non-whitespace string length.  This seems to work fine for  	//monospaced fonts' and tabs and spaces never line up for  	//proportional fonts anyway.  	fTabWidth = (float)Math.Floor (fTabWidth);  	for (int i = 0; i < arTabStops.Length; i++) {  		arTabStops [i] = fTabWidth;  	}  	m_StringFormat.SetTabStops (0' arTabStops);  }  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,UpdateTextMetrics,The following statement contains a magic number: if (bFontOrTabsChanged) {  	//Get the pixel width that a space should be.  	Graphics G = Graphics.FromHwnd (Handle);  	//See KBase article Q125681 for what I'm doing here to get the average character width.  	m_fCharWidth = MeasureStringDisplayWidth (G' "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"' 52' Font' m_StringFormat) / 52;  	m_iCharWidth = (int)Math.Ceiling (m_fCharWidth);  	//Get the average pixels per inch  	float fDpi = (G.DpiX + G.DpiY) / 2;  	G.Dispose ();  	//Get the line height in pixels  	FontFamily FF = Font.FontFamily;  	int iLineSpacingDesignUnits = FF.GetLineSpacing (Font.Style);  	int iFontHeightDesignUnits = FF.GetEmHeight (Font.Style);  	float fFontPoints = Font.Size;  	float fFontPixels = fFontPoints * fDpi / 72;  	m_iLineHeight = (int)Math.Ceiling ((fFontPixels * iLineSpacingDesignUnits) / iFontHeightDesignUnits);  	//This height still isn't "enough" (i.e. it still doesn't match   	//what the GetTextMetrics API would return as TEXTMETRICS.Height   	//+ TEXTMETRICS.ExternalLeading.  It seems to be one pixel too  	//short' so I'll just add it back.  	m_iLineHeight++;  	//Update the string format's Tab stops  	float[] arTabStops = new float[100];  	float fTabWidth = m_fCharWidth * DiffOptions.SpacesPerTab;  	//Without Floor() then sometimes we end up with tabs that are  	//only a few pixels wide' when they should be fTabWidth wide.  	//It happens when a cumulative tab stop has enough fractional  	//portion to be more than a pixel larger than the current  	//non-whitespace string length.  This seems to work fine for  	//monospaced fonts' and tabs and spaces never line up for  	//proportional fonts anyway.  	fTabWidth = (float)Math.Floor (fTabWidth);  	for (int i = 0; i < arTabStops.Length; i++) {  		arTabStops [i] = fTabWidth;  	}  	m_StringFormat.SetTabStops (0' arTabStops);  }  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,UpdateTextMetrics,The following statement contains a magic number: if (bFontOrTabsChanged) {  	//Get the pixel width that a space should be.  	Graphics G = Graphics.FromHwnd (Handle);  	//See KBase article Q125681 for what I'm doing here to get the average character width.  	m_fCharWidth = MeasureStringDisplayWidth (G' "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"' 52' Font' m_StringFormat) / 52;  	m_iCharWidth = (int)Math.Ceiling (m_fCharWidth);  	//Get the average pixels per inch  	float fDpi = (G.DpiX + G.DpiY) / 2;  	G.Dispose ();  	//Get the line height in pixels  	FontFamily FF = Font.FontFamily;  	int iLineSpacingDesignUnits = FF.GetLineSpacing (Font.Style);  	int iFontHeightDesignUnits = FF.GetEmHeight (Font.Style);  	float fFontPoints = Font.Size;  	float fFontPixels = fFontPoints * fDpi / 72;  	m_iLineHeight = (int)Math.Ceiling ((fFontPixels * iLineSpacingDesignUnits) / iFontHeightDesignUnits);  	//This height still isn't "enough" (i.e. it still doesn't match   	//what the GetTextMetrics API would return as TEXTMETRICS.Height   	//+ TEXTMETRICS.ExternalLeading.  It seems to be one pixel too  	//short' so I'll just add it back.  	m_iLineHeight++;  	//Update the string format's Tab stops  	float[] arTabStops = new float[100];  	float fTabWidth = m_fCharWidth * DiffOptions.SpacesPerTab;  	//Without Floor() then sometimes we end up with tabs that are  	//only a few pixels wide' when they should be fTabWidth wide.  	//It happens when a cumulative tab stop has enough fractional  	//portion to be more than a pixel larger than the current  	//non-whitespace string length.  This seems to work fine for  	//monospaced fonts' and tabs and spaces never line up for  	//proportional fonts anyway.  	fTabWidth = (float)Math.Floor (fTabWidth);  	for (int i = 0; i < arTabStops.Length; i++) {  		arTabStops [i] = fTabWidth;  	}  	m_StringFormat.SetTabStops (0' arTabStops);  }  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,UpdateTextMetrics,The following statement contains a magic number: if (bFontOrTabsChanged) {  	//Get the pixel width that a space should be.  	Graphics G = Graphics.FromHwnd (Handle);  	//See KBase article Q125681 for what I'm doing here to get the average character width.  	m_fCharWidth = MeasureStringDisplayWidth (G' "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"' 52' Font' m_StringFormat) / 52;  	m_iCharWidth = (int)Math.Ceiling (m_fCharWidth);  	//Get the average pixels per inch  	float fDpi = (G.DpiX + G.DpiY) / 2;  	G.Dispose ();  	//Get the line height in pixels  	FontFamily FF = Font.FontFamily;  	int iLineSpacingDesignUnits = FF.GetLineSpacing (Font.Style);  	int iFontHeightDesignUnits = FF.GetEmHeight (Font.Style);  	float fFontPoints = Font.Size;  	float fFontPixels = fFontPoints * fDpi / 72;  	m_iLineHeight = (int)Math.Ceiling ((fFontPixels * iLineSpacingDesignUnits) / iFontHeightDesignUnits);  	//This height still isn't "enough" (i.e. it still doesn't match   	//what the GetTextMetrics API would return as TEXTMETRICS.Height   	//+ TEXTMETRICS.ExternalLeading.  It seems to be one pixel too  	//short' so I'll just add it back.  	m_iLineHeight++;  	//Update the string format's Tab stops  	float[] arTabStops = new float[100];  	float fTabWidth = m_fCharWidth * DiffOptions.SpacesPerTab;  	//Without Floor() then sometimes we end up with tabs that are  	//only a few pixels wide' when they should be fTabWidth wide.  	//It happens when a cumulative tab stop has enough fractional  	//portion to be more than a pixel larger than the current  	//non-whitespace string length.  This seems to work fine for  	//monospaced fonts' and tabs and spaces never line up for  	//proportional fonts anyway.  	fTabWidth = (float)Math.Floor (fTabWidth);  	for (int i = 0; i < arTabStops.Length; i++) {  		arTabStops [i] = fTabWidth;  	}  	m_StringFormat.SetTabStops (0' arTabStops);  }  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,UpdateTextMetrics,The following statement contains a magic number: if (bFontOrTabsChanged) {  	//Get the pixel width that a space should be.  	Graphics G = Graphics.FromHwnd (Handle);  	//See KBase article Q125681 for what I'm doing here to get the average character width.  	m_fCharWidth = MeasureStringDisplayWidth (G' "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"' 52' Font' m_StringFormat) / 52;  	m_iCharWidth = (int)Math.Ceiling (m_fCharWidth);  	//Get the average pixels per inch  	float fDpi = (G.DpiX + G.DpiY) / 2;  	G.Dispose ();  	//Get the line height in pixels  	FontFamily FF = Font.FontFamily;  	int iLineSpacingDesignUnits = FF.GetLineSpacing (Font.Style);  	int iFontHeightDesignUnits = FF.GetEmHeight (Font.Style);  	float fFontPoints = Font.Size;  	float fFontPixels = fFontPoints * fDpi / 72;  	m_iLineHeight = (int)Math.Ceiling ((fFontPixels * iLineSpacingDesignUnits) / iFontHeightDesignUnits);  	//This height still isn't "enough" (i.e. it still doesn't match   	//what the GetTextMetrics API would return as TEXTMETRICS.Height   	//+ TEXTMETRICS.ExternalLeading.  It seems to be one pixel too  	//short' so I'll just add it back.  	m_iLineHeight++;  	//Update the string format's Tab stops  	float[] arTabStops = new float[100];  	float fTabWidth = m_fCharWidth * DiffOptions.SpacesPerTab;  	//Without Floor() then sometimes we end up with tabs that are  	//only a few pixels wide' when they should be fTabWidth wide.  	//It happens when a cumulative tab stop has enough fractional  	//portion to be more than a pixel larger than the current  	//non-whitespace string length.  This seems to work fine for  	//monospaced fonts' and tabs and spaces never line up for  	//proportional fonts anyway.  	fTabWidth = (float)Math.Floor (fTabWidth);  	for (int i = 0; i < arTabStops.Length; i++) {  		arTabStops [i] = fTabWidth;  	}  	m_StringFormat.SetTabStops (0' arTabStops);  }  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,UpdateTextMetrics,The following statement contains a magic number: m_fCharWidth = MeasureStringDisplayWidth (G' "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"' 52' Font' m_StringFormat) / 52;  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,UpdateTextMetrics,The following statement contains a magic number: m_fCharWidth = MeasureStringDisplayWidth (G' "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"' 52' Font' m_StringFormat) / 52;  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,MeasureStringDisplayWidth,The following statement contains a magic number: if (iLength > 0) {  	StringFormat NewFmt = new StringFormat (Fmt);  	NewFmt.FormatFlags = StringFormatFlags.MeasureTrailingSpaces;  	RectangleF R = new RectangleF (0' 0' 1000000' 1000000);  	CharacterRange[] arRanges =  {  		new CharacterRange (0' iLength)  	};  	NewFmt.SetMeasurableCharacterRanges (arRanges);  	Region[] arRegions = G.MeasureCharacterRanges (strText' Font' R' NewFmt);  	R = arRegions [0].GetBounds (G);  	return R.Right;  }  else {  	//This little fudge factor is used to make things line up better.  	//Without this' then the caret is too far left on empty lines and  	//at column 0.  	return c_iEmptyStringWidth;  }  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,MeasureStringDisplayWidth,The following statement contains a magic number: if (iLength > 0) {  	StringFormat NewFmt = new StringFormat (Fmt);  	NewFmt.FormatFlags = StringFormatFlags.MeasureTrailingSpaces;  	RectangleF R = new RectangleF (0' 0' 1000000' 1000000);  	CharacterRange[] arRanges =  {  		new CharacterRange (0' iLength)  	};  	NewFmt.SetMeasurableCharacterRanges (arRanges);  	Region[] arRegions = G.MeasureCharacterRanges (strText' Font' R' NewFmt);  	R = arRegions [0].GetBounds (G);  	return R.Right;  }  else {  	//This little fudge factor is used to make things line up better.  	//Without this' then the caret is too far left on empty lines and  	//at column 0.  	return c_iEmptyStringWidth;  }  
Magic Number,Ankh.Diff.DiffUtils.Controls,DiffViewPosition,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffViewPosition.cs,GetHashCode,The following statement contains a magic number: return Line << 16 + Column;  
Magic Number,Ankh.Diff.DiffUtils.Controls,DirDiffControl,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DirDiffControl.cs,DirDiffControl_SizeChanged,The following statement contains a magic number: pnlLeft.Width = (Width - Splitter.Width) / 2;  
Missing Default,Ankh.Diff,NativeMethods,C:\repos\necora_ank_git\src\Ankh.Diff\Common\Classes\Windows.cs,SetBorderStyle,The following switch statement is missing a default case: switch (Style) {  case BorderStyle.Fixed3D:  	P.Style = P.Style & ~WS_BORDER;  	P.ExStyle = P.ExStyle | WS_EX_CLIENTEDGE;  	break;  case BorderStyle.FixedSingle:  	P.Style = P.Style | WS_BORDER;  	P.ExStyle = P.ExStyle & ~WS_EX_CLIENTEDGE;  	break;  case BorderStyle.None:  	P.Style = P.Style & ~WS_BORDER;  	P.ExStyle = P.ExStyle & ~WS_EX_CLIENTEDGE;  	break;  }  
Missing Default,Ankh.Diff.DiffUtils,Functions,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Classes\Functions.cs,GetXMLTextLines,The following switch statement is missing a default case: switch (Reader.NodeType) {  case XmlNodeType.Attribute:  	//This should never be returned by XmlReader  	Coll.Add (String.Format ("{2}{0}={3}{1}{3}"' Reader.Name' Reader.Value' strIndent' Reader.QuoteChar));  	break;  case XmlNodeType.Comment:  	SplitAndAddXMLLines (Coll' String.Format ("<!-- {0} -->"' Reader.Value)' strIndent' bTrimWSInSplit);  	break;  case XmlNodeType.Element:  	B.Length = 0;  	B.AppendFormat ("{1}<{0}"' Reader.Name' strIndent);  	//We have to check for this before we move to the attributes.  	bool bIsEmptyElement = Reader.IsEmptyElement;  	while (Reader.MoveToNextAttribute ()) {  		B.AppendFormat (" {0}={2}{1}{2}"' Reader.Name' Reader.Value' Reader.QuoteChar);  	}  	if (bIsEmptyElement)  		B.Append ("/>");  	else  		B.Append (">");  	Coll.Add (B.ToString ());  	break;  case XmlNodeType.EndElement:  	Coll.Add (String.Format ("{1}</{0}>"' Reader.Name' strIndent));  	break;  case XmlNodeType.ProcessingInstruction:  case XmlNodeType.XmlDeclaration:  	Coll.Add (String.Format ("{2}<?{0} {1}?>"' Reader.Name' Reader.Value' strIndent));  	break;  case XmlNodeType.SignificantWhitespace:  	if (eWS != WhitespaceHandling.None) {  		Coll.Add (String.Format ("{1}{0}"' Reader.Value' strIndent));  	}  	break;  case XmlNodeType.Whitespace:  	if (eWS == WhitespaceHandling.All) {  		Coll.Add (String.Format ("{1}{0}"' Reader.Value' strIndent));  	}  	break;  case XmlNodeType.CDATA:  	Coll.Add (String.Format ("{1}<![CDATA[{0}]]>"' Reader.Value' strIndent));  	break;  case XmlNodeType.Document:  case XmlNodeType.DocumentFragment:  	Coll.Add (String.Format ("{1}{0}"' Reader.Value' strIndent));  	break;  case XmlNodeType.DocumentType:  	Coll.Add (String.Format ("{1}<!DOCTYPE {0} ["' Reader.Name' strIndent));  	SplitAndAddXMLLines (Coll' Reader.Value' GetIndentString (iDepth + 1)' bTrimWSInSplit);  	Coll.Add (String.Format ("{0}]>"' strIndent));  	break;  case XmlNodeType.Entity:  	Coll.Add (String.Format ("{2}<!ENTITY {0} [{1}]"' Reader.Name' Reader.Value' strIndent));  	SplitAndAddXMLLines (Coll' Reader.Value' GetIndentString (iDepth + 1)' bTrimWSInSplit);  	Coll.Add (String.Format ("{0}]>"' strIndent));  	break;  case XmlNodeType.EntityReference:  	Coll.Add (String.Format ("{1}&{0}"' Reader.Value' strIndent));  	break;  case XmlNodeType.Notation:  	Coll.Add (String.Format ("{2}<!NOTATION {0} [{1}]>"' Reader.Name' Reader.Value' strIndent));  	break;  case XmlNodeType.EndEntity:  case XmlNodeType.None:  case XmlNodeType.Text:  	SplitAndAddXMLLines (Coll' Reader.Value' strIndent' bTrimWSInSplit);  	break;  }  
Missing Default,Ankh.Diff.DiffUtils.Controls,DiffControl,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffControl.cs,ProcessCmdKey,The following switch statement is missing a default case: switch (keyData) {  case Keys.Up | Keys.Control | Keys.Shift:  	GoToFirstDiff ();  	return true;  case Keys.Up | Keys.Control:  	GoToPreviousDiff ();  	return true;  case Keys.Down | Keys.Control:  	GoToNextDiff ();  	return true;  case Keys.Down | Keys.Control | Keys.Shift:  	GoToLastDiff ();  	return true;  }  
Missing Default,Ankh.Diff.DiffUtils.Controls,DiffOptions,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffOptions.cs,GetColorForEditType,The following switch statement is missing a default case: switch (ET) {  case EditType.Change:  	return ChangedColor;  case EditType.Insert:  	return InsertedColor;  case EditType.Delete:  	return DeletedColor;  }  
Missing Default,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,WndProc,The following switch statement is missing a default case: switch (usSBCode) {  case NativeMethods.SB_TOP:  	//SB_LEFT  	iNewPos = Info.nMin;  	break;  case NativeMethods.SB_BOTTOM:  	//SB_RIGHT  	iNewPos = Info.nMax;  	break;  case NativeMethods.SB_LINEUP:  	//SB_LINELEFT;  	iNewPos--;  	break;  case NativeMethods.SB_LINEDOWN:  	//SB_LINERIGHT  	iNewPos++;  	break;  case NativeMethods.SB_PAGEUP:  	//SB_PAGELEFT  	iNewPos -= (int)Info.nPage;  	break;  case NativeMethods.SB_PAGEDOWN:  	//SB_PAGERIGHT  	iNewPos += (int)Info.nPage;  	break;  case NativeMethods.SB_THUMBTRACK:  	iNewPos = Info.nTrackPos;  	break;  }  
Missing Default,Ankh.Diff.DiffUtils.Controls,DiffView,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DiffView.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.KeyCode) {  case Keys.C:  	if (bCtrl) {  		if (HasSelection) {  			Clipboard.SetDataObject (SelectedText' true);  		}  	}  	break;  case Keys.Up:  	if (bCtrl) {  		VScrollPos--;  		OffsetPosition (-1' 0);  	}  	else if (bShift) {  		ExtendSelection (-1' 0);  	}  	else if (bNormal) {  		OffsetPosition (-1' 0);  	}  	break;  case Keys.Down:  	if (bCtrl) {  		VScrollPos++;  		OffsetPosition (1' 0);  	}  	else if (bShift) {  		ExtendSelection (1' 0);  	}  	else if (bNormal) {  		OffsetPosition (1' 0);  	}  	break;  case Keys.Left:  	if (bShift) {  		ExtendSelection (0' -1);  	}  	else if (bNormal) {  		OffsetPosition (0' -1);  	}  	break;  case Keys.Right:  	if (bShift) {  		ExtendSelection (0' 1);  	}  	else if (bNormal) {  		OffsetPosition (0' 1);  	}  	break;  case Keys.PageUp:  	{  		int iPage = NativeMethods.GetScrollPage (this' false);  		if (bShift) {  			ExtendSelection (-iPage' 0);  		}  		else if (bNormal) {  			VScrollPos -= iPage;  			OffsetPosition (-iPage' 0);  		}  	}  	break;  case Keys.PageDown:  	{  		int iPage = NativeMethods.GetScrollPage (this' false);  		if (bShift) {  			ExtendSelection (iPage' 0);  		}  		else if (bNormal) {  			VScrollPos += iPage;  			OffsetPosition (iPage' 0);  		}  	}  	break;  case Keys.Home:  	if (bCtrl) {  		SetPosition (0' 0);  	}  	else if (bShift) {  		ExtendSelection (0' -Position.Column);  	}  	else if (bNormal) {  		SetPosition (Position.Line' 0);  	}  	break;  case Keys.End:  	if (bCtrl) {  		int iLine = LineCount;  		SetPosition (iLine' GetLineLength (iLine));  	}  	else if (bShift) {  		ExtendSelection (0' GetLineLength (Position.Line) - Position.Column);  	}  	else if (bNormal) {  		int iLine = Position.Line;  		SetPosition (iLine' GetLineLength (iLine));  	}  	break;  }  
Missing Default,Ankh.Diff.DiffUtils.Controls,DirDiffControl,C:\repos\necora_ank_git\src\Ankh.Diff\DiffUtils\Controls\DirDiffControl.cs,ScrollingKey,The following switch statement is missing a default case: switch (e.KeyCode) {  case Keys.Home:  case Keys.End:  case Keys.PageUp:  case Keys.PageDown:  case Keys.Up:  case Keys.Down:  	return true;  }  
