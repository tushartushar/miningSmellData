Implementation smell,Namespace,Class,File,Method,Description
Long Method,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Decode,The method has 183 lines of code.
Long Method,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The method has 153 lines of code.
Complex Method,Serenity.Web,LogicOperatorPermissionService,C:\repos\volkanceylan_serenity\Serenity.Core\Authorization\LogicOperatorPermissionService.cs,HasPermission,Cyclomatic complexity of the method is 9
Complex Method,Serenity,TwoLevelCache,C:\repos\volkanceylan_serenity\Serenity.Core\Caching\TwoLevelCache.cs,GetInternal,Cyclomatic complexity of the method is 10
Complex Method,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Decode,Cyclomatic complexity of the method is 28
Complex Method,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,Cyclomatic complexity of the method is 30
Complex Method,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,IsMatch,Cyclomatic complexity of the method is 13
Complex Method,Serenity.IO,TemporaryFileHelper,C:\repos\volkanceylan_serenity\Serenity.Core\IO\TemporaryFileHelper.cs,PurgeDirectory,Cyclomatic complexity of the method is 13
Complex Method,Serenity.Localization,NestedPermissionKeyRegistration,C:\repos\volkanceylan_serenity\Serenity.Core\Localization\NestedPermissionKeyRegistration.cs,AddKeysFrom,Cyclomatic complexity of the method is 11
Complex Method,Serenity.Localization,LocalTextRegistry,C:\repos\volkanceylan_serenity\Serenity.Core\Localization\LocalTextRegistry.cs,TryGet,Cyclomatic complexity of the method is 15
Complex Method,Serenity.Localization,LocalTextRegistry,C:\repos\volkanceylan_serenity\Serenity.Core\Localization\LocalTextRegistry.cs,GetAllAvailableTextsInLanguage,Cyclomatic complexity of the method is 10
Complex Method,Serenity.Localization,EnumLocalTextRegistration,C:\repos\volkanceylan_serenity\Serenity.Core\Localization\EnumLocalTextRegistration.cs,Initialize,Cyclomatic complexity of the method is 8
Long Parameter List,Serenity,TwoLevelCache,C:\repos\volkanceylan_serenity\Serenity.Core\Caching\TwoLevelCache.cs,Get,The method has 5 parameters. Parameters: cacheKey' localExpiration' remoteExpiration' groupKey' loader
Long Parameter List,Serenity,TwoLevelCache,C:\repos\volkanceylan_serenity\Serenity.Core\Caching\TwoLevelCache.cs,GetWithCustomSerializer,The method has 7 parameters. Parameters: cacheKey' localExpiration' remoteExpiration' groupKey' loader' serialize' deserialize
Long Parameter List,Serenity,TwoLevelCache,C:\repos\volkanceylan_serenity\Serenity.Core\Caching\TwoLevelCache.cs,GetInternal,The method has 7 parameters. Parameters: cacheKey' localExpiration' remoteExpiration' groupKey' loader' serialize' deserialize
Long Parameter List,Serenity.Reflection,AssemblySorter,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\AssemblySorter.cs,Visit,The method has 5 parameters. Parameters: item' visited' sorted' dependencies' throwOnCycle
Long Parameter List,Serenity.Reflection,TypeAccessor,C:\repos\volkanceylan_serenity\Serenity.Core\Reflection\TypeAccessor.cs,WriteGetter,The method has 5 parameters. Parameters: il' type' props' fields' isStatic
Long Parameter List,Serenity.Reflection,TypeAccessor,C:\repos\volkanceylan_serenity\Serenity.Core\Reflection\TypeAccessor.cs,WriteSetter,The method has 5 parameters. Parameters: il' type' props' fields' isStatic
Long Identifier,Munq,CreateInstanceDelegateFactory,C:\repos\volkanceylan_serenity\Serenity.Core\Munq\CreateInstanceDelegateFactory.cs,,The length of the parameter STR_TheRequestedClassDoesNotHaveAPublicConstructor is 50.
Long Statement,Serenity,ReflectionExtensions,C:\repos\volkanceylan_serenity\Serenity.Core\Reflection\ReflectionExtensions.cs,GetAttribute,The length of the statement  "                throw new InvalidOperationException(String.Format("{0} has more than 1 of {1} attribute"' member.Name' typeof(TAttribute).Name)); " is 129.
Long Statement,Serenity.Reflection,ILGeneration,C:\repos\volkanceylan_serenity\Serenity.Core\Reflection\ILGeneration.cs,GenerateGetter,The length of the statement  "            il.Emit(OpCodes.Castclass' fieldInfo.DeclaringType); // cast the parameter of type object to the type containing the field " is 122.
Long Statement,Serenity.Reflection,ILGeneration,C:\repos\volkanceylan_serenity\Serenity.Core\Reflection\ILGeneration.cs,GenerateGetter,The length of the statement  "            il.Emit(OpCodes.Ldfld' fieldInfo); // store the value of the given field on the stack. The casted version of source is used as instance " is 135.
Long Statement,Serenity.Reflection,ILGeneration,C:\repos\volkanceylan_serenity\Serenity.Core\Reflection\ILGeneration.cs,GenerateSetter,The length of the statement  "            var method = new DynamicMethod(string.Empty' null' new[] { typeof(object)' typeof(object) }' fieldInfo.DeclaringType' true); " is 124.
Long Statement,Serenity.Reflection,ILGeneration,C:\repos\volkanceylan_serenity\Serenity.Core\Reflection\ILGeneration.cs,GenerateSetter,The length of the statement  "            il.Emit(OpCodes.Castclass' fieldInfo.DeclaringType); // cast the parameter of type object to the type containing the field " is 122.
Long Statement,Serenity.Reflection,TypeAccessor,C:\repos\volkanceylan_serenity\Serenity.Core\Reflection\TypeAccessor.cs,CreateNew,The length of the statement  "                DynamicMethod dynGetter = new DynamicMethod(type.FullName + "_get"' typeof(object)' new Type[] { typeof(object)' typeof(string) }' type' true)' " is 143.
Long Statement,Serenity.Reflection,TypeAccessor,C:\repos\volkanceylan_serenity\Serenity.Core\Reflection\TypeAccessor.cs,CreateNew,The length of the statement  "                              dynSetter = new DynamicMethod(type.FullName + "_set"' null' new Type[] { typeof(object)' typeof(string)' typeof(object) }' type' true); " is 135.
Long Statement,Serenity.Reflection,TypeAccessor,C:\repos\volkanceylan_serenity\Serenity.Core\Reflection\TypeAccessor.cs,CreateNew,The length of the statement  "            MethodBuilder body = tb.DefineMethod(baseGetter.Name' baseGetter.Attributes & ~MethodAttributes.Abstract' typeof(object)' new Type[] { typeof(object)' typeof(string) }); " is 169.
Long Statement,Serenity.Reflection,TypeAccessor,C:\repos\volkanceylan_serenity\Serenity.Core\Reflection\TypeAccessor.cs,CreateNew,The length of the statement  "            body = tb.DefineMethod(baseSetter.Name' baseSetter.Attributes & ~MethodAttributes.Abstract' null' new Type[] { typeof(object)' typeof(string)' typeof(object) }); " is 161.
Long Statement,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,WildcardToRegex,The length of the statement  "                    .Replace(@"\*\*"' ".*") // For recursive wildcards that don't end in a slash e.g. **.txt would be treated as a .txt file at any depth " is 133.
Long Statement,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,WildcardToRegex,The length of the statement  "                    .Replace(@"\*\*"' ".*") // For recursive wildcards that don't end in a slash e.g. **.txt would be treated as a .txt file at any depth " is 133.
Long Statement,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,WildcardToRegex,The length of the statement  "            return new Regex('^' + pattern + '$'' RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.ExplicitCapture | RegexOptions.CultureInvariant); " is 150.
Complex Conditional,Serenity,StringHelper,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\StringHelper.cs,IsTrimmedSame,The conditional expression  "(string1 == null || string1.Length == 0) &&                   (string2 == null || string2.Length == 0)"  is complex.
Complex Conditional,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The conditional expression  "s[0] == sep &&                      s[s.Length - 1] != '/' &&                      s[s.Length - 1] != '\\' &&                      s.IndexOfAny(AsteriskQue' 1) < 0"  is complex.
Complex Conditional,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The conditional expression  "starDotIndex > 1 &&                      s[starDotIndex - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0 &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 1) < 0"  is complex.
Complex Conditional,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The conditional expression  "starDotIndex > 4 &&                      s[starDotIndex - 1] == sep &&                      s[starDotIndex - 2] == '*' &&                      s[starDotIndex - 3] == '*' &&                      s[starDotIndex - 4] == sep &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 5) < 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0"  is complex.
Complex Conditional,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The conditional expression  "s[0] == sep &&                      s.Length > 2 &&                      s[1] == '*' &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0"  is complex.
Complex Conditional,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,IsMatch,The conditional expression  "startsWithAndEndsWith != null &&                  startsWithAndEndsWith.Any(x =>                  {                      if (!path.EndsWith(x.Item3' StringComparison.OrdinalIgnoreCase))                          return false;                        if (x.Item1 == null)                      {                          if (path.Length > x.Item3.Length &&                              path.LastIndexOfAny(FolderSeps' path.Length - x.Item3.Length - 1) >= 0)                              return false;                      }                      else                      {                          if (!path.StartsWith(x.Item1' StringComparison.OrdinalIgnoreCase))                              return false;                            if (!x.Item2 &&                              path.IndexOfAny(FolderSeps' x.Item1.Length) >= 0)                          {                              return false;                          }                      }                        return true;                  })"  is complex.
Complex Conditional,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,IsMatch,The conditional expression  "containsAndEndsWith != null &&                  containsAndEndsWith.Any(x =>                  {                      if (!path.EndsWith(x.Item3' StringComparison.OrdinalIgnoreCase))                          return false;                        if (x.Item1 == null)                      {                          if (path.Length > x.Item3.Length &&                              path.LastIndexOfAny(FolderSeps' path.Length - x.Item3.Length - 1) >= 0)                              return false;                      }                      else                      {                          var idx = path.IndexOf(x.Item1' StringComparison.OrdinalIgnoreCase);                          if (idx < 0)                              return false;                            if (!x.Item2 &&                              path.IndexOfAny(FolderSeps' idx + x.Item1.Length) >= 0)                          {                              return false;                          }                      }                        return true;                  })"  is complex.
Complex Conditional,Serenity.Localization,NestedPermissionKeyRegistration,C:\repos\volkanceylan_serenity\Serenity.Core\Localization\NestedPermissionKeyRegistration.cs,AddKeysFrom,The conditional expression  "displayName != null &&                      lastColonIndex > 0 &&                      lastColonIndex < thisKeys[0].Length - 1 &&                      thisKeys.TrueForAll(x => x.LastIndexOf(":") == lastColonIndex)"  is complex.
Empty Catch Block,Serenity,ExceptionLog,C:\repos\volkanceylan_serenity\Serenity.Core\Interface\ExceptionLog.cs,Log,The method has an empty catch block.
Empty Catch Block,Serenity.Extensibility,ExtensibilityHelper,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\ExtensibilityHelper.cs,EnumerateDirectory,The method has an empty catch block.
Empty Catch Block,Serenity.Extensibility,ExtensibilityHelper,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\ExtensibilityHelper.cs,DetermineSelfAssemblies,The method has an empty catch block.
Empty Catch Block,Serenity.IO,TemporaryFileHelper,C:\repos\volkanceylan_serenity\Serenity.Core\IO\TemporaryFileHelper.cs,PurgeDirectory,The method has an empty catch block.
Empty Catch Block,Serenity.IO,TemporaryFileHelper,C:\repos\volkanceylan_serenity\Serenity.Core\IO\TemporaryFileHelper.cs,PurgeDirectory,The method has an empty catch block.
Empty Catch Block,Serenity.IO,TemporaryFileHelper,C:\repos\volkanceylan_serenity\Serenity.Core\IO\TemporaryFileHelper.cs,TryDelete,The method has an empty catch block.
Empty Catch Block,Serenity.IO,TemporaryFileHelper,C:\repos\volkanceylan_serenity\Serenity.Core\IO\TemporaryFileHelper.cs,Delete,The method has an empty catch block.
Empty Catch Block,Serenity.IO,TemporaryFileHelper,C:\repos\volkanceylan_serenity\Serenity.Core\IO\TemporaryFileHelper.cs,TryDeleteOrMark,The method has an empty catch block.
Empty Catch Block,Serenity.IO,TemporaryFileHelper,C:\repos\volkanceylan_serenity\Serenity.Core\IO\TemporaryFileHelper.cs,TryDeleteMarkedFiles,The method has an empty catch block.
Empty Catch Block,Serenity.IO,TemporaryFileHelper,C:\repos\volkanceylan_serenity\Serenity.Core\IO\TemporaryFileHelper.cs,ClearTempFiles,The method has an empty catch block.
Magic Number,Serenity,TwoLevelCache,C:\repos\volkanceylan_serenity\Serenity.Core\Caching\TwoLevelCache.cs,GetSeed,The following statement contains a magic number: int i2 = BitConverter.ToInt32(raw' 4);
Magic Number,Serenity,TwoLevelCache,C:\repos\volkanceylan_serenity\Serenity.Core\Caching\TwoLevelCache.cs,GetSeed,The following statement contains a magic number: int i3 = BitConverter.ToInt32(raw' 8);
Magic Number,Serenity,TwoLevelCache,C:\repos\volkanceylan_serenity\Serenity.Core\Caching\TwoLevelCache.cs,GetSeed,The following statement contains a magic number: int i4 = BitConverter.ToInt32(raw' 12);
Magic Number,Serenity,StringHelper,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\StringHelper.cs,ThreeDots,The following statement contains a magic number: if (maxLength > 3)                  maxLength -= 3;              else                   return "...";
Magic Number,Serenity,StringHelper,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\StringHelper.cs,ThreeDots,The following statement contains a magic number: if (maxLength > 3)                  maxLength -= 3;              else                   return "...";
Magic Number,Serenity,StringHelper,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\StringHelper.cs,QuoteString,The following statement contains a magic number: sb.EnsureCapacity(sb.Length + (s.Length * 2));
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: StringBuilder base32 = new StringBuilder((len * 8 + 4) / 5);
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: StringBuilder base32 = new StringBuilder((len * 8 + 4) / 5);
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: StringBuilder base32 = new StringBuilder((len * 8 + 4) / 5);
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: while (i < len)              {                  // INVARIANTS FOR EACH STEP n in [0..5[; digit in [0..31[;                  // The remaining n bits are already aligned on top positions                  // of the 5 least bits of digit' the other bits are 0.                  ////// STEP n = 0; insert new 5 bits' leave 3 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[currByte >> 3]);                  digit = (currByte & 7) << 2;                  if (i >= len)                  { // put the last 3 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 3: insert 2 new bits' then 5 bits' leave 1 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 6)]);                  base32.Append(base32Chars[(currByte >> 1) & 31]);                  digit = (currByte & 1) << 4;                  if (i >= len)                  { // put the last 1 bit                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 1: insert 4 new bits' leave 4 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 4)]);                  digit = (currByte & 15) << 1;                  if (i >= len)                  { // put the last 4 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 4: insert 1 new bit' then 5 bits' leave 2 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 7)]);                  base32.Append(base32Chars[(currByte >> 2) & 31]);                  digit = (currByte & 3) << 3;                  if (i >= len)                  { // put the last 2 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ///// STEP n = 2: insert 3 new bits' then 5 bits' leave 0 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 5)]);                  base32.Append(base32Chars[currByte & 31]);                  //// This point is reached for len multiple of 5              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: while (i < len)              {                  // INVARIANTS FOR EACH STEP n in [0..5[; digit in [0..31[;                  // The remaining n bits are already aligned on top positions                  // of the 5 least bits of digit' the other bits are 0.                  ////// STEP n = 0; insert new 5 bits' leave 3 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[currByte >> 3]);                  digit = (currByte & 7) << 2;                  if (i >= len)                  { // put the last 3 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 3: insert 2 new bits' then 5 bits' leave 1 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 6)]);                  base32.Append(base32Chars[(currByte >> 1) & 31]);                  digit = (currByte & 1) << 4;                  if (i >= len)                  { // put the last 1 bit                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 1: insert 4 new bits' leave 4 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 4)]);                  digit = (currByte & 15) << 1;                  if (i >= len)                  { // put the last 4 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 4: insert 1 new bit' then 5 bits' leave 2 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 7)]);                  base32.Append(base32Chars[(currByte >> 2) & 31]);                  digit = (currByte & 3) << 3;                  if (i >= len)                  { // put the last 2 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ///// STEP n = 2: insert 3 new bits' then 5 bits' leave 0 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 5)]);                  base32.Append(base32Chars[currByte & 31]);                  //// This point is reached for len multiple of 5              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: while (i < len)              {                  // INVARIANTS FOR EACH STEP n in [0..5[; digit in [0..31[;                  // The remaining n bits are already aligned on top positions                  // of the 5 least bits of digit' the other bits are 0.                  ////// STEP n = 0; insert new 5 bits' leave 3 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[currByte >> 3]);                  digit = (currByte & 7) << 2;                  if (i >= len)                  { // put the last 3 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 3: insert 2 new bits' then 5 bits' leave 1 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 6)]);                  base32.Append(base32Chars[(currByte >> 1) & 31]);                  digit = (currByte & 1) << 4;                  if (i >= len)                  { // put the last 1 bit                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 1: insert 4 new bits' leave 4 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 4)]);                  digit = (currByte & 15) << 1;                  if (i >= len)                  { // put the last 4 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 4: insert 1 new bit' then 5 bits' leave 2 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 7)]);                  base32.Append(base32Chars[(currByte >> 2) & 31]);                  digit = (currByte & 3) << 3;                  if (i >= len)                  { // put the last 2 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ///// STEP n = 2: insert 3 new bits' then 5 bits' leave 0 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 5)]);                  base32.Append(base32Chars[currByte & 31]);                  //// This point is reached for len multiple of 5              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: while (i < len)              {                  // INVARIANTS FOR EACH STEP n in [0..5[; digit in [0..31[;                  // The remaining n bits are already aligned on top positions                  // of the 5 least bits of digit' the other bits are 0.                  ////// STEP n = 0; insert new 5 bits' leave 3 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[currByte >> 3]);                  digit = (currByte & 7) << 2;                  if (i >= len)                  { // put the last 3 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 3: insert 2 new bits' then 5 bits' leave 1 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 6)]);                  base32.Append(base32Chars[(currByte >> 1) & 31]);                  digit = (currByte & 1) << 4;                  if (i >= len)                  { // put the last 1 bit                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 1: insert 4 new bits' leave 4 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 4)]);                  digit = (currByte & 15) << 1;                  if (i >= len)                  { // put the last 4 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 4: insert 1 new bit' then 5 bits' leave 2 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 7)]);                  base32.Append(base32Chars[(currByte >> 2) & 31]);                  digit = (currByte & 3) << 3;                  if (i >= len)                  { // put the last 2 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ///// STEP n = 2: insert 3 new bits' then 5 bits' leave 0 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 5)]);                  base32.Append(base32Chars[currByte & 31]);                  //// This point is reached for len multiple of 5              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: while (i < len)              {                  // INVARIANTS FOR EACH STEP n in [0..5[; digit in [0..31[;                  // The remaining n bits are already aligned on top positions                  // of the 5 least bits of digit' the other bits are 0.                  ////// STEP n = 0; insert new 5 bits' leave 3 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[currByte >> 3]);                  digit = (currByte & 7) << 2;                  if (i >= len)                  { // put the last 3 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 3: insert 2 new bits' then 5 bits' leave 1 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 6)]);                  base32.Append(base32Chars[(currByte >> 1) & 31]);                  digit = (currByte & 1) << 4;                  if (i >= len)                  { // put the last 1 bit                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 1: insert 4 new bits' leave 4 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 4)]);                  digit = (currByte & 15) << 1;                  if (i >= len)                  { // put the last 4 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 4: insert 1 new bit' then 5 bits' leave 2 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 7)]);                  base32.Append(base32Chars[(currByte >> 2) & 31]);                  digit = (currByte & 3) << 3;                  if (i >= len)                  { // put the last 2 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ///// STEP n = 2: insert 3 new bits' then 5 bits' leave 0 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 5)]);                  base32.Append(base32Chars[currByte & 31]);                  //// This point is reached for len multiple of 5              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: while (i < len)              {                  // INVARIANTS FOR EACH STEP n in [0..5[; digit in [0..31[;                  // The remaining n bits are already aligned on top positions                  // of the 5 least bits of digit' the other bits are 0.                  ////// STEP n = 0; insert new 5 bits' leave 3 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[currByte >> 3]);                  digit = (currByte & 7) << 2;                  if (i >= len)                  { // put the last 3 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 3: insert 2 new bits' then 5 bits' leave 1 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 6)]);                  base32.Append(base32Chars[(currByte >> 1) & 31]);                  digit = (currByte & 1) << 4;                  if (i >= len)                  { // put the last 1 bit                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 1: insert 4 new bits' leave 4 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 4)]);                  digit = (currByte & 15) << 1;                  if (i >= len)                  { // put the last 4 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 4: insert 1 new bit' then 5 bits' leave 2 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 7)]);                  base32.Append(base32Chars[(currByte >> 2) & 31]);                  digit = (currByte & 3) << 3;                  if (i >= len)                  { // put the last 2 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ///// STEP n = 2: insert 3 new bits' then 5 bits' leave 0 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 5)]);                  base32.Append(base32Chars[currByte & 31]);                  //// This point is reached for len multiple of 5              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: while (i < len)              {                  // INVARIANTS FOR EACH STEP n in [0..5[; digit in [0..31[;                  // The remaining n bits are already aligned on top positions                  // of the 5 least bits of digit' the other bits are 0.                  ////// STEP n = 0; insert new 5 bits' leave 3 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[currByte >> 3]);                  digit = (currByte & 7) << 2;                  if (i >= len)                  { // put the last 3 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 3: insert 2 new bits' then 5 bits' leave 1 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 6)]);                  base32.Append(base32Chars[(currByte >> 1) & 31]);                  digit = (currByte & 1) << 4;                  if (i >= len)                  { // put the last 1 bit                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 1: insert 4 new bits' leave 4 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 4)]);                  digit = (currByte & 15) << 1;                  if (i >= len)                  { // put the last 4 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 4: insert 1 new bit' then 5 bits' leave 2 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 7)]);                  base32.Append(base32Chars[(currByte >> 2) & 31]);                  digit = (currByte & 3) << 3;                  if (i >= len)                  { // put the last 2 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ///// STEP n = 2: insert 3 new bits' then 5 bits' leave 0 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 5)]);                  base32.Append(base32Chars[currByte & 31]);                  //// This point is reached for len multiple of 5              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: while (i < len)              {                  // INVARIANTS FOR EACH STEP n in [0..5[; digit in [0..31[;                  // The remaining n bits are already aligned on top positions                  // of the 5 least bits of digit' the other bits are 0.                  ////// STEP n = 0; insert new 5 bits' leave 3 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[currByte >> 3]);                  digit = (currByte & 7) << 2;                  if (i >= len)                  { // put the last 3 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 3: insert 2 new bits' then 5 bits' leave 1 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 6)]);                  base32.Append(base32Chars[(currByte >> 1) & 31]);                  digit = (currByte & 1) << 4;                  if (i >= len)                  { // put the last 1 bit                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 1: insert 4 new bits' leave 4 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 4)]);                  digit = (currByte & 15) << 1;                  if (i >= len)                  { // put the last 4 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 4: insert 1 new bit' then 5 bits' leave 2 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 7)]);                  base32.Append(base32Chars[(currByte >> 2) & 31]);                  digit = (currByte & 3) << 3;                  if (i >= len)                  { // put the last 2 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ///// STEP n = 2: insert 3 new bits' then 5 bits' leave 0 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 5)]);                  base32.Append(base32Chars[currByte & 31]);                  //// This point is reached for len multiple of 5              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: while (i < len)              {                  // INVARIANTS FOR EACH STEP n in [0..5[; digit in [0..31[;                  // The remaining n bits are already aligned on top positions                  // of the 5 least bits of digit' the other bits are 0.                  ////// STEP n = 0; insert new 5 bits' leave 3 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[currByte >> 3]);                  digit = (currByte & 7) << 2;                  if (i >= len)                  { // put the last 3 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 3: insert 2 new bits' then 5 bits' leave 1 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 6)]);                  base32.Append(base32Chars[(currByte >> 1) & 31]);                  digit = (currByte & 1) << 4;                  if (i >= len)                  { // put the last 1 bit                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 1: insert 4 new bits' leave 4 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 4)]);                  digit = (currByte & 15) << 1;                  if (i >= len)                  { // put the last 4 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 4: insert 1 new bit' then 5 bits' leave 2 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 7)]);                  base32.Append(base32Chars[(currByte >> 2) & 31]);                  digit = (currByte & 3) << 3;                  if (i >= len)                  { // put the last 2 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ///// STEP n = 2: insert 3 new bits' then 5 bits' leave 0 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 5)]);                  base32.Append(base32Chars[currByte & 31]);                  //// This point is reached for len multiple of 5              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: while (i < len)              {                  // INVARIANTS FOR EACH STEP n in [0..5[; digit in [0..31[;                  // The remaining n bits are already aligned on top positions                  // of the 5 least bits of digit' the other bits are 0.                  ////// STEP n = 0; insert new 5 bits' leave 3 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[currByte >> 3]);                  digit = (currByte & 7) << 2;                  if (i >= len)                  { // put the last 3 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 3: insert 2 new bits' then 5 bits' leave 1 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 6)]);                  base32.Append(base32Chars[(currByte >> 1) & 31]);                  digit = (currByte & 1) << 4;                  if (i >= len)                  { // put the last 1 bit                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 1: insert 4 new bits' leave 4 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 4)]);                  digit = (currByte & 15) << 1;                  if (i >= len)                  { // put the last 4 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 4: insert 1 new bit' then 5 bits' leave 2 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 7)]);                  base32.Append(base32Chars[(currByte >> 2) & 31]);                  digit = (currByte & 3) << 3;                  if (i >= len)                  { // put the last 2 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ///// STEP n = 2: insert 3 new bits' then 5 bits' leave 0 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 5)]);                  base32.Append(base32Chars[currByte & 31]);                  //// This point is reached for len multiple of 5              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: while (i < len)              {                  // INVARIANTS FOR EACH STEP n in [0..5[; digit in [0..31[;                  // The remaining n bits are already aligned on top positions                  // of the 5 least bits of digit' the other bits are 0.                  ////// STEP n = 0; insert new 5 bits' leave 3 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[currByte >> 3]);                  digit = (currByte & 7) << 2;                  if (i >= len)                  { // put the last 3 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 3: insert 2 new bits' then 5 bits' leave 1 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 6)]);                  base32.Append(base32Chars[(currByte >> 1) & 31]);                  digit = (currByte & 1) << 4;                  if (i >= len)                  { // put the last 1 bit                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 1: insert 4 new bits' leave 4 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 4)]);                  digit = (currByte & 15) << 1;                  if (i >= len)                  { // put the last 4 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 4: insert 1 new bit' then 5 bits' leave 2 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 7)]);                  base32.Append(base32Chars[(currByte >> 2) & 31]);                  digit = (currByte & 3) << 3;                  if (i >= len)                  { // put the last 2 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ///// STEP n = 2: insert 3 new bits' then 5 bits' leave 0 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 5)]);                  base32.Append(base32Chars[currByte & 31]);                  //// This point is reached for len multiple of 5              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: while (i < len)              {                  // INVARIANTS FOR EACH STEP n in [0..5[; digit in [0..31[;                  // The remaining n bits are already aligned on top positions                  // of the 5 least bits of digit' the other bits are 0.                  ////// STEP n = 0; insert new 5 bits' leave 3 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[currByte >> 3]);                  digit = (currByte & 7) << 2;                  if (i >= len)                  { // put the last 3 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 3: insert 2 new bits' then 5 bits' leave 1 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 6)]);                  base32.Append(base32Chars[(currByte >> 1) & 31]);                  digit = (currByte & 1) << 4;                  if (i >= len)                  { // put the last 1 bit                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 1: insert 4 new bits' leave 4 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 4)]);                  digit = (currByte & 15) << 1;                  if (i >= len)                  { // put the last 4 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 4: insert 1 new bit' then 5 bits' leave 2 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 7)]);                  base32.Append(base32Chars[(currByte >> 2) & 31]);                  digit = (currByte & 3) << 3;                  if (i >= len)                  { // put the last 2 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ///// STEP n = 2: insert 3 new bits' then 5 bits' leave 0 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 5)]);                  base32.Append(base32Chars[currByte & 31]);                  //// This point is reached for len multiple of 5              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: while (i < len)              {                  // INVARIANTS FOR EACH STEP n in [0..5[; digit in [0..31[;                  // The remaining n bits are already aligned on top positions                  // of the 5 least bits of digit' the other bits are 0.                  ////// STEP n = 0; insert new 5 bits' leave 3 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[currByte >> 3]);                  digit = (currByte & 7) << 2;                  if (i >= len)                  { // put the last 3 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 3: insert 2 new bits' then 5 bits' leave 1 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 6)]);                  base32.Append(base32Chars[(currByte >> 1) & 31]);                  digit = (currByte & 1) << 4;                  if (i >= len)                  { // put the last 1 bit                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 1: insert 4 new bits' leave 4 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 4)]);                  digit = (currByte & 15) << 1;                  if (i >= len)                  { // put the last 4 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 4: insert 1 new bit' then 5 bits' leave 2 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 7)]);                  base32.Append(base32Chars[(currByte >> 2) & 31]);                  digit = (currByte & 3) << 3;                  if (i >= len)                  { // put the last 2 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ///// STEP n = 2: insert 3 new bits' then 5 bits' leave 0 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 5)]);                  base32.Append(base32Chars[currByte & 31]);                  //// This point is reached for len multiple of 5              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: while (i < len)              {                  // INVARIANTS FOR EACH STEP n in [0..5[; digit in [0..31[;                  // The remaining n bits are already aligned on top positions                  // of the 5 least bits of digit' the other bits are 0.                  ////// STEP n = 0; insert new 5 bits' leave 3 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[currByte >> 3]);                  digit = (currByte & 7) << 2;                  if (i >= len)                  { // put the last 3 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 3: insert 2 new bits' then 5 bits' leave 1 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 6)]);                  base32.Append(base32Chars[(currByte >> 1) & 31]);                  digit = (currByte & 1) << 4;                  if (i >= len)                  { // put the last 1 bit                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 1: insert 4 new bits' leave 4 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 4)]);                  digit = (currByte & 15) << 1;                  if (i >= len)                  { // put the last 4 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 4: insert 1 new bit' then 5 bits' leave 2 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 7)]);                  base32.Append(base32Chars[(currByte >> 2) & 31]);                  digit = (currByte & 3) << 3;                  if (i >= len)                  { // put the last 2 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ///// STEP n = 2: insert 3 new bits' then 5 bits' leave 0 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 5)]);                  base32.Append(base32Chars[currByte & 31]);                  //// This point is reached for len multiple of 5              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: while (i < len)              {                  // INVARIANTS FOR EACH STEP n in [0..5[; digit in [0..31[;                  // The remaining n bits are already aligned on top positions                  // of the 5 least bits of digit' the other bits are 0.                  ////// STEP n = 0; insert new 5 bits' leave 3 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[currByte >> 3]);                  digit = (currByte & 7) << 2;                  if (i >= len)                  { // put the last 3 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 3: insert 2 new bits' then 5 bits' leave 1 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 6)]);                  base32.Append(base32Chars[(currByte >> 1) & 31]);                  digit = (currByte & 1) << 4;                  if (i >= len)                  { // put the last 1 bit                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 1: insert 4 new bits' leave 4 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 4)]);                  digit = (currByte & 15) << 1;                  if (i >= len)                  { // put the last 4 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 4: insert 1 new bit' then 5 bits' leave 2 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 7)]);                  base32.Append(base32Chars[(currByte >> 2) & 31]);                  digit = (currByte & 3) << 3;                  if (i >= len)                  { // put the last 2 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ///// STEP n = 2: insert 3 new bits' then 5 bits' leave 0 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 5)]);                  base32.Append(base32Chars[currByte & 31]);                  //// This point is reached for len multiple of 5              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: while (i < len)              {                  // INVARIANTS FOR EACH STEP n in [0..5[; digit in [0..31[;                  // The remaining n bits are already aligned on top positions                  // of the 5 least bits of digit' the other bits are 0.                  ////// STEP n = 0; insert new 5 bits' leave 3 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[currByte >> 3]);                  digit = (currByte & 7) << 2;                  if (i >= len)                  { // put the last 3 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 3: insert 2 new bits' then 5 bits' leave 1 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 6)]);                  base32.Append(base32Chars[(currByte >> 1) & 31]);                  digit = (currByte & 1) << 4;                  if (i >= len)                  { // put the last 1 bit                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 1: insert 4 new bits' leave 4 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 4)]);                  digit = (currByte & 15) << 1;                  if (i >= len)                  { // put the last 4 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 4: insert 1 new bit' then 5 bits' leave 2 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 7)]);                  base32.Append(base32Chars[(currByte >> 2) & 31]);                  digit = (currByte & 3) << 3;                  if (i >= len)                  { // put the last 2 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ///// STEP n = 2: insert 3 new bits' then 5 bits' leave 0 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 5)]);                  base32.Append(base32Chars[currByte & 31]);                  //// This point is reached for len multiple of 5              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: while (i < len)              {                  // INVARIANTS FOR EACH STEP n in [0..5[; digit in [0..31[;                  // The remaining n bits are already aligned on top positions                  // of the 5 least bits of digit' the other bits are 0.                  ////// STEP n = 0; insert new 5 bits' leave 3 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[currByte >> 3]);                  digit = (currByte & 7) << 2;                  if (i >= len)                  { // put the last 3 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 3: insert 2 new bits' then 5 bits' leave 1 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 6)]);                  base32.Append(base32Chars[(currByte >> 1) & 31]);                  digit = (currByte & 1) << 4;                  if (i >= len)                  { // put the last 1 bit                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 1: insert 4 new bits' leave 4 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 4)]);                  digit = (currByte & 15) << 1;                  if (i >= len)                  { // put the last 4 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 4: insert 1 new bit' then 5 bits' leave 2 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 7)]);                  base32.Append(base32Chars[(currByte >> 2) & 31]);                  digit = (currByte & 3) << 3;                  if (i >= len)                  { // put the last 2 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ///// STEP n = 2: insert 3 new bits' then 5 bits' leave 0 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 5)]);                  base32.Append(base32Chars[currByte & 31]);                  //// This point is reached for len multiple of 5              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: while (i < len)              {                  // INVARIANTS FOR EACH STEP n in [0..5[; digit in [0..31[;                  // The remaining n bits are already aligned on top positions                  // of the 5 least bits of digit' the other bits are 0.                  ////// STEP n = 0; insert new 5 bits' leave 3 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[currByte >> 3]);                  digit = (currByte & 7) << 2;                  if (i >= len)                  { // put the last 3 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 3: insert 2 new bits' then 5 bits' leave 1 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 6)]);                  base32.Append(base32Chars[(currByte >> 1) & 31]);                  digit = (currByte & 1) << 4;                  if (i >= len)                  { // put the last 1 bit                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 1: insert 4 new bits' leave 4 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 4)]);                  digit = (currByte & 15) << 1;                  if (i >= len)                  { // put the last 4 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 4: insert 1 new bit' then 5 bits' leave 2 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 7)]);                  base32.Append(base32Chars[(currByte >> 2) & 31]);                  digit = (currByte & 3) << 3;                  if (i >= len)                  { // put the last 2 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ///// STEP n = 2: insert 3 new bits' then 5 bits' leave 0 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 5)]);                  base32.Append(base32Chars[currByte & 31]);                  //// This point is reached for len multiple of 5              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: while (i < len)              {                  // INVARIANTS FOR EACH STEP n in [0..5[; digit in [0..31[;                  // The remaining n bits are already aligned on top positions                  // of the 5 least bits of digit' the other bits are 0.                  ////// STEP n = 0; insert new 5 bits' leave 3 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[currByte >> 3]);                  digit = (currByte & 7) << 2;                  if (i >= len)                  { // put the last 3 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 3: insert 2 new bits' then 5 bits' leave 1 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 6)]);                  base32.Append(base32Chars[(currByte >> 1) & 31]);                  digit = (currByte & 1) << 4;                  if (i >= len)                  { // put the last 1 bit                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 1: insert 4 new bits' leave 4 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 4)]);                  digit = (currByte & 15) << 1;                  if (i >= len)                  { // put the last 4 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 4: insert 1 new bit' then 5 bits' leave 2 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 7)]);                  base32.Append(base32Chars[(currByte >> 2) & 31]);                  digit = (currByte & 3) << 3;                  if (i >= len)                  { // put the last 2 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ///// STEP n = 2: insert 3 new bits' then 5 bits' leave 0 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 5)]);                  base32.Append(base32Chars[currByte & 31]);                  //// This point is reached for len multiple of 5              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Encode,The following statement contains a magic number: while (i < len)              {                  // INVARIANTS FOR EACH STEP n in [0..5[; digit in [0..31[;                  // The remaining n bits are already aligned on top positions                  // of the 5 least bits of digit' the other bits are 0.                  ////// STEP n = 0; insert new 5 bits' leave 3 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[currByte >> 3]);                  digit = (currByte & 7) << 2;                  if (i >= len)                  { // put the last 3 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 3: insert 2 new bits' then 5 bits' leave 1 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 6)]);                  base32.Append(base32Chars[(currByte >> 1) & 31]);                  digit = (currByte & 1) << 4;                  if (i >= len)                  { // put the last 1 bit                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 1: insert 4 new bits' leave 4 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 4)]);                  digit = (currByte & 15) << 1;                  if (i >= len)                  { // put the last 4 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ////// STEP n = 4: insert 1 new bit' then 5 bits' leave 2 bits                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 7)]);                  base32.Append(base32Chars[(currByte >> 2) & 31]);                  digit = (currByte & 3) << 3;                  if (i >= len)                  { // put the last 2 bits                      base32.Append(base32Chars[digit]);                      break;                  }                  ///// STEP n = 2: insert 3 new bits' then 5 bits' leave 0 bit                  currByte = bytes[i++] & 255;                  base32.Append(base32Chars[digit | (currByte >> 5)]);                  base32.Append(base32Chars[currByte & 31]);                  //// This point is reached for len multiple of 5              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Decode,The following statement contains a magic number: switch (len % 8)              { // test the length of last subblock                  case 1: //  5 bits in subblock:  0 useful bits but 5 discarded                  case 3: // 15 bits in subblock:  8 useful bits but 7 discarded                  case 6: // 30 bits in subblock: 24 useful bits but 6 discarded                      throw new ArgumentException(errorCanonicalLength);              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Decode,The following statement contains a magic number: switch (len % 8)              { // test the length of last subblock                  case 1: //  5 bits in subblock:  0 useful bits but 5 discarded                  case 3: // 15 bits in subblock:  8 useful bits but 7 discarded                  case 6: // 30 bits in subblock: 24 useful bits but 6 discarded                      throw new ArgumentException(errorCanonicalLength);              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Decode,The following statement contains a magic number: switch (len % 8)              { // test the length of last subblock                  case 1: //  5 bits in subblock:  0 useful bits but 5 discarded                  case 3: // 15 bits in subblock:  8 useful bits but 7 discarded                  case 6: // 30 bits in subblock: 24 useful bits but 6 discarded                      throw new ArgumentException(errorCanonicalLength);              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Decode,The following statement contains a magic number: byte[] bytes = new byte[len * 5 / 8];
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Decode,The following statement contains a magic number: byte[] bytes = new byte[len * 5 / 8];
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Decode,The following statement contains a magic number: while (i < len)              {                  // Read the 1st char in a 8-chars subblock                  // check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 0: leave 5 bits                  nextByte = (byte)(digit << 3);                  // Assert(i < base32.length) // tested before loop                  // Read the 2nd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 5: insert 3 bits' leave 2 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 2));                  nextByte = (byte)((digit & 3) << 6);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 2 bits                  }                  // Read the 3rd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 2: leave 7 bits                  nextByte |= (byte)(digit << 1);                  // Assert(i < base32.length) // tested before loop                  // Read the 4th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 7: insert 1 bit' leave 4 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 4));                  nextByte = (byte)((digit & 15) << 4);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 4 bits                  }                  // Read the 5th char in a 8-chars subblock                  // Assert that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 4: insert 4 bits' leave 1 bit                  bytes[offset++] = (byte)(nextByte | (digit >> 1));                  nextByte = (byte)((digit & 1) << 7);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 1 bit                  }                  // Read the 6th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 1: leave 6 bits                  nextByte |= (byte)(digit << 2);                  // Assert(i < base32.length) // tested before loop                  // Read the 7th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 6: insert 2 bits' leave 3 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 3));                  nextByte = (byte)((digit & 7) << 5);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 3 bits                  }                  // Read the 8th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 3: insert 5 bits' leave 0 bit                  bytes[offset++] = (byte)(nextByte | digit);                  //// possible end of string here with no trailing bits              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Decode,The following statement contains a magic number: while (i < len)              {                  // Read the 1st char in a 8-chars subblock                  // check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 0: leave 5 bits                  nextByte = (byte)(digit << 3);                  // Assert(i < base32.length) // tested before loop                  // Read the 2nd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 5: insert 3 bits' leave 2 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 2));                  nextByte = (byte)((digit & 3) << 6);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 2 bits                  }                  // Read the 3rd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 2: leave 7 bits                  nextByte |= (byte)(digit << 1);                  // Assert(i < base32.length) // tested before loop                  // Read the 4th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 7: insert 1 bit' leave 4 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 4));                  nextByte = (byte)((digit & 15) << 4);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 4 bits                  }                  // Read the 5th char in a 8-chars subblock                  // Assert that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 4: insert 4 bits' leave 1 bit                  bytes[offset++] = (byte)(nextByte | (digit >> 1));                  nextByte = (byte)((digit & 1) << 7);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 1 bit                  }                  // Read the 6th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 1: leave 6 bits                  nextByte |= (byte)(digit << 2);                  // Assert(i < base32.length) // tested before loop                  // Read the 7th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 6: insert 2 bits' leave 3 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 3));                  nextByte = (byte)((digit & 7) << 5);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 3 bits                  }                  // Read the 8th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 3: insert 5 bits' leave 0 bit                  bytes[offset++] = (byte)(nextByte | digit);                  //// possible end of string here with no trailing bits              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Decode,The following statement contains a magic number: while (i < len)              {                  // Read the 1st char in a 8-chars subblock                  // check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 0: leave 5 bits                  nextByte = (byte)(digit << 3);                  // Assert(i < base32.length) // tested before loop                  // Read the 2nd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 5: insert 3 bits' leave 2 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 2));                  nextByte = (byte)((digit & 3) << 6);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 2 bits                  }                  // Read the 3rd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 2: leave 7 bits                  nextByte |= (byte)(digit << 1);                  // Assert(i < base32.length) // tested before loop                  // Read the 4th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 7: insert 1 bit' leave 4 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 4));                  nextByte = (byte)((digit & 15) << 4);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 4 bits                  }                  // Read the 5th char in a 8-chars subblock                  // Assert that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 4: insert 4 bits' leave 1 bit                  bytes[offset++] = (byte)(nextByte | (digit >> 1));                  nextByte = (byte)((digit & 1) << 7);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 1 bit                  }                  // Read the 6th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 1: leave 6 bits                  nextByte |= (byte)(digit << 2);                  // Assert(i < base32.length) // tested before loop                  // Read the 7th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 6: insert 2 bits' leave 3 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 3));                  nextByte = (byte)((digit & 7) << 5);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 3 bits                  }                  // Read the 8th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 3: insert 5 bits' leave 0 bit                  bytes[offset++] = (byte)(nextByte | digit);                  //// possible end of string here with no trailing bits              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Decode,The following statement contains a magic number: while (i < len)              {                  // Read the 1st char in a 8-chars subblock                  // check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 0: leave 5 bits                  nextByte = (byte)(digit << 3);                  // Assert(i < base32.length) // tested before loop                  // Read the 2nd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 5: insert 3 bits' leave 2 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 2));                  nextByte = (byte)((digit & 3) << 6);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 2 bits                  }                  // Read the 3rd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 2: leave 7 bits                  nextByte |= (byte)(digit << 1);                  // Assert(i < base32.length) // tested before loop                  // Read the 4th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 7: insert 1 bit' leave 4 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 4));                  nextByte = (byte)((digit & 15) << 4);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 4 bits                  }                  // Read the 5th char in a 8-chars subblock                  // Assert that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 4: insert 4 bits' leave 1 bit                  bytes[offset++] = (byte)(nextByte | (digit >> 1));                  nextByte = (byte)((digit & 1) << 7);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 1 bit                  }                  // Read the 6th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 1: leave 6 bits                  nextByte |= (byte)(digit << 2);                  // Assert(i < base32.length) // tested before loop                  // Read the 7th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 6: insert 2 bits' leave 3 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 3));                  nextByte = (byte)((digit & 7) << 5);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 3 bits                  }                  // Read the 8th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 3: insert 5 bits' leave 0 bit                  bytes[offset++] = (byte)(nextByte | digit);                  //// possible end of string here with no trailing bits              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Decode,The following statement contains a magic number: while (i < len)              {                  // Read the 1st char in a 8-chars subblock                  // check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 0: leave 5 bits                  nextByte = (byte)(digit << 3);                  // Assert(i < base32.length) // tested before loop                  // Read the 2nd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 5: insert 3 bits' leave 2 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 2));                  nextByte = (byte)((digit & 3) << 6);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 2 bits                  }                  // Read the 3rd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 2: leave 7 bits                  nextByte |= (byte)(digit << 1);                  // Assert(i < base32.length) // tested before loop                  // Read the 4th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 7: insert 1 bit' leave 4 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 4));                  nextByte = (byte)((digit & 15) << 4);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 4 bits                  }                  // Read the 5th char in a 8-chars subblock                  // Assert that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 4: insert 4 bits' leave 1 bit                  bytes[offset++] = (byte)(nextByte | (digit >> 1));                  nextByte = (byte)((digit & 1) << 7);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 1 bit                  }                  // Read the 6th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 1: leave 6 bits                  nextByte |= (byte)(digit << 2);                  // Assert(i < base32.length) // tested before loop                  // Read the 7th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 6: insert 2 bits' leave 3 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 3));                  nextByte = (byte)((digit & 7) << 5);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 3 bits                  }                  // Read the 8th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 3: insert 5 bits' leave 0 bit                  bytes[offset++] = (byte)(nextByte | digit);                  //// possible end of string here with no trailing bits              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Decode,The following statement contains a magic number: while (i < len)              {                  // Read the 1st char in a 8-chars subblock                  // check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 0: leave 5 bits                  nextByte = (byte)(digit << 3);                  // Assert(i < base32.length) // tested before loop                  // Read the 2nd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 5: insert 3 bits' leave 2 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 2));                  nextByte = (byte)((digit & 3) << 6);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 2 bits                  }                  // Read the 3rd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 2: leave 7 bits                  nextByte |= (byte)(digit << 1);                  // Assert(i < base32.length) // tested before loop                  // Read the 4th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 7: insert 1 bit' leave 4 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 4));                  nextByte = (byte)((digit & 15) << 4);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 4 bits                  }                  // Read the 5th char in a 8-chars subblock                  // Assert that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 4: insert 4 bits' leave 1 bit                  bytes[offset++] = (byte)(nextByte | (digit >> 1));                  nextByte = (byte)((digit & 1) << 7);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 1 bit                  }                  // Read the 6th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 1: leave 6 bits                  nextByte |= (byte)(digit << 2);                  // Assert(i < base32.length) // tested before loop                  // Read the 7th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 6: insert 2 bits' leave 3 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 3));                  nextByte = (byte)((digit & 7) << 5);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 3 bits                  }                  // Read the 8th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 3: insert 5 bits' leave 0 bit                  bytes[offset++] = (byte)(nextByte | digit);                  //// possible end of string here with no trailing bits              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Decode,The following statement contains a magic number: while (i < len)              {                  // Read the 1st char in a 8-chars subblock                  // check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 0: leave 5 bits                  nextByte = (byte)(digit << 3);                  // Assert(i < base32.length) // tested before loop                  // Read the 2nd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 5: insert 3 bits' leave 2 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 2));                  nextByte = (byte)((digit & 3) << 6);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 2 bits                  }                  // Read the 3rd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 2: leave 7 bits                  nextByte |= (byte)(digit << 1);                  // Assert(i < base32.length) // tested before loop                  // Read the 4th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 7: insert 1 bit' leave 4 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 4));                  nextByte = (byte)((digit & 15) << 4);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 4 bits                  }                  // Read the 5th char in a 8-chars subblock                  // Assert that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 4: insert 4 bits' leave 1 bit                  bytes[offset++] = (byte)(nextByte | (digit >> 1));                  nextByte = (byte)((digit & 1) << 7);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 1 bit                  }                  // Read the 6th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 1: leave 6 bits                  nextByte |= (byte)(digit << 2);                  // Assert(i < base32.length) // tested before loop                  // Read the 7th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 6: insert 2 bits' leave 3 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 3));                  nextByte = (byte)((digit & 7) << 5);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 3 bits                  }                  // Read the 8th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 3: insert 5 bits' leave 0 bit                  bytes[offset++] = (byte)(nextByte | digit);                  //// possible end of string here with no trailing bits              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Decode,The following statement contains a magic number: while (i < len)              {                  // Read the 1st char in a 8-chars subblock                  // check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 0: leave 5 bits                  nextByte = (byte)(digit << 3);                  // Assert(i < base32.length) // tested before loop                  // Read the 2nd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 5: insert 3 bits' leave 2 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 2));                  nextByte = (byte)((digit & 3) << 6);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 2 bits                  }                  // Read the 3rd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 2: leave 7 bits                  nextByte |= (byte)(digit << 1);                  // Assert(i < base32.length) // tested before loop                  // Read the 4th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 7: insert 1 bit' leave 4 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 4));                  nextByte = (byte)((digit & 15) << 4);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 4 bits                  }                  // Read the 5th char in a 8-chars subblock                  // Assert that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 4: insert 4 bits' leave 1 bit                  bytes[offset++] = (byte)(nextByte | (digit >> 1));                  nextByte = (byte)((digit & 1) << 7);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 1 bit                  }                  // Read the 6th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 1: leave 6 bits                  nextByte |= (byte)(digit << 2);                  // Assert(i < base32.length) // tested before loop                  // Read the 7th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 6: insert 2 bits' leave 3 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 3));                  nextByte = (byte)((digit & 7) << 5);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 3 bits                  }                  // Read the 8th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 3: insert 5 bits' leave 0 bit                  bytes[offset++] = (byte)(nextByte | digit);                  //// possible end of string here with no trailing bits              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Decode,The following statement contains a magic number: while (i < len)              {                  // Read the 1st char in a 8-chars subblock                  // check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 0: leave 5 bits                  nextByte = (byte)(digit << 3);                  // Assert(i < base32.length) // tested before loop                  // Read the 2nd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 5: insert 3 bits' leave 2 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 2));                  nextByte = (byte)((digit & 3) << 6);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 2 bits                  }                  // Read the 3rd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 2: leave 7 bits                  nextByte |= (byte)(digit << 1);                  // Assert(i < base32.length) // tested before loop                  // Read the 4th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 7: insert 1 bit' leave 4 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 4));                  nextByte = (byte)((digit & 15) << 4);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 4 bits                  }                  // Read the 5th char in a 8-chars subblock                  // Assert that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 4: insert 4 bits' leave 1 bit                  bytes[offset++] = (byte)(nextByte | (digit >> 1));                  nextByte = (byte)((digit & 1) << 7);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 1 bit                  }                  // Read the 6th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 1: leave 6 bits                  nextByte |= (byte)(digit << 2);                  // Assert(i < base32.length) // tested before loop                  // Read the 7th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 6: insert 2 bits' leave 3 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 3));                  nextByte = (byte)((digit & 7) << 5);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 3 bits                  }                  // Read the 8th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 3: insert 5 bits' leave 0 bit                  bytes[offset++] = (byte)(nextByte | digit);                  //// possible end of string here with no trailing bits              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Decode,The following statement contains a magic number: while (i < len)              {                  // Read the 1st char in a 8-chars subblock                  // check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 0: leave 5 bits                  nextByte = (byte)(digit << 3);                  // Assert(i < base32.length) // tested before loop                  // Read the 2nd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 5: insert 3 bits' leave 2 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 2));                  nextByte = (byte)((digit & 3) << 6);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 2 bits                  }                  // Read the 3rd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 2: leave 7 bits                  nextByte |= (byte)(digit << 1);                  // Assert(i < base32.length) // tested before loop                  // Read the 4th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 7: insert 1 bit' leave 4 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 4));                  nextByte = (byte)((digit & 15) << 4);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 4 bits                  }                  // Read the 5th char in a 8-chars subblock                  // Assert that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 4: insert 4 bits' leave 1 bit                  bytes[offset++] = (byte)(nextByte | (digit >> 1));                  nextByte = (byte)((digit & 1) << 7);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 1 bit                  }                  // Read the 6th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 1: leave 6 bits                  nextByte |= (byte)(digit << 2);                  // Assert(i < base32.length) // tested before loop                  // Read the 7th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 6: insert 2 bits' leave 3 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 3));                  nextByte = (byte)((digit & 7) << 5);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 3 bits                  }                  // Read the 8th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 3: insert 5 bits' leave 0 bit                  bytes[offset++] = (byte)(nextByte | digit);                  //// possible end of string here with no trailing bits              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Decode,The following statement contains a magic number: while (i < len)              {                  // Read the 1st char in a 8-chars subblock                  // check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 0: leave 5 bits                  nextByte = (byte)(digit << 3);                  // Assert(i < base32.length) // tested before loop                  // Read the 2nd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 5: insert 3 bits' leave 2 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 2));                  nextByte = (byte)((digit & 3) << 6);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 2 bits                  }                  // Read the 3rd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 2: leave 7 bits                  nextByte |= (byte)(digit << 1);                  // Assert(i < base32.length) // tested before loop                  // Read the 4th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 7: insert 1 bit' leave 4 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 4));                  nextByte = (byte)((digit & 15) << 4);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 4 bits                  }                  // Read the 5th char in a 8-chars subblock                  // Assert that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 4: insert 4 bits' leave 1 bit                  bytes[offset++] = (byte)(nextByte | (digit >> 1));                  nextByte = (byte)((digit & 1) << 7);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 1 bit                  }                  // Read the 6th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 1: leave 6 bits                  nextByte |= (byte)(digit << 2);                  // Assert(i < base32.length) // tested before loop                  // Read the 7th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 6: insert 2 bits' leave 3 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 3));                  nextByte = (byte)((digit & 7) << 5);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 3 bits                  }                  // Read the 8th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 3: insert 5 bits' leave 0 bit                  bytes[offset++] = (byte)(nextByte | digit);                  //// possible end of string here with no trailing bits              }
Magic Number,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Decode,The following statement contains a magic number: while (i < len)              {                  // Read the 1st char in a 8-chars subblock                  // check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 0: leave 5 bits                  nextByte = (byte)(digit << 3);                  // Assert(i < base32.length) // tested before loop                  // Read the 2nd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 5: insert 3 bits' leave 2 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 2));                  nextByte = (byte)((digit & 3) << 6);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 2 bits                  }                  // Read the 3rd char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 2: leave 7 bits                  nextByte |= (byte)(digit << 1);                  // Assert(i < base32.length) // tested before loop                  // Read the 4th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 7: insert 1 bit' leave 4 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 4));                  nextByte = (byte)((digit & 15) << 4);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 4 bits                  }                  // Read the 5th char in a 8-chars subblock                  // Assert that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 4: insert 4 bits' leave 1 bit                  bytes[offset++] = (byte)(nextByte | (digit >> 1));                  nextByte = (byte)((digit & 1) << 7);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 1 bit                  }                  // Read the 6th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 1: leave 6 bits                  nextByte |= (byte)(digit << 2);                  // Assert(i < base32.length) // tested before loop                  // Read the 7th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 6: insert 2 bits' leave 3 bits                  bytes[offset++] = (byte)(nextByte | (digit >> 3));                  nextByte = (byte)((digit & 7) << 5);                  if (i >= len)                  {                      if (nextByte != (byte)0)                      {                          throw new ArgumentException(errorCanonicalEnd);                      }                      break; // discard the remaining 3 bits                  }                  // Read the 8th char in a 8-chars subblock                  // Check that chars are not outside the lookup table and valid                  lookup = base32[i++] - '2';                  if (lookup < 0 || lookup >= base32LookupLength)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  digit = base32Lookup[lookup];                  if (digit == XX)                  {                      throw new ArgumentException(errorInvalidChar);                  }                  //// STEP n = 3: insert 5 bits' leave 0 bit                  bytes[offset++] = (byte)(nextByte | digit);                  //// possible end of string here with no trailing bits              }
Magic Number,Serenity.Data,JsonSafeInt64Converter,C:\repos\volkanceylan_serenity\Serenity.Core\Json\JsonSafeInt64Converter.cs,WriteJson,The following statement contains a magic number: if (value == null)                  writer.WriteNull();              else              {                  var intvalue = Convert.ToInt64(value);                  if (intvalue > 9007199254740992 ||                      intvalue < -9007199254740992)                      writer.WriteValue(intvalue.ToString(CultureInfo.InvariantCulture));                  else                      writer.WriteValue(intvalue);              }
Magic Number,Serenity.Data,JsonSafeInt64Converter,C:\repos\volkanceylan_serenity\Serenity.Core\Json\JsonSafeInt64Converter.cs,WriteJson,The following statement contains a magic number: if (value == null)                  writer.WriteNull();              else              {                  var intvalue = Convert.ToInt64(value);                  if (intvalue > 9007199254740992 ||                      intvalue < -9007199254740992)                      writer.WriteValue(intvalue.ToString(CultureInfo.InvariantCulture));                  else                      writer.WriteValue(intvalue);              }
Magic Number,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The following statement contains a magic number: foreach (var glob in globs)              {                  if (string.IsNullOrEmpty(glob))                      continue;                    isActive = true;                    var sep = System.IO.Path.DirectorySeparatorChar;                    var s = glob;                  if (sep == '\\')                      s = glob.Replace('/'' '\\');                    var starDotIndex = s.IndexOf("*.");                    // exact match                  if (s[0] == sep &&                      s[s.Length - 1] != '/' &&                      s[s.Length - 1] != '\\' &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        exactMatch.Add(s.Substring(1));                      continue;                  }                    // simple extension filter (*.txt)                  if (starDotIndex == 0 &&                      s.IndexOfAny(DotAsteriskSlashBackQue' 2) < 0)                  {                      if (extensions == null)                          extensions = new HashSet<string>();                        extensions.Add(s.Substring(1));                      continue;                  }                    // simple extension filter with extra dot (*.csproj.user)                  if (starDotIndex == 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    // subdirectory under root and extension (/bin/some/*.txt)                  if (starDotIndex > 1 &&                      s[starDotIndex - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0 &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 1) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                          s.Substring(1' starDotIndex - 1)' false' s.Substring(starDotIndex + 1)));                        continue;                  }                    // extension under root (/*.txt)                  if (starDotIndex == 1 &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(starDotIndex + 1)));                      continue;                  }                    // directory filter at any depth (.git/)                  if (s[s.Length - 1] == sep &&                      s[0] != sep &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (contains == null)                          contains = new List<string>();                        if (startsWith == null)                          startsWith = new List<string>();                        contains.Add(sep.ToString() + s);                      startsWith.Add(s);                        continue;                  }                    // directory filter at root (/Imports/)                  if (s[s.Length - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskQue) < 0)                  {                      if (startsWith == null)                          startsWith = new List<string>();                        startsWith.Add(s.Substring(1));                      continue;                  }                    // folder than any then extension (App_Data/**/*.log) or (/App_Code/**/*.xyz)                  if (starDotIndex > 4 &&                      s[starDotIndex - 1] == sep &&                      s[starDotIndex - 2] == '*' &&                      s[starDotIndex - 3] == '*' &&                      s[starDotIndex - 4] == sep &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 5) < 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        if (s[0] == sep)                      {                          startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(1' starDotIndex - 4)' true' s.Substring(starDotIndex + 1)));                      }                      else                      {                          if (containsAndEndsWith == null)                              containsAndEndsWith = new List<Tuple<string' bool' string>>();                            startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                            containsAndEndsWith.Add(new Tuple<string' bool' string>(                              sep.ToString() + s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                      }                        continue;                  }                    if (s.IndexOfAny(AsteriskQue) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        if (s[0] == sep)                      {                          exactMatch.Add(s.Substring(0));                      }                      else                      {                          exactMatch.Add(s.Substring(0));                            if (endsWith == null)                              endsWith = new List<string>();                            endsWith.Add(sep + s.Substring(0));                      }                        continue;                  }                    if (s[0] == '*' && s.IndexOfAny(AsteriskSlashBackQue' 1) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    if (s[0] == sep &&                      s.Length > 2 &&                      s[1] == '*' &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(2)));                      continue;                  }                    matchers.Add(ToMatcher(glob));              }
Magic Number,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The following statement contains a magic number: foreach (var glob in globs)              {                  if (string.IsNullOrEmpty(glob))                      continue;                    isActive = true;                    var sep = System.IO.Path.DirectorySeparatorChar;                    var s = glob;                  if (sep == '\\')                      s = glob.Replace('/'' '\\');                    var starDotIndex = s.IndexOf("*.");                    // exact match                  if (s[0] == sep &&                      s[s.Length - 1] != '/' &&                      s[s.Length - 1] != '\\' &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        exactMatch.Add(s.Substring(1));                      continue;                  }                    // simple extension filter (*.txt)                  if (starDotIndex == 0 &&                      s.IndexOfAny(DotAsteriskSlashBackQue' 2) < 0)                  {                      if (extensions == null)                          extensions = new HashSet<string>();                        extensions.Add(s.Substring(1));                      continue;                  }                    // simple extension filter with extra dot (*.csproj.user)                  if (starDotIndex == 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    // subdirectory under root and extension (/bin/some/*.txt)                  if (starDotIndex > 1 &&                      s[starDotIndex - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0 &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 1) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                          s.Substring(1' starDotIndex - 1)' false' s.Substring(starDotIndex + 1)));                        continue;                  }                    // extension under root (/*.txt)                  if (starDotIndex == 1 &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(starDotIndex + 1)));                      continue;                  }                    // directory filter at any depth (.git/)                  if (s[s.Length - 1] == sep &&                      s[0] != sep &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (contains == null)                          contains = new List<string>();                        if (startsWith == null)                          startsWith = new List<string>();                        contains.Add(sep.ToString() + s);                      startsWith.Add(s);                        continue;                  }                    // directory filter at root (/Imports/)                  if (s[s.Length - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskQue) < 0)                  {                      if (startsWith == null)                          startsWith = new List<string>();                        startsWith.Add(s.Substring(1));                      continue;                  }                    // folder than any then extension (App_Data/**/*.log) or (/App_Code/**/*.xyz)                  if (starDotIndex > 4 &&                      s[starDotIndex - 1] == sep &&                      s[starDotIndex - 2] == '*' &&                      s[starDotIndex - 3] == '*' &&                      s[starDotIndex - 4] == sep &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 5) < 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        if (s[0] == sep)                      {                          startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(1' starDotIndex - 4)' true' s.Substring(starDotIndex + 1)));                      }                      else                      {                          if (containsAndEndsWith == null)                              containsAndEndsWith = new List<Tuple<string' bool' string>>();                            startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                            containsAndEndsWith.Add(new Tuple<string' bool' string>(                              sep.ToString() + s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                      }                        continue;                  }                    if (s.IndexOfAny(AsteriskQue) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        if (s[0] == sep)                      {                          exactMatch.Add(s.Substring(0));                      }                      else                      {                          exactMatch.Add(s.Substring(0));                            if (endsWith == null)                              endsWith = new List<string>();                            endsWith.Add(sep + s.Substring(0));                      }                        continue;                  }                    if (s[0] == '*' && s.IndexOfAny(AsteriskSlashBackQue' 1) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    if (s[0] == sep &&                      s.Length > 2 &&                      s[1] == '*' &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(2)));                      continue;                  }                    matchers.Add(ToMatcher(glob));              }
Magic Number,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The following statement contains a magic number: foreach (var glob in globs)              {                  if (string.IsNullOrEmpty(glob))                      continue;                    isActive = true;                    var sep = System.IO.Path.DirectorySeparatorChar;                    var s = glob;                  if (sep == '\\')                      s = glob.Replace('/'' '\\');                    var starDotIndex = s.IndexOf("*.");                    // exact match                  if (s[0] == sep &&                      s[s.Length - 1] != '/' &&                      s[s.Length - 1] != '\\' &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        exactMatch.Add(s.Substring(1));                      continue;                  }                    // simple extension filter (*.txt)                  if (starDotIndex == 0 &&                      s.IndexOfAny(DotAsteriskSlashBackQue' 2) < 0)                  {                      if (extensions == null)                          extensions = new HashSet<string>();                        extensions.Add(s.Substring(1));                      continue;                  }                    // simple extension filter with extra dot (*.csproj.user)                  if (starDotIndex == 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    // subdirectory under root and extension (/bin/some/*.txt)                  if (starDotIndex > 1 &&                      s[starDotIndex - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0 &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 1) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                          s.Substring(1' starDotIndex - 1)' false' s.Substring(starDotIndex + 1)));                        continue;                  }                    // extension under root (/*.txt)                  if (starDotIndex == 1 &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(starDotIndex + 1)));                      continue;                  }                    // directory filter at any depth (.git/)                  if (s[s.Length - 1] == sep &&                      s[0] != sep &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (contains == null)                          contains = new List<string>();                        if (startsWith == null)                          startsWith = new List<string>();                        contains.Add(sep.ToString() + s);                      startsWith.Add(s);                        continue;                  }                    // directory filter at root (/Imports/)                  if (s[s.Length - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskQue) < 0)                  {                      if (startsWith == null)                          startsWith = new List<string>();                        startsWith.Add(s.Substring(1));                      continue;                  }                    // folder than any then extension (App_Data/**/*.log) or (/App_Code/**/*.xyz)                  if (starDotIndex > 4 &&                      s[starDotIndex - 1] == sep &&                      s[starDotIndex - 2] == '*' &&                      s[starDotIndex - 3] == '*' &&                      s[starDotIndex - 4] == sep &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 5) < 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        if (s[0] == sep)                      {                          startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(1' starDotIndex - 4)' true' s.Substring(starDotIndex + 1)));                      }                      else                      {                          if (containsAndEndsWith == null)                              containsAndEndsWith = new List<Tuple<string' bool' string>>();                            startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                            containsAndEndsWith.Add(new Tuple<string' bool' string>(                              sep.ToString() + s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                      }                        continue;                  }                    if (s.IndexOfAny(AsteriskQue) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        if (s[0] == sep)                      {                          exactMatch.Add(s.Substring(0));                      }                      else                      {                          exactMatch.Add(s.Substring(0));                            if (endsWith == null)                              endsWith = new List<string>();                            endsWith.Add(sep + s.Substring(0));                      }                        continue;                  }                    if (s[0] == '*' && s.IndexOfAny(AsteriskSlashBackQue' 1) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    if (s[0] == sep &&                      s.Length > 2 &&                      s[1] == '*' &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(2)));                      continue;                  }                    matchers.Add(ToMatcher(glob));              }
Magic Number,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The following statement contains a magic number: foreach (var glob in globs)              {                  if (string.IsNullOrEmpty(glob))                      continue;                    isActive = true;                    var sep = System.IO.Path.DirectorySeparatorChar;                    var s = glob;                  if (sep == '\\')                      s = glob.Replace('/'' '\\');                    var starDotIndex = s.IndexOf("*.");                    // exact match                  if (s[0] == sep &&                      s[s.Length - 1] != '/' &&                      s[s.Length - 1] != '\\' &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        exactMatch.Add(s.Substring(1));                      continue;                  }                    // simple extension filter (*.txt)                  if (starDotIndex == 0 &&                      s.IndexOfAny(DotAsteriskSlashBackQue' 2) < 0)                  {                      if (extensions == null)                          extensions = new HashSet<string>();                        extensions.Add(s.Substring(1));                      continue;                  }                    // simple extension filter with extra dot (*.csproj.user)                  if (starDotIndex == 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    // subdirectory under root and extension (/bin/some/*.txt)                  if (starDotIndex > 1 &&                      s[starDotIndex - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0 &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 1) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                          s.Substring(1' starDotIndex - 1)' false' s.Substring(starDotIndex + 1)));                        continue;                  }                    // extension under root (/*.txt)                  if (starDotIndex == 1 &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(starDotIndex + 1)));                      continue;                  }                    // directory filter at any depth (.git/)                  if (s[s.Length - 1] == sep &&                      s[0] != sep &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (contains == null)                          contains = new List<string>();                        if (startsWith == null)                          startsWith = new List<string>();                        contains.Add(sep.ToString() + s);                      startsWith.Add(s);                        continue;                  }                    // directory filter at root (/Imports/)                  if (s[s.Length - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskQue) < 0)                  {                      if (startsWith == null)                          startsWith = new List<string>();                        startsWith.Add(s.Substring(1));                      continue;                  }                    // folder than any then extension (App_Data/**/*.log) or (/App_Code/**/*.xyz)                  if (starDotIndex > 4 &&                      s[starDotIndex - 1] == sep &&                      s[starDotIndex - 2] == '*' &&                      s[starDotIndex - 3] == '*' &&                      s[starDotIndex - 4] == sep &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 5) < 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        if (s[0] == sep)                      {                          startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(1' starDotIndex - 4)' true' s.Substring(starDotIndex + 1)));                      }                      else                      {                          if (containsAndEndsWith == null)                              containsAndEndsWith = new List<Tuple<string' bool' string>>();                            startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                            containsAndEndsWith.Add(new Tuple<string' bool' string>(                              sep.ToString() + s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                      }                        continue;                  }                    if (s.IndexOfAny(AsteriskQue) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        if (s[0] == sep)                      {                          exactMatch.Add(s.Substring(0));                      }                      else                      {                          exactMatch.Add(s.Substring(0));                            if (endsWith == null)                              endsWith = new List<string>();                            endsWith.Add(sep + s.Substring(0));                      }                        continue;                  }                    if (s[0] == '*' && s.IndexOfAny(AsteriskSlashBackQue' 1) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    if (s[0] == sep &&                      s.Length > 2 &&                      s[1] == '*' &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(2)));                      continue;                  }                    matchers.Add(ToMatcher(glob));              }
Magic Number,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The following statement contains a magic number: foreach (var glob in globs)              {                  if (string.IsNullOrEmpty(glob))                      continue;                    isActive = true;                    var sep = System.IO.Path.DirectorySeparatorChar;                    var s = glob;                  if (sep == '\\')                      s = glob.Replace('/'' '\\');                    var starDotIndex = s.IndexOf("*.");                    // exact match                  if (s[0] == sep &&                      s[s.Length - 1] != '/' &&                      s[s.Length - 1] != '\\' &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        exactMatch.Add(s.Substring(1));                      continue;                  }                    // simple extension filter (*.txt)                  if (starDotIndex == 0 &&                      s.IndexOfAny(DotAsteriskSlashBackQue' 2) < 0)                  {                      if (extensions == null)                          extensions = new HashSet<string>();                        extensions.Add(s.Substring(1));                      continue;                  }                    // simple extension filter with extra dot (*.csproj.user)                  if (starDotIndex == 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    // subdirectory under root and extension (/bin/some/*.txt)                  if (starDotIndex > 1 &&                      s[starDotIndex - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0 &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 1) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                          s.Substring(1' starDotIndex - 1)' false' s.Substring(starDotIndex + 1)));                        continue;                  }                    // extension under root (/*.txt)                  if (starDotIndex == 1 &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(starDotIndex + 1)));                      continue;                  }                    // directory filter at any depth (.git/)                  if (s[s.Length - 1] == sep &&                      s[0] != sep &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (contains == null)                          contains = new List<string>();                        if (startsWith == null)                          startsWith = new List<string>();                        contains.Add(sep.ToString() + s);                      startsWith.Add(s);                        continue;                  }                    // directory filter at root (/Imports/)                  if (s[s.Length - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskQue) < 0)                  {                      if (startsWith == null)                          startsWith = new List<string>();                        startsWith.Add(s.Substring(1));                      continue;                  }                    // folder than any then extension (App_Data/**/*.log) or (/App_Code/**/*.xyz)                  if (starDotIndex > 4 &&                      s[starDotIndex - 1] == sep &&                      s[starDotIndex - 2] == '*' &&                      s[starDotIndex - 3] == '*' &&                      s[starDotIndex - 4] == sep &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 5) < 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        if (s[0] == sep)                      {                          startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(1' starDotIndex - 4)' true' s.Substring(starDotIndex + 1)));                      }                      else                      {                          if (containsAndEndsWith == null)                              containsAndEndsWith = new List<Tuple<string' bool' string>>();                            startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                            containsAndEndsWith.Add(new Tuple<string' bool' string>(                              sep.ToString() + s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                      }                        continue;                  }                    if (s.IndexOfAny(AsteriskQue) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        if (s[0] == sep)                      {                          exactMatch.Add(s.Substring(0));                      }                      else                      {                          exactMatch.Add(s.Substring(0));                            if (endsWith == null)                              endsWith = new List<string>();                            endsWith.Add(sep + s.Substring(0));                      }                        continue;                  }                    if (s[0] == '*' && s.IndexOfAny(AsteriskSlashBackQue' 1) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    if (s[0] == sep &&                      s.Length > 2 &&                      s[1] == '*' &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(2)));                      continue;                  }                    matchers.Add(ToMatcher(glob));              }
Magic Number,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The following statement contains a magic number: foreach (var glob in globs)              {                  if (string.IsNullOrEmpty(glob))                      continue;                    isActive = true;                    var sep = System.IO.Path.DirectorySeparatorChar;                    var s = glob;                  if (sep == '\\')                      s = glob.Replace('/'' '\\');                    var starDotIndex = s.IndexOf("*.");                    // exact match                  if (s[0] == sep &&                      s[s.Length - 1] != '/' &&                      s[s.Length - 1] != '\\' &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        exactMatch.Add(s.Substring(1));                      continue;                  }                    // simple extension filter (*.txt)                  if (starDotIndex == 0 &&                      s.IndexOfAny(DotAsteriskSlashBackQue' 2) < 0)                  {                      if (extensions == null)                          extensions = new HashSet<string>();                        extensions.Add(s.Substring(1));                      continue;                  }                    // simple extension filter with extra dot (*.csproj.user)                  if (starDotIndex == 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    // subdirectory under root and extension (/bin/some/*.txt)                  if (starDotIndex > 1 &&                      s[starDotIndex - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0 &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 1) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                          s.Substring(1' starDotIndex - 1)' false' s.Substring(starDotIndex + 1)));                        continue;                  }                    // extension under root (/*.txt)                  if (starDotIndex == 1 &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(starDotIndex + 1)));                      continue;                  }                    // directory filter at any depth (.git/)                  if (s[s.Length - 1] == sep &&                      s[0] != sep &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (contains == null)                          contains = new List<string>();                        if (startsWith == null)                          startsWith = new List<string>();                        contains.Add(sep.ToString() + s);                      startsWith.Add(s);                        continue;                  }                    // directory filter at root (/Imports/)                  if (s[s.Length - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskQue) < 0)                  {                      if (startsWith == null)                          startsWith = new List<string>();                        startsWith.Add(s.Substring(1));                      continue;                  }                    // folder than any then extension (App_Data/**/*.log) or (/App_Code/**/*.xyz)                  if (starDotIndex > 4 &&                      s[starDotIndex - 1] == sep &&                      s[starDotIndex - 2] == '*' &&                      s[starDotIndex - 3] == '*' &&                      s[starDotIndex - 4] == sep &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 5) < 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        if (s[0] == sep)                      {                          startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(1' starDotIndex - 4)' true' s.Substring(starDotIndex + 1)));                      }                      else                      {                          if (containsAndEndsWith == null)                              containsAndEndsWith = new List<Tuple<string' bool' string>>();                            startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                            containsAndEndsWith.Add(new Tuple<string' bool' string>(                              sep.ToString() + s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                      }                        continue;                  }                    if (s.IndexOfAny(AsteriskQue) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        if (s[0] == sep)                      {                          exactMatch.Add(s.Substring(0));                      }                      else                      {                          exactMatch.Add(s.Substring(0));                            if (endsWith == null)                              endsWith = new List<string>();                            endsWith.Add(sep + s.Substring(0));                      }                        continue;                  }                    if (s[0] == '*' && s.IndexOfAny(AsteriskSlashBackQue' 1) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    if (s[0] == sep &&                      s.Length > 2 &&                      s[1] == '*' &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(2)));                      continue;                  }                    matchers.Add(ToMatcher(glob));              }
Magic Number,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The following statement contains a magic number: foreach (var glob in globs)              {                  if (string.IsNullOrEmpty(glob))                      continue;                    isActive = true;                    var sep = System.IO.Path.DirectorySeparatorChar;                    var s = glob;                  if (sep == '\\')                      s = glob.Replace('/'' '\\');                    var starDotIndex = s.IndexOf("*.");                    // exact match                  if (s[0] == sep &&                      s[s.Length - 1] != '/' &&                      s[s.Length - 1] != '\\' &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        exactMatch.Add(s.Substring(1));                      continue;                  }                    // simple extension filter (*.txt)                  if (starDotIndex == 0 &&                      s.IndexOfAny(DotAsteriskSlashBackQue' 2) < 0)                  {                      if (extensions == null)                          extensions = new HashSet<string>();                        extensions.Add(s.Substring(1));                      continue;                  }                    // simple extension filter with extra dot (*.csproj.user)                  if (starDotIndex == 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    // subdirectory under root and extension (/bin/some/*.txt)                  if (starDotIndex > 1 &&                      s[starDotIndex - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0 &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 1) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                          s.Substring(1' starDotIndex - 1)' false' s.Substring(starDotIndex + 1)));                        continue;                  }                    // extension under root (/*.txt)                  if (starDotIndex == 1 &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(starDotIndex + 1)));                      continue;                  }                    // directory filter at any depth (.git/)                  if (s[s.Length - 1] == sep &&                      s[0] != sep &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (contains == null)                          contains = new List<string>();                        if (startsWith == null)                          startsWith = new List<string>();                        contains.Add(sep.ToString() + s);                      startsWith.Add(s);                        continue;                  }                    // directory filter at root (/Imports/)                  if (s[s.Length - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskQue) < 0)                  {                      if (startsWith == null)                          startsWith = new List<string>();                        startsWith.Add(s.Substring(1));                      continue;                  }                    // folder than any then extension (App_Data/**/*.log) or (/App_Code/**/*.xyz)                  if (starDotIndex > 4 &&                      s[starDotIndex - 1] == sep &&                      s[starDotIndex - 2] == '*' &&                      s[starDotIndex - 3] == '*' &&                      s[starDotIndex - 4] == sep &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 5) < 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        if (s[0] == sep)                      {                          startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(1' starDotIndex - 4)' true' s.Substring(starDotIndex + 1)));                      }                      else                      {                          if (containsAndEndsWith == null)                              containsAndEndsWith = new List<Tuple<string' bool' string>>();                            startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                            containsAndEndsWith.Add(new Tuple<string' bool' string>(                              sep.ToString() + s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                      }                        continue;                  }                    if (s.IndexOfAny(AsteriskQue) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        if (s[0] == sep)                      {                          exactMatch.Add(s.Substring(0));                      }                      else                      {                          exactMatch.Add(s.Substring(0));                            if (endsWith == null)                              endsWith = new List<string>();                            endsWith.Add(sep + s.Substring(0));                      }                        continue;                  }                    if (s[0] == '*' && s.IndexOfAny(AsteriskSlashBackQue' 1) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    if (s[0] == sep &&                      s.Length > 2 &&                      s[1] == '*' &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(2)));                      continue;                  }                    matchers.Add(ToMatcher(glob));              }
Magic Number,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The following statement contains a magic number: foreach (var glob in globs)              {                  if (string.IsNullOrEmpty(glob))                      continue;                    isActive = true;                    var sep = System.IO.Path.DirectorySeparatorChar;                    var s = glob;                  if (sep == '\\')                      s = glob.Replace('/'' '\\');                    var starDotIndex = s.IndexOf("*.");                    // exact match                  if (s[0] == sep &&                      s[s.Length - 1] != '/' &&                      s[s.Length - 1] != '\\' &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        exactMatch.Add(s.Substring(1));                      continue;                  }                    // simple extension filter (*.txt)                  if (starDotIndex == 0 &&                      s.IndexOfAny(DotAsteriskSlashBackQue' 2) < 0)                  {                      if (extensions == null)                          extensions = new HashSet<string>();                        extensions.Add(s.Substring(1));                      continue;                  }                    // simple extension filter with extra dot (*.csproj.user)                  if (starDotIndex == 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    // subdirectory under root and extension (/bin/some/*.txt)                  if (starDotIndex > 1 &&                      s[starDotIndex - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0 &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 1) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                          s.Substring(1' starDotIndex - 1)' false' s.Substring(starDotIndex + 1)));                        continue;                  }                    // extension under root (/*.txt)                  if (starDotIndex == 1 &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(starDotIndex + 1)));                      continue;                  }                    // directory filter at any depth (.git/)                  if (s[s.Length - 1] == sep &&                      s[0] != sep &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (contains == null)                          contains = new List<string>();                        if (startsWith == null)                          startsWith = new List<string>();                        contains.Add(sep.ToString() + s);                      startsWith.Add(s);                        continue;                  }                    // directory filter at root (/Imports/)                  if (s[s.Length - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskQue) < 0)                  {                      if (startsWith == null)                          startsWith = new List<string>();                        startsWith.Add(s.Substring(1));                      continue;                  }                    // folder than any then extension (App_Data/**/*.log) or (/App_Code/**/*.xyz)                  if (starDotIndex > 4 &&                      s[starDotIndex - 1] == sep &&                      s[starDotIndex - 2] == '*' &&                      s[starDotIndex - 3] == '*' &&                      s[starDotIndex - 4] == sep &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 5) < 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        if (s[0] == sep)                      {                          startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(1' starDotIndex - 4)' true' s.Substring(starDotIndex + 1)));                      }                      else                      {                          if (containsAndEndsWith == null)                              containsAndEndsWith = new List<Tuple<string' bool' string>>();                            startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                            containsAndEndsWith.Add(new Tuple<string' bool' string>(                              sep.ToString() + s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                      }                        continue;                  }                    if (s.IndexOfAny(AsteriskQue) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        if (s[0] == sep)                      {                          exactMatch.Add(s.Substring(0));                      }                      else                      {                          exactMatch.Add(s.Substring(0));                            if (endsWith == null)                              endsWith = new List<string>();                            endsWith.Add(sep + s.Substring(0));                      }                        continue;                  }                    if (s[0] == '*' && s.IndexOfAny(AsteriskSlashBackQue' 1) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    if (s[0] == sep &&                      s.Length > 2 &&                      s[1] == '*' &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(2)));                      continue;                  }                    matchers.Add(ToMatcher(glob));              }
Magic Number,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The following statement contains a magic number: foreach (var glob in globs)              {                  if (string.IsNullOrEmpty(glob))                      continue;                    isActive = true;                    var sep = System.IO.Path.DirectorySeparatorChar;                    var s = glob;                  if (sep == '\\')                      s = glob.Replace('/'' '\\');                    var starDotIndex = s.IndexOf("*.");                    // exact match                  if (s[0] == sep &&                      s[s.Length - 1] != '/' &&                      s[s.Length - 1] != '\\' &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        exactMatch.Add(s.Substring(1));                      continue;                  }                    // simple extension filter (*.txt)                  if (starDotIndex == 0 &&                      s.IndexOfAny(DotAsteriskSlashBackQue' 2) < 0)                  {                      if (extensions == null)                          extensions = new HashSet<string>();                        extensions.Add(s.Substring(1));                      continue;                  }                    // simple extension filter with extra dot (*.csproj.user)                  if (starDotIndex == 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    // subdirectory under root and extension (/bin/some/*.txt)                  if (starDotIndex > 1 &&                      s[starDotIndex - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0 &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 1) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                          s.Substring(1' starDotIndex - 1)' false' s.Substring(starDotIndex + 1)));                        continue;                  }                    // extension under root (/*.txt)                  if (starDotIndex == 1 &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(starDotIndex + 1)));                      continue;                  }                    // directory filter at any depth (.git/)                  if (s[s.Length - 1] == sep &&                      s[0] != sep &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (contains == null)                          contains = new List<string>();                        if (startsWith == null)                          startsWith = new List<string>();                        contains.Add(sep.ToString() + s);                      startsWith.Add(s);                        continue;                  }                    // directory filter at root (/Imports/)                  if (s[s.Length - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskQue) < 0)                  {                      if (startsWith == null)                          startsWith = new List<string>();                        startsWith.Add(s.Substring(1));                      continue;                  }                    // folder than any then extension (App_Data/**/*.log) or (/App_Code/**/*.xyz)                  if (starDotIndex > 4 &&                      s[starDotIndex - 1] == sep &&                      s[starDotIndex - 2] == '*' &&                      s[starDotIndex - 3] == '*' &&                      s[starDotIndex - 4] == sep &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 5) < 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        if (s[0] == sep)                      {                          startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(1' starDotIndex - 4)' true' s.Substring(starDotIndex + 1)));                      }                      else                      {                          if (containsAndEndsWith == null)                              containsAndEndsWith = new List<Tuple<string' bool' string>>();                            startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                            containsAndEndsWith.Add(new Tuple<string' bool' string>(                              sep.ToString() + s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                      }                        continue;                  }                    if (s.IndexOfAny(AsteriskQue) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        if (s[0] == sep)                      {                          exactMatch.Add(s.Substring(0));                      }                      else                      {                          exactMatch.Add(s.Substring(0));                            if (endsWith == null)                              endsWith = new List<string>();                            endsWith.Add(sep + s.Substring(0));                      }                        continue;                  }                    if (s[0] == '*' && s.IndexOfAny(AsteriskSlashBackQue' 1) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    if (s[0] == sep &&                      s.Length > 2 &&                      s[1] == '*' &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(2)));                      continue;                  }                    matchers.Add(ToMatcher(glob));              }
Magic Number,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The following statement contains a magic number: foreach (var glob in globs)              {                  if (string.IsNullOrEmpty(glob))                      continue;                    isActive = true;                    var sep = System.IO.Path.DirectorySeparatorChar;                    var s = glob;                  if (sep == '\\')                      s = glob.Replace('/'' '\\');                    var starDotIndex = s.IndexOf("*.");                    // exact match                  if (s[0] == sep &&                      s[s.Length - 1] != '/' &&                      s[s.Length - 1] != '\\' &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        exactMatch.Add(s.Substring(1));                      continue;                  }                    // simple extension filter (*.txt)                  if (starDotIndex == 0 &&                      s.IndexOfAny(DotAsteriskSlashBackQue' 2) < 0)                  {                      if (extensions == null)                          extensions = new HashSet<string>();                        extensions.Add(s.Substring(1));                      continue;                  }                    // simple extension filter with extra dot (*.csproj.user)                  if (starDotIndex == 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    // subdirectory under root and extension (/bin/some/*.txt)                  if (starDotIndex > 1 &&                      s[starDotIndex - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0 &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 1) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                          s.Substring(1' starDotIndex - 1)' false' s.Substring(starDotIndex + 1)));                        continue;                  }                    // extension under root (/*.txt)                  if (starDotIndex == 1 &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(starDotIndex + 1)));                      continue;                  }                    // directory filter at any depth (.git/)                  if (s[s.Length - 1] == sep &&                      s[0] != sep &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (contains == null)                          contains = new List<string>();                        if (startsWith == null)                          startsWith = new List<string>();                        contains.Add(sep.ToString() + s);                      startsWith.Add(s);                        continue;                  }                    // directory filter at root (/Imports/)                  if (s[s.Length - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskQue) < 0)                  {                      if (startsWith == null)                          startsWith = new List<string>();                        startsWith.Add(s.Substring(1));                      continue;                  }                    // folder than any then extension (App_Data/**/*.log) or (/App_Code/**/*.xyz)                  if (starDotIndex > 4 &&                      s[starDotIndex - 1] == sep &&                      s[starDotIndex - 2] == '*' &&                      s[starDotIndex - 3] == '*' &&                      s[starDotIndex - 4] == sep &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 5) < 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        if (s[0] == sep)                      {                          startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(1' starDotIndex - 4)' true' s.Substring(starDotIndex + 1)));                      }                      else                      {                          if (containsAndEndsWith == null)                              containsAndEndsWith = new List<Tuple<string' bool' string>>();                            startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                            containsAndEndsWith.Add(new Tuple<string' bool' string>(                              sep.ToString() + s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                      }                        continue;                  }                    if (s.IndexOfAny(AsteriskQue) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        if (s[0] == sep)                      {                          exactMatch.Add(s.Substring(0));                      }                      else                      {                          exactMatch.Add(s.Substring(0));                            if (endsWith == null)                              endsWith = new List<string>();                            endsWith.Add(sep + s.Substring(0));                      }                        continue;                  }                    if (s[0] == '*' && s.IndexOfAny(AsteriskSlashBackQue' 1) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    if (s[0] == sep &&                      s.Length > 2 &&                      s[1] == '*' &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(2)));                      continue;                  }                    matchers.Add(ToMatcher(glob));              }
Magic Number,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The following statement contains a magic number: foreach (var glob in globs)              {                  if (string.IsNullOrEmpty(glob))                      continue;                    isActive = true;                    var sep = System.IO.Path.DirectorySeparatorChar;                    var s = glob;                  if (sep == '\\')                      s = glob.Replace('/'' '\\');                    var starDotIndex = s.IndexOf("*.");                    // exact match                  if (s[0] == sep &&                      s[s.Length - 1] != '/' &&                      s[s.Length - 1] != '\\' &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        exactMatch.Add(s.Substring(1));                      continue;                  }                    // simple extension filter (*.txt)                  if (starDotIndex == 0 &&                      s.IndexOfAny(DotAsteriskSlashBackQue' 2) < 0)                  {                      if (extensions == null)                          extensions = new HashSet<string>();                        extensions.Add(s.Substring(1));                      continue;                  }                    // simple extension filter with extra dot (*.csproj.user)                  if (starDotIndex == 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    // subdirectory under root and extension (/bin/some/*.txt)                  if (starDotIndex > 1 &&                      s[starDotIndex - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0 &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 1) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                          s.Substring(1' starDotIndex - 1)' false' s.Substring(starDotIndex + 1)));                        continue;                  }                    // extension under root (/*.txt)                  if (starDotIndex == 1 &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(starDotIndex + 1)));                      continue;                  }                    // directory filter at any depth (.git/)                  if (s[s.Length - 1] == sep &&                      s[0] != sep &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (contains == null)                          contains = new List<string>();                        if (startsWith == null)                          startsWith = new List<string>();                        contains.Add(sep.ToString() + s);                      startsWith.Add(s);                        continue;                  }                    // directory filter at root (/Imports/)                  if (s[s.Length - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskQue) < 0)                  {                      if (startsWith == null)                          startsWith = new List<string>();                        startsWith.Add(s.Substring(1));                      continue;                  }                    // folder than any then extension (App_Data/**/*.log) or (/App_Code/**/*.xyz)                  if (starDotIndex > 4 &&                      s[starDotIndex - 1] == sep &&                      s[starDotIndex - 2] == '*' &&                      s[starDotIndex - 3] == '*' &&                      s[starDotIndex - 4] == sep &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 5) < 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        if (s[0] == sep)                      {                          startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(1' starDotIndex - 4)' true' s.Substring(starDotIndex + 1)));                      }                      else                      {                          if (containsAndEndsWith == null)                              containsAndEndsWith = new List<Tuple<string' bool' string>>();                            startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                            containsAndEndsWith.Add(new Tuple<string' bool' string>(                              sep.ToString() + s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                      }                        continue;                  }                    if (s.IndexOfAny(AsteriskQue) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        if (s[0] == sep)                      {                          exactMatch.Add(s.Substring(0));                      }                      else                      {                          exactMatch.Add(s.Substring(0));                            if (endsWith == null)                              endsWith = new List<string>();                            endsWith.Add(sep + s.Substring(0));                      }                        continue;                  }                    if (s[0] == '*' && s.IndexOfAny(AsteriskSlashBackQue' 1) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    if (s[0] == sep &&                      s.Length > 2 &&                      s[1] == '*' &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(2)));                      continue;                  }                    matchers.Add(ToMatcher(glob));              }
Magic Number,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The following statement contains a magic number: foreach (var glob in globs)              {                  if (string.IsNullOrEmpty(glob))                      continue;                    isActive = true;                    var sep = System.IO.Path.DirectorySeparatorChar;                    var s = glob;                  if (sep == '\\')                      s = glob.Replace('/'' '\\');                    var starDotIndex = s.IndexOf("*.");                    // exact match                  if (s[0] == sep &&                      s[s.Length - 1] != '/' &&                      s[s.Length - 1] != '\\' &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        exactMatch.Add(s.Substring(1));                      continue;                  }                    // simple extension filter (*.txt)                  if (starDotIndex == 0 &&                      s.IndexOfAny(DotAsteriskSlashBackQue' 2) < 0)                  {                      if (extensions == null)                          extensions = new HashSet<string>();                        extensions.Add(s.Substring(1));                      continue;                  }                    // simple extension filter with extra dot (*.csproj.user)                  if (starDotIndex == 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    // subdirectory under root and extension (/bin/some/*.txt)                  if (starDotIndex > 1 &&                      s[starDotIndex - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0 &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 1) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                          s.Substring(1' starDotIndex - 1)' false' s.Substring(starDotIndex + 1)));                        continue;                  }                    // extension under root (/*.txt)                  if (starDotIndex == 1 &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(starDotIndex + 1)));                      continue;                  }                    // directory filter at any depth (.git/)                  if (s[s.Length - 1] == sep &&                      s[0] != sep &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (contains == null)                          contains = new List<string>();                        if (startsWith == null)                          startsWith = new List<string>();                        contains.Add(sep.ToString() + s);                      startsWith.Add(s);                        continue;                  }                    // directory filter at root (/Imports/)                  if (s[s.Length - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskQue) < 0)                  {                      if (startsWith == null)                          startsWith = new List<string>();                        startsWith.Add(s.Substring(1));                      continue;                  }                    // folder than any then extension (App_Data/**/*.log) or (/App_Code/**/*.xyz)                  if (starDotIndex > 4 &&                      s[starDotIndex - 1] == sep &&                      s[starDotIndex - 2] == '*' &&                      s[starDotIndex - 3] == '*' &&                      s[starDotIndex - 4] == sep &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 5) < 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        if (s[0] == sep)                      {                          startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(1' starDotIndex - 4)' true' s.Substring(starDotIndex + 1)));                      }                      else                      {                          if (containsAndEndsWith == null)                              containsAndEndsWith = new List<Tuple<string' bool' string>>();                            startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                            containsAndEndsWith.Add(new Tuple<string' bool' string>(                              sep.ToString() + s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                      }                        continue;                  }                    if (s.IndexOfAny(AsteriskQue) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        if (s[0] == sep)                      {                          exactMatch.Add(s.Substring(0));                      }                      else                      {                          exactMatch.Add(s.Substring(0));                            if (endsWith == null)                              endsWith = new List<string>();                            endsWith.Add(sep + s.Substring(0));                      }                        continue;                  }                    if (s[0] == '*' && s.IndexOfAny(AsteriskSlashBackQue' 1) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    if (s[0] == sep &&                      s.Length > 2 &&                      s[1] == '*' &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(2)));                      continue;                  }                    matchers.Add(ToMatcher(glob));              }
Magic Number,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The following statement contains a magic number: foreach (var glob in globs)              {                  if (string.IsNullOrEmpty(glob))                      continue;                    isActive = true;                    var sep = System.IO.Path.DirectorySeparatorChar;                    var s = glob;                  if (sep == '\\')                      s = glob.Replace('/'' '\\');                    var starDotIndex = s.IndexOf("*.");                    // exact match                  if (s[0] == sep &&                      s[s.Length - 1] != '/' &&                      s[s.Length - 1] != '\\' &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        exactMatch.Add(s.Substring(1));                      continue;                  }                    // simple extension filter (*.txt)                  if (starDotIndex == 0 &&                      s.IndexOfAny(DotAsteriskSlashBackQue' 2) < 0)                  {                      if (extensions == null)                          extensions = new HashSet<string>();                        extensions.Add(s.Substring(1));                      continue;                  }                    // simple extension filter with extra dot (*.csproj.user)                  if (starDotIndex == 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    // subdirectory under root and extension (/bin/some/*.txt)                  if (starDotIndex > 1 &&                      s[starDotIndex - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0 &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 1) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                          s.Substring(1' starDotIndex - 1)' false' s.Substring(starDotIndex + 1)));                        continue;                  }                    // extension under root (/*.txt)                  if (starDotIndex == 1 &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(starDotIndex + 1)));                      continue;                  }                    // directory filter at any depth (.git/)                  if (s[s.Length - 1] == sep &&                      s[0] != sep &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (contains == null)                          contains = new List<string>();                        if (startsWith == null)                          startsWith = new List<string>();                        contains.Add(sep.ToString() + s);                      startsWith.Add(s);                        continue;                  }                    // directory filter at root (/Imports/)                  if (s[s.Length - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskQue) < 0)                  {                      if (startsWith == null)                          startsWith = new List<string>();                        startsWith.Add(s.Substring(1));                      continue;                  }                    // folder than any then extension (App_Data/**/*.log) or (/App_Code/**/*.xyz)                  if (starDotIndex > 4 &&                      s[starDotIndex - 1] == sep &&                      s[starDotIndex - 2] == '*' &&                      s[starDotIndex - 3] == '*' &&                      s[starDotIndex - 4] == sep &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 5) < 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        if (s[0] == sep)                      {                          startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(1' starDotIndex - 4)' true' s.Substring(starDotIndex + 1)));                      }                      else                      {                          if (containsAndEndsWith == null)                              containsAndEndsWith = new List<Tuple<string' bool' string>>();                            startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                            containsAndEndsWith.Add(new Tuple<string' bool' string>(                              sep.ToString() + s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                      }                        continue;                  }                    if (s.IndexOfAny(AsteriskQue) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        if (s[0] == sep)                      {                          exactMatch.Add(s.Substring(0));                      }                      else                      {                          exactMatch.Add(s.Substring(0));                            if (endsWith == null)                              endsWith = new List<string>();                            endsWith.Add(sep + s.Substring(0));                      }                        continue;                  }                    if (s[0] == '*' && s.IndexOfAny(AsteriskSlashBackQue' 1) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    if (s[0] == sep &&                      s.Length > 2 &&                      s[1] == '*' &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(2)));                      continue;                  }                    matchers.Add(ToMatcher(glob));              }
Magic Number,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The following statement contains a magic number: foreach (var glob in globs)              {                  if (string.IsNullOrEmpty(glob))                      continue;                    isActive = true;                    var sep = System.IO.Path.DirectorySeparatorChar;                    var s = glob;                  if (sep == '\\')                      s = glob.Replace('/'' '\\');                    var starDotIndex = s.IndexOf("*.");                    // exact match                  if (s[0] == sep &&                      s[s.Length - 1] != '/' &&                      s[s.Length - 1] != '\\' &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        exactMatch.Add(s.Substring(1));                      continue;                  }                    // simple extension filter (*.txt)                  if (starDotIndex == 0 &&                      s.IndexOfAny(DotAsteriskSlashBackQue' 2) < 0)                  {                      if (extensions == null)                          extensions = new HashSet<string>();                        extensions.Add(s.Substring(1));                      continue;                  }                    // simple extension filter with extra dot (*.csproj.user)                  if (starDotIndex == 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    // subdirectory under root and extension (/bin/some/*.txt)                  if (starDotIndex > 1 &&                      s[starDotIndex - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0 &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 1) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                          s.Substring(1' starDotIndex - 1)' false' s.Substring(starDotIndex + 1)));                        continue;                  }                    // extension under root (/*.txt)                  if (starDotIndex == 1 &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(starDotIndex + 1)));                      continue;                  }                    // directory filter at any depth (.git/)                  if (s[s.Length - 1] == sep &&                      s[0] != sep &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (contains == null)                          contains = new List<string>();                        if (startsWith == null)                          startsWith = new List<string>();                        contains.Add(sep.ToString() + s);                      startsWith.Add(s);                        continue;                  }                    // directory filter at root (/Imports/)                  if (s[s.Length - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskQue) < 0)                  {                      if (startsWith == null)                          startsWith = new List<string>();                        startsWith.Add(s.Substring(1));                      continue;                  }                    // folder than any then extension (App_Data/**/*.log) or (/App_Code/**/*.xyz)                  if (starDotIndex > 4 &&                      s[starDotIndex - 1] == sep &&                      s[starDotIndex - 2] == '*' &&                      s[starDotIndex - 3] == '*' &&                      s[starDotIndex - 4] == sep &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 5) < 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        if (s[0] == sep)                      {                          startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(1' starDotIndex - 4)' true' s.Substring(starDotIndex + 1)));                      }                      else                      {                          if (containsAndEndsWith == null)                              containsAndEndsWith = new List<Tuple<string' bool' string>>();                            startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                            containsAndEndsWith.Add(new Tuple<string' bool' string>(                              sep.ToString() + s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                      }                        continue;                  }                    if (s.IndexOfAny(AsteriskQue) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        if (s[0] == sep)                      {                          exactMatch.Add(s.Substring(0));                      }                      else                      {                          exactMatch.Add(s.Substring(0));                            if (endsWith == null)                              endsWith = new List<string>();                            endsWith.Add(sep + s.Substring(0));                      }                        continue;                  }                    if (s[0] == '*' && s.IndexOfAny(AsteriskSlashBackQue' 1) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    if (s[0] == sep &&                      s.Length > 2 &&                      s[1] == '*' &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(2)));                      continue;                  }                    matchers.Add(ToMatcher(glob));              }
Magic Number,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The following statement contains a magic number: foreach (var glob in globs)              {                  if (string.IsNullOrEmpty(glob))                      continue;                    isActive = true;                    var sep = System.IO.Path.DirectorySeparatorChar;                    var s = glob;                  if (sep == '\\')                      s = glob.Replace('/'' '\\');                    var starDotIndex = s.IndexOf("*.");                    // exact match                  if (s[0] == sep &&                      s[s.Length - 1] != '/' &&                      s[s.Length - 1] != '\\' &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        exactMatch.Add(s.Substring(1));                      continue;                  }                    // simple extension filter (*.txt)                  if (starDotIndex == 0 &&                      s.IndexOfAny(DotAsteriskSlashBackQue' 2) < 0)                  {                      if (extensions == null)                          extensions = new HashSet<string>();                        extensions.Add(s.Substring(1));                      continue;                  }                    // simple extension filter with extra dot (*.csproj.user)                  if (starDotIndex == 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    // subdirectory under root and extension (/bin/some/*.txt)                  if (starDotIndex > 1 &&                      s[starDotIndex - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0 &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 1) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                          s.Substring(1' starDotIndex - 1)' false' s.Substring(starDotIndex + 1)));                        continue;                  }                    // extension under root (/*.txt)                  if (starDotIndex == 1 &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(starDotIndex + 1)));                      continue;                  }                    // directory filter at any depth (.git/)                  if (s[s.Length - 1] == sep &&                      s[0] != sep &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (contains == null)                          contains = new List<string>();                        if (startsWith == null)                          startsWith = new List<string>();                        contains.Add(sep.ToString() + s);                      startsWith.Add(s);                        continue;                  }                    // directory filter at root (/Imports/)                  if (s[s.Length - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskQue) < 0)                  {                      if (startsWith == null)                          startsWith = new List<string>();                        startsWith.Add(s.Substring(1));                      continue;                  }                    // folder than any then extension (App_Data/**/*.log) or (/App_Code/**/*.xyz)                  if (starDotIndex > 4 &&                      s[starDotIndex - 1] == sep &&                      s[starDotIndex - 2] == '*' &&                      s[starDotIndex - 3] == '*' &&                      s[starDotIndex - 4] == sep &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 5) < 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        if (s[0] == sep)                      {                          startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(1' starDotIndex - 4)' true' s.Substring(starDotIndex + 1)));                      }                      else                      {                          if (containsAndEndsWith == null)                              containsAndEndsWith = new List<Tuple<string' bool' string>>();                            startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                            containsAndEndsWith.Add(new Tuple<string' bool' string>(                              sep.ToString() + s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                      }                        continue;                  }                    if (s.IndexOfAny(AsteriskQue) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        if (s[0] == sep)                      {                          exactMatch.Add(s.Substring(0));                      }                      else                      {                          exactMatch.Add(s.Substring(0));                            if (endsWith == null)                              endsWith = new List<string>();                            endsWith.Add(sep + s.Substring(0));                      }                        continue;                  }                    if (s[0] == '*' && s.IndexOfAny(AsteriskSlashBackQue' 1) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    if (s[0] == sep &&                      s.Length > 2 &&                      s[1] == '*' &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(2)));                      continue;                  }                    matchers.Add(ToMatcher(glob));              }
Magic Number,Serenity.IO,GlobFilter,C:\repos\volkanceylan_serenity\Serenity.Core\IO\GlobFilter.cs,GlobFilter,The following statement contains a magic number: foreach (var glob in globs)              {                  if (string.IsNullOrEmpty(glob))                      continue;                    isActive = true;                    var sep = System.IO.Path.DirectorySeparatorChar;                    var s = glob;                  if (sep == '\\')                      s = glob.Replace('/'' '\\');                    var starDotIndex = s.IndexOf("*.");                    // exact match                  if (s[0] == sep &&                      s[s.Length - 1] != '/' &&                      s[s.Length - 1] != '\\' &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        exactMatch.Add(s.Substring(1));                      continue;                  }                    // simple extension filter (*.txt)                  if (starDotIndex == 0 &&                      s.IndexOfAny(DotAsteriskSlashBackQue' 2) < 0)                  {                      if (extensions == null)                          extensions = new HashSet<string>();                        extensions.Add(s.Substring(1));                      continue;                  }                    // simple extension filter with extra dot (*.csproj.user)                  if (starDotIndex == 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    // subdirectory under root and extension (/bin/some/*.txt)                  if (starDotIndex > 1 &&                      s[starDotIndex - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0 &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 1) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                          s.Substring(1' starDotIndex - 1)' false' s.Substring(starDotIndex + 1)));                        continue;                  }                    // extension under root (/*.txt)                  if (starDotIndex == 1 &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(starDotIndex + 1)));                      continue;                  }                    // directory filter at any depth (.git/)                  if (s[s.Length - 1] == sep &&                      s[0] != sep &&                      s.IndexOfAny(AsteriskQue' 1) < 0)                  {                      if (contains == null)                          contains = new List<string>();                        if (startsWith == null)                          startsWith = new List<string>();                        contains.Add(sep.ToString() + s);                      startsWith.Add(s);                        continue;                  }                    // directory filter at root (/Imports/)                  if (s[s.Length - 1] == sep &&                      s[0] == sep &&                      s.IndexOfAny(AsteriskQue) < 0)                  {                      if (startsWith == null)                          startsWith = new List<string>();                        startsWith.Add(s.Substring(1));                      continue;                  }                    // folder than any then extension (App_Data/**/*.log) or (/App_Code/**/*.xyz)                  if (starDotIndex > 4 &&                      s[starDotIndex - 1] == sep &&                      s[starDotIndex - 2] == '*' &&                      s[starDotIndex - 3] == '*' &&                      s[starDotIndex - 4] == sep &&                      s.LastIndexOfAny(AsteriskQue' starDotIndex - 5) < 0 &&                      s.IndexOfAny(AsteriskSlashBackQue' starDotIndex + 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        if (s[0] == sep)                      {                          startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(1' starDotIndex - 4)' true' s.Substring(starDotIndex + 1)));                      }                      else                      {                          if (containsAndEndsWith == null)                              containsAndEndsWith = new List<Tuple<string' bool' string>>();                            startsWithAndEndsWith.Add(new Tuple<string' bool' string>(                              s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                            containsAndEndsWith.Add(new Tuple<string' bool' string>(                              sep.ToString() + s.Substring(0' starDotIndex - 3)' true' s.Substring(starDotIndex + 1)));                      }                        continue;                  }                    if (s.IndexOfAny(AsteriskQue) < 0)                  {                      if (exactMatch == null)                          exactMatch = new HashSet<string>(StringComparer.OrdinalIgnoreCase);                        if (s[0] == sep)                      {                          exactMatch.Add(s.Substring(0));                      }                      else                      {                          exactMatch.Add(s.Substring(0));                            if (endsWith == null)                              endsWith = new List<string>();                            endsWith.Add(sep + s.Substring(0));                      }                        continue;                  }                    if (s[0] == '*' && s.IndexOfAny(AsteriskSlashBackQue' 1) < 0)                  {                      if (endsWith == null)                          endsWith = new List<string>();                        endsWith.Add(s.Substring(1));                      continue;                  }                    if (s[0] == sep &&                      s.Length > 2 &&                      s[1] == '*' &&                      s.IndexOfAny(AsteriskSlashBackQue' 2) < 0)                  {                      if (startsWithAndEndsWith == null)                          startsWithAndEndsWith = new List<Tuple<string' bool' string>>();                        startsWithAndEndsWith.Add(new Tuple<string' bool' string>(null' false' s.Substring(2)));                      continue;                  }                    matchers.Add(ToMatcher(glob));              }
Magic Number,Serenity.IO,TemporaryFileHelper,C:\repos\volkanceylan_serenity\Serenity.Core\IO\TemporaryFileHelper.cs,TryDeleteMarkedFiles,The following statement contains a magic number: if (Directory.Exists(path))              {                  foreach (var name in Directory.GetFiles(path' "*.delete"))                  {                      try                      {                          string readLine;                          using (var sr = new StreamReader(File.OpenRead(name)))                               readLine = sr.ReadToEnd();                          long fileTime;                          string actualFile = name.Substring(0' name.Length - 7);                          if (File.Exists(actualFile))                          {                              if (long.TryParse(readLine' out fileTime))                              {                                  if (fileTime == File.GetLastWriteTimeUtc(actualFile).ToFileTimeUtc())                                      TryDelete(actualFile);                              }                              TryDelete(name);                          }                          else                              TryDelete(name);                      }                      catch                      {                      }                  }              }
Magic Number,Serenity.IO,TemporaryFileHelper,C:\repos\volkanceylan_serenity\Serenity.Core\IO\TemporaryFileHelper.cs,RandomFileCode,The following statement contains a magic number: var eightBytes = new byte[8];
Magic Number,Serenity.IO,TemporaryFileHelper,C:\repos\volkanceylan_serenity\Serenity.Core\IO\TemporaryFileHelper.cs,RandomFileCode,The following statement contains a magic number: for (int i = 0; i < 8; i++)                  eightBytes[i] = (byte)(guidBytes[i] ^ guidBytes[i + 8]);
Magic Number,Serenity.IO,TemporaryFileHelper,C:\repos\volkanceylan_serenity\Serenity.Core\IO\TemporaryFileHelper.cs,RandomFileCode,The following statement contains a magic number: for (int i = 0; i < 8; i++)                  eightBytes[i] = (byte)(guidBytes[i] ^ guidBytes[i + 8]);
Magic Number,Serenity.Localization,FallbackLocalTextRegistry,C:\repos\volkanceylan_serenity\Serenity.Core\Localization\FallbackLocalTextRegistry.cs,TryGetKeyFallback,The following statement contains a magic number: if (lastDot > 0 && lastDot < key.Length - 1)              {                  key = key.Substring(lastDot + 1);                    // Remove Id                  if (key.Length > 2 && key.EndsWith("Id"))                      key = key.Substring(0' key.Length - 2);                    return key;              }
Magic Number,Serenity.Localization,FallbackLocalTextRegistry,C:\repos\volkanceylan_serenity\Serenity.Core\Localization\FallbackLocalTextRegistry.cs,TryGetKeyFallback,The following statement contains a magic number: if (lastDot > 0 && lastDot < key.Length - 1)              {                  key = key.Substring(lastDot + 1);                    // Remove Id                  if (key.Length > 2 && key.EndsWith("Id"))                      key = key.Substring(0' key.Length - 2);                    return key;              }
Magic Number,Serenity.Localization,LocalTextRegistry,C:\repos\volkanceylan_serenity\Serenity.Core\Localization\LocalTextRegistry.cs,TryGet,The following statement contains a magic number: if (isApprovalMode)              {                  // first search in pending texts                  if (pendingTexts.TryGetValue(k' out s))                  {                      // pending text is available' return it                      if (s != null)                          return s;                        // pending text is null' it means marked for deletion'                       // if this is default language' return key itself                      if (languageID == LocalText.InvariantLanguageID)                          return null;                  }                  else if (approvedTexts.TryGetValue(k' out s))                  {                      // approved is available' return it                      return s;                  }                  else if (languageID == LocalText.InvariantLanguageID)                  {                      // if language is default language' return text key                      return null;                  }                    var circularCheck1 = 0;                  while (true)                  {                      languageID = TryGetLanguageFallback(languageID) ?? LocalText.InvariantLanguageID;                        // search in fallback or default language                      k = new ItemKey(languageID' textKey);                        if (pendingTexts.TryGetValue(k' out s))                      {                          // text available in pending language fallback                          if (s != null)                              return s;                            // if marked for deletion in default language' return key itself                          if (languageID == LocalText.InvariantLanguageID)                              return null;                      }                      else if (approvedTexts.TryGetValue(k' out s))                      {                          // text available in approved default language                          return s;                      }                      else if (languageID == LocalText.InvariantLanguageID)                      {                          // not in pending nor approved' or circular reference' return key itself                          return null;                      }                                            // check for possible circular Fallbacks                      if (circularCheck1++ >= 10)                          return null;                        // try again for language fallback...                  }              }
Magic Number,Serenity.Localization,LocalTextRegistry,C:\repos\volkanceylan_serenity\Serenity.Core\Localization\LocalTextRegistry.cs,TryGet,The following statement contains a magic number: if (!approvedTexts.TryGetValue(k' out s))              {                  // couldn't find' if requested language is not DefaultLanguageID' search in it too                  if (languageID != LocalText.InvariantLanguageID)                  {                      int circularCheck2 = 0;                      while (true)                      {                          languageID = TryGetLanguageFallback(languageID) ?? LocalText.InvariantLanguageID;                            // search in fallback or default language                          k = new ItemKey(languageID' textKey);                            // search again                          if (approvedTexts.TryGetValue(k' out s))                              return s;                            if (languageID == LocalText.InvariantLanguageID ||                              circularCheck2++ >= 10)                              return null;                      }                  }                    // couldn't find in requested language or its Fallbacks' return key itself                  return null;              }
Magic Number,Serenity.Localization,LocalTextRegistry,C:\repos\volkanceylan_serenity\Serenity.Core\Localization\LocalTextRegistry.cs,GetAllAvailableTextsInLanguage,The following statement contains a magic number: while (true)              {                  if (pending)                  {                      foreach (var item in pendingTexts)                      {                          var key = item.Key.Item2;                          if (item.Key.Item1 == currentID && !texts.ContainsKey(key))                          {                              text = TryGet(languageID' key' true);                              if (text != null)                                  texts[key] = text;                          }                      }                  }                    foreach (var item in approvedTexts)                  {                      var key = item.Key.Item2;                      if (item.Key.Item1 == currentID && !texts.ContainsKey(key))                      {                          text = TryGet(languageID' key' true);                          if (text != null)                              texts[key] = text;                      }                  }                    tries++;                    if (tries > 10 ||                      currentID == LocalText.InvariantLanguageID)                      break;                    currentID = TryGetLanguageFallback(currentID) ?? LocalText.InvariantLanguageID;              }
Magic Number,Serenity.Logging,FileLogger,C:\repos\volkanceylan_serenity\Serenity.Core\Logging\FileLogger.cs,RandomFileCode,The following statement contains a magic number: var eightBytes = new byte[8];
Magic Number,Serenity.Logging,FileLogger,C:\repos\volkanceylan_serenity\Serenity.Core\Logging\FileLogger.cs,RandomFileCode,The following statement contains a magic number: for (int i = 0; i < 8; i++)                  eightBytes[i] = (byte)(guidBytes[i] ^ guidBytes[i + 8]);
Magic Number,Serenity.Logging,FileLogger,C:\repos\volkanceylan_serenity\Serenity.Core\Logging\FileLogger.cs,RandomFileCode,The following statement contains a magic number: for (int i = 0; i < 8; i++)                  eightBytes[i] = (byte)(guidBytes[i] ^ guidBytes[i + 8]);
Magic Number,Serenity.Logging,FileLogger,C:\repos\volkanceylan_serenity\Serenity.Core\Logging\FileLogger.cs,Write,The following statement contains a magic number: lock (sync)              {                  try                  {                      StringBuilder sb = new StringBuilder();                      if (level >= LoggingLevel.Verbose && level <= LoggingLevel.Fatal)                          sb.Append(SeverityChar[(int)level + 6]);                      else                          sb.Append("[?]");                        sb.Append(DateTimeProvider.Now.ToString(DateHelper.ISODateTimeFormatLocal));                      sb.Append(' ');                        if (source != null)                      {                          sb.Append(source.FullName);                          sb.Append(' ');                      }                        if (message != null)                          sb.AppendLine(message);                        if (exception != null)                          sb.AppendLine(exception.ToString());                        var currentDate = DateTimeProvider.Now.Date;                      if (stream == null || writerDate != currentDate)                      {                          writerDate = currentDate;                          string newFile = String.Format(file' writerDate.ToString("yyyyMMdd")' RandomFileCode());                            Directory.CreateDirectory(Path.GetDirectoryName(newFile));                            if (stream != null)                          {                              InternalFlush();                                try                              {                                  stream.Dispose();                              }  #if COREFX                              catch                              {                              }  #else                              catch (Exception ex1)                              {                                  var internalLogger = Dependency.TryResolve<ILogger>("Internal");                                  if (internalLogger != null)                                      internalLogger.Write(LoggingLevel.Fatal' null' ex1' this.GetType());                              }  #endif                                stream = null;                              stream = new StreamWriter(System.IO.File.Open(newFile' FileMode.OpenOrCreate'                                   FileAccess.Write' FileShare.Read)' Encoding.UTF8);                          }                          else                              stream = new StreamWriter(System.IO.File.Open(newFile' FileMode.OpenOrCreate'                                   FileAccess.Write' FileShare.Read)' Encoding.UTF8);                      }                        queue.Enqueue(sb.ToString());                        if (flushTimeout <= TimeSpan.Zero ||                          flushTimeout > TimeSpan.Zero && (DateTimeProvider.Now - lastFlush) >= flushTimeout)                          InternalFlush();                  }  #if COREFX                  catch                  {                  }  #else                  catch (Exception ex2)                  {                      var internalLogger = Dependency.TryResolve<ILogger>("Internal");                      if (internalLogger != null)                          internalLogger.Write(LoggingLevel.Fatal' null' ex2' this.GetType());                  }  #endif              }
Missing Default,Serenity.Data,Base32,C:\repos\volkanceylan_serenity\Serenity.Core\Helpers\Base32.cs,Decode,The following switch statement is missing a default case: switch (len % 8)              { // test the length of last subblock                  case 1: //  5 bits in subblock:  0 useful bits but 5 discarded                  case 3: // 15 bits in subblock:  8 useful bits but 7 discarded                  case 6: // 30 bits in subblock: 24 useful bits but 6 discarded                      throw new ArgumentException(errorCanonicalLength);              }
