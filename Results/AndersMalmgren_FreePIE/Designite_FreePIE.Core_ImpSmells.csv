Implementation smell,Namespace,Class,File,Method,Description
Complex Method,FreePIE.Core.Common,CurveMath,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\CurveMath.cs,GetInterpolatedCubicSplinedCurve,Cyclomatic complexity of the method is 9
Complex Method,FreePIE.Core.Common,CurveMath,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\CurveMath.cs,SolveCubicSpline,Cyclomatic complexity of the method is 9
Long Parameter List,FreePIE.Core.Common,CurveMath,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\CurveMath.cs,SolveTridiag,The method has 5 parameters. Parameters: sub' diag' sup' b' n
Long Parameter List,FreePIE.Core.ScriptEngine.Globals.ScriptHelpers,FilterHelper,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\ScriptEngine\Globals\ScriptHelpers\FilterHelper.cs,mapRange,The method has 5 parameters. Parameters: x' xMin' xMax' yMin' yMax
Long Parameter List,FreePIE.Core.ScriptEngine.Globals.ScriptHelpers,FilterHelper,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\ScriptEngine\Globals\ScriptHelpers\FilterHelper.cs,ensureMapRange,The method has 5 parameters. Parameters: x' xMin' xMax' yMin' yMax
Long Parameter List,FreePIE.Core.ScriptEngine.Python,PythonScriptEngine,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\ScriptEngine\Python\PythonScriptEngine.cs,PythonScriptEngine,The method has 6 parameters. Parameters: parser' globalProviders' eventAggregator' threadTimingFactory' paths' log
Long Statement,FreePIE.Core.Common.Extensions,TypeExtensions,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\Extensions\TypeExtensions.cs,GetTypes,The length of the statement  "                .Where(t => !t.IsAbstract && (type.IsGenericType ? t.IsAssignableFrom(type.GetGenericTypeDefinition()) : type.IsAssignableFrom(t))) " is 131.
Long Statement,FreePIE.Core.Common,Log,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\Log.cs,Error,The length of the statement  "            var log = string.Format("{0}{1}{2} - {3}: {5}{4}{5}"' new string('\t'' indentation)' delimiter' e.GetType().FullName' e.Message' PrependTabsToLinebreaks(e.StackTrace' indentation)' Environment.NewLine); " is 202.
Long Statement,FreePIE.Core.Plugins,PluginInvoker,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Plugins\PluginInvoker.cs,PopulatePluginSettings,The length of the statement  "            var removedPluginSettings = settings.PluginSettings.Where(ps => !pluginTypes.Any(pt => pt.FullName == ps.PluginType)).ToList(); " is 127.
Long Statement,FreePIE.Core.Plugins,PluginInvoker,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Plugins\PluginInvoker.cs,PopulatePluginSettings,The length of the statement  "            var addedPluginTypes = pluginTypes.Where(pt => !settings.PluginSettings.Any(ps => ps.PluginType == pt.FullName)).ToList(); " is 122.
Long Statement,FreePIE.Core.Plugins,PluginInvoker,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Plugins\PluginInvoker.cs,InitProperties,The length of the statement  "                    if (property.Value == null || (property.DefaultValue != null && property.Value.GetType() != property.DefaultValue.GetType())) " is 125.
Long Statement,FreePIE.Core.ScriptEngine.CodeCompletion,InfoTransformHelper,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\ScriptEngine\CodeCompletion\InfoTransformHelper.cs,AddProperties,The length of the statement  "            propDelim.AddChildren(members.Where(m => m.MemberType == MemberTypes.Property && !IsDeprecated(m)).Select(m => MapProperty(m as PropertyInfo))); " is 144.
Long Statement,FreePIE.Core.ScriptEngine.CodeCompletion,InfoTransformHelper,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\ScriptEngine\CodeCompletion\InfoTransformHelper.cs,AddMethods,The length of the statement  "            methodDelim.AddChildren(members.Where(m => m.MemberType == MemberTypes.Method && !(m as MethodInfo).IsSpecialName && !IsDeprecated(m)).Select(m => MapMethod(m as MethodInfo))); " is 176.
Long Statement,FreePIE.Core.ScriptEngine.CodeCompletion,InfoTransformHelper,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\ScriptEngine\CodeCompletion\InfoTransformHelper.cs,ConstructDelimiterNode,The length of the statement  "            return new Node<TokenInfo>(new TokenInfo(new Token(TokenType.Delimiter' delimiter.ToString())' new ExpressionInfo() { Name = delimiter.ToString() } )); " is 151.
Long Statement,FreePIE.Core.ScriptEngine.CodeCompletion,InfoTransformHelper,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\ScriptEngine\CodeCompletion\InfoTransformHelper.cs,MapMethod,The length of the statement  "            var parameters = string.Join("'"' GetParametersWithoutIndexer(mi).Select(pi => string.Format("{0} {1}"' pi.ParameterType.Name' pi.Name))); " is 138.
Long Statement,FreePIE.Core.ScriptEngine.CodeCompletion,InfoTransformHelper,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\ScriptEngine\CodeCompletion\InfoTransformHelper.cs,MapMethod,The length of the statement  "            expInfo.Description = string.Format("{0} {1} ({2})"' mi.ReturnType.Name == "Void" ? "void" : mi.ReturnType.Name' mi.Name' parameters); " is 134.
Long Statement,FreePIE.Core.ScriptEngine.CodeCompletion,InfoTransformHelper,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\ScriptEngine\CodeCompletion\InfoTransformHelper.cs,GetParametersWithoutIndexer,The length of the statement  "            return mi.GetCustomAttributes(typeof(NeedIndexer)' false).Length > 0 ? parameters.Take(parameters.Length - 1) : parameters; " is 123.
Long Statement,FreePIE.Core.ScriptEngine.CodeCompletion,RuntimeInfoProvider,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\ScriptEngine\CodeCompletion\RuntimeInfoProvider.cs,AnalyzeExpression,The length of the statement  "            Node<TokenInfo> parent = RuntimeInfo.FindSequence(sequence' (tokenInfo' token) => tokenInfo.Identifier.IsCompleteMatch(token)); " is 127.
Long Statement,FreePIE.Core.ScriptEngine.Python,PythonScriptParser,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\ScriptEngine\Python\PythonScriptParser.cs,ListDeprecatedWarnings,The length of the statement  "                .Select(m => new ScriptErrorEvent(ErrorLevel.Warning' string.Format("{0} marked as deprecated' use {1}"' m.Info.Deprecated' m.Info.ReplacedWith)' GetLineNumber(script' m.IndexOf))) " is 180.
Long Statement,FreePIE.Core.ScriptEngine.Python,PythonScriptParser,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\ScriptEngine\Python\PythonScriptParser.cs,FindAndInitMethodsThatNeedIndexer,The length of the statement  "                        var newArguments = string.Format(@"{0}' ""{1}"")"' proccesedArguments' arguments.Substring(1' arguments.Length - 2).Replace(@""""' @"'")); " is 138.
Long Statement,FreePIE.Core.Services,ServiceBootstrapper,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Services\ServiceBootstrapper.cs,VerifyGenericFactoryFunction,The length of the statement  "            return request.ParentContext.Kernel.CanResolve(new Request(genericArguments[0]' null' new IParameter[0]' null' false' true)) || " is 127.
Magic Number,FreePIE.Core.Common,CurveMath,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\CurveMath.cs,GetInterpolatedCubicSplinedCurve,The following statement contains a magic number: if (np > 0)              {                  for (int i = 0; i < np; i++)                  {                      var p = points[i];                      xCoords[i] = p.X;                      yCoords[i] = p.Y;                  }                  if (np > 1)                  {                      double[] a = new double[np];                      double x1;                      double x2;                      double[] h = new double[np];                      for (int i = 1; i <= np - 1; i++)                      {                          h[i] = xCoords[i] - xCoords[i - 1];                      }                      if (np > 2)                      {                          double[] sub = new double[np - 1];                          double[] diag = new double[np - 1];                          double[] sup = new double[np - 1];                            for (int i = 1; i <= np - 2; i++)                          {                              diag[i] = (h[i] + h[i + 1])/3;                              sup[i] = h[i + 1]/6;                              sub[i] = h[i]/6;                              a[i] = (yCoords[i + 1] - yCoords[i])/h[i + 1] - (yCoords[i] - yCoords[i - 1])/h[i];                          }                          SolveTridiag(sub' diag' sup' ref a' np - 2);                      }                        output.Add(points.First());                        for (int i = 1; i <= np - 1; i++)                      {                          // loop over intervals between nodes                          for (int j = 1; j <= precision; j++)                          {                              x1 = (h[i]*j)/precision;                              x2 = h[i] - x1;                              y = ((-a[i - 1]/6*(x2 + h[i])*x1 + yCoords[i - 1])*x2 +                                   (-a[i]/6*(x1 + h[i])*x2 + yCoords[i])*x1)/h[i];                              x = xCoords[i - 1] + x1;                                output.Add(new Point(x' y));                          }                      }                  }              }
Magic Number,FreePIE.Core.Common,CurveMath,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\CurveMath.cs,GetInterpolatedCubicSplinedCurve,The following statement contains a magic number: if (np > 0)              {                  for (int i = 0; i < np; i++)                  {                      var p = points[i];                      xCoords[i] = p.X;                      yCoords[i] = p.Y;                  }                  if (np > 1)                  {                      double[] a = new double[np];                      double x1;                      double x2;                      double[] h = new double[np];                      for (int i = 1; i <= np - 1; i++)                      {                          h[i] = xCoords[i] - xCoords[i - 1];                      }                      if (np > 2)                      {                          double[] sub = new double[np - 1];                          double[] diag = new double[np - 1];                          double[] sup = new double[np - 1];                            for (int i = 1; i <= np - 2; i++)                          {                              diag[i] = (h[i] + h[i + 1])/3;                              sup[i] = h[i + 1]/6;                              sub[i] = h[i]/6;                              a[i] = (yCoords[i + 1] - yCoords[i])/h[i + 1] - (yCoords[i] - yCoords[i - 1])/h[i];                          }                          SolveTridiag(sub' diag' sup' ref a' np - 2);                      }                        output.Add(points.First());                        for (int i = 1; i <= np - 1; i++)                      {                          // loop over intervals between nodes                          for (int j = 1; j <= precision; j++)                          {                              x1 = (h[i]*j)/precision;                              x2 = h[i] - x1;                              y = ((-a[i - 1]/6*(x2 + h[i])*x1 + yCoords[i - 1])*x2 +                                   (-a[i]/6*(x1 + h[i])*x2 + yCoords[i])*x1)/h[i];                              x = xCoords[i - 1] + x1;                                output.Add(new Point(x' y));                          }                      }                  }              }
Magic Number,FreePIE.Core.Common,CurveMath,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\CurveMath.cs,GetInterpolatedCubicSplinedCurve,The following statement contains a magic number: if (np > 0)              {                  for (int i = 0; i < np; i++)                  {                      var p = points[i];                      xCoords[i] = p.X;                      yCoords[i] = p.Y;                  }                  if (np > 1)                  {                      double[] a = new double[np];                      double x1;                      double x2;                      double[] h = new double[np];                      for (int i = 1; i <= np - 1; i++)                      {                          h[i] = xCoords[i] - xCoords[i - 1];                      }                      if (np > 2)                      {                          double[] sub = new double[np - 1];                          double[] diag = new double[np - 1];                          double[] sup = new double[np - 1];                            for (int i = 1; i <= np - 2; i++)                          {                              diag[i] = (h[i] + h[i + 1])/3;                              sup[i] = h[i + 1]/6;                              sub[i] = h[i]/6;                              a[i] = (yCoords[i + 1] - yCoords[i])/h[i + 1] - (yCoords[i] - yCoords[i - 1])/h[i];                          }                          SolveTridiag(sub' diag' sup' ref a' np - 2);                      }                        output.Add(points.First());                        for (int i = 1; i <= np - 1; i++)                      {                          // loop over intervals between nodes                          for (int j = 1; j <= precision; j++)                          {                              x1 = (h[i]*j)/precision;                              x2 = h[i] - x1;                              y = ((-a[i - 1]/6*(x2 + h[i])*x1 + yCoords[i - 1])*x2 +                                   (-a[i]/6*(x1 + h[i])*x2 + yCoords[i])*x1)/h[i];                              x = xCoords[i - 1] + x1;                                output.Add(new Point(x' y));                          }                      }                  }              }
Magic Number,FreePIE.Core.Common,CurveMath,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\CurveMath.cs,GetInterpolatedCubicSplinedCurve,The following statement contains a magic number: if (np > 0)              {                  for (int i = 0; i < np; i++)                  {                      var p = points[i];                      xCoords[i] = p.X;                      yCoords[i] = p.Y;                  }                  if (np > 1)                  {                      double[] a = new double[np];                      double x1;                      double x2;                      double[] h = new double[np];                      for (int i = 1; i <= np - 1; i++)                      {                          h[i] = xCoords[i] - xCoords[i - 1];                      }                      if (np > 2)                      {                          double[] sub = new double[np - 1];                          double[] diag = new double[np - 1];                          double[] sup = new double[np - 1];                            for (int i = 1; i <= np - 2; i++)                          {                              diag[i] = (h[i] + h[i + 1])/3;                              sup[i] = h[i + 1]/6;                              sub[i] = h[i]/6;                              a[i] = (yCoords[i + 1] - yCoords[i])/h[i + 1] - (yCoords[i] - yCoords[i - 1])/h[i];                          }                          SolveTridiag(sub' diag' sup' ref a' np - 2);                      }                        output.Add(points.First());                        for (int i = 1; i <= np - 1; i++)                      {                          // loop over intervals between nodes                          for (int j = 1; j <= precision; j++)                          {                              x1 = (h[i]*j)/precision;                              x2 = h[i] - x1;                              y = ((-a[i - 1]/6*(x2 + h[i])*x1 + yCoords[i - 1])*x2 +                                   (-a[i]/6*(x1 + h[i])*x2 + yCoords[i])*x1)/h[i];                              x = xCoords[i - 1] + x1;                                output.Add(new Point(x' y));                          }                      }                  }              }
Magic Number,FreePIE.Core.Common,CurveMath,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\CurveMath.cs,GetInterpolatedCubicSplinedCurve,The following statement contains a magic number: if (np > 0)              {                  for (int i = 0; i < np; i++)                  {                      var p = points[i];                      xCoords[i] = p.X;                      yCoords[i] = p.Y;                  }                  if (np > 1)                  {                      double[] a = new double[np];                      double x1;                      double x2;                      double[] h = new double[np];                      for (int i = 1; i <= np - 1; i++)                      {                          h[i] = xCoords[i] - xCoords[i - 1];                      }                      if (np > 2)                      {                          double[] sub = new double[np - 1];                          double[] diag = new double[np - 1];                          double[] sup = new double[np - 1];                            for (int i = 1; i <= np - 2; i++)                          {                              diag[i] = (h[i] + h[i + 1])/3;                              sup[i] = h[i + 1]/6;                              sub[i] = h[i]/6;                              a[i] = (yCoords[i + 1] - yCoords[i])/h[i + 1] - (yCoords[i] - yCoords[i - 1])/h[i];                          }                          SolveTridiag(sub' diag' sup' ref a' np - 2);                      }                        output.Add(points.First());                        for (int i = 1; i <= np - 1; i++)                      {                          // loop over intervals between nodes                          for (int j = 1; j <= precision; j++)                          {                              x1 = (h[i]*j)/precision;                              x2 = h[i] - x1;                              y = ((-a[i - 1]/6*(x2 + h[i])*x1 + yCoords[i - 1])*x2 +                                   (-a[i]/6*(x1 + h[i])*x2 + yCoords[i])*x1)/h[i];                              x = xCoords[i - 1] + x1;                                output.Add(new Point(x' y));                          }                      }                  }              }
Magic Number,FreePIE.Core.Common,CurveMath,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\CurveMath.cs,GetInterpolatedCubicSplinedCurve,The following statement contains a magic number: if (np > 0)              {                  for (int i = 0; i < np; i++)                  {                      var p = points[i];                      xCoords[i] = p.X;                      yCoords[i] = p.Y;                  }                  if (np > 1)                  {                      double[] a = new double[np];                      double x1;                      double x2;                      double[] h = new double[np];                      for (int i = 1; i <= np - 1; i++)                      {                          h[i] = xCoords[i] - xCoords[i - 1];                      }                      if (np > 2)                      {                          double[] sub = new double[np - 1];                          double[] diag = new double[np - 1];                          double[] sup = new double[np - 1];                            for (int i = 1; i <= np - 2; i++)                          {                              diag[i] = (h[i] + h[i + 1])/3;                              sup[i] = h[i + 1]/6;                              sub[i] = h[i]/6;                              a[i] = (yCoords[i + 1] - yCoords[i])/h[i + 1] - (yCoords[i] - yCoords[i - 1])/h[i];                          }                          SolveTridiag(sub' diag' sup' ref a' np - 2);                      }                        output.Add(points.First());                        for (int i = 1; i <= np - 1; i++)                      {                          // loop over intervals between nodes                          for (int j = 1; j <= precision; j++)                          {                              x1 = (h[i]*j)/precision;                              x2 = h[i] - x1;                              y = ((-a[i - 1]/6*(x2 + h[i])*x1 + yCoords[i - 1])*x2 +                                   (-a[i]/6*(x1 + h[i])*x2 + yCoords[i])*x1)/h[i];                              x = xCoords[i - 1] + x1;                                output.Add(new Point(x' y));                          }                      }                  }              }
Magic Number,FreePIE.Core.Common,CurveMath,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\CurveMath.cs,GetInterpolatedCubicSplinedCurve,The following statement contains a magic number: if (np > 0)              {                  for (int i = 0; i < np; i++)                  {                      var p = points[i];                      xCoords[i] = p.X;                      yCoords[i] = p.Y;                  }                  if (np > 1)                  {                      double[] a = new double[np];                      double x1;                      double x2;                      double[] h = new double[np];                      for (int i = 1; i <= np - 1; i++)                      {                          h[i] = xCoords[i] - xCoords[i - 1];                      }                      if (np > 2)                      {                          double[] sub = new double[np - 1];                          double[] diag = new double[np - 1];                          double[] sup = new double[np - 1];                            for (int i = 1; i <= np - 2; i++)                          {                              diag[i] = (h[i] + h[i + 1])/3;                              sup[i] = h[i + 1]/6;                              sub[i] = h[i]/6;                              a[i] = (yCoords[i + 1] - yCoords[i])/h[i + 1] - (yCoords[i] - yCoords[i - 1])/h[i];                          }                          SolveTridiag(sub' diag' sup' ref a' np - 2);                      }                        output.Add(points.First());                        for (int i = 1; i <= np - 1; i++)                      {                          // loop over intervals between nodes                          for (int j = 1; j <= precision; j++)                          {                              x1 = (h[i]*j)/precision;                              x2 = h[i] - x1;                              y = ((-a[i - 1]/6*(x2 + h[i])*x1 + yCoords[i - 1])*x2 +                                   (-a[i]/6*(x1 + h[i])*x2 + yCoords[i])*x1)/h[i];                              x = xCoords[i - 1] + x1;                                output.Add(new Point(x' y));                          }                      }                  }              }
Magic Number,FreePIE.Core.Common,CurveMath,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\CurveMath.cs,GetInterpolatedCubicSplinedCurve,The following statement contains a magic number: if (np > 0)              {                  for (int i = 0; i < np; i++)                  {                      var p = points[i];                      xCoords[i] = p.X;                      yCoords[i] = p.Y;                  }                  if (np > 1)                  {                      double[] a = new double[np];                      double x1;                      double x2;                      double[] h = new double[np];                      for (int i = 1; i <= np - 1; i++)                      {                          h[i] = xCoords[i] - xCoords[i - 1];                      }                      if (np > 2)                      {                          double[] sub = new double[np - 1];                          double[] diag = new double[np - 1];                          double[] sup = new double[np - 1];                            for (int i = 1; i <= np - 2; i++)                          {                              diag[i] = (h[i] + h[i + 1])/3;                              sup[i] = h[i + 1]/6;                              sub[i] = h[i]/6;                              a[i] = (yCoords[i + 1] - yCoords[i])/h[i + 1] - (yCoords[i] - yCoords[i - 1])/h[i];                          }                          SolveTridiag(sub' diag' sup' ref a' np - 2);                      }                        output.Add(points.First());                        for (int i = 1; i <= np - 1; i++)                      {                          // loop over intervals between nodes                          for (int j = 1; j <= precision; j++)                          {                              x1 = (h[i]*j)/precision;                              x2 = h[i] - x1;                              y = ((-a[i - 1]/6*(x2 + h[i])*x1 + yCoords[i - 1])*x2 +                                   (-a[i]/6*(x1 + h[i])*x2 + yCoords[i])*x1)/h[i];                              x = xCoords[i - 1] + x1;                                output.Add(new Point(x' y));                          }                      }                  }              }
Magic Number,FreePIE.Core.Common,CurveMath,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\CurveMath.cs,SolveCubicSpline,The following statement contains a magic number: if (np > 1)              {                    double[] a = new double[np];                    double x1;                    double x2;                    double y;                    double[] h = new double[np];                    for (int i = 1; i <= np - 1; i++)                  {                        h[i] = knownSamples[i].X - knownSamples[i - 1].X;                    }                    if (np > 2)                  {                        double[] sub = new double[np - 1];                        double[] diag = new double[np - 1];                        double[] sup = new double[np - 1];                        for (int i = 1; i <= np - 2; i++)                      {                            diag[i] = (h[i] + h[i + 1])/3;                            sup[i] = h[i + 1]/6;                            sub[i] = h[i]/6;                            a[i] = (knownSamples[i + 1].Y - knownSamples[i].Y)/h[i + 1] -                                   (knownSamples[i].Y - knownSamples[i - 1].Y)/h[i];                        }                        // SolveTridiag is a support function' see Marco Roello's original code                        // for more information at                        // http://www.codeproject.com/useritems/SplineInterpolation.asp                        SolveTridiag(sub' diag' sup' ref a' np - 2);                    }                        int gap = 0;                    double previous = double.MinValue;                    // At the end of this iteration' "gap" will contain the index of the interval                    // between two known values' which contains the unknown z' and "previous" will                    // contain the biggest z value among the known samples' left of the unknown z                    for (int i = 0; i < knownSamples.Count; i++)                  {                        if (knownSamples[i].X < z && knownSamples[i].X > previous)                      {                            previous = knownSamples[i].X;                            gap = i + 1;                        }                    }                    x1 = z - previous;                    if (gap > h.Length - 1)                      return z;                    x2 = h[gap] - x1;                    if (gap == 0)                      return 0.0;                    y = ((-a[gap - 1]/6*(x2 + h[gap])*x1 + knownSamples[gap - 1].Y)*x2 +                         (-a[gap]/6*(x1 + h[gap])*x2 + knownSamples[gap].Y)*x1)/h[gap];                    return y;                }
Magic Number,FreePIE.Core.Common,CurveMath,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\CurveMath.cs,SolveCubicSpline,The following statement contains a magic number: if (np > 1)              {                    double[] a = new double[np];                    double x1;                    double x2;                    double y;                    double[] h = new double[np];                    for (int i = 1; i <= np - 1; i++)                  {                        h[i] = knownSamples[i].X - knownSamples[i - 1].X;                    }                    if (np > 2)                  {                        double[] sub = new double[np - 1];                        double[] diag = new double[np - 1];                        double[] sup = new double[np - 1];                        for (int i = 1; i <= np - 2; i++)                      {                            diag[i] = (h[i] + h[i + 1])/3;                            sup[i] = h[i + 1]/6;                            sub[i] = h[i]/6;                            a[i] = (knownSamples[i + 1].Y - knownSamples[i].Y)/h[i + 1] -                                   (knownSamples[i].Y - knownSamples[i - 1].Y)/h[i];                        }                        // SolveTridiag is a support function' see Marco Roello's original code                        // for more information at                        // http://www.codeproject.com/useritems/SplineInterpolation.asp                        SolveTridiag(sub' diag' sup' ref a' np - 2);                    }                        int gap = 0;                    double previous = double.MinValue;                    // At the end of this iteration' "gap" will contain the index of the interval                    // between two known values' which contains the unknown z' and "previous" will                    // contain the biggest z value among the known samples' left of the unknown z                    for (int i = 0; i < knownSamples.Count; i++)                  {                        if (knownSamples[i].X < z && knownSamples[i].X > previous)                      {                            previous = knownSamples[i].X;                            gap = i + 1;                        }                    }                    x1 = z - previous;                    if (gap > h.Length - 1)                      return z;                    x2 = h[gap] - x1;                    if (gap == 0)                      return 0.0;                    y = ((-a[gap - 1]/6*(x2 + h[gap])*x1 + knownSamples[gap - 1].Y)*x2 +                         (-a[gap]/6*(x1 + h[gap])*x2 + knownSamples[gap].Y)*x1)/h[gap];                    return y;                }
Magic Number,FreePIE.Core.Common,CurveMath,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\CurveMath.cs,SolveCubicSpline,The following statement contains a magic number: if (np > 1)              {                    double[] a = new double[np];                    double x1;                    double x2;                    double y;                    double[] h = new double[np];                    for (int i = 1; i <= np - 1; i++)                  {                        h[i] = knownSamples[i].X - knownSamples[i - 1].X;                    }                    if (np > 2)                  {                        double[] sub = new double[np - 1];                        double[] diag = new double[np - 1];                        double[] sup = new double[np - 1];                        for (int i = 1; i <= np - 2; i++)                      {                            diag[i] = (h[i] + h[i + 1])/3;                            sup[i] = h[i + 1]/6;                            sub[i] = h[i]/6;                            a[i] = (knownSamples[i + 1].Y - knownSamples[i].Y)/h[i + 1] -                                   (knownSamples[i].Y - knownSamples[i - 1].Y)/h[i];                        }                        // SolveTridiag is a support function' see Marco Roello's original code                        // for more information at                        // http://www.codeproject.com/useritems/SplineInterpolation.asp                        SolveTridiag(sub' diag' sup' ref a' np - 2);                    }                        int gap = 0;                    double previous = double.MinValue;                    // At the end of this iteration' "gap" will contain the index of the interval                    // between two known values' which contains the unknown z' and "previous" will                    // contain the biggest z value among the known samples' left of the unknown z                    for (int i = 0; i < knownSamples.Count; i++)                  {                        if (knownSamples[i].X < z && knownSamples[i].X > previous)                      {                            previous = knownSamples[i].X;                            gap = i + 1;                        }                    }                    x1 = z - previous;                    if (gap > h.Length - 1)                      return z;                    x2 = h[gap] - x1;                    if (gap == 0)                      return 0.0;                    y = ((-a[gap - 1]/6*(x2 + h[gap])*x1 + knownSamples[gap - 1].Y)*x2 +                         (-a[gap]/6*(x1 + h[gap])*x2 + knownSamples[gap].Y)*x1)/h[gap];                    return y;                }
Magic Number,FreePIE.Core.Common,CurveMath,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\CurveMath.cs,SolveCubicSpline,The following statement contains a magic number: if (np > 1)              {                    double[] a = new double[np];                    double x1;                    double x2;                    double y;                    double[] h = new double[np];                    for (int i = 1; i <= np - 1; i++)                  {                        h[i] = knownSamples[i].X - knownSamples[i - 1].X;                    }                    if (np > 2)                  {                        double[] sub = new double[np - 1];                        double[] diag = new double[np - 1];                        double[] sup = new double[np - 1];                        for (int i = 1; i <= np - 2; i++)                      {                            diag[i] = (h[i] + h[i + 1])/3;                            sup[i] = h[i + 1]/6;                            sub[i] = h[i]/6;                            a[i] = (knownSamples[i + 1].Y - knownSamples[i].Y)/h[i + 1] -                                   (knownSamples[i].Y - knownSamples[i - 1].Y)/h[i];                        }                        // SolveTridiag is a support function' see Marco Roello's original code                        // for more information at                        // http://www.codeproject.com/useritems/SplineInterpolation.asp                        SolveTridiag(sub' diag' sup' ref a' np - 2);                    }                        int gap = 0;                    double previous = double.MinValue;                    // At the end of this iteration' "gap" will contain the index of the interval                    // between two known values' which contains the unknown z' and "previous" will                    // contain the biggest z value among the known samples' left of the unknown z                    for (int i = 0; i < knownSamples.Count; i++)                  {                        if (knownSamples[i].X < z && knownSamples[i].X > previous)                      {                            previous = knownSamples[i].X;                            gap = i + 1;                        }                    }                    x1 = z - previous;                    if (gap > h.Length - 1)                      return z;                    x2 = h[gap] - x1;                    if (gap == 0)                      return 0.0;                    y = ((-a[gap - 1]/6*(x2 + h[gap])*x1 + knownSamples[gap - 1].Y)*x2 +                         (-a[gap]/6*(x1 + h[gap])*x2 + knownSamples[gap].Y)*x1)/h[gap];                    return y;                }
Magic Number,FreePIE.Core.Common,CurveMath,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\CurveMath.cs,SolveCubicSpline,The following statement contains a magic number: if (np > 1)              {                    double[] a = new double[np];                    double x1;                    double x2;                    double y;                    double[] h = new double[np];                    for (int i = 1; i <= np - 1; i++)                  {                        h[i] = knownSamples[i].X - knownSamples[i - 1].X;                    }                    if (np > 2)                  {                        double[] sub = new double[np - 1];                        double[] diag = new double[np - 1];                        double[] sup = new double[np - 1];                        for (int i = 1; i <= np - 2; i++)                      {                            diag[i] = (h[i] + h[i + 1])/3;                            sup[i] = h[i + 1]/6;                            sub[i] = h[i]/6;                            a[i] = (knownSamples[i + 1].Y - knownSamples[i].Y)/h[i + 1] -                                   (knownSamples[i].Y - knownSamples[i - 1].Y)/h[i];                        }                        // SolveTridiag is a support function' see Marco Roello's original code                        // for more information at                        // http://www.codeproject.com/useritems/SplineInterpolation.asp                        SolveTridiag(sub' diag' sup' ref a' np - 2);                    }                        int gap = 0;                    double previous = double.MinValue;                    // At the end of this iteration' "gap" will contain the index of the interval                    // between two known values' which contains the unknown z' and "previous" will                    // contain the biggest z value among the known samples' left of the unknown z                    for (int i = 0; i < knownSamples.Count; i++)                  {                        if (knownSamples[i].X < z && knownSamples[i].X > previous)                      {                            previous = knownSamples[i].X;                            gap = i + 1;                        }                    }                    x1 = z - previous;                    if (gap > h.Length - 1)                      return z;                    x2 = h[gap] - x1;                    if (gap == 0)                      return 0.0;                    y = ((-a[gap - 1]/6*(x2 + h[gap])*x1 + knownSamples[gap - 1].Y)*x2 +                         (-a[gap]/6*(x1 + h[gap])*x2 + knownSamples[gap].Y)*x1)/h[gap];                    return y;                }
Magic Number,FreePIE.Core.Common,CurveMath,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\CurveMath.cs,SolveCubicSpline,The following statement contains a magic number: if (np > 1)              {                    double[] a = new double[np];                    double x1;                    double x2;                    double y;                    double[] h = new double[np];                    for (int i = 1; i <= np - 1; i++)                  {                        h[i] = knownSamples[i].X - knownSamples[i - 1].X;                    }                    if (np > 2)                  {                        double[] sub = new double[np - 1];                        double[] diag = new double[np - 1];                        double[] sup = new double[np - 1];                        for (int i = 1; i <= np - 2; i++)                      {                            diag[i] = (h[i] + h[i + 1])/3;                            sup[i] = h[i + 1]/6;                            sub[i] = h[i]/6;                            a[i] = (knownSamples[i + 1].Y - knownSamples[i].Y)/h[i + 1] -                                   (knownSamples[i].Y - knownSamples[i - 1].Y)/h[i];                        }                        // SolveTridiag is a support function' see Marco Roello's original code                        // for more information at                        // http://www.codeproject.com/useritems/SplineInterpolation.asp                        SolveTridiag(sub' diag' sup' ref a' np - 2);                    }                        int gap = 0;                    double previous = double.MinValue;                    // At the end of this iteration' "gap" will contain the index of the interval                    // between two known values' which contains the unknown z' and "previous" will                    // contain the biggest z value among the known samples' left of the unknown z                    for (int i = 0; i < knownSamples.Count; i++)                  {                        if (knownSamples[i].X < z && knownSamples[i].X > previous)                      {                            previous = knownSamples[i].X;                            gap = i + 1;                        }                    }                    x1 = z - previous;                    if (gap > h.Length - 1)                      return z;                    x2 = h[gap] - x1;                    if (gap == 0)                      return 0.0;                    y = ((-a[gap - 1]/6*(x2 + h[gap])*x1 + knownSamples[gap - 1].Y)*x2 +                         (-a[gap]/6*(x1 + h[gap])*x2 + knownSamples[gap].Y)*x1)/h[gap];                    return y;                }
Magic Number,FreePIE.Core.Common,CurveMath,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\CurveMath.cs,SolveCubicSpline,The following statement contains a magic number: if (np > 1)              {                    double[] a = new double[np];                    double x1;                    double x2;                    double y;                    double[] h = new double[np];                    for (int i = 1; i <= np - 1; i++)                  {                        h[i] = knownSamples[i].X - knownSamples[i - 1].X;                    }                    if (np > 2)                  {                        double[] sub = new double[np - 1];                        double[] diag = new double[np - 1];                        double[] sup = new double[np - 1];                        for (int i = 1; i <= np - 2; i++)                      {                            diag[i] = (h[i] + h[i + 1])/3;                            sup[i] = h[i + 1]/6;                            sub[i] = h[i]/6;                            a[i] = (knownSamples[i + 1].Y - knownSamples[i].Y)/h[i + 1] -                                   (knownSamples[i].Y - knownSamples[i - 1].Y)/h[i];                        }                        // SolveTridiag is a support function' see Marco Roello's original code                        // for more information at                        // http://www.codeproject.com/useritems/SplineInterpolation.asp                        SolveTridiag(sub' diag' sup' ref a' np - 2);                    }                        int gap = 0;                    double previous = double.MinValue;                    // At the end of this iteration' "gap" will contain the index of the interval                    // between two known values' which contains the unknown z' and "previous" will                    // contain the biggest z value among the known samples' left of the unknown z                    for (int i = 0; i < knownSamples.Count; i++)                  {                        if (knownSamples[i].X < z && knownSamples[i].X > previous)                      {                            previous = knownSamples[i].X;                            gap = i + 1;                        }                    }                    x1 = z - previous;                    if (gap > h.Length - 1)                      return z;                    x2 = h[gap] - x1;                    if (gap == 0)                      return 0.0;                    y = ((-a[gap - 1]/6*(x2 + h[gap])*x1 + knownSamples[gap - 1].Y)*x2 +                         (-a[gap]/6*(x1 + h[gap])*x2 + knownSamples[gap].Y)*x1)/h[gap];                    return y;                }
Magic Number,FreePIE.Core.Common,CurveMath,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\CurveMath.cs,SolveCubicSpline,The following statement contains a magic number: if (np > 1)              {                    double[] a = new double[np];                    double x1;                    double x2;                    double y;                    double[] h = new double[np];                    for (int i = 1; i <= np - 1; i++)                  {                        h[i] = knownSamples[i].X - knownSamples[i - 1].X;                    }                    if (np > 2)                  {                        double[] sub = new double[np - 1];                        double[] diag = new double[np - 1];                        double[] sup = new double[np - 1];                        for (int i = 1; i <= np - 2; i++)                      {                            diag[i] = (h[i] + h[i + 1])/3;                            sup[i] = h[i + 1]/6;                            sub[i] = h[i]/6;                            a[i] = (knownSamples[i + 1].Y - knownSamples[i].Y)/h[i + 1] -                                   (knownSamples[i].Y - knownSamples[i - 1].Y)/h[i];                        }                        // SolveTridiag is a support function' see Marco Roello's original code                        // for more information at                        // http://www.codeproject.com/useritems/SplineInterpolation.asp                        SolveTridiag(sub' diag' sup' ref a' np - 2);                    }                        int gap = 0;                    double previous = double.MinValue;                    // At the end of this iteration' "gap" will contain the index of the interval                    // between two known values' which contains the unknown z' and "previous" will                    // contain the biggest z value among the known samples' left of the unknown z                    for (int i = 0; i < knownSamples.Count; i++)                  {                        if (knownSamples[i].X < z && knownSamples[i].X > previous)                      {                            previous = knownSamples[i].X;                            gap = i + 1;                        }                    }                    x1 = z - previous;                    if (gap > h.Length - 1)                      return z;                    x2 = h[gap] - x1;                    if (gap == 0)                      return 0.0;                    y = ((-a[gap - 1]/6*(x2 + h[gap])*x1 + knownSamples[gap - 1].Y)*x2 +                         (-a[gap]/6*(x1 + h[gap])*x2 + knownSamples[gap].Y)*x1)/h[gap];                    return y;                }
Magic Number,FreePIE.Core.Common,CurveMath,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Common\CurveMath.cs,SolveTridiag,The following statement contains a magic number: for (i = 2; i <= n; i++)              {                  sub[i] = sub[i]/diag[i - 1];                  diag[i] = diag[i] - sub[i]*sup[i - 1];                  b[i] = b[i] - sub[i]*b[i - 1];              }
Magic Number,FreePIE.Core.Model,Settings,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Model\Settings.cs,AddRecentScript,The following statement contains a magic number: if (path != null)              {                  const int n = 10;                  RecentScripts.Remove(path);                  RecentScripts.Insert(0'path);                  if(RecentScripts.Count > n)                       RecentScripts.RemoveRange(n' RecentScripts.Count-n);              }
Magic Number,FreePIE.Core.Model,Point,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Model\Curve.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return (X.GetHashCode() * 397) ^ Y.GetHashCode();              }
Magic Number,FreePIE.Core.ScriptEngine.CodeCompletion,Token,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\ScriptEngine\CodeCompletion\Token.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return ((Value != null ? Value.GetHashCode() : 0)*397) ^ Type.GetHashCode();              }
Magic Number,FreePIE.Core.ScriptEngine.CodeCompletion,ExpressionInfo,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\ScriptEngine\CodeCompletion\ExpressionInfo.cs,GetFormattedDescription,The following statement contains a magic number: var b = new StringBuilder(Name.Length + Description.Length + 5);
Magic Number,FreePIE.Core.ScriptEngine.Globals.ScriptHelpers.Strategies,ContinuesRotationStrategy,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\ScriptEngine\Globals\ScriptHelpers\Strategies\ContinuesRotationStrategy.cs,Update,The following statement contains a magic number: if (Math.Abs(delta) > halfCircle)              {                  if (delta > 0)                      delta -= (2*halfCircle);                  else                      delta += (2*halfCircle);              }
Magic Number,FreePIE.Core.ScriptEngine.Globals.ScriptHelpers.Strategies,ContinuesRotationStrategy,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\ScriptEngine\Globals\ScriptHelpers\Strategies\ContinuesRotationStrategy.cs,Update,The following statement contains a magic number: if (Math.Abs(delta) > halfCircle)              {                  if (delta > 0)                      delta -= (2*halfCircle);                  else                      delta += (2*halfCircle);              }
Magic Number,FreePIE.Core.ScriptEngine.Python,PythonScriptEngine,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\ScriptEngine\Python\PythonScriptEngine.cs,Stop,The following statement contains a magic number: const int maximumShutdownTime = 200;
Magic Number,FreePIE.Core.ScriptEngine.Python,PythonScriptParser,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\ScriptEngine\Python\PythonScriptParser.cs,FindAndInitMethodsThatNeedIndexer,The following statement contains a magic number: for (int i = 0; i < script.Length; i++)              {                  foreach (var needIndex in globalsThatNeedsIndex)                  {                      var name = GlobalsInfo.GetGlobalName(needIndex.Global);                      var methodName = needIndex.MethodInfo.Name;                      var searchFor = string.Format("{0}.{1}"' name' methodName);                        if (i + searchFor.Length <= script.Length && script.Substring(i' searchFor.Length) == searchFor)                      {                          int argumentStart = i + searchFor.Length;                          var arguments = ExtractArguments(script' argumentStart);                          int argumentEnd = argumentStart + arguments.Length;                            var proccesedArguments = FindAndInitMethodsThatNeedIndexer(arguments.Substring(0' arguments.Length - 1)' globals);                            var newArguments = string.Format(@"{0}' ""{1}"")"' proccesedArguments' arguments.Substring(1' arguments.Length - 2).Replace(@""""' @"'"));                            script = script.Substring(0' argumentStart) +                                      newArguments + script.Substring(argumentEnd' script.Length - argumentEnd);                            i = argumentStart + newArguments.Length;                      }                  }              }
Magic Number,FreePIE.Core.Services,ServiceBootstrapper,C:\repos\AndersMalmgren_FreePIE\FreePIE.Core\Services\ServiceBootstrapper.cs,VerifyFactoryFunction,The following statement contains a magic number: if (genericArguments.Count() > 2)              {                  return false;              }
