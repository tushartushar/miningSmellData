Implementation smell,Namespace,Class,File,Method,Description
Long Method,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The method has 105 lines of code.
Complex Method,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,LoadEmoticonsThread,Cyclomatic complexity of the method is 10
Complex Method,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,Cyclomatic complexity of the method is 11
Complex Method,Client,UserStateDetector,C:\repos\npcook_infinichat-client\Client\UserStateDetector.cs,UpdateIdleTimer,Cyclomatic complexity of the method is 8
Complex Method,Client.UI,FontDialog,C:\repos\npcook_infinichat-client\Client\UI\FontDialog.xaml.cs,FontDialog,Cyclomatic complexity of the method is 9
Complex Method,Client.UI,FontDialog,C:\repos\npcook_infinichat-client\Client\UI\FontDialog.xaml.cs,CheckBoxChecked,Cyclomatic complexity of the method is 9
Complex Method,Client.UI,FontDialog,C:\repos\npcook_infinichat-client\Client\UI\FontDialog.xaml.cs,CheckBoxUnchecked,Cyclomatic complexity of the method is 9
Complex Method,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,SetConversation,Cyclomatic complexity of the method is 8
Complex Method,Client.UI.ViewModel,NewTabViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\NewTabViewModel.cs,UpdateContacts,Cyclomatic complexity of the method is 20
Long Parameter List,Client,ConnectionManager,C:\repos\npcook_infinichat-client\Client\ConnectionManager.cs,Connect,The method has 5 parameters.
Long Parameter List,Client,NotificationManager,C:\repos\npcook_infinichat-client\Client\NotificationManager.cs,CreateNotification,The method has 6 parameters.
Long Parameter List,Client,UserStateDetector,C:\repos\npcook_infinichat-client\Client\UserStateDetector.cs,MessageWindowHook,The method has 5 parameters.
Long Parameter List,Client.UI.ViewModel,MainWindowViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\MainWindowViewModel.cs,MainWindowViewModel,The method has 12 parameters.
Long Statement,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The length of the statement  "						 * Some gifs render correctly when you do this' but some don't. They are just poorly made? So' there's a heuristic in here:" is 122.
Long Statement,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The length of the statement  "						 * draw to the graphics surface in this case because the next frame might required layering the current frame. */using (var surface = new Bitmap (image.Width' image.Height' PixelFormat.Format32bppArgb)) " is 201.
Long Statement,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The length of the statement  "		// If the image is not animated or some of the properties required to animate it are corrupt' just process it as a static image " is 127.
Long Statement,Client,App,C:\repos\npcook_infinichat-client\Client\App.xaml.cs,OnStartup,The length of the statement  "	FontStyle fontStyle = (settings.FontBold ? FontStyle.Bold : 0) | (settings.FontItalic ? FontStyle.Italic : 0) | (settings.FontUnderline ? FontStyle.Underline : 0); " is 163.
Long Statement,Client,App,C:\repos\npcook_infinichat-client\Client\App.xaml.cs,CreateMainView,The length of the statement  "	var view = new UI.View.MainWindowView (new UI.ViewModel.MainWindowViewModel (this' ChatClient' ConnectionManager' Dispatcher)); " is 127.
Long Statement,Client.UI.ViewModel,MainWindowViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\MainWindowViewModel.cs,OnNewConversation,The length of the statement  "			App.NotificationManager.CreateNotification (e.Conversation.Contact.DisplayName' "has started a conversation"' Colors.Transparent' App.NotificationManager.DefaultShowTime); " is 171.
Virtual Method Call from Constructor,Client.UI.ViewModel,CloseableViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\CloseableViewModel.cs,CloseableViewModel,The constructor "CloseableViewModel" calls a virtual method "RequestClose".
Virtual Method Call from Constructor,Client.UI.ViewModel,ContactViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ContactViewModel.cs,ContactViewModel,The constructor "ContactViewModel" calls a virtual method "OnContactChanged".
Empty Catch Block,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,LoadEmoticonsThread,The method has an empty catch block.
Empty Catch Block,Client,App,C:\repos\npcook_infinichat-client\Client\App.xaml.cs,OnStartup,The method has an empty catch block.
Magic Number,Client,ConnectionManager,C:\repos\npcook_infinichat-client\Client\ConnectionManager.cs,ConnectThread,The following statement contains a magic number: for (int i = 0; i <= maxRetryCount; ++i' waitTime *= 2) {  	try {  		netClient = new TcpClient ();  		var asyncResult = netClient.BeginConnect (hostname' port' null' null);  		try {  			// Stop what we're doing if the connection is cancelled from the main thread  			if (EventWaitHandle.WaitAny (new WaitHandle[] {  				connectDone'  				asyncResult.AsyncWaitHandle  			}) == 0) {  				netClient.Close ();  				netClient = null;  				return;  			}  			netClient.EndConnect (asyncResult);  		}  		finally {  			asyncResult.AsyncWaitHandle.Close ();  		}  		break;  	}  	catch (SocketException ex) {  		if (i == maxRetryCount) {  			NotifyConnectionResult (false' ex.Message);  			return;  		}  		else {  			Thread.Sleep (waitTime);  		}  	}  }  
Magic Number,Client,ConnectionManager,C:\repos\npcook_infinichat-client\Client\ConnectionManager.cs,ConnectThread,The following statement contains a magic number: waitTime *= 2
Magic Number,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The following statement contains a magic number: using (var memory = new MemoryStream ()) {  	if (IsAnimated (image)) {  		int frameCount = image.GetFrameCount (FrameDimension.Time);  		const int PropertyTagFrameDelay = 0x5100;  		var frameDelayProperty = image.GetPropertyItem (PropertyTagFrameDelay);  		if (frameDelayProperty != null && frameDelayProperty.Len == 4 * frameCount) {  			int[] frameDelays = new int[frameCount];  			for (int i = 0; i < frameDelays.Length; ++i) {  				// The frame delay property is in hundredths of a second' but we want milliseconds' so multiply by 10  				frameDelays [i] = 10 * BitConverter.ToInt32 (frameDelayProperty.Value' 4 * i);  			}  			/* Gifs are complicated. Technically' their frames must be layered on top of one another as they are displayed. 						 * Some gifs render correctly when you do this' but some don't. They are just poorly made? So' there's a heuristic in here: 						 * If the frame delay is zero' assume that the gif author wanted the frames layered (to get more colors in each frame). 						 * Otherwise' assume that layering is not desired and clear the graphics surface before drawing on it.  We still have to 						 * draw to the graphics surface in this case because the next frame might required layering the current frame. */using (var surface = new Bitmap (image.Width' image.Height' PixelFormat.Format32bppArgb))  				using (var graphics = Graphics.FromImage (surface)) {  					var frames = new EmoticonFrame[frameCount];  					for (int i = 0; i < frameCount; ++i) {  						memory.Position = 0;  						image.SelectActiveFrame (FrameDimension.Time' i);  						if (frameDelays [i] != 0)  							graphics.Clear (Color.Transparent);  						graphics.DrawImage (image' 0' 0);  						surface.Save (memory' ImageFormat.Png);  						// Reset stream to the beginning so that we can read the image we just saved  						memory.Position = 0;  						frames [i] = CreateFrame (memory' Math.Max (frameDelays [i]' 60));  					}  					return frames;  				}  		}  	}  	// If the image is not animated or some of the properties required to animate it are corrupt' just process it as a static image  	image.Save (memory' ImageFormat.Png);  	// Reset stream to the beginning so that we can read the image we just saved  	memory.Position = 0;  	return new EmoticonFrame[] {  		CreateFrame (memory' 0)  	};  }  
Magic Number,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The following statement contains a magic number: using (var memory = new MemoryStream ()) {  	if (IsAnimated (image)) {  		int frameCount = image.GetFrameCount (FrameDimension.Time);  		const int PropertyTagFrameDelay = 0x5100;  		var frameDelayProperty = image.GetPropertyItem (PropertyTagFrameDelay);  		if (frameDelayProperty != null && frameDelayProperty.Len == 4 * frameCount) {  			int[] frameDelays = new int[frameCount];  			for (int i = 0; i < frameDelays.Length; ++i) {  				// The frame delay property is in hundredths of a second' but we want milliseconds' so multiply by 10  				frameDelays [i] = 10 * BitConverter.ToInt32 (frameDelayProperty.Value' 4 * i);  			}  			/* Gifs are complicated. Technically' their frames must be layered on top of one another as they are displayed. 						 * Some gifs render correctly when you do this' but some don't. They are just poorly made? So' there's a heuristic in here: 						 * If the frame delay is zero' assume that the gif author wanted the frames layered (to get more colors in each frame). 						 * Otherwise' assume that layering is not desired and clear the graphics surface before drawing on it.  We still have to 						 * draw to the graphics surface in this case because the next frame might required layering the current frame. */using (var surface = new Bitmap (image.Width' image.Height' PixelFormat.Format32bppArgb))  				using (var graphics = Graphics.FromImage (surface)) {  					var frames = new EmoticonFrame[frameCount];  					for (int i = 0; i < frameCount; ++i) {  						memory.Position = 0;  						image.SelectActiveFrame (FrameDimension.Time' i);  						if (frameDelays [i] != 0)  							graphics.Clear (Color.Transparent);  						graphics.DrawImage (image' 0' 0);  						surface.Save (memory' ImageFormat.Png);  						// Reset stream to the beginning so that we can read the image we just saved  						memory.Position = 0;  						frames [i] = CreateFrame (memory' Math.Max (frameDelays [i]' 60));  					}  					return frames;  				}  		}  	}  	// If the image is not animated or some of the properties required to animate it are corrupt' just process it as a static image  	image.Save (memory' ImageFormat.Png);  	// Reset stream to the beginning so that we can read the image we just saved  	memory.Position = 0;  	return new EmoticonFrame[] {  		CreateFrame (memory' 0)  	};  }  
Magic Number,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The following statement contains a magic number: using (var memory = new MemoryStream ()) {  	if (IsAnimated (image)) {  		int frameCount = image.GetFrameCount (FrameDimension.Time);  		const int PropertyTagFrameDelay = 0x5100;  		var frameDelayProperty = image.GetPropertyItem (PropertyTagFrameDelay);  		if (frameDelayProperty != null && frameDelayProperty.Len == 4 * frameCount) {  			int[] frameDelays = new int[frameCount];  			for (int i = 0; i < frameDelays.Length; ++i) {  				// The frame delay property is in hundredths of a second' but we want milliseconds' so multiply by 10  				frameDelays [i] = 10 * BitConverter.ToInt32 (frameDelayProperty.Value' 4 * i);  			}  			/* Gifs are complicated. Technically' their frames must be layered on top of one another as they are displayed. 						 * Some gifs render correctly when you do this' but some don't. They are just poorly made? So' there's a heuristic in here: 						 * If the frame delay is zero' assume that the gif author wanted the frames layered (to get more colors in each frame). 						 * Otherwise' assume that layering is not desired and clear the graphics surface before drawing on it.  We still have to 						 * draw to the graphics surface in this case because the next frame might required layering the current frame. */using (var surface = new Bitmap (image.Width' image.Height' PixelFormat.Format32bppArgb))  				using (var graphics = Graphics.FromImage (surface)) {  					var frames = new EmoticonFrame[frameCount];  					for (int i = 0; i < frameCount; ++i) {  						memory.Position = 0;  						image.SelectActiveFrame (FrameDimension.Time' i);  						if (frameDelays [i] != 0)  							graphics.Clear (Color.Transparent);  						graphics.DrawImage (image' 0' 0);  						surface.Save (memory' ImageFormat.Png);  						// Reset stream to the beginning so that we can read the image we just saved  						memory.Position = 0;  						frames [i] = CreateFrame (memory' Math.Max (frameDelays [i]' 60));  					}  					return frames;  				}  		}  	}  	// If the image is not animated or some of the properties required to animate it are corrupt' just process it as a static image  	image.Save (memory' ImageFormat.Png);  	// Reset stream to the beginning so that we can read the image we just saved  	memory.Position = 0;  	return new EmoticonFrame[] {  		CreateFrame (memory' 0)  	};  }  
Magic Number,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The following statement contains a magic number: using (var memory = new MemoryStream ()) {  	if (IsAnimated (image)) {  		int frameCount = image.GetFrameCount (FrameDimension.Time);  		const int PropertyTagFrameDelay = 0x5100;  		var frameDelayProperty = image.GetPropertyItem (PropertyTagFrameDelay);  		if (frameDelayProperty != null && frameDelayProperty.Len == 4 * frameCount) {  			int[] frameDelays = new int[frameCount];  			for (int i = 0; i < frameDelays.Length; ++i) {  				// The frame delay property is in hundredths of a second' but we want milliseconds' so multiply by 10  				frameDelays [i] = 10 * BitConverter.ToInt32 (frameDelayProperty.Value' 4 * i);  			}  			/* Gifs are complicated. Technically' their frames must be layered on top of one another as they are displayed. 						 * Some gifs render correctly when you do this' but some don't. They are just poorly made? So' there's a heuristic in here: 						 * If the frame delay is zero' assume that the gif author wanted the frames layered (to get more colors in each frame). 						 * Otherwise' assume that layering is not desired and clear the graphics surface before drawing on it.  We still have to 						 * draw to the graphics surface in this case because the next frame might required layering the current frame. */using (var surface = new Bitmap (image.Width' image.Height' PixelFormat.Format32bppArgb))  				using (var graphics = Graphics.FromImage (surface)) {  					var frames = new EmoticonFrame[frameCount];  					for (int i = 0; i < frameCount; ++i) {  						memory.Position = 0;  						image.SelectActiveFrame (FrameDimension.Time' i);  						if (frameDelays [i] != 0)  							graphics.Clear (Color.Transparent);  						graphics.DrawImage (image' 0' 0);  						surface.Save (memory' ImageFormat.Png);  						// Reset stream to the beginning so that we can read the image we just saved  						memory.Position = 0;  						frames [i] = CreateFrame (memory' Math.Max (frameDelays [i]' 60));  					}  					return frames;  				}  		}  	}  	// If the image is not animated or some of the properties required to animate it are corrupt' just process it as a static image  	image.Save (memory' ImageFormat.Png);  	// Reset stream to the beginning so that we can read the image we just saved  	memory.Position = 0;  	return new EmoticonFrame[] {  		CreateFrame (memory' 0)  	};  }  
Magic Number,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The following statement contains a magic number: if (IsAnimated (image)) {  	int frameCount = image.GetFrameCount (FrameDimension.Time);  	const int PropertyTagFrameDelay = 0x5100;  	var frameDelayProperty = image.GetPropertyItem (PropertyTagFrameDelay);  	if (frameDelayProperty != null && frameDelayProperty.Len == 4 * frameCount) {  		int[] frameDelays = new int[frameCount];  		for (int i = 0; i < frameDelays.Length; ++i) {  			// The frame delay property is in hundredths of a second' but we want milliseconds' so multiply by 10  			frameDelays [i] = 10 * BitConverter.ToInt32 (frameDelayProperty.Value' 4 * i);  		}  		/* Gifs are complicated. Technically' their frames must be layered on top of one another as they are displayed. 						 * Some gifs render correctly when you do this' but some don't. They are just poorly made? So' there's a heuristic in here: 						 * If the frame delay is zero' assume that the gif author wanted the frames layered (to get more colors in each frame). 						 * Otherwise' assume that layering is not desired and clear the graphics surface before drawing on it.  We still have to 						 * draw to the graphics surface in this case because the next frame might required layering the current frame. */using (var surface = new Bitmap (image.Width' image.Height' PixelFormat.Format32bppArgb))  			using (var graphics = Graphics.FromImage (surface)) {  				var frames = new EmoticonFrame[frameCount];  				for (int i = 0; i < frameCount; ++i) {  					memory.Position = 0;  					image.SelectActiveFrame (FrameDimension.Time' i);  					if (frameDelays [i] != 0)  						graphics.Clear (Color.Transparent);  					graphics.DrawImage (image' 0' 0);  					surface.Save (memory' ImageFormat.Png);  					// Reset stream to the beginning so that we can read the image we just saved  					memory.Position = 0;  					frames [i] = CreateFrame (memory' Math.Max (frameDelays [i]' 60));  				}  				return frames;  			}  	}  }  
Magic Number,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The following statement contains a magic number: if (IsAnimated (image)) {  	int frameCount = image.GetFrameCount (FrameDimension.Time);  	const int PropertyTagFrameDelay = 0x5100;  	var frameDelayProperty = image.GetPropertyItem (PropertyTagFrameDelay);  	if (frameDelayProperty != null && frameDelayProperty.Len == 4 * frameCount) {  		int[] frameDelays = new int[frameCount];  		for (int i = 0; i < frameDelays.Length; ++i) {  			// The frame delay property is in hundredths of a second' but we want milliseconds' so multiply by 10  			frameDelays [i] = 10 * BitConverter.ToInt32 (frameDelayProperty.Value' 4 * i);  		}  		/* Gifs are complicated. Technically' their frames must be layered on top of one another as they are displayed. 						 * Some gifs render correctly when you do this' but some don't. They are just poorly made? So' there's a heuristic in here: 						 * If the frame delay is zero' assume that the gif author wanted the frames layered (to get more colors in each frame). 						 * Otherwise' assume that layering is not desired and clear the graphics surface before drawing on it.  We still have to 						 * draw to the graphics surface in this case because the next frame might required layering the current frame. */using (var surface = new Bitmap (image.Width' image.Height' PixelFormat.Format32bppArgb))  			using (var graphics = Graphics.FromImage (surface)) {  				var frames = new EmoticonFrame[frameCount];  				for (int i = 0; i < frameCount; ++i) {  					memory.Position = 0;  					image.SelectActiveFrame (FrameDimension.Time' i);  					if (frameDelays [i] != 0)  						graphics.Clear (Color.Transparent);  					graphics.DrawImage (image' 0' 0);  					surface.Save (memory' ImageFormat.Png);  					// Reset stream to the beginning so that we can read the image we just saved  					memory.Position = 0;  					frames [i] = CreateFrame (memory' Math.Max (frameDelays [i]' 60));  				}  				return frames;  			}  	}  }  
Magic Number,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The following statement contains a magic number: if (IsAnimated (image)) {  	int frameCount = image.GetFrameCount (FrameDimension.Time);  	const int PropertyTagFrameDelay = 0x5100;  	var frameDelayProperty = image.GetPropertyItem (PropertyTagFrameDelay);  	if (frameDelayProperty != null && frameDelayProperty.Len == 4 * frameCount) {  		int[] frameDelays = new int[frameCount];  		for (int i = 0; i < frameDelays.Length; ++i) {  			// The frame delay property is in hundredths of a second' but we want milliseconds' so multiply by 10  			frameDelays [i] = 10 * BitConverter.ToInt32 (frameDelayProperty.Value' 4 * i);  		}  		/* Gifs are complicated. Technically' their frames must be layered on top of one another as they are displayed. 						 * Some gifs render correctly when you do this' but some don't. They are just poorly made? So' there's a heuristic in here: 						 * If the frame delay is zero' assume that the gif author wanted the frames layered (to get more colors in each frame). 						 * Otherwise' assume that layering is not desired and clear the graphics surface before drawing on it.  We still have to 						 * draw to the graphics surface in this case because the next frame might required layering the current frame. */using (var surface = new Bitmap (image.Width' image.Height' PixelFormat.Format32bppArgb))  			using (var graphics = Graphics.FromImage (surface)) {  				var frames = new EmoticonFrame[frameCount];  				for (int i = 0; i < frameCount; ++i) {  					memory.Position = 0;  					image.SelectActiveFrame (FrameDimension.Time' i);  					if (frameDelays [i] != 0)  						graphics.Clear (Color.Transparent);  					graphics.DrawImage (image' 0' 0);  					surface.Save (memory' ImageFormat.Png);  					// Reset stream to the beginning so that we can read the image we just saved  					memory.Position = 0;  					frames [i] = CreateFrame (memory' Math.Max (frameDelays [i]' 60));  				}  				return frames;  			}  	}  }  
Magic Number,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The following statement contains a magic number: if (IsAnimated (image)) {  	int frameCount = image.GetFrameCount (FrameDimension.Time);  	const int PropertyTagFrameDelay = 0x5100;  	var frameDelayProperty = image.GetPropertyItem (PropertyTagFrameDelay);  	if (frameDelayProperty != null && frameDelayProperty.Len == 4 * frameCount) {  		int[] frameDelays = new int[frameCount];  		for (int i = 0; i < frameDelays.Length; ++i) {  			// The frame delay property is in hundredths of a second' but we want milliseconds' so multiply by 10  			frameDelays [i] = 10 * BitConverter.ToInt32 (frameDelayProperty.Value' 4 * i);  		}  		/* Gifs are complicated. Technically' their frames must be layered on top of one another as they are displayed. 						 * Some gifs render correctly when you do this' but some don't. They are just poorly made? So' there's a heuristic in here: 						 * If the frame delay is zero' assume that the gif author wanted the frames layered (to get more colors in each frame). 						 * Otherwise' assume that layering is not desired and clear the graphics surface before drawing on it.  We still have to 						 * draw to the graphics surface in this case because the next frame might required layering the current frame. */using (var surface = new Bitmap (image.Width' image.Height' PixelFormat.Format32bppArgb))  			using (var graphics = Graphics.FromImage (surface)) {  				var frames = new EmoticonFrame[frameCount];  				for (int i = 0; i < frameCount; ++i) {  					memory.Position = 0;  					image.SelectActiveFrame (FrameDimension.Time' i);  					if (frameDelays [i] != 0)  						graphics.Clear (Color.Transparent);  					graphics.DrawImage (image' 0' 0);  					surface.Save (memory' ImageFormat.Png);  					// Reset stream to the beginning so that we can read the image we just saved  					memory.Position = 0;  					frames [i] = CreateFrame (memory' Math.Max (frameDelays [i]' 60));  				}  				return frames;  			}  	}  }  
Magic Number,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The following statement contains a magic number: if (frameDelayProperty != null && frameDelayProperty.Len == 4 * frameCount) {  	int[] frameDelays = new int[frameCount];  	for (int i = 0; i < frameDelays.Length; ++i) {  		// The frame delay property is in hundredths of a second' but we want milliseconds' so multiply by 10  		frameDelays [i] = 10 * BitConverter.ToInt32 (frameDelayProperty.Value' 4 * i);  	}  	/* Gifs are complicated. Technically' their frames must be layered on top of one another as they are displayed. 						 * Some gifs render correctly when you do this' but some don't. They are just poorly made? So' there's a heuristic in here: 						 * If the frame delay is zero' assume that the gif author wanted the frames layered (to get more colors in each frame). 						 * Otherwise' assume that layering is not desired and clear the graphics surface before drawing on it.  We still have to 						 * draw to the graphics surface in this case because the next frame might required layering the current frame. */using (var surface = new Bitmap (image.Width' image.Height' PixelFormat.Format32bppArgb))  		using (var graphics = Graphics.FromImage (surface)) {  			var frames = new EmoticonFrame[frameCount];  			for (int i = 0; i < frameCount; ++i) {  				memory.Position = 0;  				image.SelectActiveFrame (FrameDimension.Time' i);  				if (frameDelays [i] != 0)  					graphics.Clear (Color.Transparent);  				graphics.DrawImage (image' 0' 0);  				surface.Save (memory' ImageFormat.Png);  				// Reset stream to the beginning so that we can read the image we just saved  				memory.Position = 0;  				frames [i] = CreateFrame (memory' Math.Max (frameDelays [i]' 60));  			}  			return frames;  		}  }  
Magic Number,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The following statement contains a magic number: if (frameDelayProperty != null && frameDelayProperty.Len == 4 * frameCount) {  	int[] frameDelays = new int[frameCount];  	for (int i = 0; i < frameDelays.Length; ++i) {  		// The frame delay property is in hundredths of a second' but we want milliseconds' so multiply by 10  		frameDelays [i] = 10 * BitConverter.ToInt32 (frameDelayProperty.Value' 4 * i);  	}  	/* Gifs are complicated. Technically' their frames must be layered on top of one another as they are displayed. 						 * Some gifs render correctly when you do this' but some don't. They are just poorly made? So' there's a heuristic in here: 						 * If the frame delay is zero' assume that the gif author wanted the frames layered (to get more colors in each frame). 						 * Otherwise' assume that layering is not desired and clear the graphics surface before drawing on it.  We still have to 						 * draw to the graphics surface in this case because the next frame might required layering the current frame. */using (var surface = new Bitmap (image.Width' image.Height' PixelFormat.Format32bppArgb))  		using (var graphics = Graphics.FromImage (surface)) {  			var frames = new EmoticonFrame[frameCount];  			for (int i = 0; i < frameCount; ++i) {  				memory.Position = 0;  				image.SelectActiveFrame (FrameDimension.Time' i);  				if (frameDelays [i] != 0)  					graphics.Clear (Color.Transparent);  				graphics.DrawImage (image' 0' 0);  				surface.Save (memory' ImageFormat.Png);  				// Reset stream to the beginning so that we can read the image we just saved  				memory.Position = 0;  				frames [i] = CreateFrame (memory' Math.Max (frameDelays [i]' 60));  			}  			return frames;  		}  }  
Magic Number,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The following statement contains a magic number: if (frameDelayProperty != null && frameDelayProperty.Len == 4 * frameCount) {  	int[] frameDelays = new int[frameCount];  	for (int i = 0; i < frameDelays.Length; ++i) {  		// The frame delay property is in hundredths of a second' but we want milliseconds' so multiply by 10  		frameDelays [i] = 10 * BitConverter.ToInt32 (frameDelayProperty.Value' 4 * i);  	}  	/* Gifs are complicated. Technically' their frames must be layered on top of one another as they are displayed. 						 * Some gifs render correctly when you do this' but some don't. They are just poorly made? So' there's a heuristic in here: 						 * If the frame delay is zero' assume that the gif author wanted the frames layered (to get more colors in each frame). 						 * Otherwise' assume that layering is not desired and clear the graphics surface before drawing on it.  We still have to 						 * draw to the graphics surface in this case because the next frame might required layering the current frame. */using (var surface = new Bitmap (image.Width' image.Height' PixelFormat.Format32bppArgb))  		using (var graphics = Graphics.FromImage (surface)) {  			var frames = new EmoticonFrame[frameCount];  			for (int i = 0; i < frameCount; ++i) {  				memory.Position = 0;  				image.SelectActiveFrame (FrameDimension.Time' i);  				if (frameDelays [i] != 0)  					graphics.Clear (Color.Transparent);  				graphics.DrawImage (image' 0' 0);  				surface.Save (memory' ImageFormat.Png);  				// Reset stream to the beginning so that we can read the image we just saved  				memory.Position = 0;  				frames [i] = CreateFrame (memory' Math.Max (frameDelays [i]' 60));  			}  			return frames;  		}  }  
Magic Number,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The following statement contains a magic number: if (frameDelayProperty != null && frameDelayProperty.Len == 4 * frameCount) {  	int[] frameDelays = new int[frameCount];  	for (int i = 0; i < frameDelays.Length; ++i) {  		// The frame delay property is in hundredths of a second' but we want milliseconds' so multiply by 10  		frameDelays [i] = 10 * BitConverter.ToInt32 (frameDelayProperty.Value' 4 * i);  	}  	/* Gifs are complicated. Technically' their frames must be layered on top of one another as they are displayed. 						 * Some gifs render correctly when you do this' but some don't. They are just poorly made? So' there's a heuristic in here: 						 * If the frame delay is zero' assume that the gif author wanted the frames layered (to get more colors in each frame). 						 * Otherwise' assume that layering is not desired and clear the graphics surface before drawing on it.  We still have to 						 * draw to the graphics surface in this case because the next frame might required layering the current frame. */using (var surface = new Bitmap (image.Width' image.Height' PixelFormat.Format32bppArgb))  		using (var graphics = Graphics.FromImage (surface)) {  			var frames = new EmoticonFrame[frameCount];  			for (int i = 0; i < frameCount; ++i) {  				memory.Position = 0;  				image.SelectActiveFrame (FrameDimension.Time' i);  				if (frameDelays [i] != 0)  					graphics.Clear (Color.Transparent);  				graphics.DrawImage (image' 0' 0);  				surface.Save (memory' ImageFormat.Png);  				// Reset stream to the beginning so that we can read the image we just saved  				memory.Position = 0;  				frames [i] = CreateFrame (memory' Math.Max (frameDelays [i]' 60));  			}  			return frames;  		}  }  
Magic Number,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The following statement contains a magic number: for (int i = 0; i < frameDelays.Length; ++i) {  	// The frame delay property is in hundredths of a second' but we want milliseconds' so multiply by 10  	frameDelays [i] = 10 * BitConverter.ToInt32 (frameDelayProperty.Value' 4 * i);  }  
Magic Number,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The following statement contains a magic number: for (int i = 0; i < frameDelays.Length; ++i) {  	// The frame delay property is in hundredths of a second' but we want milliseconds' so multiply by 10  	frameDelays [i] = 10 * BitConverter.ToInt32 (frameDelayProperty.Value' 4 * i);  }  
Magic Number,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The following statement contains a magic number: frameDelays [i] = 10 * BitConverter.ToInt32 (frameDelayProperty.Value' 4 * i);  
Magic Number,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The following statement contains a magic number: frameDelays [i] = 10 * BitConverter.ToInt32 (frameDelayProperty.Value' 4 * i);  
Magic Number,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The following statement contains a magic number: using (var surface = new Bitmap (image.Width' image.Height' PixelFormat.Format32bppArgb))  	using (var graphics = Graphics.FromImage (surface)) {  		var frames = new EmoticonFrame[frameCount];  		for (int i = 0; i < frameCount; ++i) {  			memory.Position = 0;  			image.SelectActiveFrame (FrameDimension.Time' i);  			if (frameDelays [i] != 0)  				graphics.Clear (Color.Transparent);  			graphics.DrawImage (image' 0' 0);  			surface.Save (memory' ImageFormat.Png);  			// Reset stream to the beginning so that we can read the image we just saved  			memory.Position = 0;  			frames [i] = CreateFrame (memory' Math.Max (frameDelays [i]' 60));  		}  		return frames;  	}  
Magic Number,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The following statement contains a magic number: using (var graphics = Graphics.FromImage (surface)) {  	var frames = new EmoticonFrame[frameCount];  	for (int i = 0; i < frameCount; ++i) {  		memory.Position = 0;  		image.SelectActiveFrame (FrameDimension.Time' i);  		if (frameDelays [i] != 0)  			graphics.Clear (Color.Transparent);  		graphics.DrawImage (image' 0' 0);  		surface.Save (memory' ImageFormat.Png);  		// Reset stream to the beginning so that we can read the image we just saved  		memory.Position = 0;  		frames [i] = CreateFrame (memory' Math.Max (frameDelays [i]' 60));  	}  	return frames;  }  
Magic Number,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The following statement contains a magic number: for (int i = 0; i < frameCount; ++i) {  	memory.Position = 0;  	image.SelectActiveFrame (FrameDimension.Time' i);  	if (frameDelays [i] != 0)  		graphics.Clear (Color.Transparent);  	graphics.DrawImage (image' 0' 0);  	surface.Save (memory' ImageFormat.Png);  	// Reset stream to the beginning so that we can read the image we just saved  	memory.Position = 0;  	frames [i] = CreateFrame (memory' Math.Max (frameDelays [i]' 60));  }  
Magic Number,Client,EmoticonManager,C:\repos\npcook_infinichat-client\Client\EmoticonManager.cs,GetEmoticonFrames,The following statement contains a magic number: frames [i] = CreateFrame (memory' Math.Max (frameDelays [i]' 60));  
Magic Number,Client,NotificationManager,C:\repos\npcook_infinichat-client\Client\NotificationManager.cs,PlaceNotification,The following statement contains a magic number: if (App.Current.MainWindow != null) {  	var source = System.Windows.PresentationSource.FromVisual (notification);  	if (source != null) {  		var workArea = System.Windows.SystemParameters.WorkArea;  		var point = source.CompositionTarget.TransformToDevice.Transform (workArea.BottomRight);  		point.X -= notification.Width + 5;  		point.Y -= notifications.Count * notification.Height + 5;  		notification.Left = point.X;  		notification.Top = point.Y;  	}  }  
Magic Number,Client,NotificationManager,C:\repos\npcook_infinichat-client\Client\NotificationManager.cs,PlaceNotification,The following statement contains a magic number: if (App.Current.MainWindow != null) {  	var source = System.Windows.PresentationSource.FromVisual (notification);  	if (source != null) {  		var workArea = System.Windows.SystemParameters.WorkArea;  		var point = source.CompositionTarget.TransformToDevice.Transform (workArea.BottomRight);  		point.X -= notification.Width + 5;  		point.Y -= notifications.Count * notification.Height + 5;  		notification.Left = point.X;  		notification.Top = point.Y;  	}  }  
Magic Number,Client,NotificationManager,C:\repos\npcook_infinichat-client\Client\NotificationManager.cs,PlaceNotification,The following statement contains a magic number: if (source != null) {  	var workArea = System.Windows.SystemParameters.WorkArea;  	var point = source.CompositionTarget.TransformToDevice.Transform (workArea.BottomRight);  	point.X -= notification.Width + 5;  	point.Y -= notifications.Count * notification.Height + 5;  	notification.Left = point.X;  	notification.Top = point.Y;  }  
Magic Number,Client,NotificationManager,C:\repos\npcook_infinichat-client\Client\NotificationManager.cs,PlaceNotification,The following statement contains a magic number: if (source != null) {  	var workArea = System.Windows.SystemParameters.WorkArea;  	var point = source.CompositionTarget.TransformToDevice.Transform (workArea.BottomRight);  	point.X -= notification.Width + 5;  	point.Y -= notifications.Count * notification.Height + 5;  	notification.Left = point.X;  	notification.Top = point.Y;  }  
Magic Number,Client,NotificationManager,C:\repos\npcook_infinichat-client\Client\NotificationManager.cs,PlaceNotification,The following statement contains a magic number: point.X -= notification.Width + 5;  
Magic Number,Client,NotificationManager,C:\repos\npcook_infinichat-client\Client\NotificationManager.cs,PlaceNotification,The following statement contains a magic number: point.Y -= notifications.Count * notification.Height + 5;  
Magic Number,Client,UserStateDetector,C:\repos\npcook_infinichat-client\Client\UserStateDetector.cs,UpdateIdleTimer,The following statement contains a magic number: if (!IsIdle) {  	long MSToGo = (long)idleThreshold - (long)ticksSinceLastInput;  	if (MSToGo < 0) {  		IsIdle = true;  		if (UserIdleChanged != null)  			UserIdleChanged (this' new UserIdleEventArgs (true));  		idleTimer.Change (5000' 5000);  	}  	else  		idleTimer.Change (MSToGo + 1000' Timeout.Infinite);  }  else {  	if (ticksSinceLastInput < idleThreshold) {  		IsIdle = false;  		if (UserIdleChanged != null)  			UserIdleChanged (this' new UserIdleEventArgs (false));  		UpdateIdleTimer ();  	}  }  
Magic Number,Client,UserStateDetector,C:\repos\npcook_infinichat-client\Client\UserStateDetector.cs,UpdateIdleTimer,The following statement contains a magic number: if (!IsIdle) {  	long MSToGo = (long)idleThreshold - (long)ticksSinceLastInput;  	if (MSToGo < 0) {  		IsIdle = true;  		if (UserIdleChanged != null)  			UserIdleChanged (this' new UserIdleEventArgs (true));  		idleTimer.Change (5000' 5000);  	}  	else  		idleTimer.Change (MSToGo + 1000' Timeout.Infinite);  }  else {  	if (ticksSinceLastInput < idleThreshold) {  		IsIdle = false;  		if (UserIdleChanged != null)  			UserIdleChanged (this' new UserIdleEventArgs (false));  		UpdateIdleTimer ();  	}  }  
Magic Number,Client,UserStateDetector,C:\repos\npcook_infinichat-client\Client\UserStateDetector.cs,UpdateIdleTimer,The following statement contains a magic number: if (!IsIdle) {  	long MSToGo = (long)idleThreshold - (long)ticksSinceLastInput;  	if (MSToGo < 0) {  		IsIdle = true;  		if (UserIdleChanged != null)  			UserIdleChanged (this' new UserIdleEventArgs (true));  		idleTimer.Change (5000' 5000);  	}  	else  		idleTimer.Change (MSToGo + 1000' Timeout.Infinite);  }  else {  	if (ticksSinceLastInput < idleThreshold) {  		IsIdle = false;  		if (UserIdleChanged != null)  			UserIdleChanged (this' new UserIdleEventArgs (false));  		UpdateIdleTimer ();  	}  }  
Magic Number,Client,UserStateDetector,C:\repos\npcook_infinichat-client\Client\UserStateDetector.cs,UpdateIdleTimer,The following statement contains a magic number: if (MSToGo < 0) {  	IsIdle = true;  	if (UserIdleChanged != null)  		UserIdleChanged (this' new UserIdleEventArgs (true));  	idleTimer.Change (5000' 5000);  }  else  	idleTimer.Change (MSToGo + 1000' Timeout.Infinite);  
Magic Number,Client,UserStateDetector,C:\repos\npcook_infinichat-client\Client\UserStateDetector.cs,UpdateIdleTimer,The following statement contains a magic number: if (MSToGo < 0) {  	IsIdle = true;  	if (UserIdleChanged != null)  		UserIdleChanged (this' new UserIdleEventArgs (true));  	idleTimer.Change (5000' 5000);  }  else  	idleTimer.Change (MSToGo + 1000' Timeout.Infinite);  
Magic Number,Client,UserStateDetector,C:\repos\npcook_infinichat-client\Client\UserStateDetector.cs,UpdateIdleTimer,The following statement contains a magic number: if (MSToGo < 0) {  	IsIdle = true;  	if (UserIdleChanged != null)  		UserIdleChanged (this' new UserIdleEventArgs (true));  	idleTimer.Change (5000' 5000);  }  else  	idleTimer.Change (MSToGo + 1000' Timeout.Infinite);  
Magic Number,Client,UserStateDetector,C:\repos\npcook_infinichat-client\Client\UserStateDetector.cs,UpdateIdleTimer,The following statement contains a magic number: idleTimer.Change (5000' 5000);  
Magic Number,Client,UserStateDetector,C:\repos\npcook_infinichat-client\Client\UserStateDetector.cs,UpdateIdleTimer,The following statement contains a magic number: idleTimer.Change (5000' 5000);  
Magic Number,Client,UserStateDetector,C:\repos\npcook_infinichat-client\Client\UserStateDetector.cs,UpdateIdleTimer,The following statement contains a magic number: idleTimer.Change (MSToGo + 1000' Timeout.Infinite);  
Magic Number,Client.UI,FontDialog,C:\repos\npcook_infinichat-client\Client\UI\FontDialog.xaml.cs,FontDialog,The following statement contains a magic number: foreach (var family in families) {  	var item = new ListBoxItem () {  		Content = family.Source'  		VerticalContentAlignment = VerticalAlignment.Top'  		FontFamily = family'  		Padding = new Thickness (2)'  		FontSize = 14'  	};  	FontFamilyListBox.Items.Add (item);  	if (family.Source == currentFont.Family)  		FontFamilyListBox.SelectedItem = item;  }  
Magic Number,Client.UI,FontDialog,C:\repos\npcook_infinichat-client\Client\UI\FontDialog.xaml.cs,FontDialog,The following statement contains a magic number: foreach (var family in families) {  	var item = new ListBoxItem () {  		Content = family.Source'  		VerticalContentAlignment = VerticalAlignment.Top'  		FontFamily = family'  		Padding = new Thickness (2)'  		FontSize = 14'  	};  	FontFamilyListBox.Items.Add (item);  	if (family.Source == currentFont.Family)  		FontFamilyListBox.SelectedItem = item;  }  
Magic Number,Client.UI,FontDialog,C:\repos\npcook_infinichat-client\Client\UI\FontDialog.xaml.cs,FontDialog,The following statement contains a magic number: SizeComboBox.SelectedIndex = 5;  
Magic Number,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The following statement contains a magic number: App.Current.Dispatcher.BeginInvoke (new Action (() =>  {  	const int FontSize = 14;  	var message = e.Message.Text;  	var font = e.Message.Font;  	var sender = e.Message.Sender;  	// Add this color to the brush cache if it's not there already  	var brush = App.GetBrush (font.Color);  	Paragraph paragraph;  	if (sender != lastSender) {  		lastSender = sender;  		paragraph = new Paragraph () {  			FontSize = FontSize + 2'  			Foreground = Brushes.Black'  			FontWeight = FontWeights.Light'  			Margin = new Thickness (0' 4.0' 0' 2.0)'  			Padding = new Thickness (0' 0' 0' 2.0)'  			BorderBrush = Brushes.LightGray'  			BorderThickness = new Thickness (0' 0' 0' 1)'  		};  		paragraph.Inlines.Add (new Run (sender.DisplayName));  		ChatHistory.Add (paragraph);  	}  	paragraph = new Paragraph () {  		FontFamily = new FontFamily (font.Family)'  		FontSize = FontSize'  		LineHeight = 3 * FontSize / 2'  		Foreground = brush'  		Margin = new Thickness (16.0' 0' 0' 0)'  		TextIndent = 0'  	};  	/*				var path = new System.Windows.Shapes.Path() 				{ 					Stroke = Brushes.Black' 					StrokeThickness = 2' 					Data = App.Current.FindResource("CrossGeometry") as Geometry' 					Width = 12' 					Height = paragraph.FontSize' 					Margin = new Thickness(0' 0' 4' 0)' 				};  				paragraph.Inlines.Add(new InlineUIContainer(path));*/var stops = new List<ChatStop> ();  	foreach (var emoteStop in App.EmoticonManager.SearchForEmoticons (message)) {  		stops.Add (new ChatStop () {  			Index = emoteStop.Key'  			Length = emoteStop.Value.Shortcut.Length'  			Type = StopType.Emoticon'  			Data = emoteStop.Value'  		});  	}  	string[] urls = new string[] {  		"http://"'  		"https://"  	};  	foreach (var url in urls) {  		int index = message.IndexOf (url);  		while (index != -1) {  			int endIndex = message.IndexOf (' '' index);  			if (endIndex == -1)  				endIndex = message.Length - 1;  			stops.Add (new ChatStop () {  				Index = index'  				Length = endIndex - index + 1'  				Type = StopType.Url'  			});  			index = message.IndexOf (url' endIndex);  		}  	}  	var orderedStops = stops.OrderBy (_ => _.Index);  	int startIndex = 0;  	foreach (var stop in orderedStops) {  		if (stop.Index < startIndex)  			continue;  		if (stop.Index != startIndex)  			paragraph.Inlines.Add (new Run (message.Substring (startIndex' stop.Index - startIndex)));  		switch (stop.Type) {  		case StopType.Emoticon:  			var picture = new EmoteImage () {  				SnapsToDevicePixels = true'  				Emote = stop.Data as Emoticon'  			};  			paragraph.Inlines.Add (new InlineUIContainer (picture));  			break;  		case StopType.Url:  			var text = message.Substring (stop.Index' stop.Length);  			var link = new Hyperlink (new Run (text));  			link.Tag = text;  			link.Click += OnChatLinkClicked;  			paragraph.Inlines.Add (link);  			break;  		}  		startIndex = stop.Index + stop.Length;  	}  	paragraph.Inlines.Add (new Run (message.Substring (startIndex)));  	if (font.Style.HasFlag (Protocol.FontStyle.Bold))  		paragraph.FontWeight = FontWeights.Bold;  	if (font.Style.HasFlag (Protocol.FontStyle.Italic))  		paragraph.FontStyle = FontStyles.Italic;  	if (font.Style.HasFlag (Protocol.FontStyle.Underline)) {  		paragraph.TextDecorations = new TextDecorationCollection ();  		paragraph.TextDecorations.Add (System.Windows.TextDecorations.Underline);  	}  	ChatHistory.Add (paragraph);  }));  
Magic Number,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The following statement contains a magic number: App.Current.Dispatcher.BeginInvoke (new Action (() =>  {  	const int FontSize = 14;  	var message = e.Message.Text;  	var font = e.Message.Font;  	var sender = e.Message.Sender;  	// Add this color to the brush cache if it's not there already  	var brush = App.GetBrush (font.Color);  	Paragraph paragraph;  	if (sender != lastSender) {  		lastSender = sender;  		paragraph = new Paragraph () {  			FontSize = FontSize + 2'  			Foreground = Brushes.Black'  			FontWeight = FontWeights.Light'  			Margin = new Thickness (0' 4.0' 0' 2.0)'  			Padding = new Thickness (0' 0' 0' 2.0)'  			BorderBrush = Brushes.LightGray'  			BorderThickness = new Thickness (0' 0' 0' 1)'  		};  		paragraph.Inlines.Add (new Run (sender.DisplayName));  		ChatHistory.Add (paragraph);  	}  	paragraph = new Paragraph () {  		FontFamily = new FontFamily (font.Family)'  		FontSize = FontSize'  		LineHeight = 3 * FontSize / 2'  		Foreground = brush'  		Margin = new Thickness (16.0' 0' 0' 0)'  		TextIndent = 0'  	};  	/*				var path = new System.Windows.Shapes.Path() 				{ 					Stroke = Brushes.Black' 					StrokeThickness = 2' 					Data = App.Current.FindResource("CrossGeometry") as Geometry' 					Width = 12' 					Height = paragraph.FontSize' 					Margin = new Thickness(0' 0' 4' 0)' 				};  				paragraph.Inlines.Add(new InlineUIContainer(path));*/var stops = new List<ChatStop> ();  	foreach (var emoteStop in App.EmoticonManager.SearchForEmoticons (message)) {  		stops.Add (new ChatStop () {  			Index = emoteStop.Key'  			Length = emoteStop.Value.Shortcut.Length'  			Type = StopType.Emoticon'  			Data = emoteStop.Value'  		});  	}  	string[] urls = new string[] {  		"http://"'  		"https://"  	};  	foreach (var url in urls) {  		int index = message.IndexOf (url);  		while (index != -1) {  			int endIndex = message.IndexOf (' '' index);  			if (endIndex == -1)  				endIndex = message.Length - 1;  			stops.Add (new ChatStop () {  				Index = index'  				Length = endIndex - index + 1'  				Type = StopType.Url'  			});  			index = message.IndexOf (url' endIndex);  		}  	}  	var orderedStops = stops.OrderBy (_ => _.Index);  	int startIndex = 0;  	foreach (var stop in orderedStops) {  		if (stop.Index < startIndex)  			continue;  		if (stop.Index != startIndex)  			paragraph.Inlines.Add (new Run (message.Substring (startIndex' stop.Index - startIndex)));  		switch (stop.Type) {  		case StopType.Emoticon:  			var picture = new EmoteImage () {  				SnapsToDevicePixels = true'  				Emote = stop.Data as Emoticon'  			};  			paragraph.Inlines.Add (new InlineUIContainer (picture));  			break;  		case StopType.Url:  			var text = message.Substring (stop.Index' stop.Length);  			var link = new Hyperlink (new Run (text));  			link.Tag = text;  			link.Click += OnChatLinkClicked;  			paragraph.Inlines.Add (link);  			break;  		}  		startIndex = stop.Index + stop.Length;  	}  	paragraph.Inlines.Add (new Run (message.Substring (startIndex)));  	if (font.Style.HasFlag (Protocol.FontStyle.Bold))  		paragraph.FontWeight = FontWeights.Bold;  	if (font.Style.HasFlag (Protocol.FontStyle.Italic))  		paragraph.FontStyle = FontStyles.Italic;  	if (font.Style.HasFlag (Protocol.FontStyle.Underline)) {  		paragraph.TextDecorations = new TextDecorationCollection ();  		paragraph.TextDecorations.Add (System.Windows.TextDecorations.Underline);  	}  	ChatHistory.Add (paragraph);  }));  
Magic Number,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The following statement contains a magic number: App.Current.Dispatcher.BeginInvoke (new Action (() =>  {  	const int FontSize = 14;  	var message = e.Message.Text;  	var font = e.Message.Font;  	var sender = e.Message.Sender;  	// Add this color to the brush cache if it's not there already  	var brush = App.GetBrush (font.Color);  	Paragraph paragraph;  	if (sender != lastSender) {  		lastSender = sender;  		paragraph = new Paragraph () {  			FontSize = FontSize + 2'  			Foreground = Brushes.Black'  			FontWeight = FontWeights.Light'  			Margin = new Thickness (0' 4.0' 0' 2.0)'  			Padding = new Thickness (0' 0' 0' 2.0)'  			BorderBrush = Brushes.LightGray'  			BorderThickness = new Thickness (0' 0' 0' 1)'  		};  		paragraph.Inlines.Add (new Run (sender.DisplayName));  		ChatHistory.Add (paragraph);  	}  	paragraph = new Paragraph () {  		FontFamily = new FontFamily (font.Family)'  		FontSize = FontSize'  		LineHeight = 3 * FontSize / 2'  		Foreground = brush'  		Margin = new Thickness (16.0' 0' 0' 0)'  		TextIndent = 0'  	};  	/*				var path = new System.Windows.Shapes.Path() 				{ 					Stroke = Brushes.Black' 					StrokeThickness = 2' 					Data = App.Current.FindResource("CrossGeometry") as Geometry' 					Width = 12' 					Height = paragraph.FontSize' 					Margin = new Thickness(0' 0' 4' 0)' 				};  				paragraph.Inlines.Add(new InlineUIContainer(path));*/var stops = new List<ChatStop> ();  	foreach (var emoteStop in App.EmoticonManager.SearchForEmoticons (message)) {  		stops.Add (new ChatStop () {  			Index = emoteStop.Key'  			Length = emoteStop.Value.Shortcut.Length'  			Type = StopType.Emoticon'  			Data = emoteStop.Value'  		});  	}  	string[] urls = new string[] {  		"http://"'  		"https://"  	};  	foreach (var url in urls) {  		int index = message.IndexOf (url);  		while (index != -1) {  			int endIndex = message.IndexOf (' '' index);  			if (endIndex == -1)  				endIndex = message.Length - 1;  			stops.Add (new ChatStop () {  				Index = index'  				Length = endIndex - index + 1'  				Type = StopType.Url'  			});  			index = message.IndexOf (url' endIndex);  		}  	}  	var orderedStops = stops.OrderBy (_ => _.Index);  	int startIndex = 0;  	foreach (var stop in orderedStops) {  		if (stop.Index < startIndex)  			continue;  		if (stop.Index != startIndex)  			paragraph.Inlines.Add (new Run (message.Substring (startIndex' stop.Index - startIndex)));  		switch (stop.Type) {  		case StopType.Emoticon:  			var picture = new EmoteImage () {  				SnapsToDevicePixels = true'  				Emote = stop.Data as Emoticon'  			};  			paragraph.Inlines.Add (new InlineUIContainer (picture));  			break;  		case StopType.Url:  			var text = message.Substring (stop.Index' stop.Length);  			var link = new Hyperlink (new Run (text));  			link.Tag = text;  			link.Click += OnChatLinkClicked;  			paragraph.Inlines.Add (link);  			break;  		}  		startIndex = stop.Index + stop.Length;  	}  	paragraph.Inlines.Add (new Run (message.Substring (startIndex)));  	if (font.Style.HasFlag (Protocol.FontStyle.Bold))  		paragraph.FontWeight = FontWeights.Bold;  	if (font.Style.HasFlag (Protocol.FontStyle.Italic))  		paragraph.FontStyle = FontStyles.Italic;  	if (font.Style.HasFlag (Protocol.FontStyle.Underline)) {  		paragraph.TextDecorations = new TextDecorationCollection ();  		paragraph.TextDecorations.Add (System.Windows.TextDecorations.Underline);  	}  	ChatHistory.Add (paragraph);  }));  
Magic Number,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The following statement contains a magic number: App.Current.Dispatcher.BeginInvoke (new Action (() =>  {  	const int FontSize = 14;  	var message = e.Message.Text;  	var font = e.Message.Font;  	var sender = e.Message.Sender;  	// Add this color to the brush cache if it's not there already  	var brush = App.GetBrush (font.Color);  	Paragraph paragraph;  	if (sender != lastSender) {  		lastSender = sender;  		paragraph = new Paragraph () {  			FontSize = FontSize + 2'  			Foreground = Brushes.Black'  			FontWeight = FontWeights.Light'  			Margin = new Thickness (0' 4.0' 0' 2.0)'  			Padding = new Thickness (0' 0' 0' 2.0)'  			BorderBrush = Brushes.LightGray'  			BorderThickness = new Thickness (0' 0' 0' 1)'  		};  		paragraph.Inlines.Add (new Run (sender.DisplayName));  		ChatHistory.Add (paragraph);  	}  	paragraph = new Paragraph () {  		FontFamily = new FontFamily (font.Family)'  		FontSize = FontSize'  		LineHeight = 3 * FontSize / 2'  		Foreground = brush'  		Margin = new Thickness (16.0' 0' 0' 0)'  		TextIndent = 0'  	};  	/*				var path = new System.Windows.Shapes.Path() 				{ 					Stroke = Brushes.Black' 					StrokeThickness = 2' 					Data = App.Current.FindResource("CrossGeometry") as Geometry' 					Width = 12' 					Height = paragraph.FontSize' 					Margin = new Thickness(0' 0' 4' 0)' 				};  				paragraph.Inlines.Add(new InlineUIContainer(path));*/var stops = new List<ChatStop> ();  	foreach (var emoteStop in App.EmoticonManager.SearchForEmoticons (message)) {  		stops.Add (new ChatStop () {  			Index = emoteStop.Key'  			Length = emoteStop.Value.Shortcut.Length'  			Type = StopType.Emoticon'  			Data = emoteStop.Value'  		});  	}  	string[] urls = new string[] {  		"http://"'  		"https://"  	};  	foreach (var url in urls) {  		int index = message.IndexOf (url);  		while (index != -1) {  			int endIndex = message.IndexOf (' '' index);  			if (endIndex == -1)  				endIndex = message.Length - 1;  			stops.Add (new ChatStop () {  				Index = index'  				Length = endIndex - index + 1'  				Type = StopType.Url'  			});  			index = message.IndexOf (url' endIndex);  		}  	}  	var orderedStops = stops.OrderBy (_ => _.Index);  	int startIndex = 0;  	foreach (var stop in orderedStops) {  		if (stop.Index < startIndex)  			continue;  		if (stop.Index != startIndex)  			paragraph.Inlines.Add (new Run (message.Substring (startIndex' stop.Index - startIndex)));  		switch (stop.Type) {  		case StopType.Emoticon:  			var picture = new EmoteImage () {  				SnapsToDevicePixels = true'  				Emote = stop.Data as Emoticon'  			};  			paragraph.Inlines.Add (new InlineUIContainer (picture));  			break;  		case StopType.Url:  			var text = message.Substring (stop.Index' stop.Length);  			var link = new Hyperlink (new Run (text));  			link.Tag = text;  			link.Click += OnChatLinkClicked;  			paragraph.Inlines.Add (link);  			break;  		}  		startIndex = stop.Index + stop.Length;  	}  	paragraph.Inlines.Add (new Run (message.Substring (startIndex)));  	if (font.Style.HasFlag (Protocol.FontStyle.Bold))  		paragraph.FontWeight = FontWeights.Bold;  	if (font.Style.HasFlag (Protocol.FontStyle.Italic))  		paragraph.FontStyle = FontStyles.Italic;  	if (font.Style.HasFlag (Protocol.FontStyle.Underline)) {  		paragraph.TextDecorations = new TextDecorationCollection ();  		paragraph.TextDecorations.Add (System.Windows.TextDecorations.Underline);  	}  	ChatHistory.Add (paragraph);  }));  
Magic Number,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The following statement contains a magic number: App.Current.Dispatcher.BeginInvoke (new Action (() =>  {  	const int FontSize = 14;  	var message = e.Message.Text;  	var font = e.Message.Font;  	var sender = e.Message.Sender;  	// Add this color to the brush cache if it's not there already  	var brush = App.GetBrush (font.Color);  	Paragraph paragraph;  	if (sender != lastSender) {  		lastSender = sender;  		paragraph = new Paragraph () {  			FontSize = FontSize + 2'  			Foreground = Brushes.Black'  			FontWeight = FontWeights.Light'  			Margin = new Thickness (0' 4.0' 0' 2.0)'  			Padding = new Thickness (0' 0' 0' 2.0)'  			BorderBrush = Brushes.LightGray'  			BorderThickness = new Thickness (0' 0' 0' 1)'  		};  		paragraph.Inlines.Add (new Run (sender.DisplayName));  		ChatHistory.Add (paragraph);  	}  	paragraph = new Paragraph () {  		FontFamily = new FontFamily (font.Family)'  		FontSize = FontSize'  		LineHeight = 3 * FontSize / 2'  		Foreground = brush'  		Margin = new Thickness (16.0' 0' 0' 0)'  		TextIndent = 0'  	};  	/*				var path = new System.Windows.Shapes.Path() 				{ 					Stroke = Brushes.Black' 					StrokeThickness = 2' 					Data = App.Current.FindResource("CrossGeometry") as Geometry' 					Width = 12' 					Height = paragraph.FontSize' 					Margin = new Thickness(0' 0' 4' 0)' 				};  				paragraph.Inlines.Add(new InlineUIContainer(path));*/var stops = new List<ChatStop> ();  	foreach (var emoteStop in App.EmoticonManager.SearchForEmoticons (message)) {  		stops.Add (new ChatStop () {  			Index = emoteStop.Key'  			Length = emoteStop.Value.Shortcut.Length'  			Type = StopType.Emoticon'  			Data = emoteStop.Value'  		});  	}  	string[] urls = new string[] {  		"http://"'  		"https://"  	};  	foreach (var url in urls) {  		int index = message.IndexOf (url);  		while (index != -1) {  			int endIndex = message.IndexOf (' '' index);  			if (endIndex == -1)  				endIndex = message.Length - 1;  			stops.Add (new ChatStop () {  				Index = index'  				Length = endIndex - index + 1'  				Type = StopType.Url'  			});  			index = message.IndexOf (url' endIndex);  		}  	}  	var orderedStops = stops.OrderBy (_ => _.Index);  	int startIndex = 0;  	foreach (var stop in orderedStops) {  		if (stop.Index < startIndex)  			continue;  		if (stop.Index != startIndex)  			paragraph.Inlines.Add (new Run (message.Substring (startIndex' stop.Index - startIndex)));  		switch (stop.Type) {  		case StopType.Emoticon:  			var picture = new EmoteImage () {  				SnapsToDevicePixels = true'  				Emote = stop.Data as Emoticon'  			};  			paragraph.Inlines.Add (new InlineUIContainer (picture));  			break;  		case StopType.Url:  			var text = message.Substring (stop.Index' stop.Length);  			var link = new Hyperlink (new Run (text));  			link.Tag = text;  			link.Click += OnChatLinkClicked;  			paragraph.Inlines.Add (link);  			break;  		}  		startIndex = stop.Index + stop.Length;  	}  	paragraph.Inlines.Add (new Run (message.Substring (startIndex)));  	if (font.Style.HasFlag (Protocol.FontStyle.Bold))  		paragraph.FontWeight = FontWeights.Bold;  	if (font.Style.HasFlag (Protocol.FontStyle.Italic))  		paragraph.FontStyle = FontStyles.Italic;  	if (font.Style.HasFlag (Protocol.FontStyle.Underline)) {  		paragraph.TextDecorations = new TextDecorationCollection ();  		paragraph.TextDecorations.Add (System.Windows.TextDecorations.Underline);  	}  	ChatHistory.Add (paragraph);  }));  
Magic Number,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The following statement contains a magic number: App.Current.Dispatcher.BeginInvoke (new Action (() =>  {  	const int FontSize = 14;  	var message = e.Message.Text;  	var font = e.Message.Font;  	var sender = e.Message.Sender;  	// Add this color to the brush cache if it's not there already  	var brush = App.GetBrush (font.Color);  	Paragraph paragraph;  	if (sender != lastSender) {  		lastSender = sender;  		paragraph = new Paragraph () {  			FontSize = FontSize + 2'  			Foreground = Brushes.Black'  			FontWeight = FontWeights.Light'  			Margin = new Thickness (0' 4.0' 0' 2.0)'  			Padding = new Thickness (0' 0' 0' 2.0)'  			BorderBrush = Brushes.LightGray'  			BorderThickness = new Thickness (0' 0' 0' 1)'  		};  		paragraph.Inlines.Add (new Run (sender.DisplayName));  		ChatHistory.Add (paragraph);  	}  	paragraph = new Paragraph () {  		FontFamily = new FontFamily (font.Family)'  		FontSize = FontSize'  		LineHeight = 3 * FontSize / 2'  		Foreground = brush'  		Margin = new Thickness (16.0' 0' 0' 0)'  		TextIndent = 0'  	};  	/*				var path = new System.Windows.Shapes.Path() 				{ 					Stroke = Brushes.Black' 					StrokeThickness = 2' 					Data = App.Current.FindResource("CrossGeometry") as Geometry' 					Width = 12' 					Height = paragraph.FontSize' 					Margin = new Thickness(0' 0' 4' 0)' 				};  				paragraph.Inlines.Add(new InlineUIContainer(path));*/var stops = new List<ChatStop> ();  	foreach (var emoteStop in App.EmoticonManager.SearchForEmoticons (message)) {  		stops.Add (new ChatStop () {  			Index = emoteStop.Key'  			Length = emoteStop.Value.Shortcut.Length'  			Type = StopType.Emoticon'  			Data = emoteStop.Value'  		});  	}  	string[] urls = new string[] {  		"http://"'  		"https://"  	};  	foreach (var url in urls) {  		int index = message.IndexOf (url);  		while (index != -1) {  			int endIndex = message.IndexOf (' '' index);  			if (endIndex == -1)  				endIndex = message.Length - 1;  			stops.Add (new ChatStop () {  				Index = index'  				Length = endIndex - index + 1'  				Type = StopType.Url'  			});  			index = message.IndexOf (url' endIndex);  		}  	}  	var orderedStops = stops.OrderBy (_ => _.Index);  	int startIndex = 0;  	foreach (var stop in orderedStops) {  		if (stop.Index < startIndex)  			continue;  		if (stop.Index != startIndex)  			paragraph.Inlines.Add (new Run (message.Substring (startIndex' stop.Index - startIndex)));  		switch (stop.Type) {  		case StopType.Emoticon:  			var picture = new EmoteImage () {  				SnapsToDevicePixels = true'  				Emote = stop.Data as Emoticon'  			};  			paragraph.Inlines.Add (new InlineUIContainer (picture));  			break;  		case StopType.Url:  			var text = message.Substring (stop.Index' stop.Length);  			var link = new Hyperlink (new Run (text));  			link.Tag = text;  			link.Click += OnChatLinkClicked;  			paragraph.Inlines.Add (link);  			break;  		}  		startIndex = stop.Index + stop.Length;  	}  	paragraph.Inlines.Add (new Run (message.Substring (startIndex)));  	if (font.Style.HasFlag (Protocol.FontStyle.Bold))  		paragraph.FontWeight = FontWeights.Bold;  	if (font.Style.HasFlag (Protocol.FontStyle.Italic))  		paragraph.FontStyle = FontStyles.Italic;  	if (font.Style.HasFlag (Protocol.FontStyle.Underline)) {  		paragraph.TextDecorations = new TextDecorationCollection ();  		paragraph.TextDecorations.Add (System.Windows.TextDecorations.Underline);  	}  	ChatHistory.Add (paragraph);  }));  
Magic Number,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The following statement contains a magic number: App.Current.Dispatcher.BeginInvoke (new Action (() =>  {  	const int FontSize = 14;  	var message = e.Message.Text;  	var font = e.Message.Font;  	var sender = e.Message.Sender;  	// Add this color to the brush cache if it's not there already  	var brush = App.GetBrush (font.Color);  	Paragraph paragraph;  	if (sender != lastSender) {  		lastSender = sender;  		paragraph = new Paragraph () {  			FontSize = FontSize + 2'  			Foreground = Brushes.Black'  			FontWeight = FontWeights.Light'  			Margin = new Thickness (0' 4.0' 0' 2.0)'  			Padding = new Thickness (0' 0' 0' 2.0)'  			BorderBrush = Brushes.LightGray'  			BorderThickness = new Thickness (0' 0' 0' 1)'  		};  		paragraph.Inlines.Add (new Run (sender.DisplayName));  		ChatHistory.Add (paragraph);  	}  	paragraph = new Paragraph () {  		FontFamily = new FontFamily (font.Family)'  		FontSize = FontSize'  		LineHeight = 3 * FontSize / 2'  		Foreground = brush'  		Margin = new Thickness (16.0' 0' 0' 0)'  		TextIndent = 0'  	};  	/*				var path = new System.Windows.Shapes.Path() 				{ 					Stroke = Brushes.Black' 					StrokeThickness = 2' 					Data = App.Current.FindResource("CrossGeometry") as Geometry' 					Width = 12' 					Height = paragraph.FontSize' 					Margin = new Thickness(0' 0' 4' 0)' 				};  				paragraph.Inlines.Add(new InlineUIContainer(path));*/var stops = new List<ChatStop> ();  	foreach (var emoteStop in App.EmoticonManager.SearchForEmoticons (message)) {  		stops.Add (new ChatStop () {  			Index = emoteStop.Key'  			Length = emoteStop.Value.Shortcut.Length'  			Type = StopType.Emoticon'  			Data = emoteStop.Value'  		});  	}  	string[] urls = new string[] {  		"http://"'  		"https://"  	};  	foreach (var url in urls) {  		int index = message.IndexOf (url);  		while (index != -1) {  			int endIndex = message.IndexOf (' '' index);  			if (endIndex == -1)  				endIndex = message.Length - 1;  			stops.Add (new ChatStop () {  				Index = index'  				Length = endIndex - index + 1'  				Type = StopType.Url'  			});  			index = message.IndexOf (url' endIndex);  		}  	}  	var orderedStops = stops.OrderBy (_ => _.Index);  	int startIndex = 0;  	foreach (var stop in orderedStops) {  		if (stop.Index < startIndex)  			continue;  		if (stop.Index != startIndex)  			paragraph.Inlines.Add (new Run (message.Substring (startIndex' stop.Index - startIndex)));  		switch (stop.Type) {  		case StopType.Emoticon:  			var picture = new EmoteImage () {  				SnapsToDevicePixels = true'  				Emote = stop.Data as Emoticon'  			};  			paragraph.Inlines.Add (new InlineUIContainer (picture));  			break;  		case StopType.Url:  			var text = message.Substring (stop.Index' stop.Length);  			var link = new Hyperlink (new Run (text));  			link.Tag = text;  			link.Click += OnChatLinkClicked;  			paragraph.Inlines.Add (link);  			break;  		}  		startIndex = stop.Index + stop.Length;  	}  	paragraph.Inlines.Add (new Run (message.Substring (startIndex)));  	if (font.Style.HasFlag (Protocol.FontStyle.Bold))  		paragraph.FontWeight = FontWeights.Bold;  	if (font.Style.HasFlag (Protocol.FontStyle.Italic))  		paragraph.FontStyle = FontStyles.Italic;  	if (font.Style.HasFlag (Protocol.FontStyle.Underline)) {  		paragraph.TextDecorations = new TextDecorationCollection ();  		paragraph.TextDecorations.Add (System.Windows.TextDecorations.Underline);  	}  	ChatHistory.Add (paragraph);  }));  
Magic Number,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The following statement contains a magic number: App.Current.Dispatcher.BeginInvoke (new Action (() =>  {  	const int FontSize = 14;  	var message = e.Message.Text;  	var font = e.Message.Font;  	var sender = e.Message.Sender;  	// Add this color to the brush cache if it's not there already  	var brush = App.GetBrush (font.Color);  	Paragraph paragraph;  	if (sender != lastSender) {  		lastSender = sender;  		paragraph = new Paragraph () {  			FontSize = FontSize + 2'  			Foreground = Brushes.Black'  			FontWeight = FontWeights.Light'  			Margin = new Thickness (0' 4.0' 0' 2.0)'  			Padding = new Thickness (0' 0' 0' 2.0)'  			BorderBrush = Brushes.LightGray'  			BorderThickness = new Thickness (0' 0' 0' 1)'  		};  		paragraph.Inlines.Add (new Run (sender.DisplayName));  		ChatHistory.Add (paragraph);  	}  	paragraph = new Paragraph () {  		FontFamily = new FontFamily (font.Family)'  		FontSize = FontSize'  		LineHeight = 3 * FontSize / 2'  		Foreground = brush'  		Margin = new Thickness (16.0' 0' 0' 0)'  		TextIndent = 0'  	};  	/*				var path = new System.Windows.Shapes.Path() 				{ 					Stroke = Brushes.Black' 					StrokeThickness = 2' 					Data = App.Current.FindResource("CrossGeometry") as Geometry' 					Width = 12' 					Height = paragraph.FontSize' 					Margin = new Thickness(0' 0' 4' 0)' 				};  				paragraph.Inlines.Add(new InlineUIContainer(path));*/var stops = new List<ChatStop> ();  	foreach (var emoteStop in App.EmoticonManager.SearchForEmoticons (message)) {  		stops.Add (new ChatStop () {  			Index = emoteStop.Key'  			Length = emoteStop.Value.Shortcut.Length'  			Type = StopType.Emoticon'  			Data = emoteStop.Value'  		});  	}  	string[] urls = new string[] {  		"http://"'  		"https://"  	};  	foreach (var url in urls) {  		int index = message.IndexOf (url);  		while (index != -1) {  			int endIndex = message.IndexOf (' '' index);  			if (endIndex == -1)  				endIndex = message.Length - 1;  			stops.Add (new ChatStop () {  				Index = index'  				Length = endIndex - index + 1'  				Type = StopType.Url'  			});  			index = message.IndexOf (url' endIndex);  		}  	}  	var orderedStops = stops.OrderBy (_ => _.Index);  	int startIndex = 0;  	foreach (var stop in orderedStops) {  		if (stop.Index < startIndex)  			continue;  		if (stop.Index != startIndex)  			paragraph.Inlines.Add (new Run (message.Substring (startIndex' stop.Index - startIndex)));  		switch (stop.Type) {  		case StopType.Emoticon:  			var picture = new EmoteImage () {  				SnapsToDevicePixels = true'  				Emote = stop.Data as Emoticon'  			};  			paragraph.Inlines.Add (new InlineUIContainer (picture));  			break;  		case StopType.Url:  			var text = message.Substring (stop.Index' stop.Length);  			var link = new Hyperlink (new Run (text));  			link.Tag = text;  			link.Click += OnChatLinkClicked;  			paragraph.Inlines.Add (link);  			break;  		}  		startIndex = stop.Index + stop.Length;  	}  	paragraph.Inlines.Add (new Run (message.Substring (startIndex)));  	if (font.Style.HasFlag (Protocol.FontStyle.Bold))  		paragraph.FontWeight = FontWeights.Bold;  	if (font.Style.HasFlag (Protocol.FontStyle.Italic))  		paragraph.FontStyle = FontStyles.Italic;  	if (font.Style.HasFlag (Protocol.FontStyle.Underline)) {  		paragraph.TextDecorations = new TextDecorationCollection ();  		paragraph.TextDecorations.Add (System.Windows.TextDecorations.Underline);  	}  	ChatHistory.Add (paragraph);  }));  
Magic Number,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The following statement contains a magic number: if (sender != lastSender) {  	lastSender = sender;  	paragraph = new Paragraph () {  		FontSize = FontSize + 2'  		Foreground = Brushes.Black'  		FontWeight = FontWeights.Light'  		Margin = new Thickness (0' 4.0' 0' 2.0)'  		Padding = new Thickness (0' 0' 0' 2.0)'  		BorderBrush = Brushes.LightGray'  		BorderThickness = new Thickness (0' 0' 0' 1)'  	};  	paragraph.Inlines.Add (new Run (sender.DisplayName));  	ChatHistory.Add (paragraph);  }  
Magic Number,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The following statement contains a magic number: if (sender != lastSender) {  	lastSender = sender;  	paragraph = new Paragraph () {  		FontSize = FontSize + 2'  		Foreground = Brushes.Black'  		FontWeight = FontWeights.Light'  		Margin = new Thickness (0' 4.0' 0' 2.0)'  		Padding = new Thickness (0' 0' 0' 2.0)'  		BorderBrush = Brushes.LightGray'  		BorderThickness = new Thickness (0' 0' 0' 1)'  	};  	paragraph.Inlines.Add (new Run (sender.DisplayName));  	ChatHistory.Add (paragraph);  }  
Magic Number,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The following statement contains a magic number: if (sender != lastSender) {  	lastSender = sender;  	paragraph = new Paragraph () {  		FontSize = FontSize + 2'  		Foreground = Brushes.Black'  		FontWeight = FontWeights.Light'  		Margin = new Thickness (0' 4.0' 0' 2.0)'  		Padding = new Thickness (0' 0' 0' 2.0)'  		BorderBrush = Brushes.LightGray'  		BorderThickness = new Thickness (0' 0' 0' 1)'  	};  	paragraph.Inlines.Add (new Run (sender.DisplayName));  	ChatHistory.Add (paragraph);  }  
Magic Number,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The following statement contains a magic number: if (sender != lastSender) {  	lastSender = sender;  	paragraph = new Paragraph () {  		FontSize = FontSize + 2'  		Foreground = Brushes.Black'  		FontWeight = FontWeights.Light'  		Margin = new Thickness (0' 4.0' 0' 2.0)'  		Padding = new Thickness (0' 0' 0' 2.0)'  		BorderBrush = Brushes.LightGray'  		BorderThickness = new Thickness (0' 0' 0' 1)'  	};  	paragraph.Inlines.Add (new Run (sender.DisplayName));  	ChatHistory.Add (paragraph);  }  
Magic Number,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The following statement contains a magic number: paragraph = new Paragraph () {  	FontSize = FontSize + 2'  	Foreground = Brushes.Black'  	FontWeight = FontWeights.Light'  	Margin = new Thickness (0' 4.0' 0' 2.0)'  	Padding = new Thickness (0' 0' 0' 2.0)'  	BorderBrush = Brushes.LightGray'  	BorderThickness = new Thickness (0' 0' 0' 1)'  };  
Magic Number,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The following statement contains a magic number: paragraph = new Paragraph () {  	FontSize = FontSize + 2'  	Foreground = Brushes.Black'  	FontWeight = FontWeights.Light'  	Margin = new Thickness (0' 4.0' 0' 2.0)'  	Padding = new Thickness (0' 0' 0' 2.0)'  	BorderBrush = Brushes.LightGray'  	BorderThickness = new Thickness (0' 0' 0' 1)'  };  
Magic Number,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The following statement contains a magic number: paragraph = new Paragraph () {  	FontSize = FontSize + 2'  	Foreground = Brushes.Black'  	FontWeight = FontWeights.Light'  	Margin = new Thickness (0' 4.0' 0' 2.0)'  	Padding = new Thickness (0' 0' 0' 2.0)'  	BorderBrush = Brushes.LightGray'  	BorderThickness = new Thickness (0' 0' 0' 1)'  };  
Magic Number,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The following statement contains a magic number: paragraph = new Paragraph () {  	FontSize = FontSize + 2'  	Foreground = Brushes.Black'  	FontWeight = FontWeights.Light'  	Margin = new Thickness (0' 4.0' 0' 2.0)'  	Padding = new Thickness (0' 0' 0' 2.0)'  	BorderBrush = Brushes.LightGray'  	BorderThickness = new Thickness (0' 0' 0' 1)'  };  
Magic Number,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The following statement contains a magic number: paragraph = new Paragraph () {  	FontFamily = new FontFamily (font.Family)'  	FontSize = FontSize'  	LineHeight = 3 * FontSize / 2'  	Foreground = brush'  	Margin = new Thickness (16.0' 0' 0' 0)'  	TextIndent = 0'  };  
Magic Number,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The following statement contains a magic number: paragraph = new Paragraph () {  	FontFamily = new FontFamily (font.Family)'  	FontSize = FontSize'  	LineHeight = 3 * FontSize / 2'  	Foreground = brush'  	Margin = new Thickness (16.0' 0' 0' 0)'  	TextIndent = 0'  };  
Magic Number,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The following statement contains a magic number: paragraph = new Paragraph () {  	FontFamily = new FontFamily (font.Family)'  	FontSize = FontSize'  	LineHeight = 3 * FontSize / 2'  	Foreground = brush'  	Margin = new Thickness (16.0' 0' 0' 0)'  	TextIndent = 0'  };  
Magic Number,Client.UI.ViewModel,MainWindowViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\MainWindowViewModel.cs,MainWindowViewModel,The following statement contains a magic number: stateDetector.IdleTimeThreshold = 60 * 5;  
Magic Number,Client.UI.ViewModel,MainWindowViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\MainWindowViewModel.cs,MainWindowViewModel,The following statement contains a magic number: stateDetector.IdleTimeThreshold = 60 * 5;  
Magic Number,Client.UI.View,UserToCommaSeparatedConverter,C:\repos\npcook_infinichat-client\Client\UI\View\ConversationView.xaml.cs,Convert,The following statement contains a magic number: if (names.Length == 0)  	return "";  else if (names.Length == 1)  	return names [0];  else if (names.Length == 2)  	return names [0] + " and " + names [1];  
Magic Number,Client.UI.View,UserToCommaSeparatedConverter,C:\repos\npcook_infinichat-client\Client\UI\View\ConversationView.xaml.cs,Convert,The following statement contains a magic number: if (names.Length == 1)  	return names [0];  else if (names.Length == 2)  	return names [0] + " and " + names [1];  
Magic Number,Client.UI.View,UserToCommaSeparatedConverter,C:\repos\npcook_infinichat-client\Client\UI\View\ConversationView.xaml.cs,Convert,The following statement contains a magic number: if (names.Length == 2)  	return names [0] + " and " + names [1];  
Missing Default,Client,UserStateDetector,C:\repos\npcook_infinichat-client\Client\UserStateDetector.cs,MessageWindowHook,The following switch statement is missing a default case: switch ((NativeMethods.ABNotify)wParam) {  case NativeMethods.ABNotify.ABN_FULLSCREENAPP:  	{  		IsBusy = lParam != IntPtr.Zero;  		if (UserBusyChanged != null)  			UserBusyChanged.Invoke (this' new UserBusyEventArgs (IsBusy));  	}  	break;  }  
Missing Default,Client.UI,FontDialog,C:\repos\npcook_infinichat-client\Client\UI\FontDialog.xaml.cs,CheckBoxChecked,The following switch statement is missing a default case: switch (source.Name) {  case "BoldCheckBox":  	SampleTextBlock.FontWeight = FontWeights.Bold;  	break;  case "ItalicCheckBox":  	SampleTextBlock.FontStyle = FontStyles.Italic;  	break;  case "UnderlineCheckBox":  	SampleTextBlock.TextDecorations.Add (TextDecorations.Underline);  	break;  }  
Missing Default,Client.UI,FontDialog,C:\repos\npcook_infinichat-client\Client\UI\FontDialog.xaml.cs,CheckBoxUnchecked,The following switch statement is missing a default case: switch (source.Name) {  case "BoldCheckBox":  	SampleTextBlock.FontWeight = FontWeights.Normal;  	break;  case "ItalicCheckBox":  	SampleTextBlock.FontStyle = FontStyles.Normal;  	break;  case "UnderlineCheckBox":  	SampleTextBlock.TextDecorations.RemoveAt (0);  	break;  }  
Missing Default,Client.UI.ViewModel,ConversationViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\ConversationViewModel.cs,OnChatReceived,The following switch statement is missing a default case: switch (stop.Type) {  case StopType.Emoticon:  	var picture = new EmoteImage () {  		SnapsToDevicePixels = true'  		Emote = stop.Data as Emoticon'  	};  	paragraph.Inlines.Add (new InlineUIContainer (picture));  	break;  case StopType.Url:  	var text = message.Substring (stop.Index' stop.Length);  	var link = new Hyperlink (new Run (text));  	link.Tag = text;  	link.Click += OnChatLinkClicked;  	paragraph.Inlines.Add (link);  	break;  }  
Missing Default,Client.UI.ViewModel,MainWindowViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\MainWindowViewModel.cs,OnStreamError,The following switch statement is missing a default case: switch (socketEx.SocketErrorCode) {  case SocketError.Interrupted:  	handled = true;  	break;  case SocketError.ConnectionAborted:  case SocketError.ConnectionReset:  	if (!connection.Reconnect ()) {  		LogOut ();  	}  	handled = true;  	break;  }  
Missing Default,Client.UI.ViewModel,NewTabViewModel,C:\repos\npcook_infinichat-client\Client\UI\ViewModel\NewTabViewModel.cs,UpdateContacts,The following switch statement is missing a default case: switch (user.Relation) {  case UserRelation.None:  	remove = true;  	break;  // Don't include ourselves in any lists  case UserRelation.Me:  	continue;  // Add any users who just became our friends  case UserRelation.Friend:  case UserRelation.PendingFriend:  	if (contactVMs.SingleOrDefault (_ => _.Contact == contact) == null)  		contactVMs.Add (ContactViewModel.Create (client' contact));  	break;  }  
